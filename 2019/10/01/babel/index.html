<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="国庆放假了，我还在利用碎片时间在写文章，不知道长假还有没有人看，试试水吧！ 这个文章系列将带大家深入浅出 Babel, 这个系列将分为上下两篇：上篇主要介绍 Babel 的架构和原理，顺便实践一下插件开发的；下篇会介绍 `babel-plugin-macros , 利用它来写属于 Javascript 的’宏‘， ✨满满的干货，不容错过哦. 写文不易，点赞是最大的鼓励。  注意: 本文不是 Bab">
<meta name="keywords" content="Blog,FrontEnd,React,Javascript,Typescript">
<meta property="og:type" content="article">
<meta property="og:title" content="深入浅出 Babel 上篇：架构和原理 + 实战">
<meta property="og:url" content="https://bobi.ink/2019/10/01/babel/index.html">
<meta property="og:site_name" content="Bobi.ink">
<meta property="og:description" content="国庆放假了，我还在利用碎片时间在写文章，不知道长假还有没有人看，试试水吧！ 这个文章系列将带大家深入浅出 Babel, 这个系列将分为上下两篇：上篇主要介绍 Babel 的架构和原理，顺便实践一下插件开发的；下篇会介绍 `babel-plugin-macros , 利用它来写属于 Javascript 的’宏‘， ✨满满的干货，不容错过哦. 写文不易，点赞是最大的鼓励。  注意: 本文不是 Bab">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://bobi.ink/images/babel/process.png">
<meta property="og:image" content="https://bobi.ink/images/babel/tokens.png">
<meta property="og:image" content="https://bobi.ink/images/babel/ast.png">
<meta property="og:image" content="https://bobi.ink/images/babel/arch.png">
<meta property="og:image" content="https://bobi.ink/images/babel/traveser.png">
<meta property="og:image" content="https://bobi.ink/images/babel/replace.png">
<meta property="og:image" content="https://bobi.ink/images/babel/scope.png">
<meta property="og:image" content="https://bobi.ink/images/babel/scope2.png">
<meta property="og:image" content="https://bobi.ink/images/babel/import.png">
<meta property="og:image" content="https://bobi.ink/images/sponsor.jpg">
<meta property="og:updated_time" content="2023-06-01T09:55:14.328Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入浅出 Babel 上篇：架构和原理 + 实战">
<meta name="twitter:description" content="国庆放假了，我还在利用碎片时间在写文章，不知道长假还有没有人看，试试水吧！ 这个文章系列将带大家深入浅出 Babel, 这个系列将分为上下两篇：上篇主要介绍 Babel 的架构和原理，顺便实践一下插件开发的；下篇会介绍 `babel-plugin-macros , 利用它来写属于 Javascript 的’宏‘， ✨满满的干货，不容错过哦. 写文不易，点赞是最大的鼓励。  注意: 本文不是 Bab">
<meta name="twitter:image" content="https://bobi.ink/images/babel/process.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>深入浅出 Babel 上篇：架构和原理 + 实战</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/10/10/babel-macro/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/09/23/kanban/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2019/10/01/babel/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2019/10/01/babel/&text=深入浅出 Babel 上篇：架构和原理 + 实战"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2019/10/01/babel/&title=深入浅出 Babel 上篇：架构和原理 + 实战"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2019/10/01/babel/&is_video=false&description=深入浅出 Babel 上篇：架构和原理 + 实战"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=深入浅出 Babel 上篇：架构和原理 + 实战&body=Check out this article: https://bobi.ink/2019/10/01/babel/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2019/10/01/babel/&title=深入浅出 Babel 上篇：架构和原理 + 实战"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2019/10/01/babel/&title=深入浅出 Babel 上篇：架构和原理 + 实战"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2019/10/01/babel/&title=深入浅出 Babel 上篇：架构和原理 + 实战"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2019/10/01/babel/&title=深入浅出 Babel 上篇：架构和原理 + 实战"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2019/10/01/babel/&name=深入浅出 Babel 上篇：架构和原理 + 实战&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#babel-的处理流程"><span class="toc-number">1.</span> <span class="toc-text">Babel 的处理流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#babel-的架构"><span class="toc-number">2.</span> <span class="toc-text">Babel 的架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问者模式"><span class="toc-number">3.</span> <span class="toc-text">访问者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#节点的遍历"><span class="toc-number">3.1.</span> <span class="toc-text">节点的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#节点的上下文"><span class="toc-number">3.2.</span> <span class="toc-text">节点的上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#副作用的处理"><span class="toc-number">3.3.</span> <span class="toc-text">副作用的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域的处理"><span class="toc-number">3.4.</span> <span class="toc-text">作用域的处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#搞一个插件呗"><span class="toc-number">4.</span> <span class="toc-text">搞一个插件呗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最后"><span class="toc-number">5.</span> <span class="toc-text">最后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展"><span class="toc-number">6.</span> <span class="toc-text">扩展</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        深入浅出 Babel 上篇：架构和原理 + 实战
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Bobi.ink</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-09-30T16:00:00.000Z" itemprop="datePublished">2019-10-01</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>国庆放假了，我还在利用碎片时间在写文章，不知道长假还有没有人看，试试水吧！</p>
<p>这个文章系列将带大家深入浅出 <a href="https://babeljs.io" target="_blank" rel="noopener"><code>Babel</code></a>, 这个系列将分为上下两篇：上篇主要介绍 Babel 的架构和原理，顺便实践一下插件开发的；下篇会介绍 <a href="https://github.com/kentcdodds/babel-plugin-macros" target="_blank" rel="noopener">`babel-plugin-macros </a>, 利用它来写属于 Javascript 的’宏‘，</p>
<p>✨满满的干货，不容错过哦. 写文不易，点赞是最大的鼓励。</p>
<blockquote>
<p>注意: 本文不是 Babel 的基础使用教程！如果你对 Babel 尚不了解，请查看<a href="https://babeljs.io" target="_blank" rel="noopener">官方网站</a>, 或者这个<a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md" target="_blank" rel="noopener">用户手册</a></p>
</blockquote>
<p><br></p>
<p><strong>文章大纲</strong></p>
<!-- TOC -->
<ul>
<li><a href="#babel-的处理流程">Babel 的处理流程</a></li>
<li><a href="#babel-的架构">Babel 的架构</a></li>
<li><a href="#访问者模式">访问者模式</a><ul>
<li><a href="#节点的遍历">节点的遍历</a></li>
<li><a href="#节点的上下文">节点的上下文</a></li>
<li><a href="#副作用的处理">副作用的处理</a></li>
<li><a href="#作用域的处理">作用域的处理</a></li>
</ul>
</li>
<li><a href="#搞一个插件呗">搞一个插件呗</a></li>
<li><a href="#最后">最后</a></li>
<li><a href="#扩展">扩展</a></li>
</ul>
<!-- /TOC -->
<p><br></p>
<h2 id="babel-的处理流程"><a href="#babel-的处理流程" class="headerlink" title="Babel 的处理流程"></a>Babel 的处理流程</h2><p><img src="/images/babel/process.png" alt><br><i>Babel 的处理流程</i></p>
<p><br></p>
<p>上图是 Babel 的处理流程, 如果读者学习过<code>编译器原理</code>，这个过程就相当亲切了.</p>
<p>首先从源码 <code>解析(Parsing)</code> 开始，解析包含了两个步骤:</p>
<p><strong>1️⃣词法解析(Lexical Analysis)</strong>： <code>词法解析器(Tokenizer)</code>在这个阶段将字符串形式的代码转换为<code>Tokens(令牌)</code>. Tokens 可以视作是一些语法片段组成的数组. 例如<code>for (const item of items) {}</code> 词法解析后的结果如下:</p>
<p><img src="/images/babel/tokens.png" alt></p>
<p>从上图可以看，每个 Token 中包含了语法片段、位置信息、以及一些类型信息. 这些信息有助于后续的语法分析。</p>
<p><br></p>
<p><strong>2️⃣语法解析(Syntactic Analysis)</strong>：这个阶段语法<code>解析器(Parser)</code>会把<code>Tokens</code>转换为<code>抽象语法树(Abstract Syntax Tree，AST)</code></p>
<p><strong>什么是AST</strong>?</p>
<p>它就是一棵’对象树’，用来表示代码的语法结构，例如<code>console.log(&#39;hello world&#39;)</code>会解析成为:</p>
<p><img src="/images/babel/ast.png" alt></p>
<p><code>Program</code>、<code>CallExpression</code>、<code>Identifier</code> <strong>这些都是节点的类型，每个节点都是一个有意义的语法单元</strong>。 这些节点类型定义了一些属性来描述节点的信息。</p>
<p>JavaScript的语法越来越复杂，而且 Babel 除了支持最新的JavaScript规范语法, 还支持 <code>JSX</code>、<code>Flow</code>、现在还有<code>Typescript</code>。想象一下 AST 的节点类型有多少，其实我们不需要去记住这么多类型、也记不住. <strong>插件开发者会利用 <a href="https://astexplorer.net" target="_blank" rel="noopener"><code>ASTExplorer</code></a> 来审查解析后的AST树</strong>, 非常强大👍。</p>
<p><strong>AST 是 Babel 转译的核心数据结构，后续的操作都依赖于 AST</strong>。</p>
<p><br></p>
<p>接着就是<strong>转换(Transform)</strong>了，转换阶段会对 AST 进行遍历，在这个过程中对节点进行增删查改。Babel 所有插件都是在这个阶段工作, 比如语法转换、代码压缩。</p>
<p><br></p>
<p><strong>Javascript In Javascript Out</strong>, 最后阶段还是要把 AST 转换回字符串形式的Javascript，同时这个阶段还会生成Source Map。</p>
<p><br><br><br></p>
<h2 id="babel-的架构"><a href="#babel-的架构" class="headerlink" title="Babel 的架构"></a>Babel 的架构</h2><p>我在<a href="https://juejin.im/post/5d7ffad551882545ff173083" target="_blank" rel="noopener">《透过现象看本质: 常见的前端架构风格和案例🔥》</a> 提及 <code>Babel</code> 和 <code>Webpack</code> 为了适应复杂的定制需求和频繁的功能变化，都使用了<a href="https://juejin.im/post/5d7ffad551882545ff173083#heading-10" target="_blank" rel="noopener">微内核</a> 的架构风格。<strong>也就是说它们的核心非常小，大部分功能都是通过插件扩展实现的</strong>。</p>
<p><br></p>
<p>所以简单地了解一下 Babel 的架构和一些基本概念，对后续文章内容的理解, 以及Babel的使用还是有帮助的。</p>
<p><strong>一图胜千言</strong>。仔细读过我文章的朋友会发现，我的风格就是能用图片说明的就不用文字、能用文字的就不用代码。<strong>虽然我的原创文章篇幅都很长，图片还是值得看看的</strong>。</p>
<p><img src="/images/babel/arch.png" alt></p>
<p><br></p>
<p>Babel 是一个 <a href="https://github.com/lerna/lerna" target="_blank" rel="noopener"><code>MonoRepo</code></a> 项目， 不过组织非常清晰，下面就源码上我们能看到的模块进行一下分类， 配合上面的架构图让你对Babel有个大概的认识:</p>
<p><br></p>
<p><strong>1️⃣ 核心</strong>:</p>
<p><code>@babel/core</code> 这也是上面说的‘微内核’架构中的‘内核’。对于Babel来说，这个内核主要干这些事情：</p>
<ul>
<li>加载和处理配置(config)</li>
<li>加载插件</li>
<li>调用 <code>Parser</code> 进行语法解析，生成 <code>AST</code></li>
<li>调用 <code>Traverser</code> 遍历AST，并使用<code>访问者模式</code>应用’插件’对 AST 进行转换</li>
<li>生成代码，包括SourceMap转换和源代码生成</li>
</ul>
<p><br></p>
<p><strong>2️⃣ 核心周边支撑</strong></p>
<ul>
<li><p><strong>Parser(<code>@babel/parser</code>)</strong>： 将源代码解析为 AST 就靠它了。 它已经内置支持很多语法. 例如 JSX、Typescript、Flow、以及最新的ECMAScript规范。目前为了执行效率，parser是<a href="https://babeljs.io/docs/en/babel-parser#faq" target="_blank" rel="noopener">不支持扩展的</a>，由官方进行维护。如果你要支持自定义语法，可以 fork 它，不过这种场景非常少。</p>
</li>
<li><p><strong>Traverser(<code>@babel/traverse</code>)</strong>：  实现了<code>访问者模式</code>，对 AST 进行遍历，<code>转换插件</code>会通过它获取感兴趣的AST节点，对节点继续操作, 下文会详细介绍<code>访问器模式</code>。</p>
</li>
<li><p><strong>Generator(<code>@babel/generator</code>)</strong>： 将 AST 转换为源代码，支持 SourceMap</p>
</li>
</ul>
<p><br></p>
<p><strong>3️⃣ 插件</strong></p>
<p>打开 Babel 的源代码，会发现有好几种类型的‘插件’。</p>
<ul>
<li><p><strong>语法插件(<code>@babel/plugin-syntax-*</code>)</strong>：上面说了 <code>@babel/parser</code> 已经支持了很多 JavaScript 语法特性，Parser也不支持扩展. <strong>因此<code>plugin-syntax-*</code>实际上只是用于开启或者配置Parser的某个功能特性</strong>。</p>
<p>一般用户不需要关心这个，Transform 插件里面已经包含了相关的<code>plugin-syntax-*</code>插件了。用户也可以通过<a href="https://babeljs.io/docs/en/options#parseropts" target="_blank" rel="noopener"><code>parserOpts</code></a>配置项来直接配置 Parser</p>
</li>
<li><p><strong>转换插件</strong>： 用于对 AST 进行转换, 实现转换为ES5代码、压缩、功能增强等目的. Babel仓库将转换插件划分为两种(只是命名上的区别)：</p>
<ul>
<li><code>@babel/plugin-transform-*</code>： 普通的转换插件</li>
<li><code>@babel/plugin-proposal-*</code>： 还在’提议阶段’(非正式)的语言特性, 目前有<a href="https://babeljs.io/docs/en/next/plugins#experimental" target="_blank" rel="noopener">这些</a></li>
</ul>
</li>
<li><p><strong>预定义集合(<code>@babel/presets-*</code>)</strong>： 插件集合或者分组，主要方便用户对插件进行管理和使用。比如<code>preset-env</code>含括所有的标准的最新特性; 再比如<code>preset-react</code>含括所有react相关的插件.</p>
</li>
</ul>
<p><br></p>
<p><strong>4️⃣ 插件开发辅助</strong></p>
<ul>
<li><p><code>@babel/template</code>： 某些场景直接操作AST太麻烦，就比如我们直接操作DOM一样，所以Babel实现了这么一个简单的模板引擎，可以将字符串代码转换为AST。比如在生成一些辅助代码(helper)时会用到这个库</p>
</li>
<li><p><code>@babel/types</code>： AST 节点构造器和断言. 插件开发时使用很频繁</p>
</li>
<li><p><code>@babel/helper-*</code>： 一些辅助器，用于辅助插件开发，例如简化AST操作</p>
</li>
<li><p><code>@babel/helper</code>： 辅助代码，单纯的语法转换可能无法让代码运行起来，比如低版本浏览器无法识别class关键字，这时候需要添加辅助代码，对class进行模拟。</p>
</li>
</ul>
<p><br></p>
<p><strong>5️⃣ 工具</strong></p>
<ul>
<li><p><code>@babel/node</code>： Node.js CLI, 通过它直接运行需要 Babel 处理的JavaScript文件</p>
</li>
<li><p><code>@babel/register</code>： Patch NodeJs 的require方法，支持导入需要Babel处理的JavaScript模块</p>
</li>
<li><p><code>@babel/cli</code>： CLI工具</p>
</li>
</ul>
<p><br><br><br></p>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>转换器会遍历 AST 树，找出自己感兴趣的节点类型, 再进行转换操作. 这个过程和我们操作<code>DOM</code>树差不多，只不过目的不太一样。AST 遍历和转换一般会使用<a href="https://www.jianshu.com/p/1f1049d0a0f4" target="_blank" rel="noopener"><code>访问者模式</code></a>。</p>
<p>想象一下，Babel 有那么多插件，如果每个插件自己去遍历AST，对不同的节点进行不同的操作，维护自己的状态。这样子不仅低效，它们的逻辑分散在各处，会让整个系统变得难以理解和调试， 最后插件之间关系就纠缠不清，乱成一锅粥。</p>
<p><strong>所以转换器操作 AST 一般都是使用<code>访问器模式</code>，由这个<code>访问者(Visitor)</code>来 ① 进行统一的遍历操作，② 提供节点的操作方法，③ 响应式维护节点之间的关系；而插件(设计模式中称为‘具体访问者’)只需要定义自己感兴趣的节点类型，当访问者访问到对应节点时，就调用插件的访问(visit)方法</strong>。</p>
<p><br></p>
<h3 id="节点的遍历"><a href="#节点的遍历" class="headerlink" title="节点的遍历"></a>节点的遍历</h3><p>假设我们的代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span> + v + <span class="string">'!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>解析后的 AST 结构如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">File</span><br><span class="line">  Program (program)</span><br><span class="line">    FunctionDeclaration (body)</span><br><span class="line">      Identifier (id)  #hello</span><br><span class="line">      Identifier (params[0]) #v</span><br><span class="line">      BlockStatement (body)</span><br><span class="line">        ExpressionStatement ([0])</span><br><span class="line">          CallExpression (expression)</span><br><span class="line">            MemberExpression (callee)  #console.log</span><br><span class="line">              Identifier (object)  #console</span><br><span class="line">              Identifier (property)  #log</span><br><span class="line">            BinaryExpression (arguments[0])</span><br><span class="line">              BinaryExpression (left)</span><br><span class="line">                StringLiteral (left)  #'hello'</span><br><span class="line">                Identifier (right)  #v</span><br><span class="line">              StringLiteral (right)  #'!'</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>访问者会以<code>深度优先</code>的顺序, 或者说递归地对 AST 进行遍历，其调用顺序如下图所示:</p>
<p><img src="/images/babel/traveser.png" alt></p>
<p><br></p>
<p>上图中<code>绿线</code>表示进入该节点，<code>红线</code>表示离开该节点。下面写一个超简单的’具体访问者’来还原上面的遍历过程:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'@babel/core'</span>)</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">'@babel/traverse'</span>).default</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = babel.parseSync(code)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> depth = <span class="number">0</span></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  enter(path) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`enter <span class="subst">$&#123;path.type&#125;</span>(<span class="subst">$&#123;path.key&#125;</span>)`</span>)</span><br><span class="line">    depth++</span><br><span class="line">  &#125;,</span><br><span class="line">  exit(path) &#123;</span><br><span class="line">    depth--</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`  exit <span class="subst">$&#123;path.type&#125;</span>(<span class="subst">$&#123;path.key&#125;</span>)`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<details><br><summary> 查看代码执行结果 </summary><br><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">enter Program(program)</span><br><span class="line">  enter FunctionDeclaration(0)</span><br><span class="line">    enter Identifier(id)</span><br><span class="line">    exit Identifier(id)</span><br><span class="line">    enter Identifier(0)</span><br><span class="line">    exit Identifier(0)</span><br><span class="line">    enter BlockStatement(body)</span><br><span class="line">      enter ExpressionStatement(0)</span><br><span class="line">        enter CallExpression(expression)</span><br><span class="line">          enter MemberExpression(callee)</span><br><span class="line">            enter Identifier(object)</span><br><span class="line">            exit Identifier(object)</span><br><span class="line">            enter Identifier(property)</span><br><span class="line">            exit Identifier(property)</span><br><span class="line">          exit MemberExpression(callee)</span><br><span class="line">          enter BinaryExpression(0)</span><br><span class="line">            enter BinaryExpression(left)</span><br><span class="line">              enter StringLiteral(left)</span><br><span class="line">              exit StringLiteral(left)</span><br><span class="line">              enter Identifier(right)</span><br><span class="line">              exit Identifier(right)</span><br><span class="line">            exit BinaryExpression(left)</span><br><span class="line">            enter StringLiteral(right)</span><br><span class="line">            exit StringLiteral(right)</span><br><span class="line">          exit BinaryExpression(0)</span><br><span class="line">        exit CallExpression(expression)</span><br><span class="line">      exit ExpressionStatement(0)</span><br><span class="line">    exit BlockStatement(body)</span><br><span class="line">  exit FunctionDeclaration(0)</span><br><span class="line">exit Program(program)</span><br></pre></td></tr></table></figure><br><br></details>

<p><br></p>
<p>当访问者进入一个节点时就会调用 <code>enter(进入)</code> 方法，反之离开该节点时会调用 <code>exit(离开)</code> 方法。 一般情况下，插件不会直接使用<code>enter</code>方法，只会关注少数几个节点类型，所以具体访问者也可以这样声明访问方法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">traverse(ast, &#123;</span><br><span class="line">  <span class="comment">// 访问标识符</span></span><br><span class="line">  Identifier(path) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`enter Identifier`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 访问调用表达式</span></span><br><span class="line">  CallExpression(path) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`enter CallExpression`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 上面是enter的简写，如果要处理exit，也可以这样</span></span><br><span class="line">  <span class="comment">// 二元操作符</span></span><br><span class="line">  BinaryExpression: &#123;</span><br><span class="line">    enter(path) &#123;&#125;,</span><br><span class="line">    exit(path) &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 更高级的, 使用同一个方法访问多种类型的节点</span></span><br><span class="line">  <span class="string">"ExportNamedDeclaration|Flow"</span>(path) &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>那么 Babel 插件是怎么被应用的呢？</strong></p>
<p>Babel 会按照插件定义的顺序来应用访问方法，比如你注册了多个插件，babel-core 最后传递给访问器的数据结构大概长这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  Identifier: &#123;</span><br><span class="line">    enter: [plugin-xx, plugin-yy,] <span class="comment">// 数组形式</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>当进入一个节点时，这些插件会按照注册的顺序被执行。大部分插件是不需要开发者关心定义的顺序的，有少数的情况需要稍微注意以下，例如<code>plugin-proposal-decorators</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">"@babel/plugin-proposal-decorators"</span>,     <span class="comment">// 必须在plugin-proposal-class-properties之前</span></span><br><span class="line">    <span class="string">"@babel/plugin-proposal-class-properties"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>所有插件定义的顺序，按照惯例，应该是新的或者说实验性的插件在前面，老的插件定义在后面。因为可能需要新的插件将 AST 转换后，老的插件才能识别语法（向后兼容）。下面是官方配置例子, 为了确保先后兼容，<code>stage-*</code>阶段的插件先执行:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"es2015"</span>, <span class="string">"react"</span>, <span class="string">"stage-2"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意Preset的执行顺序相反，详见官方<a href="https://babeljs.io/docs/en/next/plugins#plugin-ordering" target="_blank" rel="noopener">文档</a></p>
</blockquote>
<p><br></p>
<h3 id="节点的上下文"><a href="#节点的上下文" class="headerlink" title="节点的上下文"></a>节点的上下文</h3><p>访问者在访问一个节点时, 会无差别地调用 <code>enter</code> 方法，我们怎么知道这个节点在什么位置以及和其他节点的关联关系呢？</p>
<p>通过上面的代码，读者应该可以猜出几分，每个<code>visit</code>方法都接收一个 <code>Path</code> 对象, 你可以将它当做一个‘上下文’对象，类似于<code>JQuery</code>的 <code>JQuery</code>(<code>const $el = $(&#39;.el&#39;)</code>) 对象，这里面包含了很多信息：</p>
<ul>
<li>当前节点信息</li>
<li>节点的关联信息。父节点、子节点、兄弟节点等等</li>
<li>作用域信息</li>
<li>上下文信息</li>
<li>节点操作方法。节点增删查改</li>
<li>断言方法。isXXX, assertXXX</li>
</ul>
<p>下面是它的主要结构:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">NodePath</span>&lt;<span class="title">T</span> </span>= Node&gt; &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(hub: Hub, parent: Node);</span><br><span class="line">    parent: Node;</span><br><span class="line">    hub: Hub;</span><br><span class="line">    contexts: TraversalContext[];</span><br><span class="line">    data: object;</span><br><span class="line">    shouldSkip: boolean;</span><br><span class="line">    shouldStop: boolean;</span><br><span class="line">    removed: boolean;</span><br><span class="line">    state: any;</span><br><span class="line">    opts: object;</span><br><span class="line">    skipKeys: object;</span><br><span class="line">    parentPath: NodePath;</span><br><span class="line">    context: TraversalContext;</span><br><span class="line">    container: object | object[];</span><br><span class="line">    listKey: string; // 如果节点在一个数组中，这个就是节点数组的键</span><br><span class="line">    inList: boolean;</span><br><span class="line">    parentKey: string;</span><br><span class="line">    key: string | number; // 节点所在的键或索引</span><br><span class="line">    node: T;  // 🔴 当前节点</span><br><span class="line">    scope: Scope; // 🔴当前节点所在的作用域</span><br><span class="line">    type: T extends undefined | null ? string | null : string; // 🔴节点类型</span><br><span class="line">    typeAnnotation: object;</span><br><span class="line">    // ... 还有很多方法，实现增删查改</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过这个<a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-visitors" target="_blank" rel="noopener">手册</a>来学习怎么通过 Path 来转换 AST. 后面也会有代码示例，这里就不展开细节了</p>
<p><br></p>
<h3 id="副作用的处理"><a href="#副作用的处理" class="headerlink" title="副作用的处理"></a>副作用的处理</h3><p>实际上访问者的工作比我们想象的要复杂的多，上面示范的是静态 AST 的遍历过程。而 AST 转换本身是有副作用的，比如插件将旧的节点替换了，那么访问者就没有必要再向下访问旧节点了，而是继续访问新的节点, 代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">traverse(ast, &#123;</span><br><span class="line">  ExpressionStatement(path) &#123;</span><br><span class="line">    <span class="comment">// 将 `console.log('hello' + v + '!')` 替换为 `return ‘hello’ + v`</span></span><br><span class="line">    <span class="keyword">const</span> rtn = t.returnStatement(t.binaryExpression(<span class="string">'+'</span>, t.stringLiteral(<span class="string">'hello'</span>), t.identifier(<span class="string">'v'</span>)))</span><br><span class="line">    path.replaceWith(rtn)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>上面的代码, 将<code>console.log(&#39;hello&#39; + v + &#39;!&#39;)</code>语句替换为<code>return &quot;hello&quot; + v;</code>, 下图是遍历的过程：</p>
<p><img src="/images/babel/replace.png" alt></p>
<p><br></p>
<p>我们可以对 AST 进行任意的操作，比如删除父节点的兄弟节点、删除第一个子节点、新增兄弟节点… <strong>当这些操作’污染’了 AST 树后，访问者需要记录这些状态，响应式(Reactive)更新 Path 对象的关联关系, 保证正确的遍历顺序，从而获得正确的转译结果</strong>。</p>
<p><br></p>
<h3 id="作用域的处理"><a href="#作用域的处理" class="headerlink" title="作用域的处理"></a>作用域的处理</h3><p>访问者可以确保正确地遍历和修改节点，但是对于转换器来说，另一个比较棘手的是对作用域的处理，这个责任落在了插件开发者的头上。插件开发者必须非常谨慎地处理作用域，不能破坏现有代码的执行逻辑。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>, b = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">foo, bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b)</span><br><span class="line">  <span class="keyword">return</span> foo + bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如你要将 <code>add</code> 函数的第一个参数 <code>foo</code> 标识符修改为<code>a</code>, 你就需要<strong>递归</strong>遍历子树，查出<code>foo</code>标识符的所有<code>引用</code>, 然后替换它:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">traverse(ast, &#123;</span><br><span class="line">  <span class="comment">// 将第一个参数名转换为a</span></span><br><span class="line">  FunctionDeclaration(path) &#123;</span><br><span class="line">    <span class="keyword">const</span> firstParams = path.get(<span class="string">'params.0'</span>)</span><br><span class="line">    <span class="keyword">if</span> (firstParams == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> name = firstParams.node.name</span><br><span class="line">    <span class="comment">// 递归遍历，这是插件常用的模式。这样可以避免影响到外部作用域</span></span><br><span class="line">    path.traverse(&#123;</span><br><span class="line">      Identifier(path) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.node.name === name) &#123;</span><br><span class="line">          path.replaceWith(t.identifier(<span class="string">'a'</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generate(ast).code)</span><br><span class="line"><span class="comment">// function add(a, bar) &#123;</span></span><br><span class="line"><span class="comment">//   console.log(a, b);</span></span><br><span class="line"><span class="comment">//   return a + bar;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>🤯慢着，好像没那么简单，替换成 <code>a</code> 之后, <code>console.log(a, b)</code> 的行为就被破坏了。所以这里不能用 <code>a</code>，得换个标识符, 譬如<code>c</code>.</p>
<p><br></p>
<p>这就是转换器需要考虑的作用域问题，<strong>AST 转换的前提是保证程序的正确性</strong>。 我们在添加和修改<code>引用</code>时，需要确保与现有的所有引用不冲突。Babel本身不能检测这类异常，只能依靠插件开发者谨慎处理。</p>
<p><br></p>
<p>Javascript采用的是词法作用域, 也就是根据源代码的词法结构来确定作用域：</p>
<p><img src="/images/babel/scope.png" alt></p>
<p>在<strong>词法区块(block)</strong>中，由于新建变量、函数、类、函数参数等创建的标识符，都属于这个区块作用域. 这些标识符也称为<strong>绑定(Binding)</strong>，而对这些绑定的使用称为<strong>引用(Reference)</strong></p>
<p>在Babel中，使用<code>Scope</code>对象来表示作用域。 我们可以通过Path对象的<code>scope</code>字段来获取当前节点的<code>Scope</code>对象。它的结构如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: NodePath;</span><br><span class="line">  block: Node;         <span class="comment">// 所属的词法区块节点, 例如函数节点、条件语句节点</span></span><br><span class="line">  parentBlock: Node;   <span class="comment">// 所属的父级词法区块节点</span></span><br><span class="line">  parent: Scope;       <span class="comment">// ⚛️指向父作用域</span></span><br><span class="line">  bindings: &#123; [name: string]: Binding; &#125;; <span class="comment">// ⚛️ 该作用域下面的所有绑定(即该作用域创建的标识符)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><code>Scope</code> 对象和 <code>Path</code> 对象差不多，<strong>它包含了作用域之间的关联关系(通过parent指向父作用域)，收集了作用域下面的所有绑定(bindings), 另外还提供了丰富的方法来对作用域仅限操作</strong>。</p>
<p>我们可以通过<code>bindings</code>属性获取当前作用域下的所有绑定(即标识符)，每个绑定由<code>Binding</code>类来表示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Binding</span> </span>&#123;</span><br><span class="line">  identifier: t.Identifier;</span><br><span class="line">  scope: Scope;</span><br><span class="line">  path: NodePath;</span><br><span class="line">  kind: <span class="string">"var"</span> | <span class="string">"let"</span> | <span class="string">"const"</span> | <span class="string">"module"</span>;</span><br><span class="line">  referenced: boolean;</span><br><span class="line">  references: number;              <span class="comment">// 被引用的数量</span></span><br><span class="line">  referencePaths: NodePath[];      <span class="comment">// ⚛️获取所有应用该标识符的节点路径</span></span><br><span class="line">  constant: boolean;               <span class="comment">// 是否是常量</span></span><br><span class="line">  constantViolations: NodePath[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过<code>Binding</code>对象我们可以确定标识符被引用的情况</strong>。</p>
<p>Ok，有了 <code>Scope</code> 和 <code>Binding</code>, 现在有能力实现安全的变量重命名转换了。 为了更好地展示作用域交互，在上面代码的基础上，我们再增加一下难度：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>, b = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">foo, bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="string">'1'</span> <span class="comment">// 新增了一个变量声明</span></span><br><span class="line">    <span class="keyword">return</span> a + (foo + bar)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你要重命名函数参数 <code>foo</code>, 不仅要考虑<code>外部的作用域</code>, 也要考虑<code>下级作用域</code>的绑定情况，确保这两者都不冲突。</p>
<p>上面的代码作用域和标识符引用情况如下图所示:</p>
<p><img src="/images/babel/scope2.png" alt></p>
<p><br></p>
<p>来吧，接受挑战，试着将函数的第一个参数重新命名为更短的标识符:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于获取唯一的标识符</span></span><br><span class="line"><span class="keyword">const</span> getUid = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`_<span class="subst">$&#123;(uid++) || <span class="string">''</span>&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = babel.parseSync(code)</span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  FunctionDeclaration(path) &#123;</span><br><span class="line">    <span class="comment">// 获取第一个参数</span></span><br><span class="line">    <span class="keyword">const</span> firstParam = path.get(<span class="string">'params.0'</span>)</span><br><span class="line">    <span class="keyword">if</span> (firstParam == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> currentName = firstParam.node.name</span><br><span class="line">    <span class="keyword">const</span> currentBinding = path.scope.getBinding(currentName)</span><br><span class="line">    <span class="keyword">const</span> gid = getUid()</span><br><span class="line">    <span class="keyword">let</span> sname</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环找出没有被占用的变量名</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      sname = gid()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1️⃣首先看一下父作用域是否已定义了该变量</span></span><br><span class="line">      <span class="keyword">if</span> (path.scope.parentHasBinding(sname)) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2️⃣ 检查当前作用域是否定义了变量</span></span><br><span class="line">      <span class="keyword">if</span> (path.scope.hasOwnBinding(sname)) &#123;</span><br><span class="line">        <span class="comment">// 已占用</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//  再检查第一个参数的当前的引用情况,</span></span><br><span class="line">      <span class="comment">// 如果它所在的作用域定义了同名的变量，我们也得放弃</span></span><br><span class="line">      <span class="keyword">if</span> (currentBinding.references &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> findIt = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> refNode <span class="keyword">of</span> currentBinding.referencePaths) &#123;</span><br><span class="line">          <span class="keyword">if</span> (refNode.scope !== path.scope &amp;&amp; refNode.scope.hasBinding(sname)) &#123;</span><br><span class="line">            findIt = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (findIt) &#123;</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始替换掉</span></span><br><span class="line">    <span class="keyword">const</span> i = t.identifier(sname)</span><br><span class="line">    currentBinding.referencePaths.forEach(<span class="function"><span class="params">p</span> =&gt;</span> p.replaceWith(i))</span><br><span class="line">    firstParam.replaceWith(i)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generate(ast).code)</span><br><span class="line"><span class="comment">// const a = 1,</span></span><br><span class="line"><span class="comment">//       b = 2;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function add(_, bar) &#123;</span></span><br><span class="line"><span class="comment">//   console.log(a, b);</span></span><br><span class="line"><span class="comment">//   return () =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     const a = '1'; // 新增了一个变量声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return a + (_ + bar);</span></span><br><span class="line"><span class="comment">//   &#125;;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>上面的例子虽然没有什么实用性，而且还有Bug(没考虑<code>label</code>)，但是正好可以揭示了作用域处理的复杂性。</p>
<p><br></p>
<p>Babel的 <code>Scope</code> 对象其实提供了一个<code>generateUid</code>方法来生成唯一的、不冲突的标识符。我们利用这个方法再简化一下我们的代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">traverse(ast, &#123;</span><br><span class="line">  FunctionDeclaration(path) &#123;</span><br><span class="line">    <span class="keyword">const</span> firstParam = path.get(<span class="string">'params.0'</span>)</span><br><span class="line">    <span class="keyword">if</span> (firstParam == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i = path.scope.generateUidIdentifier(<span class="string">'_'</span>) <span class="comment">// 也可以使用generateUid</span></span><br><span class="line">    <span class="keyword">const</span> currentBinding = path.scope.getBinding(firstParam.node.name)</span><br><span class="line">    currentBinding.referencePaths.forEach(<span class="function"><span class="params">p</span> =&gt;</span> p.replaceWith(i))</span><br><span class="line">    firstParam.replaceWith(i)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>能不能再短点!</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">traverse(ast, &#123;</span><br><span class="line">  FunctionDeclaration(path) &#123;</span><br><span class="line">    <span class="keyword">const</span> firstParam = path.get(<span class="string">'params.0'</span>)</span><br><span class="line">    <span class="keyword">if</span> (firstParam == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i = path.scope.generateUid(<span class="string">'_'</span>) <span class="comment">// 也可以使用generateUid</span></span><br><span class="line">    path.scope.rename(firstParam.node.name, i)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<details><br><summary>查看generateUid的实现代码</summary><br><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">generateUid(name: string = <span class="string">"temp"</span>) &#123;</span><br><span class="line">  name = t</span><br><span class="line">    .toIdentifier(name)</span><br><span class="line">    .replace(<span class="regexp">/^_+/</span>, <span class="string">""</span>)</span><br><span class="line">    .replace(<span class="regexp">/[0-9]+$/g</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> uid;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    uid = <span class="keyword">this</span>._generateUid(name, i);</span><br><span class="line">    i++;</span><br><span class="line">  &#125; <span class="keyword">while</span> (</span><br><span class="line">    <span class="keyword">this</span>.hasLabel(uid) ||</span><br><span class="line">    <span class="keyword">this</span>.hasBinding(uid) ||</span><br><span class="line">    <span class="keyword">this</span>.hasGlobal(uid) ||</span><br><span class="line">    <span class="keyword">this</span>.hasReference(uid)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> program = <span class="keyword">this</span>.getProgramParent();</span><br><span class="line">  program.references[uid] = <span class="literal">true</span>;</span><br><span class="line">  program.uids[uid] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details>

<p>非常简洁哈？作用域操作最典型的场景是代码压缩，代码压缩会对变量名、函数名等进行压缩… 然而实际上很少的插件场景需要跟作用域进行复杂的交互，所以关于作用域这一块就先讲到这里。</p>
<p><br></p>
<h2 id="搞一个插件呗"><a href="#搞一个插件呗" class="headerlink" title="搞一个插件呗"></a>搞一个插件呗</h2><p>等等别走，还没完呢，这才到2/3。学了上面得了知识，总得写一个玩具插件试试水吧?</p>
<p>现在打算模仿<a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="noopener">babel-plugin-import</a>, 写一个极简版插件，来实现模块的按需导入. 在这个插件中，我们会将类似这样的导入语句:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;A, B, C <span class="keyword">as</span> D&#125; <span class="keyword">from</span> <span class="string">'foo'</span></span><br></pre></td></tr></table></figure>
<p>转换为:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> A <span class="keyword">from</span> <span class="string">'foo/A'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'foo/A/style.css'</span></span><br><span class="line"><span class="keyword">import</span> B <span class="keyword">from</span> <span class="string">'foo/B'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'foo/B/style.css'</span></span><br><span class="line"><span class="keyword">import</span> D <span class="keyword">from</span> <span class="string">'foo/C'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'foo/C/style.css'</span></span><br></pre></td></tr></table></figure>
<p>首先通过 <a href="https://astexplorer.net" target="_blank" rel="noopener">AST Explorer</a> 看一下导入语句的 AST 节点结构:</p>
<p><img src="/images/babel/import.png" alt></p>
<p><br></p>
<p>通过上面展示的结果，我们需要处理 <code>ImportDeclaration</code> 节点类型，将它的<code>specifiers</code>拿出来遍历处理一下。另外如果用户使用了<code>默认导入</code>语句，我们将抛出错误，提醒用户不能使用默认导入. </p>
<p>基本实现如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要识别的模块</span></span><br><span class="line"><span class="keyword">const</span> MODULE = <span class="string">'foo'</span></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  <span class="comment">// 访问导入语句</span></span><br><span class="line">  ImportDeclaration(path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.node.source.value !== MODULE) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是空导入则直接删除掉</span></span><br><span class="line">    <span class="keyword">const</span> specs = path.node.specifiers</span><br><span class="line">    <span class="keyword">if</span> (specs.length === <span class="number">0</span>) &#123;</span><br><span class="line">      path.remove()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否包含了默认导入和命名空间导入</span></span><br><span class="line">    <span class="keyword">if</span> (specs.some(<span class="function"><span class="params">i</span> =&gt;</span> t.isImportDefaultSpecifier(i) || t.isImportNamespaceSpecifier(i))) &#123;</span><br><span class="line">      <span class="comment">// 抛出错误，Babel会展示出错的代码帧</span></span><br><span class="line">      <span class="keyword">throw</span> path.buildCodeFrameError(<span class="string">"不能使用默认导入或命名空间导入"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换命名导入</span></span><br><span class="line">    <span class="keyword">const</span> imports = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> spec <span class="keyword">of</span> specs) &#123;</span><br><span class="line">      <span class="keyword">const</span> named = MODULE + <span class="string">'/'</span> + spec.imported.name</span><br><span class="line">      <span class="keyword">const</span> local = spec.local</span><br><span class="line">      imports.push(t.importDeclaration([t.importDefaultSpecifier(local)], t.stringLiteral(named)))</span><br><span class="line">      imports.push(t.importDeclaration([], t.stringLiteral(<span class="string">`<span class="subst">$&#123;named&#125;</span>/style.css`</span>)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换原有的导入语句</span></span><br><span class="line">    path.replaceWithMultiple(imports)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>逻辑还算简单，<code>babel-plugin-import</code>可比这复杂得多。</p>
<p><br></p>
<p>接下来，我们将它封装成标准的 Babel 插件。 按照规范，我们需要创建一个<code>babel-plugin-*</code>前缀的包名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mkdir babel-plugin-toy-<span class="keyword">import</span></span><br><span class="line">cd babel-plugin-toy-<span class="keyword">import</span></span><br><span class="line">yarn init -y</span><br><span class="line">touch index.js</span><br></pre></td></tr></table></figure>
<p><br></p>
<blockquote>
<p>你也可以通过 <a href="https://github.com/babel/generator-babel-plugin/tree/master/generators/app/templates" target="_blank" rel="noopener">generator-babel-plugin</a> 来生成项目模板.</p>
</blockquote>
<p><br></p>
<p>在 <code>index.js</code> 文件中填入我们的代码。<code>index.js</code>默认导出一个函数，函数结构如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接受一个 babel-core 对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">babel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="attr">types</span>: t&#125; = babel</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    pre(state) &#123;</span><br><span class="line">      <span class="comment">// 前置操作，可选，可以用于准备一些资源</span></span><br><span class="line">    &#125;,</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      <span class="comment">// 我们的访问者代码将放在这里</span></span><br><span class="line">      ImportDeclaration(path, state) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    post(state) &#123;</span><br><span class="line">      <span class="comment">// 后置操作，可选</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>我们可以从访问器方法的第二个参数<code>state</code>中获取用户传入的参数</strong>。假设用户配置为:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  plugins: [[<span class="string">'toy-plugin'</span>, &#123;<span class="attr">name</span>: <span class="string">'foo'</span>&#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以这样获取用户传入的参数:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">babel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="attr">types</span>: t&#125; = babel</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      ImportDeclaration(path, state) &#123;</span><br><span class="line">        <span class="keyword">const</span> mod = state.opts &amp;&amp; state.opts.name</span><br><span class="line">        <span class="keyword">if</span> (mod == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打完收工 🙏，发布!</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn publish # good luck</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote>
<p>新世界的大门已经打开: ⛩</p>
</blockquote>
<p>本文主要介绍了 Babel 的架构和原理，还实践了一下 Babel 插件开发，读到这里，你算是入了 Babel 的门了.</p>
<p>接下来你可以去熟读<a href="https://github.com/jamiebuilds/babel-handbook" target="_blank" rel="noopener">Babel手册</a>, 这是目前最好的教程,<br><a href="https://astexplorer.net/#/KJ8AjD6maa" target="_blank" rel="noopener">ASTExplorer</a>是最好的演练场，多写代码多思考。<br>你也可以去看<a href="https://github.com/babel/babel/tree/master/packages" target="_blank" rel="noopener">Babel的官方插件实现</a>, 迈向更高的台阶。</p>
<p>本文还有下篇，我将在下篇文章中介绍<a href="https://github.com/kentcdodds/babel-plugin-macros" target="_blank" rel="noopener">babel-plugin-macros</a>, 敬请期待！</p>
<p>点赞是对我最好鼓励。</p>
<p><br></p>
<p><img src="/images/sponsor.jpg" alt></p>
<p><br></p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul>
<li><a href="https://astexplorer.net/#/KJ8AjD6maa" target="_blank" rel="noopener">ASTExplorer</a></li>
<li><a href="https://github.com/jamiebuilds/babel-handbook" target="_blank" rel="noopener">babel-handbook</a></li>
<li><a href="https://github.com/babel/generator-babel-plugin" target="_blank" rel="noopener">generator-babel-plugin</a></li>
<li><a href="https://the-super-tiny-compiler.glitch.me" target="_blank" rel="noopener">the-super-tiny-compiler</a></li>
</ul>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#babel-的处理流程"><span class="toc-number">1.</span> <span class="toc-text">Babel 的处理流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#babel-的架构"><span class="toc-number">2.</span> <span class="toc-text">Babel 的架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问者模式"><span class="toc-number">3.</span> <span class="toc-text">访问者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#节点的遍历"><span class="toc-number">3.1.</span> <span class="toc-text">节点的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#节点的上下文"><span class="toc-number">3.2.</span> <span class="toc-text">节点的上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#副作用的处理"><span class="toc-number">3.3.</span> <span class="toc-text">副作用的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域的处理"><span class="toc-number">3.4.</span> <span class="toc-text">作用域的处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#搞一个插件呗"><span class="toc-number">4.</span> <span class="toc-text">搞一个插件呗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最后"><span class="toc-number">5.</span> <span class="toc-text">最后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展"><span class="toc-number">6.</span> <span class="toc-text">扩展</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2019/10/01/babel/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2019/10/01/babel/&text=深入浅出 Babel 上篇：架构和原理 + 实战"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2019/10/01/babel/&title=深入浅出 Babel 上篇：架构和原理 + 实战"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2019/10/01/babel/&is_video=false&description=深入浅出 Babel 上篇：架构和原理 + 实战"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=深入浅出 Babel 上篇：架构和原理 + 实战&body=Check out this article: https://bobi.ink/2019/10/01/babel/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2019/10/01/babel/&title=深入浅出 Babel 上篇：架构和原理 + 实战"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2019/10/01/babel/&title=深入浅出 Babel 上篇：架构和原理 + 实战"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2019/10/01/babel/&title=深入浅出 Babel 上篇：架构和原理 + 实战"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2019/10/01/babel/&title=深入浅出 Babel 上篇：架构和原理 + 实战"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2019/10/01/babel/&name=深入浅出 Babel 上篇：架构和原理 + 实战&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2023 Ivan
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-44571525-2', 'auto');
        ga('send', 'pageview');
    </script>


    <!-- Disqus Comments -->
    <script type="text/javascript">
        var disqus_shortname = 'bobi-ink';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


