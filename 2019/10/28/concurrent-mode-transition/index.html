<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="上篇文章介绍了 Suspense, 那么这篇文章就讲讲它的好搭档 useTransition。如果你是 React 的粉丝，这两篇文章一定不能错过。 我们知道 React 内部做了翻天覆地的优化，外部也提供了一些紧凑的新 API，这些 API 主要用来优化用户体验。React 官方用一篇很长的文档《Concurrent UI Patterns 》 专门来介绍这一方面的动机和创造，其中的主角就是 u">
<meta name="keywords" content="Blog,FrontEnd,React,Javascript,Typescript">
<meta property="og:type" content="article">
<meta property="og:title" content="React Concurrent 模式抢先预览下篇: useTransition 的平行世界">
<meta property="og:url" content="https://bobi.ink/2019/10/28/concurrent-mode-transition/index.html">
<meta property="og:site_name" content="Bobi.ink">
<meta property="og:description" content="上篇文章介绍了 Suspense, 那么这篇文章就讲讲它的好搭档 useTransition。如果你是 React 的粉丝，这两篇文章一定不能错过。 我们知道 React 内部做了翻天覆地的优化，外部也提供了一些紧凑的新 API，这些 API 主要用来优化用户体验。React 官方用一篇很长的文档《Concurrent UI Patterns 》 专门来介绍这一方面的动机和创造，其中的主角就是 u">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://bobi.ink/images/concurrent-mode/suspense-branch.png">
<meta property="og:image" content="https://bobi.ink/images/concurrent-mode/component-state.png">
<meta property="og:image" content="https://bobi.ink/images/concurrent-mode/browser.gif">
<meta property="og:image" content="https://bobi.ink/images/concurrent-mode/github.gif">
<meta property="og:image" content="https://bobi.ink/images/concurrent-mode/page-state.png">
<meta property="og:image" content="https://bobi.ink/images/concurrent-mode/demo1.gif">
<meta property="og:image" content="https://bobi.ink/images/concurrent-mode/demo2.gif">
<meta property="og:image" content="https://bobi.ink/images/concurrent-mode/test1.gif">
<meta property="og:image" content="https://bobi.ink/images/concurrent-mode/test2.gif">
<meta property="og:image" content="https://bobi.ink/images/concurrent-mode/test3.gif">
<meta property="og:image" content="https://bobi.ink/images/concurrent-mode/test4-1.gif">
<meta property="og:image" content="https://bobi.ink/images/concurrent-mode/test4-2.gif">
<meta property="og:image" content="https://bobi.ink/images/concurrent-mode/test4-3.gif">
<meta property="og:image" content="https://bobi.ink/images/concurrent-mode/test5.gif">
<meta property="og:image" content="https://bobi.ink/images/concurrent-mode/hyhs.png">
<meta property="og:image" content="https://bobi.ink/images/sponsor.jpg">
<meta property="og:updated_time" content="2023-06-01T09:55:14.328Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React Concurrent 模式抢先预览下篇: useTransition 的平行世界">
<meta name="twitter:description" content="上篇文章介绍了 Suspense, 那么这篇文章就讲讲它的好搭档 useTransition。如果你是 React 的粉丝，这两篇文章一定不能错过。 我们知道 React 内部做了翻天覆地的优化，外部也提供了一些紧凑的新 API，这些 API 主要用来优化用户体验。React 官方用一篇很长的文档《Concurrent UI Patterns 》 专门来介绍这一方面的动机和创造，其中的主角就是 u">
<meta name="twitter:image" content="https://bobi.ink/images/concurrent-mode/suspense-branch.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>React Concurrent 模式抢先预览下篇: useTransition 的平行世界</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/11/04/react-composition/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/10/26/concurrent-mode-suspense/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2019/10/28/concurrent-mode-transition/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2019/10/28/concurrent-mode-transition/&text=React Concurrent 模式抢先预览下篇: useTransition 的平行世界"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2019/10/28/concurrent-mode-transition/&title=React Concurrent 模式抢先预览下篇: useTransition 的平行世界"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2019/10/28/concurrent-mode-transition/&is_video=false&description=React Concurrent 模式抢先预览下篇: useTransition 的平行世界"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=React Concurrent 模式抢先预览下篇: useTransition 的平行世界&body=Check out this article: https://bobi.ink/2019/10/28/concurrent-mode-transition/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2019/10/28/concurrent-mode-transition/&title=React Concurrent 模式抢先预览下篇: useTransition 的平行世界"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2019/10/28/concurrent-mode-transition/&title=React Concurrent 模式抢先预览下篇: useTransition 的平行世界"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2019/10/28/concurrent-mode-transition/&title=React Concurrent 模式抢先预览下篇: useTransition 的平行世界"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2019/10/28/concurrent-mode-transition/&title=React Concurrent 模式抢先预览下篇: useTransition 的平行世界"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2019/10/28/concurrent-mode-transition/&name=React Concurrent 模式抢先预览下篇: useTransition 的平行世界&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#应用场景是什么？"><span class="toc-number">1.</span> <span class="toc-text">应用场景是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#usetransition-登场"><span class="toc-number">2.</span> <span class="toc-text">useTransition 登场</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#usetransition-原理初探"><span class="toc-number">3.</span> <span class="toc-text">useTransition 原理初探</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1️⃣-利用-starttransition-来运行低优先级任务"><span class="toc-number">3.1.</span> <span class="toc-text">1️⃣ 利用 startTransition 来运行低优先级任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2️⃣-starttransition-更新触发-suspense"><span class="toc-number">3.2.</span> <span class="toc-text">2️⃣ startTransition 更新触发 Suspense</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3️⃣-将-tick-更新提到-starttransition-作用域外"><span class="toc-number">3.3.</span> <span class="toc-text">3️⃣ 将 tick 更新提到 startTransition 作用域外</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4️⃣-嵌套suspense"><span class="toc-number">3.4.</span> <span class="toc-text">4️⃣ 嵌套Suspense</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5️⃣-可以和-mobx-和-redux-配合使用吗"><span class="toc-number">3.5.</span> <span class="toc-text">5️⃣ 可以和 Mobx 和 Redux 配合使用吗?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#那-usedeferedvalue-呢？"><span class="toc-number">4.</span> <span class="toc-text">那 useDeferedValue 呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">6.</span> <span class="toc-text">参考资料</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        React Concurrent 模式抢先预览下篇: useTransition 的平行世界
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Bobi.ink</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-10-27T16:00:00.000Z" itemprop="datePublished">2019-10-28</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>上篇文章介绍了 <a href="https://juejin.im/post/5db65d87518825648f2ef899" target="_blank" rel="noopener"><code>Suspense</code></a>, 那么这篇文章就讲讲它的好搭档 <a href="https://reactjs.org/docs/concurrent-mode-reference.html#usetransition" target="_blank" rel="noopener"><code>useTransition</code></a>。如果你是 React 的粉丝，这两篇文章一定不能错过。</p>
<p>我们知道 React 内部做了翻天覆地的优化，外部也提供了一些紧凑的新 API，<strong>这些 API 主要用来优化用户体验</strong>。React 官方用一篇很长的文档<a href="https://reactjs.org/docs/concurrent-mode-patterns.html" target="_blank" rel="noopener">《Concurrent UI Patterns 》</a> 专门来介绍这一方面的动机和创造，其中的主角就是 <code>useTransition</code>。</p>
<p><br></p>
<p><strong>相关文章</strong></p>
<ul>
<li><a href="https://juejin.im/post/5dadc6045188255a270a0f85" target="_blank" rel="noopener">这可能是最通俗的 React Fiber(时间分片) 打开方式</a> 🔥先入个门</li>
<li><a href="https://juejin.im/post/5db65d87518825648f2ef899" target="_blank" rel="noopener">React Concurrent 模式抢先预览上篇: Suspense the world</a> 上篇</li>
</ul>
<p><br><br><br></p>
<p><strong>本文大纲</strong></p>
<!-- TOC -->
<ul>
<li><a href="#应用场景是什么">应用场景是什么？</a></li>
<li><a href="#usetransition-登场">useTransition 登场</a></li>
<li><a href="#usetransition-原理初探">useTransition 原理初探</a><ul>
<li><a href="#1️⃣-利用-starttransition-来运行低优先级任务"><strong>1️⃣ 利用 startTransition 来运行低优先级任务</strong></a></li>
<li><a href="#2️⃣-starttransition-更新触发-suspense"><strong>2️⃣ startTransition 更新触发 Suspense</strong></a></li>
<li><a href="#3️⃣-将-tick-更新提到-starttransition-作用域外"><strong>3️⃣ 将 tick 更新提到 startTransition 作用域外</strong></a></li>
<li><a href="#4️⃣-嵌套suspense"><strong>4️⃣ 嵌套Suspense</strong></a></li>
<li><a href="#5️⃣-可以和-mobx-和-redux-配合使用吗"><strong>5️⃣ 可以和 Mobx 和 Redux 配合使用吗?</strong></a></li>
</ul>
</li>
<li><a href="#那-usedeferedvalue-呢">那 useDeferedValue 呢？</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<p><br></p>
<p>React 用’<strong>平行宇宙</strong>‘来比喻这个 useTransition 这个 API。What？</p>
<p>用 Git 分支来比喻会更好理解一点, 如下图，React 可以从当前视图(可以视作 <code>Master</code>) 分支中 <code>Fork</code> 出来一个新的分支(尚且称为 <code>Pending</code>)，在这个新分支上进行更新，同时 <code>Master</code> 保持响应和更新，这两个分支就像’平行宇宙’，两者互不干扰。当 <code>Pending</code> 分支准备’妥当’，再合并(提交)到 <code>Master</code>分支。</p>
<p><img src="/images/concurrent-mode/suspense-branch.png" alt></p>
<p><br></p>
<p><code>useTransition</code> 就像一个时光隧道, 让组件进入一个平行宇宙，在这个平行宇宙中等待<code>异步状态</code>(异步请求、延时、whatever)就绪。当然组件也不能无限期待在平行宇宙，<code>useTranstion</code> 可以配置超时时间，如果超时了，就算<code>异步状态</code>未就绪也会被强制拉回现实世界。回到现实世界后，React 会立即对组件 Pengding 的变更进行合并，呈现在用户面前。</p>
<p>因此，你可以认为在Concurrent 模式下， React 组件有三种状态:</p>
<p><img src="/images/concurrent-mode/component-state.png" alt></p>
<p><br></p>
<ul>
<li><strong>Normal</strong> - 正常状态下的组件</li>
<li><strong>Suspense</strong> - 因异步状态而挂起的组件</li>
<li><strong>Pending</strong> - 进入平行宇宙的组件。对应的也有 Pending 的’状态变更’，这些变更 React 不会立即提交到用户界面，而是缓存着，等待 Suspense 就绪或超时。</li>
</ul>
<p>你可能还不太能理解, 没关系，继续往下读。</p>
<p><br><br><br></p>
<h2 id="应用场景是什么？"><a href="#应用场景是什么？" class="headerlink" title="应用场景是什么？"></a>应用场景是什么？</h2><p>‘平行宇宙’有什么用？ 我们不讲代码或者架构层次的东西。单从 <code>UI</code> 上看： <strong>在某些 UI 交互场景，我们并不想马上将变更立即应用到页面上</strong>。</p>
<p><strong>🔴比如你从一个页面切换到另一个页面，新页面可能需要一些时间才能加载完成，其实我们更乐于稍微停留在上一个页面，保持一些操作响应, 比如我们可以取消，或者进行其他操作，而给我看一个什么都没有的空白页面或者空转加载状态符, 感觉在做无谓的等待</strong>。</p>
<p>这种交互场景其实非常常见，眼前的例子就是浏览器：</p>
<p><br></p>
<p><img src="/images/concurrent-mode/browser.gif" alt><br><i>假装我要买个 AirPods</i></p>
<p><br></p>
<p>还有我们常用的 Github:</p>
<p><img src="/images/concurrent-mode/github.gif" alt><br><i>国外某著名交友网站</i></p>
<p><br></p>
<p>比如我想点击买个 <code>AirPods</code>，浏览器会停留在上一个页面，直到下一个页面的请求获得响应或者超时。另外浏览器会通过地址栏的加载指示符提示请求情况。这种交互设计，比直接切换过去，展示一个空白的页面要好得多. 页面可以保持用户响应, 也可以随时取消请求，保留在原来的页面。</p>
<blockquote>
<p>当然, Tab 切换时另外一种交互场景，我们希望它马上切换过去, 否则用户会觉得点击不起作用。</p>
</blockquote>
<p>‘平行宇宙’，还有一个好处: <strong>🔴我们假设大部分情况下，数据请求都是非常快的，这时候其实没有必要展示加载状态，这会导致页面闪烁和抖动。其实通过短暂的延时，可以来减少加载状态的展示频率</strong>。</p>
<p>另外，<strong>🔴useTransition 也可以用于包裹低优先级更新</strong>。 从目前的情况看，React 并没有意愿暴露过多的 Concurrent 模式的底层细节。如果你要调度低优先级的更新，只能使用 useTransition。</p>
<p><br><br><br></p>
<h2 id="usetransition-登场"><a href="#usetransition-登场" class="headerlink" title="useTransition 登场"></a>useTransition 登场</h2><p><img src="/images/concurrent-mode/page-state.png" alt></p>
<p><br></p>
<p>如上图，我们先按照 React 官方文档的描述来定义页面的各种状态。<strong>它提到页面加载有以下三个阶段</strong>:</p>
<p><strong>① 过渡阶段(Transition)</strong></p>
<p>指的是页面未就绪，等待加载关键数据的阶段。按照不同的展示策略，页面可以有以下两种状态：</p>
<ul>
<li><p><strong>⚛️退化(Receded)</strong>。马上将页面切换过去，展示一个大大的加载指示器或者空白页面。’退化’是什么意思? 按照 React 的说法是，页面原本有内容，现在变为无内容状态，这是一种退化，或者说历史的’退步’。</p>
</li>
<li><p><strong>⚛️待定(Pending)</strong>。这是 <code>useTransition</code> 要达到的状态，即停留在当前页面，让当前页面保持响应。在<strong>关键数据准备就绪</strong>时进入 <code>Skeleton</code>(骨架屏) 状态， 亦或者等待超时回退到 <code>Receded</code> 状态。</p>
</li>
</ul>
<p><br></p>
<p><strong>② 加载阶段(Loading)</strong></p>
<p>指的是<code>关键数据</code>已经准备就绪，可以开始展示页面的骨架或者框架部分。这个阶段有一个状态:</p>
<ul>
<li><strong>⚛️骨架(Skeleton)</strong>。关键数据已经加载完毕，页面展示了主体的框架。</li>
</ul>
<p><br></p>
<p><strong>③就绪阶段(Done)</strong>。</p>
<p>指的是页面完全加载完毕。这个阶段有一个状态:</p>
<ul>
<li><strong>⚛️完成(Complete)</strong> 页面完全呈现</li>
</ul>
<p><br><br><br></p>
<p>传统的 React 中，当我们变更状态进入一个新屏幕时，经历的是 <strong>🔴<code>Receded</code> -&gt; <code>Skeleton</code> -&gt; <code>Complete</code></strong> 路径。在此之前要实现 <strong>🔴<code>Pending</code> -&gt; <code>Skeleton</code> -&gt; <code>Complete</code></strong> 这种加载路径比较困难。 <code>useTransition</code> 可以改变这个局面。</p>
<p><br></p>
<p>接下来简单模拟一个页面切换，先来看默认情况下是如何加载的:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"letter"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️ 延迟加载2s，模拟异步数据请求</span></span><br><span class="line">  delay(<span class="string">"B"</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"letter"</span>&gt;</span>B<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️ 延迟加载4s，模拟异步数据请求</span></span><br><span class="line">  delay(<span class="string">"C"</span>, <span class="number">4000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"letter"</span>&gt;</span>C<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Page1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">A</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 页面2</span></span><br><span class="line"><span class="xml">function Page2() &#123;</span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">B</span> /&gt;</span></span></span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;Loading... C&lt;/div&gt;&#125;&gt;</span><br><span class="line">        &lt;C /&gt;</span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line"><span class="xml">  );</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function App() &#123;</span></span><br><span class="line"><span class="xml">  const [showPage2, setShowPage2] = useState(false);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  // 点击切换到页面2</span></span><br><span class="line"><span class="xml">  const handleClick = () =&gt;  setShowPage2(true)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line">    &lt;div className="App"&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;handleClick&#125;&gt;切换&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className="page"&gt;</span><br><span class="line">        &lt;Suspense fallback=&#123;&lt;div&gt;Loading ...&lt;/div&gt;&#125;&gt;</span><br><span class="line">          &#123;!showPage2 ? &lt;Page1 /&gt; : &lt;Page2 /&gt;&#125;</span><br><span class="line">        &lt;/Suspense&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  );</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>看一下运行效果:</p>
<p><img src="/images/concurrent-mode/demo1.gif" alt></p>
<p>点击切换后，我们会马上看到一个大大的 <code>Loading...</code>，接着 2s 后 B 加载完毕，再等待 2s 后 C 加载完毕。这个过程就是 <strong><code>Receded</code> -&gt; <code>Skeleton</code> -&gt; <code>Complete</code></strong></p>
<p><br></p>
<p>现在有请 useTransition 隆重登场 🎉，只需对上面的代码进行的简单改造：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⚛️ 导入 useTransition</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Suspense, useState, useTransition &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [showPage2, setShowPage2] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// ⚛️ useTransition 接收一个超时时间，返回一个startTransition 函数，以及一个 pending</span></span><br><span class="line">  <span class="keyword">const</span> [startTransition, pending] = useTransition(&#123; <span class="attr">timeoutMs</span>: <span class="number">10000</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">    <span class="comment">// ⚛️ 将可能触发 Suspense 挂起的状态变更包裹在 startTransition 中</span></span><br><span class="line">    startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setShowPage2(<span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;handleClick&#125;&gt;切换&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>* ⚛️ pending 表示处于待定状态, 你可以进行一些轻微的提示 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &#123;pending &amp;&amp; &lt;span&gt;切换中...&lt;/</span>span&gt;&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="page"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Suspense fallback=&#123;&lt;div&gt;Loading ...&lt;/</span>div&gt;&#125;&gt;</span><br><span class="line">          &#123;!showPage2 ? <span class="xml"><span class="tag">&lt;<span class="name">Page1</span> /&gt;</span> : <span class="tag">&lt;<span class="name">Page2</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>useTransition Hook 的API比较简洁，有4个需要关键的点:</p>
<ul>
<li><p><code>timeoutMs</code>, 表示切换的超时时间(最长在平行宇宙存在的时间)，useTransition 会让 React 保持在当前页面，直到被触发 Suspense 就绪或者超时。</p>
</li>
<li><p><code>startTransition</code>, 将可能触发页面切换(严格说是触发 Suspense 挂起)的状态变更包裹在 <code>startTransition</code> 下，实际上 startTransition 提供了一个’更新的上下文’。 下一节我们会深入探索这里面的细节</p>
</li>
<li><p><code>pending</code>, 表示正处于待定状态。我们可以通过这个状态值，适当地给用户一下提示。</p>
</li>
<li><p><code>Suspense</code>, useTransition 实现过渡状态必须和 Suspense 配合，也就是 <code>startTransition</code> 中的更新必须触发任意一个 Suspense 挂起。</p>
</li>
</ul>
<p><br></p>
<p>看一下实际的运行效果吧！</p>
<p><img src="/images/concurrent-mode/demo2.gif" alt></p>
<p><br></p>
<blockquote>
<p>可以在这个 <a href="https://codesandbox.io/s/usetransition-y74ry?fontsize=14" target="_blank" rel="noopener">CodeSandbox</a> 查看运行效果</p>
</blockquote>
<p>这个效果完全跟本节开始的’第一张图’一样: React 会保留在当前页面，<code>pending</code> 变为了true，接着 B 先就绪，界面马上切换过去。整个过程符合 <strong><code>Pending</code> -&gt; <code>Skeleton</code> -&gt; <code>Complete</code></strong> 的路径。</p>
<p><code>startTransition</code> 中的<code>变更</code>一旦触发 <code>Suspense</code>，React 就会将<code>变更</code>标记的 Pending 状态, React会延后 ’提交‘ 这些变更。所以<strong>实际上并没有开头说的平行宇宙, 那么高大上和神奇，React 只不过是延后了这些变更的提交。我们界面上看到的只不过是旧的或者未被 Pending 的状态，React 在后台进行了预渲染</strong>。</p>
<p>注意，React 只是暂时没有提交这些变更，不说明 React ’卡死了‘，处于Pending 状态的组件还会接收用户的响应，进行新的状态变更，新的状态更新也可以覆盖或终止 Pending 状态。</p>
<p><br></p>
<p>总结一下进入和退出 Pending 状态的条件:</p>
<ul>
<li><strong>进入Pending</strong> 状态首先需要将 <code>状态变更</code> 包裹在 <code>startTransition</code> 下，且这些更新会触发 Suspense 挂起</li>
<li><strong>退出 Pending</strong> 状态有三种方式: ① Suspense 就绪；② 超时；③ 被新的状态更新覆盖或者终止</li>
</ul>
<p><br><br><br></p>
<h2 id="usetransition-原理初探"><a href="#usetransition-原理初探" class="headerlink" title="useTransition 原理初探"></a>useTransition 原理初探</h2><p>这一节，我们深入探索一下 useTransition，但是方式不是去折腾源码，而是把它当成一个黑盒，通过几个实验来加深你对 useTransition 的理解。</p>
<p>useTransition 的前身是 <code>withSuspenseConfig</code>, <a href="https://github.com/sebmarkbage" target="_blank" rel="noopener">Sebmarkbage</a> 在今年五月份提的一个<a href="https://github.com/facebook/react/pull/15593" target="_blank" rel="noopener">PR</a> 中引进了它。</p>
<p>从命名上看，它不过是想配置一下 Suspense。 我们也可以通过最新的源码验证这一点。 useTransition 的工作’看似’非常简单:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTransition</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  config: SuspenseConfig | void | null,</span></span></span><br><span class="line">): [(() =&gt; void) =&gt; void, boolean] &#123;</span><br><span class="line">  <span class="keyword">const</span> [isPending, setPending] = updateState(<span class="literal">false</span>); <span class="comment">// 相当于useState</span></span><br><span class="line">  <span class="keyword">const</span> startTransition = updateCallback(             <span class="comment">// 相当于useCallback</span></span><br><span class="line">    callback =&gt; &#123;</span><br><span class="line">      setPending(<span class="literal">true</span>); <span class="comment">// 设置 pending 为 true</span></span><br><span class="line">      <span class="comment">// 以低优先级调度执行</span></span><br><span class="line">      Scheduler.unstable_next(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ⚛️ 设置suspenseConfig</span></span><br><span class="line">        <span class="keyword">const</span> previousConfig = ReactCurrentBatchConfig.suspense;</span><br><span class="line">        ReactCurrentBatchConfig.suspense = config === <span class="literal">undefined</span> ? <span class="literal">null</span> : config;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 还原 pending</span></span><br><span class="line">          setPending(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 执行你的回调</span></span><br><span class="line">          callback();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// ⚛️ 还原suspenseConfig</span></span><br><span class="line">          ReactCurrentBatchConfig.suspense = previousConfig;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    [config, isPending],</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> [startTransition, isPending];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>看似很普通，要点在哪？Sebmarkbage 在上述的 PR 中也提及了一些信息。</p>
<ul>
<li><p>startTransition 一开始执行就将 pending 设置为true。接着使用 <code>unstable_next</code> 执行回调, <strong>unstable_next 可以降低更新的优先级</strong>。也就是说 unstable_next 回调中触发的’变更‘优先级会比较低，它会让位为高优先级的更新，或者当前事务繁忙时，调度到下一空闲期再应用，但也可能马上就被应用。</p>
</li>
<li><p>要点是 <code>ReactCurrentBatchConfig.suspense</code> 的配置, 这里面会配置 Suspense 的超时时间。<strong>它表明这个区间触发的变更都被关联该 <code>suspenseConfig</code></strong>, 这些变更会根据 suspenseConfig 来计算自己的 <code>expiredTime</code>(可以视作‘优先级’)。我们暂且将这些关联了 suspenseConfig 的变更称为 <code>Pending 变更</code>.</p>
</li>
<li><p><code>Pending 变更</code> 触发的重新渲染(Render)也会关联该 <code>suspenseConfig</code>。如果在渲染期间触发了 Suspense，那么<code>Pending 变更</code> 就会被延迟提交(commit)，它们会缓存在内存中, 等到 Suspense 超时或者就绪, 抑或被其他更新覆盖, 才强制提交到用户界面。</p>
</li>
<li><p><code>Pending 变更</code> 只是被延迟提交了，但是不会影响最终数据和视图的一致性。React 会在内存中重新渲染，只是不提交到用户界面而已。</p>
</li>
</ul>
<p><br></p>
<p>React 内部的实现太过复杂，我发现去挖它或者用文字表达出来成本都很高。因此换一种方式，通过实验(黑盒)方式来了解它的行为：</p>
<blockquote>
<p>这些实验代码在这个 <a href="https://codesandbox.io/s/react-use-transition-tests-kg8rc?fontsize=14" target="_blank" rel="noopener">CodeSandbox</a> 中</p>
</blockquote>
<p><br></p>
<h3 id="1️⃣-利用-starttransition-来运行低优先级任务"><a href="#1️⃣-利用-starttransition-来运行低优先级任务" class="headerlink" title="1️⃣ 利用 startTransition 来运行低优先级任务"></a><strong>1️⃣ 利用 startTransition 来运行低优先级任务</strong></h3><p>这个实验主要用于验证 <code>unstable_next</code>, 它会让降低更新的优先级。通过下面的实验我们会观察到: 通过<code>startTransition</code> 包裹的变更在任务繁忙的情况会稍微延后更新，但是最终状态是一致的。</p>
<p>实验代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [tick, setTick] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [startTransition, pending] = useTransition(&#123; <span class="attr">timeoutMs</span>: <span class="number">10000</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ⚛️ 同步更新</span></span><br><span class="line">    setCount(count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ⚛️ 低优先级更新 tick</span></span><br><span class="line">      setTick(<span class="function"><span class="params">t</span> =&gt;</span> t + <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hello useTransition&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;handleClick&#125;&gt;ADD + 1&lt;/</span>button&gt;</span><br><span class="line">        &#123;pending &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>pending<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;Count: &#123;count&#125;&lt;/</span>div&gt;</span><br><span class="line">      &#123;<span class="comment">/* ⚛️ 这是一个复杂的组件，渲染需要一点时间，模拟繁忙的情况 */</span>&#125;</span><br><span class="line">      &lt;ComplexComponent value=&#123;tick&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>实验结果如下：</p>
<p><img src="/images/concurrent-mode/test1.gif" alt></p>
<p><br></p>
<p>在连续点击的情况下，<code>ComplexComponent</code> 的更新会明显滞后，这是因为 tick 变更会被延后和合并，但是最后它们的结果是一致的.</p>
<p><br><br><br></p>
<h3 id="2️⃣-starttransition-更新触发-suspense"><a href="#2️⃣-starttransition-更新触发-suspense" class="headerlink" title="2️⃣ startTransition 更新触发 Suspense"></a><strong>2️⃣ startTransition 更新触发 Suspense</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [tick, setTick] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [startTransition, pending] = useTransition(&#123; <span class="attr">timeoutMs</span>: <span class="number">10000</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">      setTick(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hello useTransition &#123;tick&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;handleClick&#125;&gt;ADD + 1&lt;/</span>button&gt;</span><br><span class="line">        &#123;pending &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">"pending"</span>&gt;</span>pending<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Tick /</span>&gt;</span><br><span class="line">      &lt;SuspenseBoundary id=&#123;count&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const SuspenseBoundary = (&#123; id &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;Suspense fallback="Loading..."&gt;</span></span><br><span class="line"><span class="regexp">      &#123;/</span>* 这里会抛出一个<span class="built_in">Promise</span>异常，<span class="number">3</span>s 后 resolved *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">      &lt;ComponentThatThrowPromise id=&#123;id&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Tick 组件每秒递增一次</span></span><br><span class="line"><span class="regexp">const Tick = (&#123; duration = 1000 &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const [tick, setTick] = useState(0);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    const t = setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      setTick(tick =&gt; tick + 1);</span></span><br><span class="line"><span class="regexp">    &#125;, duration);</span></span><br><span class="line"><span class="regexp">    return () =&gt; clearInterval(t);</span></span><br><span class="line"><span class="regexp">  &#125;, [duration]);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return &lt;div className="tick"&gt;tick: &#123;tick&#125;&lt;/</span>div&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/concurrent-mode/test2.gif" alt></p>
<p>当我们点击按钮时会递增 count 和 tick, count 会传递给 SuspenseBoundary，从而触发 Suspense。</p>
<p>通过上面的结果可以知道，在 startTransition 中进行了变更(携带suspenseConfig), 对应的重新渲染触发了 Suspense，所以进入了Pending状态，它们渲染结果不会被立即‘提交’，页面还是保持在原来的状态。</p>
<p>另外你会发现 App 组件的 tick 跟 SuspenseBoundary 一样也会被‘停止’(看Hello Transition 后面的tick)，因为 tick 变更也关联了suspenseConfig。</p>
<p>而 Tick 组件则每一秒递增一次，不会被阻塞。</p>
<p>这就说明了一旦触发了Suspense，只要关联了 suspenseConfig 的变更就会被‘暂停’提交。</p>
<p><br><br><br></p>
<h3 id="3️⃣-将-tick-更新提到-starttransition-作用域外"><a href="#3️⃣-将-tick-更新提到-starttransition-作用域外" class="headerlink" title="3️⃣ 将 tick 更新提到 startTransition 作用域外"></a><strong>3️⃣ 将 tick 更新提到 startTransition 作用域外</strong></h3><p>在 2️⃣ 的基础上，将 setTick 提到 startTransition 作用域外:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [tick, setTick] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [startTransition, pending] = useTransition(&#123; <span class="attr">timeoutMs</span>: <span class="number">10000</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"App rendering with"</span>, count, tick, pending);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTick(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">    startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleAddTick = <span class="function"><span class="params">()</span> =&gt;</span> setTick(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"App committed with"</span>, count, tick, pending);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hello useTransition &#123;tick&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;handleClick&#125;&gt;ADD + 1&lt;/</span>button&gt;</span><br><span class="line">        &lt;button onClick=&#123;handleAddTick&#125;&gt;Tick + <span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &#123;pending &amp;&amp; &lt;span className="pending"&gt;pending&lt;/</span>span&gt;&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Tick /</span>&gt;</span><br><span class="line">      &lt;SuspenseBoundary id=&#123;count&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/concurrent-mode/test3.gif" alt></p>
<p><br></p>
<p>现在 tick 会被立即更新，而 SuspenseBoundary 还会挂在 pending 状态。</p>
<p>我们打开控制台看一下，输出情况:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">App rendering with 1 2 true   # pending 被设置为true, count 这是时候是 1， 而 tick 是 2</span><br><span class="line">App rendering with 1 2 true</span><br><span class="line">read  1</span><br><span class="line">App committed with 1 2 true    # 进入Pending 状态之前的一次提交，我们在这里开始展示 pending 指示符</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面 Tick 更新了三次(3s)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们注意到，每一次 React 都会重新渲染一下 App 组件，即 <span class="string">'ping'</span> 一下处于 Pending 状态的组件, 检查一下是否‘就绪’(没有触发Suspense)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果还触发 Suspense, 说明还要继续等待，这些重新渲染的结果不会被提交</span></span><br><span class="line"></span><br><span class="line">App rendering with 2 2 false # ping, 这里count变成了2，且 pending 变成了 false</span><br><span class="line">App rendering with 2 2 false # 但是 React 在内存中渲染它们，我们看不到</span><br><span class="line">read  2</span><br><span class="line"></span><br><span class="line">Tick rendering with 76        # Tick 重新渲染</span><br><span class="line">Tick rendering with 76</span><br><span class="line">Tick committed with 76        # 提交 Tick 更新，刷新到界面上</span><br><span class="line">App rendering with 2 2 false  # ping 还是没有就绪，继续 pending</span><br><span class="line">App rendering with 2 2 false</span><br><span class="line">read  2</span><br><span class="line"></span><br><span class="line">Tick rendering with 77</span><br><span class="line">Tick rendering with 77</span><br><span class="line">Tick committed with 77</span><br><span class="line">App rendering with 2 2 false # ping</span><br><span class="line">App rendering with 2 2 false</span><br><span class="line">read  2</span><br><span class="line"></span><br><span class="line">Tick rendering with 78</span><br><span class="line">Tick rendering with 78</span><br><span class="line">Tick committed with 78</span><br><span class="line">App rendering with 2 2 false # ping</span><br><span class="line">App rendering with 2 2 false</span><br><span class="line">read  2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Ok, Promise 已经就绪了，这时候再一次重新渲染 App</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这次没有触发 Suspense，React 会马上提交用户界面</span></span><br><span class="line">App rendering with 2 2 false</span><br><span class="line">App rendering with 2 2 false</span><br><span class="line">read  2</span><br><span class="line">App committed with 2 2 false</span><br></pre></td></tr></table></figure>
<p>通过上面的日志，我们可以清晰地理解 Pending 组件的更新行为</p>
<p><br><br><br></p>
<h3 id="4️⃣-嵌套suspense"><a href="#4️⃣-嵌套suspense" class="headerlink" title="4️⃣ 嵌套Suspense"></a><strong>4️⃣ 嵌套Suspense</strong></h3><p>在3️⃣的基础上，将 SuspenseBoundary 改写为 DoubleSuspenseBoundary, 这里会嵌套一个 Suspense 加载一个更耗时的资源:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DoubleSuspenseBoundary = <span class="function">(<span class="params">&#123; id &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &#123;/</span>* 需要加载 <span class="number">2</span>s  *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">      &lt;ComponentThatThrowPromise id=&#123;id&#125; timeout=&#123;2000&#125; /</span>&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;Loading second...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>* 需要加载 <span class="number">4</span>s  *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;ComponentThatThrowPromise id=&#123;id + "second"&#125; timeout=&#123;4000&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Suspense&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试一下效果：</p>
<p><img src="/images/concurrent-mode/test4-1.gif" alt></p>
<p><br></p>
<p>首先注意观察首次挂载，<strong>Suspense 首次挂载时不会触发延迟提交</strong>，因此我们首先会看到 <code>Loading...</code>、接着第一个 <code>ComponentThatThrowPromise</code> 加载完毕，显示<code>ComponentThatThrowPromise id: 0</code> 和 <code>Loading second...</code>, 最后完全加载完毕。</p>
<p>接着我们点击按钮，这时候 DoubleSuspenseBoundary 会保持不动，等待 5s 后(也就是第二个<code>ComponentThatThrowPromise</code>加载完毕), 才提交。</p>
<p><br></p>
<p>理想的效果是跟首次挂载的时候一样：在第一个 ComponentThatThrowPromise 就绪时就切换过来，不用等待第二个加载完毕。</p>
<p>感觉有点不对？我这这里想了很久, 官方文档上 <a href="https://reactjs.org/docs/concurrent-mode-patterns.html#wrap-lazy-features-in-suspense" target="_blank" rel="noopener">Concurrent UI Patterns (Experimental) - Wrap Lazy Features in \&lt;Suspense></a> 说了，第二个<code>ComponentThatThrowPromise</code> 已经嵌套在 <code>Suspense</code> 中了，理论上应该不会阻塞提交。</p>
<p>回到开头的第一句话：’<strong>Suspense 首次挂载时不会触发延迟提交</strong>‘。我们再试一下, 给 DoubleSuspenseBoundary 设置一个key，强制让它销毁重新创建:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hello useTransition &#123;tick&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;handleClick&#125;&gt;ADD + 1&lt;/</span>button&gt;</span><br><span class="line">        &#123;pending &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">"pending"</span>&gt;</span>pending<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Tick /</span>&gt;</span><br><span class="line">      &#123;<span class="comment">/* ⚛️ 这里添加key，强制重新销毁创建 */</span>&#125;</span><br><span class="line">      &lt;DoubleSuspenseBoundary id=&#123;count&#125; key=&#123;count&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>试一下效果:</p>
<p><img src="/images/concurrent-mode/test4-2.gif" alt></p>
<p><br></p>
<p>我们发现，每次点击都是<code>Loading...</code>, Pending 状态没有了! 因为每次 <code>count</code> 递增, <code>DoubleSuspenseBoundary</code> 就会重新创建，不会触发延迟提交。</p>
<p>基于这个原理，我们可以再改造一下 <code>DoubleSuspenseBoundary</code>, 这一次，我们只给嵌套的 <code>Suspense</code> 加上key，让它们重新创建不阻塞 Pending 状态.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DoubleSuspenseBoundary = <span class="function">(<span class="params">&#123; id &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ComponentThatThrowPromise id=&#123;id&#125; timeout=&#123;2000&#125; /</span>&gt;</span><br><span class="line">      &#123;<span class="comment">/* ⚛️ 我们不希望这个 Suspense 阻塞 pending 状态, 给它加个key, 让它强制重新创建 */</span>&#125;</span><br><span class="line">      &lt;Suspense key=&#123;id&#125; fallback=&#123;&lt;div&gt;Loading second...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ComponentThatThrowPromise id=&#123;id + "second"&#125; timeout=&#123;4000&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>最后的效果</p>
<p><img src="/images/concurrent-mode/test4-3.gif" alt></p>
<p>It’s work! 🍻</p>
<p><br><br><br></p>
<h3 id="5️⃣-可以和-mobx-和-redux-配合使用吗"><a href="#5️⃣-可以和-mobx-和-redux-配合使用吗" class="headerlink" title="5️⃣ 可以和 Mobx 和 Redux 配合使用吗?"></a><strong>5️⃣ 可以和 Mobx 和 Redux 配合使用吗?</strong></h3><p>我也不知道，测试一下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mport React, &#123; useTransition, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider, useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"><span class="keyword">import</span> SuspenseBoundary <span class="keyword">from</span> <span class="string">"./SuspenseBoundary"</span>;</span><br><span class="line"><span class="keyword">import</span> Tick <span class="keyword">from</span> <span class="string">"./Tick"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">count</span>: <span class="number">0</span>, <span class="attr">tick</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> ADD_TICK = <span class="string">"ADD_TICK"</span>;</span><br><span class="line"><span class="keyword">const</span> ADD_COUNT = <span class="string">"ADD_COUNT"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(<span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> copy = &#123; ...state &#125;;</span><br><span class="line">  <span class="keyword">if</span> (action.type === ADD_TICK) &#123;</span><br><span class="line">    copy.tick++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    copy.count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copy</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Page = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; count, tick &#125; = useSelector(<span class="function">(<span class="params">&#123; tick, count &#125;</span>) =&gt;</span> (&#123; tick, count &#125;));</span><br><span class="line">  <span class="keyword">const</span> dispatch = useDispatch();</span><br><span class="line">  <span class="keyword">const</span> [startTransition, pending] = useTransition(&#123; <span class="attr">timeoutMs</span>: <span class="number">10000</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> addTick = <span class="function"><span class="params">()</span> =&gt;</span> dispatch(&#123; <span class="attr">type</span>: ADD_TICK &#125;);</span><br><span class="line">  <span class="keyword">const</span> addCount = <span class="function"><span class="params">()</span> =&gt;</span> dispatch(&#123; <span class="attr">type</span>: ADD_COUNT &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    addTick();</span><br><span class="line">    startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Start transition with count: "</span>, count);</span><br><span class="line">      addCount();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"End transition"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`App rendering with count(<span class="subst">$&#123;count&#125;</span>) pendig(<span class="subst">$&#123;pending&#125;</span>)`</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"committed with"</span>, count, tick, pending);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hello useTransition &#123;tick&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;handleClick&#125;&gt;ADD + 1&lt;/</span>button&gt;</span><br><span class="line">        &#123;pending &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">"pending"</span>&gt;</span>pending<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Tick /</span>&gt;</span><br><span class="line">      &lt;SuspenseBoundary id=&#123;count&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;Provider store=&#123;store&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Page /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>先看一下运行效果:</p>
<p><img src="/images/concurrent-mode/test5.gif" alt></p>
<p><br></p>
<p><img src="/images/concurrent-mode/hyhs.png" alt></p>
<p><br></p>
<p>What’s the problem? 整个界面都 <code>Pending</code> 了, 整个界面不单单指 <code>App</code> 这颗子树，而且 Tick 也不走了。打开控制台看到了一个警告:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Warning: Page triggered a user-blocking update that suspended.</span><br><span class="line"></span><br><span class="line">The fix is to split the update into multiple parts: a user-blocking update to provide immediate feedback, and another update that triggers the bulk of the changes.</span><br><span class="line">Refer to the documentation for useTransition to learn how to implement this pattern.</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>先来看一下目前Rudux 和 Mobx 的Hooks API 是怎么更新的，<strong>本质上它们都采用订阅机制，在事件触发后进行强制更新</strong>, 基本结构如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useSomeOutsideStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取外部 store</span></span><br><span class="line">  <span class="keyword">const</span> store = getOutsideStore()</span><br><span class="line">  <span class="keyword">const</span> [, forceUpdate] = useReducer(<span class="function"><span class="params">s</span> =&gt;</span> s + <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 订阅外部数据源</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> disposer = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ⚛️ 强制更新</span></span><br><span class="line">      forceUpdate()</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> disposer</span><br><span class="line">  &#125;, [store])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>也就是说，我们在 <code>startTransition</code> 中更新 Redux 状态时，会同步接收到事件，然后调用 <code>forceUpdate</code>。<strong><code>forceUpdate</code> 才是真正在 suspenseConfig 上下文中变更的状态</strong>。</p>
<p>我们再看一下控制台日志:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Start transition with count 0</span><br><span class="line">End transition</span><br><span class="line">App rendering with count(1) pendig(true)  # 这里出问题了 🔴, 你可以和实验 3️⃣ 中的日志对比一下</span><br><span class="line">App rendering with count(1) pendig(true)  # 实验 3️⃣ 中这里的 count 是 0，而这里的count是1，说明没有 defer!</span><br><span class="line">read  1</span><br><span class="line"></span><br><span class="line">Warning: App triggered a user-blocking update that suspended.</span><br><span class="line">The fix is to split the update into multiple parts: a user-blocking update to provide immediate feedback, and another update that triggers the bulk of the changes.</span><br><span class="line">Refer to the documentation for useTransition to learn how to implement this pattern.</span><br></pre></td></tr></table></figure>
<p>通过日志可以基本上能够定位出问题，count 没有被延迟更新，所以导致’同步’触发了 Suspense，这也是 React 警告的原因。 由于 useTransition 目前还处于实验阶段，<strong>如果不是 startTransition 上下文中的状态更新导致的Suspense，行为还是未确定的</strong>。</p>
<p>但是最终的行为有点玄学，它会导致整个应用被‘Pending’，所有状态更新都不会被提交。这块我也很疑惑，没有精力深究下去，只能等待后续官方的更新，读者也可以去琢磨琢磨。</p>
<p>因此，暂时不推荐将会触发 Suspense 的状态放置在 Redux 或者 Mobx 中。</p>
<p><br><br><br></p>
<p>最后再重申一下， <code>useTransition</code> 要进入 <code>Pending</code> 状态要符合以下几个条件:</p>
<ul>
<li>最好使用 React 本身的状态机制进行更新, 如 Hooks 或 setState, 当前不要使用 Mobx 和 Redux</li>
<li>这些更新会触发 Suspense。</li>
<li>更新必须在<code>startTransition</code>作用域下, 这些更新会关联 <code>suspenseConfig</code></li>
<li>这些更新触发的重新渲染中, 必须触发至少一个 <code>Suspense</code></li>
<li>这个 <code>Suspense</code> 不是首次挂载</li>
</ul>
<p><br><br><br></p>
<h2 id="那-usedeferedvalue-呢？"><a href="#那-usedeferedvalue-呢？" class="headerlink" title="那 useDeferedValue 呢？"></a>那 useDeferedValue 呢？</h2><p>如果你理解了上面的内容, 那么 <code>useDeferedValue</code> 就好办了，它不过是 useTransition 的简单封装：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDeferredValue</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  value: T,</span></span></span><br><span class="line"><span class="function"><span class="params">  config: TimeoutConfig | void | null,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [prevValue, setValue] = useState(value);</span><br><span class="line">  <span class="keyword">const</span> [startTransition] = useTransition(config)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ useDeferredValue 只不过是监听 value 的变化，</span></span><br><span class="line">  <span class="comment">// 然后在 startTransition 中更新它。从而实现延迟更新的效果</span></span><br><span class="line">  useEffect(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setValue(value);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    [value, config],</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> prevValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><code>useDeferredValue</code> 只不过是使用 useEffect 监听 <code>value</code> 的变化， 然后在 startTransition 中更新它。从而实现延迟更新的效果。上文实验 1️⃣ 已经介绍过运行效果，React 会降低 startTransition 中更新的优先级， 这意味着在事务繁忙时它们会延后执行。</p>
<p><br><br><br></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们一开始介绍了 useTransition 的应用场景, 让页面实现 <strong><code>Pending</code> -&gt; <code>Skeleton</code> -&gt; <code>Complete</code></strong> 的更新路径, 用户在切换页面时可以停留在当前页面，让页面保持响应。 相比展示一个无用的空白页面或者加载状态，这种用户体验更加友好。</p>
<p>当然上述的假设条件时数据加载很慢，如果数据加载很快，利用 useTransition 机制，我们实现不让用户看到加载状态，这样能避免页面页面抖动和闪烁, 看起来像没有加载的过程。</p>
<p>接着我们简单介绍了 useTransition 的运行原理和条件。 如果 startTransition 中的状态更新触发了 Suspense，那么对应的组件就会进入 Pending 状态。在 Pending 状态期间，startTransition中设置变更都会被延迟提交。 Pending 状态会持续到 Suspense 就绪或者超时。</p>
<p>useTransition 必须和 Suspense 配合使用才能施展魔法。还有一个用户场景是我们可以将低优先级的更新放置到 startTransition 中。比如某个更新的成本很高，就可以选择放到 startTransition 中, 这些更新会让位高优先级的任务，另外会 React 延迟或合并一个比较复杂的更新，让页面保持响应。</p>
<p><br><br><br></p>
<p><strong>Ok，关于 Concurrent 模式的介绍就先告一段落了, 这是中文的第一手资料。写这些文章耗掉了我大部分的业余时间，如果你喜欢我的文章，请多给我点赞和反馈。</strong></p>
<p><br><br><br></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://reactjs.org/docs/concurrent-mode-patterns.html" target="_blank" rel="noopener">Concurrent UI Patterns</a></li>
<li><a href="https://github.com/facebook/react/pull/15593" target="_blank" rel="noopener">Add withSuspenseConfig API</a></li>
</ul>
<p><br></p>
<p><img src="/images/sponsor.jpg" alt></p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#应用场景是什么？"><span class="toc-number">1.</span> <span class="toc-text">应用场景是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#usetransition-登场"><span class="toc-number">2.</span> <span class="toc-text">useTransition 登场</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#usetransition-原理初探"><span class="toc-number">3.</span> <span class="toc-text">useTransition 原理初探</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1️⃣-利用-starttransition-来运行低优先级任务"><span class="toc-number">3.1.</span> <span class="toc-text">1️⃣ 利用 startTransition 来运行低优先级任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2️⃣-starttransition-更新触发-suspense"><span class="toc-number">3.2.</span> <span class="toc-text">2️⃣ startTransition 更新触发 Suspense</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3️⃣-将-tick-更新提到-starttransition-作用域外"><span class="toc-number">3.3.</span> <span class="toc-text">3️⃣ 将 tick 更新提到 startTransition 作用域外</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4️⃣-嵌套suspense"><span class="toc-number">3.4.</span> <span class="toc-text">4️⃣ 嵌套Suspense</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5️⃣-可以和-mobx-和-redux-配合使用吗"><span class="toc-number">3.5.</span> <span class="toc-text">5️⃣ 可以和 Mobx 和 Redux 配合使用吗?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#那-usedeferedvalue-呢？"><span class="toc-number">4.</span> <span class="toc-text">那 useDeferedValue 呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">6.</span> <span class="toc-text">参考资料</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2019/10/28/concurrent-mode-transition/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2019/10/28/concurrent-mode-transition/&text=React Concurrent 模式抢先预览下篇: useTransition 的平行世界"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2019/10/28/concurrent-mode-transition/&title=React Concurrent 模式抢先预览下篇: useTransition 的平行世界"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2019/10/28/concurrent-mode-transition/&is_video=false&description=React Concurrent 模式抢先预览下篇: useTransition 的平行世界"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=React Concurrent 模式抢先预览下篇: useTransition 的平行世界&body=Check out this article: https://bobi.ink/2019/10/28/concurrent-mode-transition/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2019/10/28/concurrent-mode-transition/&title=React Concurrent 模式抢先预览下篇: useTransition 的平行世界"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2019/10/28/concurrent-mode-transition/&title=React Concurrent 模式抢先预览下篇: useTransition 的平行世界"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2019/10/28/concurrent-mode-transition/&title=React Concurrent 模式抢先预览下篇: useTransition 的平行世界"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2019/10/28/concurrent-mode-transition/&title=React Concurrent 模式抢先预览下篇: useTransition 的平行世界"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2019/10/28/concurrent-mode-transition/&name=React Concurrent 模式抢先预览下篇: useTransition 的平行世界&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2025 Ivan
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-44571525-2', 'auto');
        ga('send', 'pageview');
    </script>


    <!-- Disqus Comments -->
    <script type="text/javascript">
        var disqus_shortname = 'bobi-ink';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


