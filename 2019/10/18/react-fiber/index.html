<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="写一篇关于 React Fiber 的文章， 这个 Flag 立了很久，这也是今年的目标之一. 最近的在掘金的文章获得很多关注和鼓励，给了我很多动力，所以下定决心好好把它写出来。 我会以最通俗的方式将它讲透, 因此这算是一篇科普式的文章。不管你是使用React、还是Vue，这里面的思想值得学习学习!    一年一度的 React 春晚: React Conf 即将到来，不知道今年会不会有什么惊喜，">
<meta name="keywords" content="Blog,FrontEnd,React,Javascript,Typescript">
<meta property="og:type" content="article">
<meta property="og:title" content="这可能是最通俗的 React Fiber 打开方式">
<meta property="og:url" content="https://bobi.ink/2019/10/18/react-fiber/index.html">
<meta property="og:site_name" content="Bobi.ink">
<meta property="og:description" content="写一篇关于 React Fiber 的文章， 这个 Flag 立了很久，这也是今年的目标之一. 最近的在掘金的文章获得很多关注和鼓励，给了我很多动力，所以下定决心好好把它写出来。 我会以最通俗的方式将它讲透, 因此这算是一篇科普式的文章。不管你是使用React、还是Vue，这里面的思想值得学习学习!    一年一度的 React 春晚: React Conf 即将到来，不知道今年会不会有什么惊喜，">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/react-conf.png">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/dos.jpg">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/longzhu.jpg">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/naruto.jpg">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/process-schedule.png">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/singleroad.jpg">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/frame-full.jpg">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/perf.png">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/sync-mode.gif">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/concurrent-mode.gif">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/cs.png">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/frame.png">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/frame-life.png">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/ric.png">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/mc.png">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/workloop.png">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/diff.png">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/fiber-node.png">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/callstack.png">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/work-order.png">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/fiber-reconciler.png">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/effect-tag.png">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/gitbranch.png">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/resume-1.png">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/resume-2.png">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/resume-3.png">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/resume-4.png">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/new-frame.jpg">
<meta property="og:image" content="https://bobi.ink/images/react-fiber/benifit.png">
<meta property="og:image" content="https://bobi.ink/images/sponsor.jpg">
<meta property="og:updated_time" content="2023-06-01T09:55:14.330Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="这可能是最通俗的 React Fiber 打开方式">
<meta name="twitter:description" content="写一篇关于 React Fiber 的文章， 这个 Flag 立了很久，这也是今年的目标之一. 最近的在掘金的文章获得很多关注和鼓励，给了我很多动力，所以下定决心好好把它写出来。 我会以最通俗的方式将它讲透, 因此这算是一篇科普式的文章。不管你是使用React、还是Vue，这里面的思想值得学习学习!    一年一度的 React 春晚: React Conf 即将到来，不知道今年会不会有什么惊喜，">
<meta name="twitter:image" content="https://bobi.ink/images/react-fiber/react-conf.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>这可能是最通俗的 React Fiber 打开方式</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/10/26/concurrent-mode-suspense/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/10/10/babel-macro/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2019/10/18/react-fiber/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2019/10/18/react-fiber/&text=这可能是最通俗的 React Fiber 打开方式"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2019/10/18/react-fiber/&title=这可能是最通俗的 React Fiber 打开方式"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2019/10/18/react-fiber/&is_video=false&description=这可能是最通俗的 React Fiber 打开方式"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=这可能是最通俗的 React Fiber 打开方式&body=Check out this article: https://bobi.ink/2019/10/18/react-fiber/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2019/10/18/react-fiber/&title=这可能是最通俗的 React Fiber 打开方式"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2019/10/18/react-fiber/&title=这可能是最通俗的 React Fiber 打开方式"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2019/10/18/react-fiber/&title=这可能是最通俗的 React Fiber 打开方式"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2019/10/18/react-fiber/&title=这可能是最通俗的 React Fiber 打开方式"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2019/10/18/react-fiber/&name=这可能是最通俗的 React Fiber 打开方式&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#单处理进程调度-fiber-不是一个新的东西"><span class="toc-number">1.</span> <span class="toc-text">单处理进程调度: Fiber 不是一个新的东西</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类比浏览器javascript执行环境"><span class="toc-number">2.</span> <span class="toc-text">类比浏览器JavaScript执行环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#何为-fiber"><span class="toc-number">3.</span> <span class="toc-text">何为 Fiber</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-一种流程控制原语"><span class="toc-number">3.1.</span> <span class="toc-text">1. 一种流程控制原语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-一个执行单元"><span class="toc-number">3.2.</span> <span class="toc-text">2. 一个执行单元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#react-的fiber改造"><span class="toc-number">4.</span> <span class="toc-text">React 的Fiber改造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-数据结构的调整"><span class="toc-number">4.1.</span> <span class="toc-text">1. 数据结构的调整</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-两个阶段的拆分"><span class="toc-number">4.2.</span> <span class="toc-text">2. 两个阶段的拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-reconcilation"><span class="toc-number">4.3.</span> <span class="toc-text">3. Reconcilation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-双缓冲"><span class="toc-number">4.4.</span> <span class="toc-text">4. 双缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-副作用的收集和提交"><span class="toc-number">4.5.</span> <span class="toc-text">5. 副作用的收集和提交</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#⚠️-未展开部分-🚧-–-中断和恢复"><span class="toc-number">5.</span> <span class="toc-text">⚠️ 未展开部分 🚧 – 中断和恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#凌波微步"><span class="toc-number">6.</span> <span class="toc-text">凌波微步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#站在巨人的肩膀上"><span class="toc-number">7.</span> <span class="toc-text">站在巨人的肩膀上</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        这可能是最通俗的 React Fiber 打开方式
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Bobi.ink</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-10-17T16:00:00.000Z" itemprop="datePublished">2019-10-18</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>写一篇关于 React Fiber 的文章， 这个 Flag 立了很久，这也是今年的目标之一. 最近的在掘金的文章获得很多关注和鼓励，给了我很多动力，所以下定决心好好把它写出来。 我会以最通俗的方式将它讲透, 因此这算是一篇科普式的文章。不管你是使用React、还是Vue，这里面的思想值得学习学习!</p>
<p><br></p>
<p><img src="/images/react-fiber/react-conf.png" alt></p>
<p><br></p>
<p>一年一度的 React 春晚: <a href="https://conf.reactjs.org/schedule.html" target="_blank" rel="noopener">React Conf</a> 即将到来，不知道今年会不会有什么惊喜，去年是 React Hooks，前年是 React Fiber…<br>我得赶在 React Conf 之前发布这篇文章:</p>
<ul>
<li><p>😲 <strong>React Fiber 已经出来这么久了， 这文章是老酒装新瓶吧</strong>? <em>对于我来说，通过这篇文章我重新认识了 React Fiber，它不是一个新东西, 它也是老酒装新瓶，不信你就看吧…</em></p>
</li>
<li><p>🆕 <strong>React Fiber 不是一个新的东西，但在前端领域是第一次广为认知的应用</strong>。</p>
</li>
<li><p>😦 <strong>了解它有啥用</strong>? <em>React Fiber 代码很复杂，门槛很高，你不了解它，后面 React 新出的 Killer Feature 你可能就更不能理解了</em></p>
</li>
<li><p>🤥 <strong>我不是升到React v16了吗? 没什么出奇的啊</strong>? <em>真正要体会到 React Fiber 重构效果，可能下个月、可能要等到 v17。v16 只是一个过渡版本，也就是说，现在的React 还是同步渲染的，一直在跳票、不是说今年第二季度就出来了吗</em>？</p>
</li>
<li><p>😁 <strong>不好意思，一不小心又写得有点长，你就当小说看吧, 代码都是伪代码</strong></p>
</li>
</ul>
<p><br></p>
<p><strong>以下文章大纲</strong></p>
<ul>
<li><a href="#单处理进程调度-fiber-不是一个新的东西">单处理进程调度: Fiber 不是一个新的东西</a></li>
<li><a href="#类比浏览器javascript执行环境">类比浏览器JavaScript执行环境</a></li>
<li><a href="#何为-fiber">何为 Fiber</a><ul>
<li><a href="#1-一种流程控制原语">1. 一种流程控制原语</a></li>
<li><a href="#2-一个执行单元">2. 一个执行单元</a></li>
</ul>
</li>
<li><a href="#react-的fiber改造">React 的Fiber改造</a><ul>
<li><a href="#1-数据结构的调整">1. 数据结构的调整</a></li>
<li><a href="#2-两个阶段的拆分">2. 两个阶段的拆分</a></li>
<li><a href="#3-reconcilation">3. Reconcilation</a></li>
<li><a href="#4-双缓冲">4. 双缓冲</a></li>
<li><a href="#5-副作用的收集和提交">5. 副作用的收集和提交</a></li>
</ul>
</li>
<li><a href="#⚠️-未展开部分-🚧----中断和恢复">⚠️ 未展开部分 🚧 – 中断和恢复</a></li>
<li><a href="#凌波微步">凌波微步</a></li>
<li><a href="#站在巨人的肩膀上">站在巨人的肩膀上</a></li>
</ul>
<p><br><br><br></p>
<h2 id="单处理进程调度-fiber-不是一个新的东西"><a href="#单处理进程调度-fiber-不是一个新的东西" class="headerlink" title="单处理进程调度: Fiber 不是一个新的东西"></a>单处理进程调度: Fiber 不是一个新的东西</h2><p><br></p>
<p><img src="/images/react-fiber/dos.jpg" alt><br><i>这个黑乎乎的界面应该就是微软的 <code>DOS</code> 操作系统</i></p>
<p><br></p>
<p>微软 <a href="https://zh.wikipedia.org/zh-cn/DOS" target="_blank" rel="noopener"><code>DOS</code></a> 是一个<code>单任务操作系统</code>, 也称为’单工操作系统‘. 这种操作系统同一个时间只允许运行一个程序. <a href="https://www.zhihu.com/people/s.invalid" target="_blank" rel="noopener">invalid s</a>在<a href="https://www.zhihu.com/question/319595914/answer/683541635" target="_blank" rel="noopener">《在没有GUI的时代(只有一个文本界面），人们是怎么运行多个程序的？》</a> 的回答中将其称为: ‘<strong>一种压根没有任务调度的“残疾”操作系统</strong>‘.</p>
<p>在这种系统中，你想执行多个任务，只能等待前一个进程退出，然后再载入一个新的进程。</p>
<p>直到 Windows 3.x，它才有了真正意义的进程调度器，实现了多进程并发执行。</p>
<blockquote>
<p>注意并发和并行不是同一个概念。</p>
</blockquote>
<p><br></p>
<p>现代操作系统都是<strong>多任务操作系统</strong>. 进程的调度策略如果按照CPU核心数来划分，可以分为<strong>单处理器调度</strong>和<strong>多处理器调度</strong>。本文只关注的是单处理器调度，因为它可以类比JavaScript的运行机制。</p>
<p><strong>🔴说白了，为了实现进程的并发，操作系统会按照一定的调度策略，将CPU的执行权分配给多个进程，多个进程都有被执行的机会，让它们交替执行，形成一种“同时在运行”假象, 因为CPU速度太快，人类根本感觉不到。实际上在单核的物理环境下同时只能有一个程序在运行</strong>。</p>
<brk>

<p><img src="/images/react-fiber/longzhu.jpg" alt></p>
<p><br></p>
<p>这让我想起了“龙珠”中的分身术(小时候看过，说错了别喷)，实质上是一个人，只不过是他运动速度太快，看起来就像分身了. 这就是所谓的<strong>并发(Concurrent)</strong>(单处理器)。</p>
<p><br></p>
<p><img src="/images/react-fiber/naruto.jpg" alt></p>
<p><br></p>
<p>相比而言, 火影忍者中的分身术，是物理存在的，他们可以真正实现同时处理多个任务，这就是<strong>并行</strong>(严格地讲这是<code>Master-Slave</code>架构，分身虽然物理存在，但应该没有独立的意志)。</p>
<p>所以说<strong>🔴并行可以是并发，而并发不一定是并行，两种不能划等号, 并行一般需要物理层面的支持</strong>。 关于并发和并行，Go 之父 Rob Pike 有一个非常著名的演讲<a href="https://blog.golang.org/concurrency-is-not-parallelism" target="_blank" rel="noopener">Concurrency is not parallelism</a></p>
<p><br></p>
<p>扯远了，接下来进程怎么调度就是教科书的内容了。如果读者在大学认真学过<strong>操作系统原理</strong>, 你可以很快理解以下几种单处理器进程<strong>调度策略</strong>(我就随便科普一下，算送的, 如果你很熟悉这块，可以跳过)：</p>
<p><br></p>
<p><strong>0️⃣ 先到先得(First-Come-First-Served, FCFS)</strong></p>
<p>这是最简单的调度策略, 简单说就是<strong>没有调度</strong>。谁先来谁就先执行，执行完毕后就执行下一个。不过如果中间某些进程因为I/O阻塞了，这些进程会挂起移回就绪队列(说白了就是重新排队).</p>
<p><code>FCFS</code> 上面 <code>DOS</code> 的单任务操作系统没有太大的区别。所以非常好理解，因为生活中到处是这样的例子:。</p>
<ul>
<li><p><strong>FCFS 对<code>短进程</code>不利</strong>。 短进程即执行时间非常短的进程，可以用饭堂排队来比喻: <em>在饭堂排队打饭的时候，最烦那些一个人打包好好几份的人，这些人就像<code>长进程</code>一样，霸占着CPU资源，后面排队只打一份的人会觉得很吃亏，打一份的人会觉得他们优先级应该更高，毕竟他们花的时间很短，反正你打包那么多份再等一会也是可以的，何必让后面那么多人等这么久…</em></p>
</li>
<li><p><strong>FCFS 对<code>I/O密集</code>不利</strong>。I/O密集型进程(这里特指同步I/O)在进行I/O操作时，会阻塞休眠，这会导致进程重新被放入就绪队列，等待下一次被宠幸。 可以类比ZF部门办业务: <em>假设 CPU 一个窗口、I/O 一个窗口。在CPU窗口好不容易排到你了，这时候发现一个不符合条件或者漏办了, 需要去I/O搞一下，Ok 去 I/O窗口排队，I/O执行完了，到CPU窗口又得重新排队。对于这些丢三落四的人很不公平…</em></p>
</li>
</ul>
<p>所以 FCFS 这种原始的策略在单处理器进程调度中并不受欢迎。</p>
<p><br></p>
<p><strong>1️⃣ 轮转</strong></p>
<p>这是一种基于时钟的<strong>抢占策略</strong>，这也是抢占策略中最简单的一种: <strong>公平地给每一个进程一定的执行时间，当时间消耗完毕或阻塞，操作系统就会调度其他进程，将执行权抢占过来</strong>。</p>
<blockquote>
<p><strong>决策模式</strong>: <code>抢占策略</code>相对应的有<code>非抢占策略</code>，非抢占策略指的是让进程运行直到结束、阻塞(如I/O或睡眠)、或者主动让出控制权；抢占策略支持中断正在运行的进程，将主动权掌握在操作系统这里，不过通常开销会比较大。</p>
</blockquote>
<p>这种调度策略的要点是<strong>确定合适的时间片长度</strong>: 太长了，长进程霸占太久资源，其他进程会得不到响应(等待执行时间过长)，这时候就跟上述的 <code>FCFS</code> 没什么区别了;  太短了也不好，因为进程抢占和切换都是需要成本的, 而且成本不低，时间片太短，时间可能都浪费在上下文切换上了，导致进程干不了什么实事。</p>
<p>因此<strong>时间片的长度最好符合大部分进程完成一次典型交互所需的时间</strong>.</p>
<p>轮转策略非常容易理解，只不过确定时间片长度需要伤点脑筋；另外和<code>FCFS</code>一样，轮转策略对I/O进程还是不公平。</p>
<p><br></p>
<p><strong>2️⃣ 最短进程优先(Shortest Process Next, SPN)</strong></p>
<p>上面说了<code>先到先得</code>策略对<code>短进程</code>不公平，<code>最短进程优先</code>索性就让’最短’的进程优先执行，也就是说: <strong>按照进程的预估执行时间对进程进行优先级排序，先执行完短进程，后执行长进程。这是一种非抢占策略</strong>。</p>
<p>这样可以让短进程能得到较快的响应。但是怎么获取或者<strong>评估进程执行时间</strong>呢？一是让程序的提供者提供，这不太靠谱；二是由操作系统来收集进程运行数据，并对它们进程统计分析。例如最简单的是计算它们的平均运行时间。不管怎么说都比上面两种策略要复杂一点。</p>
<p><code>SPN</code> 的缺陷是: 如果系统有大量的短进程，那么长进程可能会饥饿得不到响应。</p>
<p>另外因为它不是抢占性策略, 尽管现在短进程可以得到更多的执行机会，但是还是没有解决 <code>FCFS</code> 的问题: 一旦长进程得到CPU资源，得等它执行完，导致后面的进程得不到响应。</p>
<p><br></p>
<p><strong>3️⃣ 最短剩余时间(Shortest Remaining Time, SRT)</strong></p>
<p><strong>SRT 进一步优化了SPN，增加了抢占机制</strong>。在 SPN 的基础上，当一个进程添加到就绪队列时，操作系统会比较<em>刚添加的新进程</em>和<em>当前正在执行的老进程</em>的‘剩余时间’，如果新进程剩余时间更短，新进程就会抢占老进程。</p>
<p>相比轮转的抢占，SRT 没有中断处理的开销。但是在 SPN 的基础上，操作系统需要记录进程的历史执行时间，这是新增的开销。<strong>另外长进程饥饿问题还是没有解决</strong>。</p>
<p><br></p>
<p><strong>4️⃣ 最高响应比优先(HRRN)</strong></p>
<p><strong>为了解决长进程饥饿问题，同时提高进程的响应速率</strong>。还有一种<code>最高响应比优先的</code>策略，首先了解什么是响应比:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">响应比 = （等待执行时间 + 进程执行时间） / 进程执行时间</span><br></pre></td></tr></table></figure>
<p><strong>这种策略会选择响应比最高的进程优先执行</strong>：</p>
<ul>
<li>对于短进程来说，因为执行时间很短，分母很小，所以响应比比较高，会被优先执行</li>
<li>对于长进程来说，执行时间长，一开始响应比小，但是随着等待时间增长，它的优先级会越来越高，最终可以被执行</li>
</ul>
<p><br></p>
<p><strong>5️⃣ 反馈法</strong></p>
<p>SPN、SRT、HRRN都需要对进程时间进行评估和统计，实现比较复杂且需要一定开销。而反馈法采取的是<strong>事后反馈</strong>的方式。这种策略下: <strong>每个进程一开始都有相同的优先级，每次被抢占(需要配合其他抢占策略使用，如轮转)，优先级就会降低一级。因此通常它会根据优先级划分多个队列</strong>。</p>
<p>举个例子: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">队列1</span><br><span class="line">队列2</span><br><span class="line">...</span><br><span class="line">队列N</span><br></pre></td></tr></table></figure>
<p>新增的任务会推入<code>队列1</code>，<code>队列1</code>会按照<code>轮转策略</code>以一个时间片为单位进行调度。短进程可以很快得到响应，而对于长进程可能一个时间片处理不完，就会被抢占，放入<code>队列2</code>。</p>
<p><code>队列2</code>会在<code>队列1</code>任务清空后被执行，有时候低优先级队列可能会等待很久才被执行，所以一般会给予一定的补偿，例如增加执行时间，所以<code>队列2</code>的轮转时间片长度是2。</p>
<p>反馈法仍然可能导致长进程饥饿，所以操作系统可以统计长进程的等待时间，当等待时间超过一定的阈值，可以选择提高它们的优先级。</p>
<p><br><br><br></p>
<p><img src="/images/react-fiber/process-schedule.png" alt></p>
<p>没有一种调度策略是万能的, 它需要考虑很多因素:</p>
<ul>
<li>响应速率。进程等待被执行的时间</li>
<li>公平性。兼顾短进程、长进程、I/O进程</li>
</ul>
<p>这两者在某些情况下是对立的，提高了响应，可能会减低公平性，导致饥饿。短进程、长进程、I/O进程之间要取得平衡也非常难。</p>
<p>上面这些知识对本文来说已经足够了，现实世界操作系统的进程调度算法比教科书上说的要复杂的多，有兴趣读者可以去研究一下 <code>Linux</code> 相关的进程调度算法，这方面的资料也非常多, 例如<a href="https://blog.csdn.net/gatieme/article/details/51456569" target="_blank" rel="noopener">《Linux进程调度策略的发展和演变》</a>。</p>
<p><br><br><br></p>
<h2 id="类比浏览器javascript执行环境"><a href="#类比浏览器javascript执行环境" class="headerlink" title="类比浏览器JavaScript执行环境"></a>类比浏览器JavaScript执行环境</h2><p><br></p>
<p><img src="/images/react-fiber/singleroad.jpg" alt><br><i>JavaScript 就像单行道</i></p>
<p><br></p>
<p>JavaScript 是<a href="https://juejin.im/post/5a6547d0f265da3e283a1df7" target="_blank" rel="noopener">单线程运行</a>的，而且在浏览器环境屁事非常多，它要负责页面的JS解析和执行、绘制、事件处理、静态资源加载和处理, 这些任务可以类比上面’进程‘。</p>
<blockquote>
<p>这里特指Javascript 引擎是单线程运行的。 严格来说，Javascript 引擎和页面渲染引擎在同一个渲染线程，GUI 渲染和 Javascript执行 两者是互斥的. 另外异步 I/O 操作底层实际上可能是多线程的在驱动。</p>
</blockquote>
<p><img src="/images/react-fiber/frame-full.jpg" alt><br><i>图片来源: <a href="https://developers.google.com/web/fundamentals/performance/rendering" target="_blank" rel="noopener">Rendering Performance</a></i></p>
<p><strong>它只是一个’JavaScript’，同时只能做一件事情，这个和 <code>DOS</code> 的单任务操作系统一样的，事情只能一件一件的干。要是前面有一个傻叉任务长期霸占CPU，后面什么事情都干不了，浏览器会呈现卡死的状态，这样的用户体验就会非常差</strong>。</p>
<p><br></p>
<p><strong>对于’前端框架‘来说，解决这种问题有三个方向</strong>:</p>
<ul>
<li>1️⃣ 优化每个任务，让它有多快就多快。挤压CPU运算量</li>
<li>2️⃣ 快速响应用户，让用户觉得够快，不能阻塞用户的交互</li>
<li>3️⃣ 尝试 Worker 多线程</li>
</ul>
<p>Vue 选择的是第1️⃣, 因为对于Vue来说，使用<code>模板</code>让它有了很多优化的空间，配合响应式机制可以让Vue可以精确地进行节点更新, 读者可以去看一下<a href="https://www.yuque.com/vueconf/2019/gwn1z0" target="_blank" rel="noopener">今年Vue Conf 尤雨溪的演讲</a>，非常棒!；而 React 选择了2️⃣ 。对于Worker 多线程渲染方案也有人尝试，要保证状态和视图的一致性相当麻烦。</p>
<p><br></p>
<p>React 为什么要引入 Fiber 架构？ 看看下面的火焰图，这是React V15 下面的一个列表渲染资源消耗情况。整个渲染花费了130ms, <strong>🔴在这里面 React 会递归比对VirtualDOM树，找出需要变动的节点，然后同步更新它们, 一气呵成。这个过程 React 称为 <code>Reconcilation</code>(中文可以译为<code>协调</code>)</strong>.</p>
<p><br></p>
<p><img src="/images/react-fiber/perf.png" alt></p>
<p><br></p>
<p>在 Reconcilation 期间，React 会霸占着浏览器资源，一则会导致用户触发的事件得不到响应, 二则会导致掉帧，用户可以感知到这些卡顿。</p>
<p>这样说，你可能没办法体会到，通过下面两个图片来体会一下(<em>图片来源于：<a href="https://twitter.com/dan_abramov" target="_blank" rel="noopener">Dan Abramov</a> 的 <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" target="_blank" rel="noopener">Beyond React 16</a> 演讲, 推荐看一下👍. 另外非常感谢<a href="https://www.zhihu.com/people/BlackGanglion/activities" target="_blank" rel="noopener">淡苍</a> 将一个<a href="https://codesandbox.io/s/koyz664q35" target="_blank" rel="noopener">类似的DEMO 分享在了 CodeSandbox</a>上🎉，大家自行体验</em>):</p>
<p><br></p>
<p>同步模式下的 React:</p>
<p><img src="/images/react-fiber/sync-mode.gif" alt></p>
<p><br></p>
<p>优化后的 <code>Concurrent</code> 模式下的 React:</p>
<p><img src="/images/react-fiber/concurrent-mode.gif" alt></p>
<p><br></p>
<p>React 的 Reconcilation 是CPU密集型的操作, 它就相当于我们上面说的’长进程‘。所以初衷和进程调度一样，我们要让高优先级的进程或者短进程优先运行，不能让长进程长期霸占资源。</p>
<p>所以React 是怎么优化的？ 划重点， <strong>🔴为了给用户制造一种应用很快的’假象’，我们不能让一个程序长期霸占着资源. 你可以将浏览器的渲染、布局、绘制、资源加载(例如HTML解析)、事件响应、脚本执行视作操作系统的’进程’，我们需要通过某些调度策略合理地分配CPU资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率</strong>。</p>
<p><br></p>
<p><strong>🔴所以 React 通过Fiber 架构，让自己的Reconcilation 过程变成可被中断。 ‘适时’地让出CPU执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处</strong>:</p>
<ul>
<li>与其一次性操作大量 DOM 节点相比, 分批延时对DOM进行操作，可以得到更好的用户体验。这个在<a href="https://juejin.im/post/5d76f469f265da039a28aff7#heading-1" target="_blank" rel="noopener">《「前端进阶」高性能渲染十万条数据(时间分片)》</a> 以及司徒正美的<a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener">《React Fiber架构》</a> 都做了相关实验</li>
<li>司徒正美在<a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener">《React Fiber架构》</a> 也提到：<strong>🔴给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对reflow进行修正</strong>.</li>
</ul>
<p><br></p>
<p>这就是为什么React 需要 Fiber 😏。</p>
<p><br></p>
<h2 id="何为-fiber"><a href="#何为-fiber" class="headerlink" title="何为 Fiber"></a>何为 Fiber</h2><p>对于 React 来说，Fiber 可以从两个角度理解:</p>
<p><br></p>
<h3 id="1-一种流程控制原语"><a href="#1-一种流程控制原语" class="headerlink" title="1. 一种流程控制原语"></a>1. 一种流程控制原语</h3><p>Fiber 也称<a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272" target="_blank" rel="noopener">协程</a>、或者纤程。 笔者第一次接触这个概念是在学习 Ruby 的时候，Ruby就将协程称为 Fiber。后来发现很多语言都有类似的机制，例如Lua 的<code>Coroutine</code>, 还有前端开发者比较熟悉的 <code>ES6</code> 新增的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="noopener"><code>Generator</code></a>。</p>
<blockquote>
<p>本文不纠结 <a href="https://stackoverflow.com/questions/3324643/processes-threads-green-threads-protothreads-fibers-coroutines-whats-the/16375591#16375591" target="_blank" rel="noopener">Processes, threads, green threads, protothreads, fibers, coroutines: what’s the difference?</a></p>
</blockquote>
<p><strong>🔴 其实协程和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制</strong>。要理解协程，你得和普通函数一起来看, 以Generator为例:</p>
<p>普通函数执行的过程中无法<strong>被中断和恢复</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task</span><br><span class="line">  <span class="keyword">while</span> (task = tasks.shift()) &#123;</span><br><span class="line">    execute(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>而 <code>Generator</code> 可以:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (task = tasks.shift()) &#123;</span><br><span class="line">    <span class="comment">// 🔴 判断是否有高优先级事件需要处理, 有的话让出控制权</span></span><br><span class="line">    <span class="keyword">if</span> (hasHighPriorityEvent()) &#123;</span><br><span class="line">      <span class="keyword">yield</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完高优先级事件后，恢复函数调用栈，继续执行...</span></span><br><span class="line">    execute(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>React Fiber 的思想和协程的概念是契合的: <strong>🔴React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染</strong>。</p>
<p><br></p>
<p>那么现在你应该有以下疑问:</p>
<ul>
<li>1️⃣ 浏览器没有抢占的条件, 所以React只能用让出机制?</li>
<li>2️⃣ 怎么确定有高优先任务要处理，即什么时候让出？</li>
<li>3️⃣ React 那为什么不使用 Generator？</li>
</ul>
<p><br><br><br></p>
<p><strong>答1️⃣: 没错, 主动让出机制</strong></p>
<p>一是浏览器中没有类似进程的概念，’任务‘之间的界限很模糊，没有上下文，所以不具备中断/恢复的条件。二是没有抢占的机制，我们无法中断一个正在执行的程序。</p>
<p>所以我们只能采用类似协程这样控制权让出机制。这个和上文提到的进程调度策略都不同，它有更一个专业的名词：<a href="https://juejin.im/post/5d12c907f265da1b6d4033c5#heading-7" target="_blank" rel="noopener"><strong>合作式调度(Cooperative Scheduling)</strong></a>, 相对应的有<strong>抢占式调度(Preemptive Scheduling)</strong></p>
<p><strong>这是一种’契约‘调度，要求我们的程序和浏览器紧密结合，互相信任</strong>。比如可以由浏览器给我们分配执行时间片(通过<code>requestIdleCallback</code>实现, 下文会介绍)，我们要按照约定在这个时间内执行完毕，并将控制权还给浏览器。</p>
<p><img src="/images/react-fiber/cs.png" alt></p>
<p><br></p>
<p>这种调度方式很有趣，你会发现<strong>这是一种身份的对调</strong>，以前我们是老子，想怎么执行就怎么执行，执行多久就执行多久; 现在为了我们共同的用户体验统一了战线, 一切听由浏览器指挥调度，浏览器是老子，我们要跟浏览器申请执行权，而且这个执行权有期限，借了后要按照约定归还给浏览器。</p>
<p>当然你超时不还浏览器也拿你没办法 🤷‍… 合作式调度的缺点就在于此，全凭自律，用户要挖大坑，谁都拦不住。</p>
<p><br></p>
<hr>
<p><br></p>
<p><strong>答2️⃣: requestIdleCallback API</strong></p>
<p>上面代码示例中的 <code>hasHighPriorityEvent()</code> 在目前浏览器中是无法实现的，我们没办法判断当前是否有更高优先级的任务等待被执行。</p>
<p>只能换一种思路，通过<strong>超时检查的机制来让出控制权</strong>。解决办法是: <em>确定一个合理的运行时长，然后在合适的检查点检测是否超时(比如每执行一个小任务)，如果超时就停止执行，将控制权交换给浏览器</em>。</p>
<p>举个例子，为了让视图流畅地运行，可以按照人类能感知到最低限度每秒60帧的频率划分时间片，这样每个时间片就是 16ms。</p>
<p>其实浏览器提供了相关的接口 —— <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noopener"><code>requestIdleCallback</code></a> API：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestIdleCallback(</span><br><span class="line">  callback: <span class="function">(<span class="params">dealine: IdleDeadline</span>) =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">  option?: &#123;timeout: <span class="built_in">number</span>&#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><code>IdleDeadline</code>的接口如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IdleDealine &#123;</span><br><span class="line">  didTimeout: <span class="built_in">boolean</span> <span class="comment">// 表示任务执行是否超过约定时间</span></span><br><span class="line">  timeRemaining(): DOMHighResTimeStamp <span class="comment">// 任务可供执行的剩余时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单从名字上理解的话, <code>requestIdleCallback</code>的意思是<strong>让浏览器在’有空’的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行, 为了不耽误事，我们最好在这个时间范围内执行完毕</strong>。</p>
<p><br></p>
<p><strong>那浏览器什么时候有空？</strong></p>
<p>我们先来看一下浏览器在一帧(Frame，可以认为事件循环的一次循环)内可能会做什么事情:</p>
<p><img src="/images/react-fiber/frame.png" alt><br><i>你可以打开 Chrome 开发者工具的Performance标签，这里可以详细看到Javascript的每一帧都执行了什么任务(Task), 花费了多少时间。</i></p>
<p><br></p>
<p><img src="/images/react-fiber/frame-life.png" alt><br><i>图片来源: <a href="https://juejin.im/post/5ad71f39f265da239f07e862" target="_blank" rel="noopener">你应该知道的requestIdleCallback</a></i></p>
<p>浏览器在一帧内可能会做执行下列任务，而且它们的执行顺序基本是固定的:</p>
<ul>
<li>处理用户输入事件</li>
<li>Javascript执行</li>
<li>requestAnimation 调用</li>
<li>布局 Layout</li>
<li>绘制 Paint</li>
</ul>
<p><br></p>
<p>上面说理想的一帧时间是 <code>16ms</code> (1000ms / 60)，如果浏览器处理完上述的任务(布局和绘制之后)，还有盈余时间，浏览器就会调用 <code>requestIdleCallback</code> 的回调。例如</p>
<p><br></p>
<p><img src="/images/react-fiber/ric.png" alt></p>
<p><br></p>
<p><strong>但是在浏览器繁忙的时候，可能不会有盈余时间，这时候<code>requestIdleCallback</code>回调可能就不会被执行。 为了避免饿死，可以通过requestIdleCallback的第二个参数指定一个超时时间</strong>。</p>
<blockquote>
<p>另外不建议在<code>requestIdleCallback</code>中进行<code>DOM</code>操作，因为这可能导致样式重新计算或重新布局(比如操作DOM后马上调用 <code>getBoundingClientRect</code>)，这些时间很难预估的，很有可能导致回调执行超时，从而掉帧。</p>
</blockquote>
<p><br></p>
<p>目前 <code>requestIdleCallback</code> 目前只有Chrome支持。所以目前 React <a href="https://github.com/facebook/react/blob/master/packages/scheduler/src/forks/SchedulerHostConfig.default.js" target="_blank" rel="noopener">自己实现了一个</a>。它利用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel" target="_blank" rel="noopener"><code>MessageChannel</code></a> 模拟将回调延迟到’绘制操作’之后执行:</p>
<p><br></p>
<p><img src="/images/react-fiber/mc.png" alt></p>
<p><br></p>
<details><br><summary>简单看一下代码</summary><br><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>)</span><br><span class="line"><span class="keyword">const</span> ch = <span class="keyword">new</span> MessageChannel()</span><br><span class="line"><span class="keyword">let</span> pendingCallback</span><br><span class="line"><span class="keyword">let</span> startTime</span><br><span class="line"><span class="keyword">let</span> timeout</span><br><span class="line"></span><br><span class="line">ch.port2.onmessage = <span class="function"><span class="keyword">function</span> <span class="title">work</span>(<span class="params"></span>)  </span>&#123;</span><br><span class="line">  <span class="comment">// 在绘制之后被执行</span></span><br><span class="line">  <span class="keyword">if</span> (pendingCallback) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = performance.now()</span><br><span class="line">    <span class="comment">// 通过now - startTime可以计算出requestAnimationFrame到绘制结束的执行时间</span></span><br><span class="line">    <span class="comment">// 通过这些数据来计算剩余时间</span></span><br><span class="line">    <span class="comment">// 另外还要处理超时(timeout)，避免任务被饿死</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (hasRemain &amp;&amp; noTimeout) &#123;</span><br><span class="line">      pendingCallback(deadline)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleRequestIdleCallback</span>(<span class="params">callback, timeout</span>) </span>&#123;</span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">animation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在绘制之前被执行</span></span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    startTime = performance.now()</span><br><span class="line">    timeout = timeout</span><br><span class="line">    dosomething()</span><br><span class="line">    <span class="comment">// 调度回调到绘制结束后执行</span></span><br><span class="line">    pendingCallback = callback</span><br><span class="line">    ch.port1.postMessage(<span class="string">'hello'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details>

<p><br></p>
<p><strong>任务优先级</strong></p>
<p>上面说了，为了避免任务被饿死，可以设置一个超时时间. <strong>这个超时时间不是死的，低优先级的可以慢慢等待, 高优先级的任务应该率先被执行</strong>. 目前 React 预定义了 5 个优先级, 这个我在[《谈谈React事件机制和未来(react-events)》]中也介绍过:</p>
<ul>
<li><code>Immediate</code>(-1) - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断</li>
<li><code>UserBlocking</code>(250ms) 这些任务一般是用户交互的结果, 需要即时得到反馈</li>
<li><code>Normal</code> (5s) 应对哪些不需要立即感受到的任务，例如网络请求</li>
<li><code>Low</code> (10s) 这些任务可以放后，但是最终应该得到执行. 例如分析通知</li>
<li><code>Idle</code> (没有超时时间) 一些没有必要做的任务 (e.g. 比如隐藏的内容), 可能会被饿死</li>
</ul>
<p><br></p>
<hr>
<p><br></p>
<p><strong>答3️⃣: 太麻烦</strong></p>
<p>官方在<a href="https://github.com/facebook/react/issues/7942" target="_blank" rel="noopener">《Fiber Principles: Contributing To Fiber》</a> 也作出了解答。主要有两个原因：</p>
<ol>
<li>Generator 不能在栈中间让出。比如你想在嵌套的函数调用中间让出, 首先你需要将这些函数都包装成Generator，另外这种栈中间的让出处理起来也比较麻烦，难以理解。除了语法开销，现有的生成器实现开销比较大，所以不如不用。</li>
<li>Generator 是有状态的, 很难在中间恢复这些状态。</li>
</ol>
<blockquote>
<p>上面理解可能有出入，建议看一下原文</p>
</blockquote>
<p>可能都没看懂，简单就是 React 尝试过用 Generator 实现，后来发现很麻烦，就放弃了。</p>
<p><br><br><br></p>
<h3 id="2-一个执行单元"><a href="#2-一个执行单元" class="headerlink" title="2. 一个执行单元"></a>2. 一个执行单元</h3><p>Fiber的另外一种解读是’纤维‘: <strong>这是一种数据结构或者说执行单元</strong>。我们暂且不管这个数据结构长什么样，<strong>🔴将它视作一个执行单元，每次执行完一个’执行单元’,  React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去</strong>.</p>
<p><br></p>
<p>上文说了，React 没有使用 Generator 这些语言/语法层面的让出机制，而是实现了自己的调度让出机制。这个机制就是基于’Fiber‘这个执行单元的，它的过程如下：</p>
<p>假设用户调用 <code>setState</code> 更新组件, 这个待更新的任务会先放入队列中, 然后通过 <code>requestIdleCallback</code> 请求浏览器调度：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">updateQueue.push(updateTask);</span><br><span class="line">requestIdleCallback(performWork, &#123;timeout&#125;);</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>现在浏览器有空闲或者超时了就会调用<code>performWork</code>来执行任务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1️⃣ performWork 会拿到一个Deadline，表示剩余时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performWork</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2️⃣ 循环取出updateQueue中的任务</span></span><br><span class="line">  <span class="keyword">while</span> (updateQueue.length &gt; <span class="number">0</span> &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123;</span><br><span class="line">    workLoop(deadline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3️⃣ 如果在本次执行中，未能将所有任务执行完毕，那就再请求浏览器调度</span></span><br><span class="line">  <span class="keyword">if</span> (updateQueue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    requestIdleCallback(performWork);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong><code>workLoop</code> 的工作大概猜到了，它会从更新队列(updateQueue)中弹出更新任务来执行，每执行完一个‘<code>执行单元</code>‘，就检查一下剩余时间是否充足，如果充足就进行执行下一个<code>执行单元</code>，反之则停止执行，保存现场，等下一次有执行权时恢复</strong>:</p>
<p><br></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存当前的处理现场</span></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork: Fiber | <span class="literal">undefined</span> <span class="comment">// 保存下一个需要处理的工作单元</span></span><br><span class="line"><span class="keyword">let</span> topWork: Fiber | <span class="literal">undefined</span>        <span class="comment">// 保存第一个工作单元</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline: IdleDeadline</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// updateQueue中获取下一个或者恢复上一次中断的执行单元</span></span><br><span class="line">  <span class="keyword">if</span> (nextUnitOfWork == <span class="literal">null</span>) &#123;</span><br><span class="line">    nextUnitOfWork = topWork = getNextUnitOfWork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴 每执行完一个执行单元，检查一次剩余时间</span></span><br><span class="line">  <span class="comment">// 如果被中断，下一次执行还是从 nextUnitOfWork 开始处理</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123;</span><br><span class="line">    <span class="comment">// 下文我们再看performUnitOfWork</span></span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork, topWork);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交工作，下文会介绍</span></span><br><span class="line">  <span class="keyword">if</span> (pendingCommit) &#123;</span><br><span class="line">    commitAllWork(pendingCommit);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>画个流程图吧！</p>
<p><br></p>
<p><img src="/images/react-fiber/workloop.png" alt></p>
<p><br><br><br></p>
<h2 id="react-的fiber改造"><a href="#react-的fiber改造" class="headerlink" title="React 的Fiber改造"></a>React 的Fiber改造</h2><p>Fiber 的核心内容已经介绍完了，现在来进一步看看React 为 Fiber 架构做了哪些改造, 如果你对这部分内容不感兴趣可以跳过。</p>
<p><br></p>
<h3 id="1-数据结构的调整"><a href="#1-数据结构的调整" class="headerlink" title="1. 数据结构的调整"></a>1. 数据结构的调整</h3><p><img src="/images/react-fiber/diff.png" alt><br><i>左侧是Virtual DOM，右侧可以看作diff的递归调用栈</i></p>
<p><br></p>
<p>上文中提到 React 16 之前，Reconcilation 是同步的、递归执行的。也就是说这是基于函数’调用栈‘的Reconcilation算法，因此通常也称它为<code>Stack Reconcilation</code>. 你可以通过这篇文章<a href="https://juejin.im/post/5cfa29e151882539c33e4f5e" target="_blank" rel="noopener">《从Preact中了解React组件和hooks基本原理》</a> 来回顾一下历史。</p>
<p><br></p>
<p>栈挺好的，代码量少，递归容易理解, 至少比现在的 React Fiber架构好理解😂, 递归非常适合树这种嵌套数据结构的处理。</p>
<p>只不过这种依赖于调用栈的方式不能随意中断、也很难被恢复, 不利于异步处理。 这种调用栈，不是程序所能控制的， 如果你要恢复递归现场，可能需要从头开始, 恢复到之前的调用栈。</p>
<p>因此<strong>首先我们需要对React现有的数据结构进行调整，<a href="https://zhuanlan.zhihu.com/p/36425839" target="_blank" rel="noopener"><code>模拟函数调用栈</code></a>, 将之前需要递归进行处理的事情分解成增量的执行单元，将递归转换成迭代</strong>.</p>
<p><br></p>
<p>React 目前的做法是使用<code>链表</code>, 每个 VirtualDOM 节点内部现在使用 <code>Fiber</code>表示, 它的结构大概如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type Fiber = &#123;</span><br><span class="line">  <span class="comment">// Fiber 类型信息</span></span><br><span class="line">  type: any,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 链表结构</span></span><br><span class="line">  <span class="comment">// 指向父节点，或者render该节点的组件</span></span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向第一个子节点</span></span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向下一个兄弟节点</span></span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>用图片来展示这种关系会更直观一些：</p>
<p><img src="/images/react-fiber/fiber-node.png" alt></p>
<p><br></p>
<p><strong>使用链表结构只是一个结果，而不是目的，React 开发者一开始的目的是冲着模拟调用栈去的</strong>。这个很多关于Fiber 的文章都有提及, 关于调用栈的详细定义参见<a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank" rel="noopener">Wiki</a>：</p>
<p><img src="/images/react-fiber/callstack.png" alt></p>
<blockquote>
<p>调用栈最经常被用于存放子程序的<strong>返回地址</strong>。在调用任何子程序时，主程序都必须暂存子程序运行完毕后应该返回到的地址。因此，如果被调用的子程序还要调用其他的子程序，其自身的返回地址就必须存入调用栈，在其自身运行完毕后再行取回。除了返回地址，还会保存<code>本地变量</code>、<code>函数参数</code>、<code>环境传递</code>(Scope?)</p>
</blockquote>
<p><br></p>
<p>React Fiber 也被称为虚拟栈帧(Virtual Stack Frame), 你可以拿它和函数调用栈类比一下, 两者结构非常像:</p>
<table>
<thead>
<tr>
<th></th>
<th>函数调用栈</th>
<th>Fiber</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本单位</td>
<td>函数</td>
<td>Virtual DOM 节点</td>
</tr>
<tr>
<td>输入</td>
<td>函数参数</td>
<td>Props</td>
</tr>
<tr>
<td>本地状态</td>
<td>本地变量</td>
<td>State</td>
</tr>
<tr>
<td>输出</td>
<td>函数返回值</td>
<td>React Element</td>
</tr>
<tr>
<td>下级</td>
<td>嵌套函数调用</td>
<td>子节点(child)</td>
</tr>
<tr>
<td>上级引用</td>
<td>返回地址</td>
<td>父节点(return)</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Fiber 和调用栈帧一样, 保存了节点处理的上下文信息，因为是手动实现的，所以更为可控，我们可以保存在内存中，随时中断和恢复。</p>
<p><br></p>
<p>有了这个数据结构调整，现在可以以迭代的方式来处理这些节点了。来看看 <code>performUnitOfWork</code> 的实现, 它其实就是一个深度优先的遍历：</p>
<p><br></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @params fiber 当前需要处理的节点</span></span><br><span class="line"><span class="comment"> * @params topWork 本次更新的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber: Fiber, topWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对该节点进行处理</span></span><br><span class="line">  beginWork(fiber);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在子节点，那么下一个待处理的就是子节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有子节点了，上溯查找兄弟节点</span></span><br><span class="line">  <span class="keyword">let</span> temp = fiber;</span><br><span class="line">  <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">    completeWork(temp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到顶层节点了, 退出</span></span><br><span class="line">    <span class="keyword">if</span> (temp === topWork) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到，下一个要处理的就是兄弟节点</span></span><br><span class="line">    <span class="keyword">if</span> (temp.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> temp.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有, 继续上溯</span></span><br><span class="line">    temp = temp.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>你可以配合上文的 <code>workLoop</code> 一起看，<strong>Fiber 就是我们所说的工作单元，<code>performUnitOfWork</code> 负责对 <code>Fiber</code> 进行操作，并按照深度遍历的顺序返回下一个 Fiber</strong>。</p>
<p><strong>因为使用了链表结构，即使处理流程被中断了，我们随时可以从上次未处理完的<code>Fiber</code>继续遍历下去</strong>。</p>
<p>整个迭代顺序和之前递归的一样, 下图假设在 <code>div.app</code> 进行了更新：</p>
<p><br></p>
<p><img src="/images/react-fiber/work-order.png" alt><br><i>比如你在<code>text(hello)</code>中断了，那么下一次就会从 <code>p</code> 节点开始处理</i></p>
<p><br></p>
<p>这个数据结构调整还有一个好处，就是某些节点异常时，我们可以打印出完整的’节点栈‘，只需要沿着节点的<code>return</code>回溯即可。</p>
<p><br><br><br></p>
<h3 id="2-两个阶段的拆分"><a href="#2-两个阶段的拆分" class="headerlink" title="2. 两个阶段的拆分"></a>2. 两个阶段的拆分</h3><p><br></p>
<p><img src="/images/react-fiber/fiber-reconciler.png" alt></p>
<p><br></p>
<p>如果你现在使用最新的 React 版本(v16), 使用 Chrome 的 Performance 工具，可以很清晰地看到每次渲染有两个阶段：<code>Reconciliation</code>(协调阶段) 和 <code>Commit</code>(提交阶段).</p>
<blockquote>
<p>我在之前的多篇文章中都有提及: <a href="https://juejin.im/post/5d8395646fb9a06ad16faa57" target="_blank" rel="noopener">《自己写个React渲染器: 以 Remax 为例(用React写小程序)》</a></p>
</blockquote>
<p>除了Fiber 工作单元的拆分，两阶段的拆分也是一个非常重要的改造，在此之前都是一边Diff一边提交的。先来看看这两者的区别:</p>
<ul>
<li><p><strong>⚛️ 协调阶段</strong>: 可以认为是 Diff 阶段, <strong>这个阶段可以被中断</strong>, 这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等, 这些变更React 称之为’<code>副作用</code>(Effect)’ . 以下生命周期钩子会在协调阶段被调用：</p>
<ul>
<li><code>constructor</code></li>
<li><code>componentWillMount</code> 废弃</li>
<li><code>componentWillReceiveProps</code> 废弃</li>
<li><code>static getDerivedStateFromProps</code></li>
<li><code>shouldComponentUpdate</code></li>
<li><code>componentWillUpdate</code> 废弃</li>
<li><code>render</code></li>
</ul>
</li>
<li><p><strong>⚛️ 提交阶段</strong>: 将上一个阶段计算出来的需要处理的<strong>副作用(Effects)</strong>一次性执行了。<strong>这个阶段必须同步执行，不能被打断</strong>. 这些生命周期钩子在提交阶段被执行:</p>
<ul>
<li><code>getSnapshotBeforeUpdate()</code> 严格来说，这个是在进入 commit 阶段前调用</li>
<li><code>componentDidMount</code></li>
<li><code>componentDidUpdate</code></li>
<li><code>componentWillUnmount</code></li>
</ul>
</li>
</ul>
<p><br></p>
<p>也就是说，在协调阶段如果时间片用完，React就会选择让出控制权。因为协调阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题。</p>
<p>需要注意的是：因为协调阶段可能被中断、恢复，甚至重做，<strong>⚠️React 协调阶段的生命周期钩子可能会被调用多次!</strong>, 例如 <code>componentWillMount</code> 可能会被调用两次。 </p>
<p>因此建议 <strong>协调阶段的生命周期钩子不要包含副作用</strong>. 索性 React 就废弃了这部分可能包含副作用的生命周期方法，例如<code>componentWillMount</code>、<code>componentWillUpdate</code>. v17后我们就不能再用它们了, 所以现有的应用应该尽快迁移.</p>
<p><br></p>
<p>现在你应该知道为什么’提交阶段’必须同步执行，不能中断的吧？ 因为我们要正确地处理各种副作用，包括DOM变更、还有你在<code>componentDidMount</code>中发起的异步请求、useEffect 中定义的副作用… 因为有副作用，所以必须保证按照次序只调用一次，况且会有用户可以察觉到的变更, 不容差池。</p>
<p>关于为什么要拆分两个阶段，<a href="https://github.com/facebook/react/issues/13186#issuecomment-403959161" target="_blank" rel="noopener">这里</a>有更详细的解释。</p>
<p><br><br><br></p>
<h3 id="3-reconcilation"><a href="#3-reconcilation" class="headerlink" title="3. Reconcilation"></a>3. Reconcilation</h3><p>接下来就是就是我们熟知的<code>Reconcilation</code>(为了方便理解，本文不区分Diff和Reconcilation, 两者是同一个东西)阶段了. <strong>思路和 Fiber 重构之前差别不大, 只不过这里不会再递归去比对、而且不会马上提交变更</strong>。</p>
<p>首先再进一步看一下<code>Fiber</code>的结构:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Fiber &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 节点的类型信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 标记 Fiber 类型, 例如函数组件、类组件、宿主组件</span></span><br><span class="line">  tag: WorkTag,</span><br><span class="line">  <span class="comment">// 节点元素类型, 是具体的类组件、函数组件、宿主组件(字符串)</span></span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">any</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 结构信息</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 子节点的唯一键, 即我们渲染列表传入的key属性</span></span><br><span class="line">  key: <span class="literal">null</span> | <span class="built_in">string</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 节点的状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 节点实例(状态)：</span></span><br><span class="line">  <span class="comment">//        对于宿主组件，这里保存宿主组件的实例, 例如DOM节点。</span></span><br><span class="line">  <span class="comment">//        对于类组件来说，这里保存类组件的实例</span></span><br><span class="line">  <span class="comment">//        对于函数组件说，这里为空，因为函数组件没有实例</span></span><br><span class="line">  stateNode: <span class="built_in">any</span>,</span><br><span class="line">  <span class="comment">// 新的、待处理的props</span></span><br><span class="line">  pendingProps: <span class="built_in">any</span>,</span><br><span class="line">  <span class="comment">// 上一次渲染的props</span></span><br><span class="line">  memoizedProps: <span class="built_in">any</span>, <span class="comment">// The props used to create the output.</span></span><br><span class="line">  <span class="comment">// 上一次渲染的组件状态</span></span><br><span class="line">  memoizedState: <span class="built_in">any</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 副作用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 当前节点的副作用类型，例如节点更新、删除、移动</span></span><br><span class="line">  effectTag: SideEffectTag,</span><br><span class="line">  <span class="comment">// 和节点关系一样，React 同样使用链表来将所有有副作用的Fiber连接起来</span></span><br><span class="line">  nextEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 替身</span></span><br><span class="line"><span class="comment">   * 指向旧树中的节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  alternate: Fiber | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>Fiber 包含的属性可以划分为 5 个部分:</p>
<ul>
<li><strong>🆕 结构信息</strong> - 这个上文我们已经见过了，Fiber 使用链表的形式来表示节点在树中的定位</li>
<li><strong>节点类型信息</strong> - 这个也容易理解，tag表示节点的分类、type 保存具体的类型值，如div、MyComp</li>
<li><strong>节点的状态</strong> - 节点的组件实例、props、state等，它们将影响组件的输出</li>
<li><p><strong>🆕 副作用</strong> - 这个也是新东西. 在 Reconciliation 过程中发现的’副作用’(变更需求)就保存在节点的<code>effectTag</code> 中(想象为打上一个标记).<br>那么怎么将本次渲染的所有节点副作用都收集起来呢？ 这里也使用了链表结构，在遍历过程中React会将所有有‘副作用’的节点都通过<code>nextEffect</code>连接起来</p>
</li>
<li><p><strong>🆕 替身</strong> - React 在 Reconciliation 过程中会构建一颗新的树(官方称为workInProgress tree，<strong>WIP树</strong>)，可以认为是一颗表示当前工作进度的树。还有一颗表示已渲染界面的<strong>旧树</strong>，React就是一边和旧树比对，一边构建WIP树的。 alternate 指向旧树的同等节点。</p>
</li>
</ul>
<p><br></p>
<p>现在可以放大看看<code>beginWork</code>  是如何对 Fiber 进行比对的:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">fiber: Fiber</span>): <span class="title">Fiber</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fiber.tag === WorkTag.HostComponent) &#123;</span><br><span class="line">    <span class="comment">// 宿主节点diff</span></span><br><span class="line">    diffHostComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.ClassComponent) &#123;</span><br><span class="line">    <span class="comment">// 类组件节点diff</span></span><br><span class="line">    diffClassComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.FunctionComponent) &#123;</span><br><span class="line">    <span class="comment">// 函数组件节点diff</span></span><br><span class="line">    diffFunctionalComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他类型节点，省略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>宿主节点比对:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffHostComponent</span>(<span class="params">fiber: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新增节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.stateNode == <span class="literal">null</span>) &#123;</span><br><span class="line">    fiber.stateNode = createHostComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateHostComponent(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newChildren = fiber.pendingProps.children;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比对子节点</span></span><br><span class="line">  diffChildren(fiber, newChildren);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>类组件节点比对也差不多:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffClassComponent</span>(<span class="params">fiber: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.stateNode == <span class="literal">null</span>) &#123;</span><br><span class="line">    fiber.stateNode = createInstance(fiber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.hasMounted) &#123;</span><br><span class="line">    <span class="comment">// 调用更新前生命周期钩子</span></span><br><span class="line">    applybeforeUpdateHooks(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 调用挂载前生命周期钩子</span></span><br><span class="line">    applybeforeMountHooks(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染新节点</span></span><br><span class="line">  <span class="keyword">const</span> newChildren = fiber.stateNode.render();</span><br><span class="line">  <span class="comment">// 比对子节点</span></span><br><span class="line">  diffChildren(fiber, newChildren);</span><br><span class="line"></span><br><span class="line">  fiber.memoizedState = fiber.stateNode.state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>子节点比对:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">fiber: Fiber, newChildren: React.ReactNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldFiber = fiber.alternate ? fiber.alternate.child : <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 全新节点，直接挂载</span></span><br><span class="line">  <span class="keyword">if</span> (oldFiber == <span class="literal">null</span>) &#123;</span><br><span class="line">    mountChildFibers(fiber, newChildren)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 新子节点</span></span><br><span class="line">  <span class="keyword">const</span> elements = extraElements(newChildren)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比对子元素</span></span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length || oldFiber != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevFiber = newFiber;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index]</span><br><span class="line">    <span class="keyword">const</span> sameType = isSameType(element, oldFiber)</span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">      newFiber = cloneFiber(oldFiber, element)</span><br><span class="line">      <span class="comment">// 更新关系</span></span><br><span class="line">      newFiber.alternate = oldFiber</span><br><span class="line">      <span class="comment">// 打上Tag</span></span><br><span class="line">      newFiber.effectTag = UPDATE</span><br><span class="line">      newFiber.return = fiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新节点</span></span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">      newFiber = createFiber(element)</span><br><span class="line">      newFiber.effectTag = PLACEMENT</span><br><span class="line">      newFiber.return = fiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除旧节点</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">      oldFiber.effectTag = DELETION;</span><br><span class="line">      oldFiber.nextEffect = fiber.nextEffect</span><br><span class="line">      fiber.nextEffect = oldFiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldFiber) &#123;</span><br><span class="line">      oldFiber = oldFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">      fiber.child = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevFiber &amp;&amp; element) &#123;</span><br><span class="line">      prevFiber.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>上面的代码很粗糙地还原了 Reconciliation 的过程, 但是对于我们理解React的基本原理已经足够了.</p>
<p><br></p>
<p>这里引用一下<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">Youtube: Lin Clark presentation in ReactConf 2017</a> 的Slide，来还原 Reconciliation 的过程. Lin Clark 这个演讲太经典了，几乎所有介绍 React Fiber 的文章都会引用它的Slide. 偷个懒，我也用下:</p>
<blockquote>
<p>这篇文章<a href="https://juejin.im/post/5ab7b3a2f265da2378403e57" target="_blank" rel="noopener">《React Fiber》</a> 用文字版解释了Link Clark Slide.</p>
</blockquote>
<p><img src="/images/react-fiber/effect-tag.png" alt></p>
<p><br></p>
<p>上图是 Reconciliation 完成后的状态，左边是旧树，右边是WIP树。对于需要变更的节点，都打上了’标签’。 在提交阶段，React 就会将这些打上标签的节点应用变更。</p>
<p><br><br><br></p>
<h3 id="4-双缓冲"><a href="#4-双缓冲" class="headerlink" title="4. 双缓冲"></a>4. 双缓冲</h3><p><code>WIP 树</code>构建这种技术类似于图形化领域的’<strong>双缓存(Double Buffering)</strong>‘技术, 图形绘制引擎一般会使用双缓冲技术，先将图片绘制到一个缓冲区，再一次性传递给屏幕进行显示，这样可以防止屏幕抖动，优化渲染性能。</p>
<p>放到React 中，WIP树就是一个缓冲，它在Reconciliation 完毕后一次性提交给浏览器进行渲染。它可以减少内存分配和垃圾回收，WIP 的节点不完全是新的，比如某颗子树不需要变动，React会克隆复用旧树中的子树。</p>
<p>双缓存技术还有另外一个重要的场景就是异常的处理，比如当一个节点抛出异常，仍然可以继续沿用旧树的节点，避免整棵树挂掉。</p>
<p>Dan 在 <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" target="_blank" rel="noopener">Beyond React 16</a> 演讲中用了一个非常恰当的比喻，那就是Git 功能分支，<strong>你可以将 WIP 树想象成从旧树中 Fork 出来的功能分支，你在这新分支中添加或移除特性，即使是操作失误也不会影响旧的分支。当你这个分支经过了测试和完善，就可以合并到旧分支，将其替换掉. 这或许就是’提交(commit)阶段‘的提交一词的来源吧？</strong>:</p>
<p><br></p>
<p><img src="/images/react-fiber/gitbranch.png" alt></p>
<p><br><br><br></p>
<h3 id="5-副作用的收集和提交"><a href="#5-副作用的收集和提交" class="headerlink" title="5. 副作用的收集和提交"></a>5. 副作用的收集和提交</h3><p>接下来就是将所有打了 Effect 标记的节点串联起来，这个可以在<code>completeWork</code>中做, 例如:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parent = fiber.return</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 到达顶端</span></span><br><span class="line">  <span class="keyword">if</span> (parent == <span class="literal">null</span> || fiber === topWork) &#123;</span><br><span class="line">    pendingCommit = fiber</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.effectTag != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.nextEffect) &#123;</span><br><span class="line">      parent.nextEffect.nextEffect = fiber</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parent.nextEffect = fiber</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.nextEffect) &#123;</span><br><span class="line">    parent.nextEffect = fiber.nextEffect</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>最后了，将所有副作用提交了:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> next = fiber</span><br><span class="line">  <span class="keyword">while</span>(next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fiber.effectTag) &#123;</span><br><span class="line">      <span class="comment">// 提交，偷一下懒，这里就不展开了</span></span><br><span class="line">      commitWork(fiber)</span><br><span class="line">    &#125;</span><br><span class="line">    next = fiber.nextEffect</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清理现场</span></span><br><span class="line">  pendingCommit = nextUnitOfWork = topWork = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="⚠️-未展开部分-🚧-–-中断和恢复"><a href="#⚠️-未展开部分-🚧-–-中断和恢复" class="headerlink" title="⚠️ 未展开部分 🚧 – 中断和恢复"></a>⚠️ 未展开部分 🚧 – 中断和恢复</h2><p>上文只是介绍了简单的中断和恢复机制，我们从哪里跌倒就从哪里站起来，在哪个节点中断就从哪个节点继续处理下去。 也就是说，到目前为止：<strong>⚠️更新任务还是串行执行的，我们只是将整个过程碎片化了. 对于那些需要优先处理的更新任务还是会被阻塞</strong>。我个人觉得这才是 React Fiber 中最难处理的一部分。</p>
<p><strong>实际情况是，在 React 得到控制权后，应该优先处理高优先级的任务</strong>。也就是说中断时正在处理的任务，在恢复时会让位给高优先级任务，原本中断的任务可能会被放弃或者重做。</p>
<p><strong>但是如果不按顺序执行任务，可能会导致前后的状态不一致</strong>。 比如低优先级任务将 <code>a</code> 设置为0，而高优先级任务将 <code>a</code> 递增1, 两个任务的执行顺序会影响最终的渲染结果。因此<strong>要让高优先级任务插队, 首先要保证状态更新的时序</strong>。</p>
<p><br></p>
<p>解决办法是: <strong>所有更新任务按照顺序插入一个队列, 状态必须按照插入顺序进行计算，但任务可以按优先级顺序执行</strong>, 例如：</p>
<p><br></p>
<p><img src="/images/react-fiber/resume-1.png" alt></p>
<p><br></p>
<p>红色表示高优先级任务。要计算它的状态必须基于前序任务计算出来的状态, 从而保证<strong>状态的最终一致性</strong>：</p>
<p><br></p>
<p><img src="/images/react-fiber/resume-2.png" alt></p>
<p>最终红色的高优先级任务 <code>C</code> 执行时的状态值是<code>a=5,b=3</code>. 在恢复控制权时，会按照优先级先执行 <code>C</code>, 前面的<code>A</code>、 <code>B</code>暂时跳过</p>
<p><br></p>
<p><img src="/images/react-fiber/resume-3.png" alt></p>
<p><br></p>
<p>上面被跳过任务不会被移除，在执行完高优先级任务后它们还是会被执行的。因为不同的更新任务影响的节点树范围可能是不一样的，举个例子 <code>a</code>、<code>b</code> 可能会影响 <code>Foo</code> 组件树，而 <code>c</code> 会影响 <code>Bar</code> 组件树。所以为了保证<strong>视图的最终一致性</strong>, 所有更新任务都要被执行。</p>
<p><br></p>
<p><img src="/images/react-fiber/resume-4.png" alt></p>
<p>首先 <code>C</code> 先被执行，它更新了 <code>Foo</code> 组件</p>
<p>接着执行 <code>A</code> 任务，它更新了<code>Foo</code> 和 <code>Bar</code> 组件，由于 <code>C</code> 已经以最终状态<code>a=5, b=3</code>更新了<code>Foo</code>组件，这里可以做一下性能优化，直接复用C的更新结果， 不必触发重新渲染。因此 <code>A</code> 仅需更新 <code>Bar</code> 组件即可。</p>
<p>接着执行 <code>B</code>，同理可以复用 Foo 更新结果。</p>
<p><br></p>
<p>道理讲起来都很简单，React Fiber 实际上非常复杂，不管执行的过程怎样拆分、以什么顺序执行，最重要的是保证<strong>状态的一致性</strong>和<strong>视图的一致性</strong>，这给了 React 团队很大的考验，以致于现在都没有正式release出来。</p>
<p><br><br><br></p>
<h2 id="凌波微步"><a href="#凌波微步" class="headerlink" title="凌波微步"></a>凌波微步</h2><p><img src="/images/react-fiber/new-frame.jpg" alt><br><i>同样来自Link Clark 的 Slider</i></p>
<p>前面说了一大堆，从操作系统进程调度、到浏览器原理、再到合作式调度、最后谈了React的基本改造工作, 地老天荒… 就是为了上面的小人可以在练就凌波微步, 它脚下的坑是浏览器的调用栈。</p>
<p>React 开启 <code>Concurrent Mode</code> 之后就不会挖大坑了，而是一小坑一坑的挖，挖一下休息一下，有紧急任务就优先去做。</p>
<p><br></p>
<p><img src="/images/react-fiber/benifit.png" alt><br><i>来源：<a href="https://www.youtube.com/watch?v=V1Ly-8Z1wQA&t=207s" target="_blank" rel="noopener">Flarnie Marchan - Ready for Concurrent Mode?</a></i></p>
<p><br></p>
<p>开启 <code>Concurrent Mode</code> 后，我们可以得到以下好处(详见<a href="https://www.youtube.com/watch?v=ByBPyMBTzM0" target="_blank" rel="noopener">Concurrent Rendering in React</a>):</p>
<ul>
<li>快速响应用户操作和输入，提升用户交互体验</li>
<li>让动画更加流畅，通过调度，可以让应用保持高帧率</li>
<li>利用好I/O 操作空闲期或者CPU空闲期，进行一些预渲染。 比如离屏(offscreen)不可见的内容，优先级最低，可以让 React 等到CPU空闲时才去渲染这部分内容。这和浏览器的preload等预加载技术差不多。</li>
<li>用<code>Suspense</code> 降低加载状态(load state)的优先级，减少闪屏。 比如数据很快返回时，可以不必显示加载状态，而是直接显示出来，避免闪屏；如果超时没有返回才显式加载状态。</li>
</ul>
<p><br></p>
<p>但是它肯定不是完美的，因为浏览器无法实现抢占式调度，无法阻止开发者做傻事的，开发者可以随心所欲，想挖多大的坑，就挖多大的坑。</p>
<p>为了共同创造美好的世界，我们要严律于己，该做的优化还需要做: 纯组件、虚表、简化组件、缓存…</p>
<p>尤雨溪在今年的<a href="https://www.yuque.com/vueconf/2019" target="_blank" rel="noopener">Vue Conf</a>一个观点让我印象深刻：<strong>如果我们可以把更新做得足够快的话，理论上就不需要时间分片了</strong>。</p>
<p><strong>时间分片并没有降低整体的工作量，该做的还是要做</strong>, 因此React 也在考虑利用CPU空闲或者I/O空闲期间做一些预渲染。所以跟尤雨溪说的一样：React Fiber 本质上是为了解决 React 更新低效率的问题，<strong>不要期望 Fiber 能给你现有应用带来质的提升, 如果性能问题是自己造成的，自己的锅还是得自己背</strong>.</p>
<p><br><br><br></p>
<h2 id="站在巨人的肩膀上"><a href="#站在巨人的肩膀上" class="headerlink" title="站在巨人的肩膀上"></a>站在巨人的肩膀上</h2><p><br></p>
<p>本文之所以能成文，离不开社区上优质的开源项目和资料。</p>
<p><strong>迷你 Fiber 实现</strong>:</p>
<p>React 现在的代码库太复杂了! 而且一直在变动和推翻自己，<a href="https://www.zhihu.com/people/he-shi-jun" target="_blank" rel="noopener">Hax</a> 在 <a href="https://www.zhihu.com/question/270428598/answer/354017709" target="_blank" rel="noopener">《为什么社区里那些类 React 库至今没有选择实现 Fiber 架构？》 </a> 就开玩笑说: Fiber 性价比略低… 到了这个阶段，竞品太多，facebook 就搞一个 fiber 来作为护城河……</p>
<p>这种工程量不是一般团队能Hold住的， 如果你只是想了解 Fiber，去读 React 的源码性价比也很低，不妨看看这些 Mini 版实现, 感受其精髓，不求甚解:</p>
<ul>
<li><a href="https://github.com/RubyLouvre/anu" target="_blank" rel="noopener">anu</a> <a href="https://github.com/RubyLouvre" target="_blank" rel="noopener">司徒正美</a> 开发的类React框架</li>
<li><a href="https://github.com/132yse/fre" target="_blank" rel="noopener">Fre</a> <a href="https://www.zhihu.com/people/132yse" target="_blank" rel="noopener">伊撒尔</a> 开发的类React框架，代码很精简⁉️</li>
<li><a href="https://github.com/Foveluy/Luy" target="_blank" rel="noopener">Luy</a></li>
<li><a href="https://github.com/pomber/didact" target="_blank" rel="noopener">didact</a></li>
</ul>
<p><br></p>
<p><strong>优秀的文章 &amp; 演讲</strong></p>
<p>本文只是对React Fiber进行了简单的科普，实际上React 的实现比本文复杂的多，如果你想深入理解React Fiber的，下面这些文章不容错过:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017 👍🎦</a> React Fiber 启蒙，YouTube</li>
<li><a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" target="_blank" rel="noopener">Beyond React 16 - Dan Abramov 👍🎦</a></li>
<li><a href="https://www.youtube.com/watch?v=ByBPyMBTzM0&amp;t=151s" target="_blank" rel="noopener">Concurrent Rendering in React - Andrew Clark and Brian Vaughn 👍🎦</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener">司徒正美: React Fiber架构 👍</a> 看不如写</li>
<li><a href="https://www.zhihu.com/people/NE_SmallTown/posts" target="_blank" rel="noopener">展望 React 17，回顾 React 往事 👍</a> 看完 <a href="https://www.zhihu.com/people/NE_SmallTown" target="_blank" rel="noopener">Heaven</a> 的相关文章，会觉得你了解的React 知识真的只是<a href="https://zhuanlan.zhihu.com/jheaven" target="_blank" rel="noopener">冰山一角</a>，我们都没资格说我们懂 React。</li>
<li><a href="https://zhuanlan.zhihu.com/p/36425839" target="_blank" rel="noopener">浅入 React16/fiber 系列 👍</a> 同样来自 Heaven</li>
<li><a href="https://www.zhihu.com/search?type=content&amp;q=requestIdleCallback" target="_blank" rel="noopener">淡苍：深入剖析 React Concurrent 👍</a></li>
<li><a href="https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec" target="_blank" rel="noopener">Didact Fiber: Incremental reconciliation  👍</a> 实现了简单的 React Fiber</li>
<li><a href="https://zhuanlan.zhihu.com/p/26027085" target="_blank" rel="noopener">程墨: React Fiber是什么</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/57346388" target="_blank" rel="noopener">译 深入React fiber架构及源码</a></li>
<li><a href="http://www.ayqy.net/blog/dive-into-react-fiber/" target="_blank" rel="noopener">黯羽轻扬: 完全理解React Fiber</a></li>
<li><a href="https://github.com/facebook/react/issues/7942" target="_blank" rel="noopener">Fiber Principles: Contributing To Fiber</a></li>
<li><a href="https://philippspiess.com/scheduling-in-react/" target="_blank" rel="noopener">Scheduling in React</a></li>
<li><a href="https://juejin.im/post/5d12c907f265da1b6d4033c5" target="_blank" rel="noopener">桃翁: Deep In React 之浅谈 React Fiber 架构（一）</a></li>
<li><a href="https://juejin.im/post/5b028db26fb9a07ac162ba68#heading-12" target="_blank" rel="noopener">为 Luy 实现 React Fiber 架构</a></li>
<li><a href="https://juejin.im/post/5ab7b3a2f265da2378403e57" target="_blank" rel="noopener">妖僧风月: React Fiber</a></li>
<li><a href="https://www.youtube.com/watch?v=V1Ly-8Z1wQA&amp;t=207s" target="_blank" rel="noopener">Flarnie Marchan - Ready for Concurrent Mode? 🎦</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/rendering" target="_blank" rel="noopener">Web Fundamentals &gt; Performance</a></li>
<li><a href="https://juejin.im/post/5ad71f39f265da239f07e862" target="_blank" rel="noopener">你应该知道的requestIdleCallback</a></li>
<li><a href="https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering/" target="_blank" rel="noopener">深入探究 eventloop 与浏览器渲染的时序问题</a></li>
<li><a href="https://nolanlawson.com/2018/09/25/accurately-measuring-layout-on-the-web/" target="_blank" rel="noopener">Accurately measuring layout on the web</a></li>
</ul>
<p><br></p>
<p><strong>自荐React 相关文章</strong></p>
<p>回顾一下今年写的关于 React 的相关文章</p>
<p>Concurrent模式预览（推荐）:</p>
<ul>
<li><a href="https://juejin.im/post/5db65d87518825648f2ef899#comment" target="_blank" rel="noopener">React Concurrent 模式抢先预览上篇: Suspense the world</a></li>
<li><a href="https://juejin.im/post/5dbee8e7e51d4558040f0830" target="_blank" rel="noopener">React Concurrent 模式抢先预览下篇: useTransition 的平行世界</a></li>
</ul>
<p><br></p>
<p>往期文章:</p>
<ul>
<li><a href="https://juejin.im/post/5cd7f2c4e51d453a7d63b715" target="_blank" rel="noopener">React组件设计实践总结 系列 共5篇</a></li>
<li><a href="https://juejin.im/post/5d8395646fb9a06ad16faa57" target="_blank" rel="noopener">自己写个React渲染器: 以 Remax 为例(用React写小程序)</a></li>
<li><a href="https://juejin.im/post/5d44e3745188255d5861d654" target="_blank" rel="noopener">谈谈React事件机制和未来(react-events)</a></li>
<li><a href="https://juejin.im/post/5d594ea5518825041301bbcb" target="_blank" rel="noopener">2019年了，整理了N个实用案例帮你快速迁移到React Hooks</a></li>
<li><a href="https://juejin.im/post/5d045350f265da1b695d5bf2" target="_blank" rel="noopener">浅谈React性能优化的方向</a></li>
<li><a href="https://juejin.im/post/5cfa29e151882539c33e4f5e" target="_blank" rel="noopener">从Preact中了解React组件和hooks基本原理</a></li>
<li><a href="https://juejin.im/post/5d06bf0a51882528194a9736" target="_blank" rel="noopener">React性能测量和分析</a></li>
</ul>
<p><br></p>
<p>本文讲了 React 如何优化 CPU 问题，React 野心远不在于此, I/O 方向的优化也在实践，例如 Suspend…  还有很多没讲完，后面的文章见！</p>
<p><br></p>
<p>问卷调查，你觉得这种文章风格怎样？</p>
<ul>
<li>A. 事无巨细，太啰嗦了</li>
<li>B. 娓娓道来，深入浅出我喜欢</li>
<li>C. 内容不够深入</li>
<li>D. 文章篇幅太长，可以拆分</li>
</ul>
<p>多选，下方评论，👍点赞走起</p>
<blockquote>
<p><strong>改了一个正经一点的网名：_sx_(傻叉) -&gt; 荒山 ⛰</strong></p>
</blockquote>
<p><br></p>
<p><img src="/images/sponsor.jpg" alt></p>
<p><br></p>
</brk>
  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#单处理进程调度-fiber-不是一个新的东西"><span class="toc-number">1.</span> <span class="toc-text">单处理进程调度: Fiber 不是一个新的东西</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类比浏览器javascript执行环境"><span class="toc-number">2.</span> <span class="toc-text">类比浏览器JavaScript执行环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#何为-fiber"><span class="toc-number">3.</span> <span class="toc-text">何为 Fiber</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-一种流程控制原语"><span class="toc-number">3.1.</span> <span class="toc-text">1. 一种流程控制原语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-一个执行单元"><span class="toc-number">3.2.</span> <span class="toc-text">2. 一个执行单元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#react-的fiber改造"><span class="toc-number">4.</span> <span class="toc-text">React 的Fiber改造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-数据结构的调整"><span class="toc-number">4.1.</span> <span class="toc-text">1. 数据结构的调整</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-两个阶段的拆分"><span class="toc-number">4.2.</span> <span class="toc-text">2. 两个阶段的拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-reconcilation"><span class="toc-number">4.3.</span> <span class="toc-text">3. Reconcilation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-双缓冲"><span class="toc-number">4.4.</span> <span class="toc-text">4. 双缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-副作用的收集和提交"><span class="toc-number">4.5.</span> <span class="toc-text">5. 副作用的收集和提交</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#⚠️-未展开部分-🚧-–-中断和恢复"><span class="toc-number">5.</span> <span class="toc-text">⚠️ 未展开部分 🚧 – 中断和恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#凌波微步"><span class="toc-number">6.</span> <span class="toc-text">凌波微步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#站在巨人的肩膀上"><span class="toc-number">7.</span> <span class="toc-text">站在巨人的肩膀上</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2019/10/18/react-fiber/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2019/10/18/react-fiber/&text=这可能是最通俗的 React Fiber 打开方式"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2019/10/18/react-fiber/&title=这可能是最通俗的 React Fiber 打开方式"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2019/10/18/react-fiber/&is_video=false&description=这可能是最通俗的 React Fiber 打开方式"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=这可能是最通俗的 React Fiber 打开方式&body=Check out this article: https://bobi.ink/2019/10/18/react-fiber/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2019/10/18/react-fiber/&title=这可能是最通俗的 React Fiber 打开方式"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2019/10/18/react-fiber/&title=这可能是最通俗的 React Fiber 打开方式"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2019/10/18/react-fiber/&title=这可能是最通俗的 React Fiber 打开方式"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2019/10/18/react-fiber/&title=这可能是最通俗的 React Fiber 打开方式"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2019/10/18/react-fiber/&name=这可能是最通俗的 React Fiber 打开方式&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2025 Ivan
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-44571525-2', 'auto');
        ga('send', 'pageview');
    </script>


    <!-- Disqus Comments -->
    <script type="text/javascript">
        var disqus_shortname = 'bobi-ink';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


