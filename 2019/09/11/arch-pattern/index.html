<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="所谓软件架构风格，是指描述某个特定应用领域中系统组织方式的惯用模式。架构风格定义一个词汇表和一组约束，词汇表中包含一些组件及连接器，约束则指出系统如何将构建和连接器组合起来。软件架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将系统中的各个模块和子系统有机的结合为一个完整的系统  没多少人能记住上面的定义，需要注意的是本文不是专业讨论系统架构的文章，笔者也还没到那个水平. 所以暂时">
<meta name="keywords" content="Blog,FrontEnd,React,Javascript,Typescript">
<meta property="og:type" content="article">
<meta property="og:title" content="透过现象看本质: 常见的前端架构风格和案例">
<meta property="og:url" content="https://bobi.ink/2019/09/11/arch-pattern/index.html">
<meta property="og:site_name" content="Bobi.ink">
<meta property="og:description" content="所谓软件架构风格，是指描述某个特定应用领域中系统组织方式的惯用模式。架构风格定义一个词汇表和一组约束，词汇表中包含一些组件及连接器，约束则指出系统如何将构建和连接器组合起来。软件架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将系统中的各个模块和子系统有机的结合为一个完整的系统  没多少人能记住上面的定义，需要注意的是本文不是专业讨论系统架构的文章，笔者也还没到那个水平. 所以暂时">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/tcp-ip-model.png">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/lang.png">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/jquery.png">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/vd1.png">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/vd2.png">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/taro.jpg">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/pipeline.png">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/gulp.png">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/middleware.png">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/mvc.png">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/redux.png">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/multi-model.png">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/vuex.png">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/pm2.png">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/codesandbox.png">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/plugin-architecture.png">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/webpack.png">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/microfrontend.jpg">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/components2.png">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/components.png">
<meta property="og:image" content="https://bobi.ink/images/arch-pattern/vue-component.png">
<meta property="og:image" content="https://bobi.ink/images/sponsor.jpg">
<meta property="og:updated_time" content="2023-06-01T09:55:14.327Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="透过现象看本质: 常见的前端架构风格和案例">
<meta name="twitter:description" content="所谓软件架构风格，是指描述某个特定应用领域中系统组织方式的惯用模式。架构风格定义一个词汇表和一组约束，词汇表中包含一些组件及连接器，约束则指出系统如何将构建和连接器组合起来。软件架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将系统中的各个模块和子系统有机的结合为一个完整的系统  没多少人能记住上面的定义，需要注意的是本文不是专业讨论系统架构的文章，笔者也还没到那个水平. 所以暂时">
<meta name="twitter:image" content="https://bobi.ink/images/arch-pattern/tcp-ip-model.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>透过现象看本质: 常见的前端架构风格和案例</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/09/15/remax/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/09/07/react-cliff/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2019/09/11/arch-pattern/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2019/09/11/arch-pattern/&text=透过现象看本质: 常见的前端架构风格和案例"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2019/09/11/arch-pattern/&title=透过现象看本质: 常见的前端架构风格和案例"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2019/09/11/arch-pattern/&is_video=false&description=透过现象看本质: 常见的前端架构风格和案例"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=透过现象看本质: 常见的前端架构风格和案例&body=Check out this article: https://bobi.ink/2019/09/11/arch-pattern/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2019/09/11/arch-pattern/&title=透过现象看本质: 常见的前端架构风格和案例"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2019/09/11/arch-pattern/&title=透过现象看本质: 常见的前端架构风格和案例"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2019/09/11/arch-pattern/&title=透过现象看本质: 常见的前端架构风格和案例"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2019/09/11/arch-pattern/&title=透过现象看本质: 常见的前端架构风格和案例"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2019/09/11/arch-pattern/&name=透过现象看本质: 常见的前端架构风格和案例&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#分层风格"><span class="toc-number">1.</span> <span class="toc-text">分层风格</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#virtual-dom"><span class="toc-number">1.1.</span> <span class="toc-text">Virtual DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#taro"><span class="toc-number">1.2.</span> <span class="toc-text">Taro</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#管道和过滤器"><span class="toc-number">2.</span> <span class="toc-text">管道和过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#中间件-middleware"><span class="toc-number">2.1.</span> <span class="toc-text">中间件(Middleware)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件驱动"><span class="toc-number">3.</span> <span class="toc-text">事件驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mv"><span class="toc-number">4.</span> <span class="toc-text">MV*</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#家喻户晓的mvc"><span class="toc-number">4.1.</span> <span class="toc-text">家喻户晓的MVC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redux"><span class="toc-number">4.2.</span> <span class="toc-text">Redux</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复制风格"><span class="toc-number">5.</span> <span class="toc-text">复制风格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#微内核架构"><span class="toc-number">6.</span> <span class="toc-text">微内核架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#微前端"><span class="toc-number">7.</span> <span class="toc-text">微前端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组件化架构"><span class="toc-number">8.</span> <span class="toc-text">组件化架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他"><span class="toc-number">9.</span> <span class="toc-text">其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展阅读"><span class="toc-number">10.</span> <span class="toc-text">扩展阅读</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        透过现象看本质: 常见的前端架构风格和案例
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Bobi.ink</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-09-10T16:00:00.000Z" itemprop="datePublished">2019-09-11</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <blockquote>
<p>所谓软件架构风格，是指描述某个特定应用领域中系统组织方式的惯用模式。架构风格定义一个词汇表和一组约束，词汇表中包含一些组件及连接器，约束则指出系统如何将构建和连接器组合起来。软件架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将系统中的各个模块和子系统有机的结合为一个完整的系统</p>
</blockquote>
<p>没多少人能记住上面的定义，需要注意的是本文不是专业讨论系统架构的文章，笔者也还没到那个水平. 所以暂时没必要纠结于什么是架构模式、什么是架构风格。在这里<strong>尚且把它们都当成一个系统架构上的套路, 所谓的套路就是一些通用的、可复用的，用于应对某类问题的方式方法. 可以理解为类似“设计模式”的东西，只是解决问题的层次不一样</strong>。</p>
<p>透过现象看本质，本文将带你领略前端领域一些流行技术栈背后的架构思想。直接进入正题吧</p>
<p><strong>文章大纲</strong></p>
<!-- TOC -->
<ul>
<li><a href="#分层风格">分层风格</a><ul>
<li><a href="#virtual-dom">Virtual DOM</a></li>
<li><a href="#taro">Taro</a></li>
</ul>
</li>
<li><a href="#管道和过滤器">管道和过滤器</a><ul>
<li><a href="#中间件middleware">中间件(Middleware)</a></li>
</ul>
</li>
<li><a href="#事件驱动">事件驱动</a></li>
<li><a href="#mv">MV*</a><ul>
<li><a href="#家喻户晓的mvc">家喻户晓的MVC</a></li>
<li><a href="#redux">Redux</a></li>
</ul>
</li>
<li><a href="#复制风格">复制风格</a></li>
<li><a href="#微内核架构">微内核架构</a></li>
<li><a href="#微前端">微前端</a></li>
<li><a href="#组件化架构">组件化架构</a></li>
<li><a href="#其他">其他</a></li>
<li><a href="#扩展阅读">扩展阅读</a></li>
</ul>
<!-- /TOC -->
<p><br></p>
<h2 id="分层风格"><a href="#分层风格" class="headerlink" title="分层风格"></a>分层风格</h2><blockquote>
<p>没有什么问题是分层解决不了，如果解决不了, 就再加一层 —— 鲁迅 <br><br>不不，原话是: <code>Any problem  in computer science can be solved by anther layer of indirection.</code></p>
</blockquote>
<p>分层架构是最常见的软件架构，你要不知道用什么架构，或者不知道怎么解决问题，那就尝试加多一层。</p>
<p>一个分层系统是按照层次来组织的，每一层为在其之上的层提供服务，并且使用在其之下的层所提供的服务. <strong>分层通常可以解决什么问题</strong>？</p>
<ul>
<li><p><strong>是隔离业务复杂度与技术复杂度的利器</strong>. 典型的例子是网络协议, 越高层越面向人类，越底层越面向机器。一层一层往上，很多技术的细节都被隐藏了，比如我们使用<code>HTTP</code>时，不需要考虑<code>TCP</code>层的握手和包传输细节，<code>TCP</code>层不需要关心<code>IP</code>层的寻址和路由。</p>
<p><img src="/images/arch-pattern/tcp-ip-model.png" alt></p>
<p><br></p>
</li>
<li><p><strong>分离关注点和复用</strong>。减少跨越多层的耦合, 当一层变动时不会影响到其他层。例如我们前端项目建议拆分逻辑层和视图层，一方面可以降低逻辑和视图之间的耦合，当视图层元素变动时可以尽量减少对逻辑层的影响；另外一个好处是, 当逻辑抽取出去后，可以被不同平台的视图复用。</p>
</li>
</ul>
<p><br></p>
<p>关注点分离之后，软件的结构会变得容易理解和开发, 每一层可以被复用, 容易被测试, 其他层的接口通过模拟解决. 但是分层架构，也不是全是优点，<strong>分层的抽象可能会丢失部分效率和灵活性</strong>, 比如编程语言就有’层次’(此例可能不太严谨)，语言抽象的层次越高，一般运行效率可能会有所衰减:</p>
<p><img src="/images/arch-pattern/lang.png" alt></p>
<p>分层架构在软件领域的案例实在太多太多了，咱讲讲前端的一些’分层’案例：</p>
<p><br></p>
<h3 id="virtual-dom"><a href="#virtual-dom" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><p>前端石器时代，我们页面交互和渲染，是通过服务端渲染或者直接操作DOM实现的, 有点像C/C++这类系统编程语言手动操纵内存. 那时候<code>JQuery</code>很火:</p>
<p><img src="/images/arch-pattern/jquery.png" alt></p>
<p>后来随着软硬件性能越来越好、Web应用也越来越复杂，前端开发者的生产力也要跟上，类似JQuery这种命令式的编程方式无疑是比较低效的. 尽管手动操作 DOM 可能可以达到更高的性能和灵活性，但是这样对大部分开发者来说太低效了，我们是可以接受牺牲一点性能换取更高的开发效率的.</p>
<p>怎么解决，再加一层吧，后来React就搞了一层VirtualDOM。我们可以声明式、组合式地构建一颗对象树, 然后交由React将它映射到DOM：</p>
<p><img src="/images/arch-pattern/vd1.png" alt></p>
<p>一开始VirtualDOM和DOM的关系比较暧昧，两者是耦合在一起的。后面有人想，我们有了VirtualDOM这个抽象层，那应该能多搞点别的，比如渲染到移动端原生组件、PDF、Canvas、终端UI等等。</p>
<p>后来VirtualDOM进行了更彻底的分层，有着这个抽象层我们可以将VirtualDOM映射到更多类似应用场景:</p>
<p><img src="/images/arch-pattern/vd2.png" alt></p>
<p>所以说 VirtualDOM 更大的意义在于开发方式的转变: 声明式、 数据驱动, 让开发者不需要关心 DOM 的操作细节(属性操作、事件绑定、DOM 节点变更)，换句话说应用的开发方式变成了<code>view=f(state)</code>, 这对生产力的解放是有很大推动作用的; 另外有了VirtualDOM这一层抽象层，使得多平台渲染成为可能。</p>
<p>当然VirtualDOM或者React，不是唯一，也不是第一个这样的解决方案。其他前端框架，例如Vue、Angular基本都是这样一个发展历程。</p>
<p>上面说了，分层不是银弹。我们通过ReactNative可以开发跨平台的移动应用，但是众所周知，它运行效率或者灵活性暂时是无法与原生应用比拟的。</p>
<p><br></p>
<h3 id="taro"><a href="#taro" class="headerlink" title="Taro"></a>Taro</h3><p><strong><a href="https://taro-docs.jd.com/taro/docs/README.html" target="_blank" rel="noopener">Taro</a> 和React一样也采用分层架构风格，只不过他们解决的问题是相反的。React加上一个分层，可以渲染到不同的视图形态；而Taro则是为了统一多样的视图形态</strong>: 国内现如今市面上端的形态多种多样，Web、React-Native、微信小程序…… 针对不同的端去编写多套代码的成本非常高，这种需求催生了Taro这类框架的诞生. 使用 Taro，我们可以只书写一套代码, 通过编译工具可以输出到不同的端:</p>
<p><img src="/images/arch-pattern/taro.jpg" alt><br>(图片来源: <a href="https://aotu.io/notes/2018/06/07/Taro/" target="_blank" rel="noopener">多端统一开发框架 - Taro</a>)</p>
<p><br><br><br></p>
<h2 id="管道和过滤器"><a href="#管道和过滤器" class="headerlink" title="管道和过滤器"></a>管道和过滤器</h2><p>在管道/过滤器架构风格中，每个组件都有一组输入和输出，每个组件职责都很单一, 数据输入组件，经过内部处理，然后将处理过的数据输出。所以这些组件也称为过滤器，连接器按照业务需求将组件连接起来，其形状就像‘管道’一样，这种架构风格由此得名。</p>
<p><img src="/images/arch-pattern/pipeline.png" alt></p>
<p>这里面最经典的案例是<code>*unix</code> Shell命令，Unix的哲学就是“只做一件事，把它做好”，所以我们常用的Unix命令功能都非常单一，但是Unix Shell还有一件法宝就是管道，通过管道我们可以将命令通过<code>标准输入输出</code>串联起来实现复杂的功能:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 获取网页，并进行拼写检查。代码来源于wiki</span><br><span class="line">curl "http://en.wikipedia.org/wiki/Pipeline_(Unix)" | \</span><br><span class="line">sed 's/[^a-zA-Z ]/ /g' | \</span><br><span class="line">tr 'A-Z ' 'a-z\n' | \</span><br><span class="line">grep '[a-z]' | \</span><br><span class="line">sort -u | \</span><br><span class="line">comm -23 - /usr/share/dict/words | \</span><br><span class="line">less</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>另一个和Unix管道相似的例子是<code>ReactiveX</code>, 例如<a href="https://github.com/ReactiveX/rxjs" target="_blank" rel="noopener">RxJS</a>. 很多教程将Rx比喻成河流，这个河流的开头就是一个事件源，这个事件源按照一定的频率发布事件。Rx真正强大的其实是它的操作符，有了这些操作符，你可以对这条河流<a href="https://rxjs.dev/operator-decision-tree" target="_blank" rel="noopener">做一切可以做的事情</a>，例如分流、节流、建大坝、转换、统计、合并、产生河流的河流……</p>
<p>这些操作符和Unix的命令一样，职责都很单一，只干好一件事情。但我们管道将它们组合起来的时候，就迸发了无限的能力.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fromEvent &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; throttleTime, map, scan &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</span><br><span class="line"></span><br><span class="line">fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>)</span><br><span class="line">  .pipe(</span><br><span class="line">    throttleTime(<span class="number">1000</span>),</span><br><span class="line">    map(<span class="function"><span class="params">event</span> =&gt;</span> event.clientX),</span><br><span class="line">    scan(<span class="function">(<span class="params">count, clientX</span>) =&gt;</span> count + clientX, <span class="number">0</span>)</span><br><span class="line">  )</span><br><span class="line">  .subscribe(<span class="function"><span class="params">count</span> =&gt;</span> <span class="built_in">console</span>.log(count));</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>除了上述的RxJS，管道模式在前端领域也有很多应用，主要集中在前端工程化领域。例如’老牌’的项目构建工具<a href="https://www.gulpjs.com.cn/" target="_blank" rel="noopener">Gulp</a>, Gulp使用管道化模式来处理各种文件类型，管道中的每一个步骤称为Transpiler(转译器), 它们以 NodeJS 的Stream 作为输入输出。整个过程高效而简单。</p>
<p><img src="/images/arch-pattern/gulp.png" alt></p>
<p><br></p>
<p>不确定是否受到Gulp的影响，现代的<a href="https://www.webpackjs.com/" target="_blank" rel="noopener">Webpack</a>打包工具，也使用同样的模式来实现对文件的处理, 即<a href="https://www.webpackjs.com/concepts/loaders/" target="_blank" rel="noopener">Loader</a>, Loader 用于对模块的源代码进行转换, 通过Loader的组合，可以实现复杂的文件转译需求.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      use: [&#123;</span><br><span class="line">          loader: <span class="string">"style-loader"</span> <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">          loader: <span class="string">"css-loader"</span> <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">          loader: <span class="string">"sass-loader"</span> <span class="comment">// 将 Sass 编译成 CSS</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="中间件-middleware"><a href="#中间件-middleware" class="headerlink" title="中间件(Middleware)"></a>中间件(Middleware)</h3><p><img src="/images/arch-pattern/middleware.png" alt></p>
<p>如果开发过<code>Express</code>、<code>Koa</code>或者<code>Redux</code>, 你可能会发现中间件模式和上述的管道模式有一定的相似性，如上图。相比管道，中间件模式可以使用一个洋葱剖面来形容. 但和管道相比，一般的中间件实现有以下特点:</p>
<ul>
<li>中间件没有显式的输入输出。这些中间件之间通常通过集中式的上下文对象来共享状态</li>
<li>有一个循环的过程。管道中，数据处理完毕后交给下游了，后面就不管了。而中间件还有一个回归的过程，当下游处理完毕后会进行回溯，所以有机会干预下游的处理结果。</li>
</ul>
<p>我在谷歌上搜了老半天中间件，对于中间件都没有得到一个令我满意的定义. <strong>暂且把它当作一个特殊形式的管道模式吧</strong>。这种模式通常用于后端，它可以干净地分离出请求的不同阶段，也就是分离关注点。比如我们可以创建这些中间件：</p>
<ul>
<li>日志： 记录开始时间 ⏸ 计算响应时间，输出请求日志</li>
<li>认证： 验证用户是否登录</li>
<li>授权： 验证用户是否有执行该操作的权限</li>
<li>缓存： 是否有缓存结果，有的话就直接返回 ⏸ 当下游响应完成后，再判断一下响应是否可以被缓存</li>
<li>执行： 执行实际的请求处理 ⏸ 响应</li>
</ul>
<p>有了中间件之后，我们不需要在每个响应处理方法中都包含这些逻辑，关注好自己该做的事情。下面是Koa的示例代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// logger</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="keyword">const</span> rt = ctx.response.get(<span class="string">'X-Response-Time'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;rt&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// x-response-time</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="built_in">Date</span>.now() - start;</span><br><span class="line">  ctx.set(<span class="string">'X-Response-Time'</span>, <span class="string">`<span class="subst">$&#123;ms&#125;</span>ms`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// response</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'Hello World'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><p>事件驱动, 或者称为<code>发布-订阅</code>风格， 对于前端开发来说是再熟悉不过的概念了. 它<strong>定义了一种一对多的依赖关系</strong>， 在事件驱动系统风格中，组件不直接调用另一个组件，而是触发或广播一个或多个事件。系统中的其他组件在一个或多个事件中注册。当一个事件被触发，系统会自动通知在这个事件中注册的所有组件. </p>
<p>这样就<strong>分离了关注点，订阅者依赖于事件而不是依赖于发布者，发布者也不需要关心订阅者，两者解除了耦合</strong>。</p>
<p>生活中也有很多<code>发布-订阅</code>的例子，比如微信公众号信息订阅，当新增一个订阅者的时候，发布者并不需要作出任何调整，同样发布者调整的时候也不会影响到订阅者，只要协议没有变化。我们可以发现，<strong>发布者和订阅者之间其实是一种弱化的动态的关联关系</strong>。</p>
<p><strong>解除耦合目的是一方面, 另一方面也可能由基因决定的，一些事情天然就不适合或不支持用同步的方式去调用，或者这些行为是异步触发的</strong>。</p>
<p>JavaScript的基因决定事件驱动模式在前端领域的广泛使用. 在<a href="https://juejin.im/post/5d693d8b6fb9a06aca383488" target="_blank" rel="noopener">浏览器和Node中的JavaScript是如何工作的? 可视化解释</a> 简单介绍了Javascript的执行原理，其中提到JavaScript是单线程的编程语言，为了应对各种实际的应用场景，一个线程以压根忙不过来的，事件驱动的异步方式是JavaScript的救命稻草.</p>
<p>浏览器方面，浏览器就是一个GUI程序，<strong>GUI程序是一个循环(更专业的名字是事件循环)，接收用户输入，程序处理然后反馈到页面，再接收用户输入…</strong> 用户的输入是异步，将用户输入抽象为事件是最简洁、自然、灵活的方式。</p>
<blockquote>
<p>需要注意的是：事件驱动和异步是不能划等号的。异步 !== 事件驱动，事件驱动 !== 异步</p>
</blockquote>
<p><strong>扩展</strong>:</p>
<ul>
<li><strong>响应式编程</strong>: 响应式编程本质上也是事件驱动的，下面是前端领域比较流行的两种响应式模式：<ul>
<li><code>函数响应式(Functional Reactive Programming)</code>, 典型代表RxJS</li>
<li><code>透明的函数响应式编程(Transparently applying Functional Reactive Programming - TFRP)</code>, 典型代表Vue、Mobx</li>
</ul>
</li>
<li><strong>消息总线</strong>：指接收、发送消息的软件系统。消息基于一组已知的格式，以便系统无需知道实际接收者就能互相通信</li>
</ul>
<p><br></p>
<h2 id="mv"><a href="#mv" class="headerlink" title="MV*"></a>MV*</h2><p><code>MV*</code>架构风格应用也非常广泛。我觉MV*本质上也是一种分层架构，一样强调职责分离。其中最为经典的是MVC架构风格，除此之外还有各种衍生风格，例如<code>MVP</code>、<code>MVVM</code>、<a href="https://medium.com/@fkrautwald/plug-and-play-all-your-observable-streams-with-cycle-js-e543fc287872#.by4c219c8" target="_blank" rel="noopener"><code>MVI(Model View Intent)</code></a>. 还有有点关联<code>Flux</code>或者<code>Redux</code>模式。</p>
<p><br></p>
<h3 id="家喻户晓的mvc"><a href="#家喻户晓的mvc" class="headerlink" title="家喻户晓的MVC"></a>家喻户晓的MVC</h3><p><img src="/images/arch-pattern/mvc.png" alt></p>
<p>如其名，MVC将应用分为三层，分别是：</p>
<ul>
<li>视图层(View) 呈现数据给用户</li>
<li>控制器(Controller) 模型和视图之间的纽带，起到不同层的组织作用：<ul>
<li>处理事件并作出响应。一般事件有用户的行为(比如用户点击、客户端请求)，模型层的变更</li>
<li>控制程序的流程。根据请求选择适当的模型进行处理，然后选择适当的视图进行渲染，最后呈现给用户</li>
</ul>
</li>
<li>模型(Model) 封装与应用程序的业务逻辑相关的数据以及对数据的处理方法, 通常它需要和数据持久化层进行通信</li>
</ul>
<p>目前前端应用很少有纯粹使用MVC的，要么视图层混合了控制器层，要么就是模型和控制器混合，或者干脆就没有所谓的控制器. 但一点可以确定的是，很多应用都不约而同分离了’逻辑层’和’视图层’。</p>
<p>下面是典型的AngularJS代码, 视图层:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Todo<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">"TodoListController as todoList"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;todoList.remaining()&#125;&#125; of &#123;&#123;todoList.todos.length&#125;&#125; remaining<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  [ <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">ng-click</span>=<span class="string">"todoList.archive()"</span>&gt;</span>archive<span class="tag">&lt;/<span class="name">a</span>&gt;</span> ]</span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"unstyled"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">ng-repeat</span>=<span class="string">"todo in todoList.todos"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">ng-model</span>=<span class="string">"todo.done"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"done-&#123;&#123;todo.done&#125;&#125;"</span>&gt;</span>&#123;&#123;todo.text&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">ng-submit</span>=<span class="string">"todoList.addTodo()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">ng-model</span>=<span class="string">"todoList.todoText"</span>  <span class="attr">size</span>=<span class="string">"30"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">placeholder</span>=<span class="string">"add new todo here"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"btn-primary"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"add"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>逻辑层:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">angular.module(<span class="string">'todoApp'</span>, [])</span><br><span class="line">  .controller(<span class="string">'TodoListController'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> todoList = <span class="keyword">this</span>;</span><br><span class="line">    todoList.todos = [</span><br><span class="line">      &#123;<span class="attr">text</span>:<span class="string">'learn AngularJS'</span>, <span class="attr">done</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">text</span>:<span class="string">'build an AngularJS app'</span>, <span class="attr">done</span>:<span class="literal">false</span>&#125;];</span><br><span class="line"></span><br><span class="line">    todoList.addTodo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      todoList.todos.push(&#123;<span class="attr">text</span>:todoList.todoText, <span class="attr">done</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">      todoList.todoText = <span class="string">''</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    todoList.remaining = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">      angular.forEach(todoList.todos, <span class="function"><span class="keyword">function</span>(<span class="params">todo</span>) </span>&#123;</span><br><span class="line">        count += todo.done ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    todoList.archive = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> oldTodos = todoList.todos;</span><br><span class="line">      todoList.todos = [];</span><br><span class="line">      angular.forEach(oldTodos, <span class="function"><span class="keyword">function</span>(<span class="params">todo</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!todo.done) todoList.todos.push(todo);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>至于MVP、MVVM，这些MVC模式的延展或者升级，网上都大量的资源，这里就不予赘述。</p>
<p><br></p>
<h3 id="redux"><a href="#redux" class="headerlink" title="Redux"></a>Redux</h3><p>Redux是Flux架构的改进、融合了Elm语言中函数式的思想. 下面是Redux的架构图:</p>
<p><img src="/images/arch-pattern/redux.png" alt></p>
<p>从上图可以看出Redux架构有以下要点:</p>
<ul>
<li><strong>单一的数据源</strong>.</li>
<li><strong>单向的数据流</strong>.</li>
</ul>
<p>单一数据源, 首先解决的是传统MVC架构多模型数据流混乱问题(如下图)。单一的数据源可以让应用的状态可预测和可被调试。另外单一数据源也方便做数据镜像，实现撤销/重做，数据持久化等等功能</p>
<p><img src="/images/arch-pattern/multi-model.png" alt></p>
<p>单向数据流用于辅助单一数据源, 主要目的是阻止应用代码直接修改数据源，这样一方面简化数据流，同样也让应用状态变化变得可预测。</p>
<p>上面两个特点是Redux架构风格的核心，至于Redux还强调不可变数据、利用中间件封装副作用、范式化状态树，只是一种最佳实践。还有许多<code>类Redux</code>的框架，例如<a href="http://vuex.vuejs.org" target="_blank" rel="noopener"><code>Vuex</code></a>、<a href="https://ngrx.io" target="_blank" rel="noopener">ngrx</a>，在架构思想层次是一致的:</p>
<p><img src="/images/arch-pattern/vuex.png" alt></p>
<p><br></p>
<h2 id="复制风格"><a href="#复制风格" class="headerlink" title="复制风格"></a>复制风格</h2><p><img src="/images/arch-pattern/pm2.png" alt></p>
<p>基于复制(Replication)风格的系统，会利用多个实例提供相同的服务，来改善服务的可访问性和可伸缩性，以及性能。这种架构风格可以改善用户可察觉的性能，简单服务响应的延迟。</p>
<p>这种风格在后端用得比较多，举前端比较熟悉的例子，NodeJS. NodeJS是单线程的，为了利用多核资源，NodeJS标准库提供了一个<a href="https://nodejs.org/api/cluster.html" target="_blank" rel="noopener"><code>cluster</code></a>模块，它可以根据CPU数创建多个Worker进程，这些Worker进程可以共享一个服务器端口，对外提供同质的服务, Master进程会根据一定的策略将资源分配给Worker:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> numCPUs = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus().length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Master <span class="subst">$&#123;process.pid&#125;</span> is running`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fork workers.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCPUs; i++) &#123;</span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cluster.on(<span class="string">'exit'</span>, (worker, code, signal) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`worker <span class="subst">$&#123;worker.process.pid&#125;</span> died`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Workers可以共享任意的TCP连接 </span></span><br><span class="line">  <span class="comment">// 比如共享HTTP服务器 </span></span><br><span class="line">  http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>);</span><br><span class="line">    res.end(<span class="string">'hello world\n'</span>);</span><br><span class="line">  &#125;).listen(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Worker <span class="subst">$&#123;process.pid&#125;</span> started`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用多核能力可以提升应用的性能和可靠性。我们也可以利用<a href="http://pm2.keymetrics.io/docs/usage/cluster-mode/" target="_blank" rel="noopener">PM2</a>这样的进程管理工具，来简化Node集群的管理，它支持很多有用的特性，例如集群节点重启、日志归集、性能监视等。</p>
<p>复制风格常用于网络服务器。浏览器和Node都有<code>Worker</code>的概念，但是一般都只推荐在CPU密集型的场景使用它们，因为浏览器或者NodeJS内置的异步操作已经非常高效。实际上前端应用CPU密集型场景并不多，或者目前阶段不是特别实用。除此之外你还要权衡进程间通信的效率、Worker管理复杂度、异常处理等事情。</p>
<p>有一个典型的CPU密集型的场景，即源文件转译. 典型的例子是<a href="https://codesandbox.io/dashboard" target="_blank" rel="noopener">CodeSandbox</a>, 它就是利用浏览器的Worker机制来提高源文件的转译性能的:</p>
<p><img src="/images/arch-pattern/codesandbox.png" alt></p>
<p>除了处理CPU密集型任务，对于浏览器来说，Worker也是一个重要的安全机制，用于隔离不安全代码的执行，或者限制访问浏览器DOM相关的东西。小程序抽离逻辑进程的原因之一就是安全性</p>
<p>其他示例：</p>
<ul>
<li>ServerLess</li>
</ul>
<p><br></p>
<h2 id="微内核架构"><a href="#微内核架构" class="headerlink" title="微内核架构"></a>微内核架构</h2><p><img src="/images/arch-pattern/plugin-architecture.png" alt></p>
<p>微内核架构(MicroKernel)又称为”插件架构”, 指的是软件的内核相对较小，主要功能和业务逻辑都通过插件形式实现。内核只包含系统运行的最小功能。插件之间相互独立，插件之间的通信，应该降到最低，减少相互依赖。</p>
<p>微内核结构的难点在于建立一套粒度合适的插件协议、以及对插件之间进行适当的隔离和解耦。从而才能保证良好的扩展性、灵活性和可迁移性。</p>
<p>前端领域比较典型的例子是<code>Webpack</code>、<code>Babel</code>、<code>PostCSS</code>以及<code>ESLint</code>, 这些应用需要应对复杂的定制需求，而且这些需求时刻在变，只有微内核架构才能保证灵活和可扩展性。</p>
<p>以Webpack为例。Webpack的核心是一个Compiler，这个Compiler主要功能是集成插件系统、维护<code>模块对象图</code>, 对于模块代码具体编译工作、模块的打包、优化、分析、聚合统统都是基于外部插件完成的.</p>
<p>如上文说的Loader运用了管道模式，负责对源文件进行转译；那Plugin则可以将行为注入到Compiler运行的整个生命周期的钩子中, 完全访问Compiler的当前状态。</p>
<blockquote>
<p><a href="https://twitter.com/thelarkinn" target="_blank" rel="noopener">Sean Larkin</a>有个演讲: <a href="https://www.youtube.com/watch?v=4tQiJaFzuJ8" target="_blank" rel="noopener">Everything is a plugin! Mastering webpack from the inside out </a></p>
</blockquote>
<p><img src="/images/arch-pattern/webpack.png" alt></p>
<p><br></p>
<p>这里还有一篇文章<a href="https://yunsong0922.github.io/2018/12/09/%E5%BE%AE%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84%E5%BA%94%E7%94%A8%E7%A0%94%E7%A9%B6/" target="_blank" rel="noopener">&lt;微内核架构应用研究&gt;</a>专门写了前端微内核架构模式的一些应用，推荐阅读一下。</p>
<p><br></p>
<h2 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h2><p>前几天听了<a href="http://codetimecn.com/" target="_blank" rel="noopener">代码时间</a>上<a href="https://coolshell.cn/haoel" target="_blank" rel="noopener">左耳朵耗子</a>的一期<a href="http://codetimecn.com/episodes/manager" target="_blank" rel="noopener">节目</a>, 他介绍得了亚马逊内部有很多小团队，亚马逊网站上一块豆腐块大小的区域可能是一个团队在维护，比如地址选择器、购物车、运达时间计算… 大厂的这种超级项目是怎么协调和维护的呢？ 这也许就是微前端或者微服务出现的原因吧。</p>
<p>微前端旨在将<code>单体前端</code>分解成更小、更简单的模块，这些模块可以被独立的团队进行开发、测试和部署，最后再组合成一个大型的整体。</p>
<p><img src="/images/arch-pattern/microfrontend.jpg" alt></p>
<p>微前端下各个应用模块是独立运行、独立开发、独立部署的，相对应的会配备更加自治的团队(一个团队干好一件事情)。 微前端的实施还需要有稳固的前端基础设施和研发体系的支撑。</p>
<p>如果你想深入学习微前端架构，建议阅读<a href="https://www.zhihu.com/people/phodal/activities" target="_blank" rel="noopener">Phodal</a>的<a href="https://juejin.im/user/5567e339e4b0349d3313190b/posts" target="_blank" rel="noopener">相关文章</a>，还有他的新书<a href="https://www.amazon.cn/dp/B07TJ7R9DX/ref=sr_1_1?__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&amp;keywords=%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84&amp;qid=1568279892&amp;s=gateway&amp;sr=8-1" target="_blank" rel="noopener">《前端架构：从入门到微前端》</a></p>
<p><br></p>
<h2 id="组件化架构"><a href="#组件化架构" class="headerlink" title="组件化架构"></a>组件化架构</h2><p>组件化开发对现在的我们来说如此自然，就像水对鱼一样。 以致于我们忘了组件化也是一种非常重要的架构思想，它的中心思想就是分而治之。按照Wiki上面的定义是：<code>组件化就是基于可复用目的，将一个大的软件系统按照分离关注点的形式，拆分成多个独立的组件，主要目的就是减少耦合</code>.</p>
<p>从前端的角度具体来讲，如下图，石器时代开发方式(右侧), 组件时代(左侧):</p>
<p><img src="/images/arch-pattern/components2.png" alt><br>(图片来源: <a href="http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text" target="_blank" rel="noopener">http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text</a>)</p>
<p>按照Vue官网的说法: <code>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树</code>：</p>
<p><img src="/images/arch-pattern/components.png" alt></p>
<p>按照我的理解<strong>组件跟函数是一样的东西，这就是为什么函数式编程思想在React中会应用的如此自然</strong>。若干个简单函数，可以复合成复杂的函数，复杂的函数再复合成复杂的应用。对于前端来说，页面也是这么来的，一个复杂的页面就是有不同粒度的组件复合而成的。</p>
<p>组件另外一个重要的特征就是<strong>内聚性</strong>，它是一个独立的单元，自包含了所有需要的资源。例如一个前端组件较包含样式、视图结构、组件逻辑:</p>
<p><img src="/images/arch-pattern/vue-component.png" alt></p>
<p><br></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>我终于编不下去了</strong>！还有很多架构风格，限于文章篇幅, 且这些风格主要应用于后端领域，这里就不一一阐述了。你可以通过扩展阅读了解这些模式</p>
<ul>
<li>面向对象风格: 将应用或系统任务分割为单独、可复用、可自给的对象，每个对象都包含数据、以及对象相关的行为</li>
<li>C/S 客户端/服务器风格</li>
<li>面向服务架构(SOA): 指那些利用契约和消息将功能暴露为服务、消费功能服务的应用</li>
<li>N层/三层: 和分层架构差不多，侧重物理层. 例如C/S风格就是一个典型的N层架构</li>
<li>点对点风格</li>
</ul>
<p>通过上文，你估计会觉得架构风格比设计模式或者算法好理解多的，正所谓‘<strong>大道至简</strong>’，但是‘<strong>简洁而不简单</strong>’！大部分项目的架构不是一开始就是这样的，它们可能经过长期的迭代，踩着巨人的肩膀，一路走过来才成为今天的样子。</p>
<p>希望本文可以给你一点启发，对于我们前端工程师来说，最牛的不是能做多酷的页面、掌握多少API，要学会通过现象看本质，举一反三融会贯通，这才是进阶之道。</p>
<p>本文完！</p>
<p><br></p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a href="https://wxs.me/2069" target="_blank" rel="noopener">几种常见的软件架构风格介绍</a></li>
<li><a href="https://docs.huihoo.com/rest/REST_cn.pdf" target="_blank" rel="noopener">架构风格与基于网络的软件架构设计</a> REST提议者，Roy Thomas Fielding的博士论文</li>
<li><a href="http://www.ruanyifeng.com/blog/2016/09/software-architecture.html" target="_blank" rel="noopener">软件架构入门</a></li>
<li><a href="https://zh.wikipedia.org/wiki/管道_\(Unix\" target="_blank" rel="noopener">管道 (Unix)</a>)</li>
<li><a href="https://zhuanlan.zhihu.com/p/20597452" target="_blank" rel="noopener">redux middleware 详解</a></li>
<li><a href="https://juejin.im/post/593021272f301e0058273468" target="_blank" rel="noopener">浅析前端开发中的 MVC/MVP/MVVM 模式</a></li>
<li><a href="https://juejin.im/post/5d1e0dea51882514bf5bedfa#comment" target="_blank" rel="noopener">CodeSandbox 浏览器端的webpack是如何工作的？ 上篇</a></li>
<li><a href="https://mp.weixin.qq.com/s/KT288QNmtJzKe-jaPyFtFA" target="_blank" rel="noopener">万金油CS与分层</a></li>
<li><a href="https://www.infoq.cn/article/03*BeU3zQegIbIytRsX9" target="_blank" rel="noopener">大前端时代下的微前端架构：实现增量升级、代码解耦、独立部署</a></li>
<li><a href="https://www.iteye.com/blog/moon-walker-2393310" target="_blank" rel="noopener">系统组件化架构设计</a></li>
<li><a href="https://github.com/xufei/blog/issues/19" target="_blank" rel="noopener">2015前端组件化框架之路</a></li>
</ul>
<p><br></p>
<p><img src="/images/sponsor.jpg" alt></p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#分层风格"><span class="toc-number">1.</span> <span class="toc-text">分层风格</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#virtual-dom"><span class="toc-number">1.1.</span> <span class="toc-text">Virtual DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#taro"><span class="toc-number">1.2.</span> <span class="toc-text">Taro</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#管道和过滤器"><span class="toc-number">2.</span> <span class="toc-text">管道和过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#中间件-middleware"><span class="toc-number">2.1.</span> <span class="toc-text">中间件(Middleware)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件驱动"><span class="toc-number">3.</span> <span class="toc-text">事件驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mv"><span class="toc-number">4.</span> <span class="toc-text">MV*</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#家喻户晓的mvc"><span class="toc-number">4.1.</span> <span class="toc-text">家喻户晓的MVC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redux"><span class="toc-number">4.2.</span> <span class="toc-text">Redux</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复制风格"><span class="toc-number">5.</span> <span class="toc-text">复制风格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#微内核架构"><span class="toc-number">6.</span> <span class="toc-text">微内核架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#微前端"><span class="toc-number">7.</span> <span class="toc-text">微前端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组件化架构"><span class="toc-number">8.</span> <span class="toc-text">组件化架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他"><span class="toc-number">9.</span> <span class="toc-text">其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展阅读"><span class="toc-number">10.</span> <span class="toc-text">扩展阅读</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2019/09/11/arch-pattern/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2019/09/11/arch-pattern/&text=透过现象看本质: 常见的前端架构风格和案例"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2019/09/11/arch-pattern/&title=透过现象看本质: 常见的前端架构风格和案例"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2019/09/11/arch-pattern/&is_video=false&description=透过现象看本质: 常见的前端架构风格和案例"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=透过现象看本质: 常见的前端架构风格和案例&body=Check out this article: https://bobi.ink/2019/09/11/arch-pattern/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2019/09/11/arch-pattern/&title=透过现象看本质: 常见的前端架构风格和案例"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2019/09/11/arch-pattern/&title=透过现象看本质: 常见的前端架构风格和案例"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2019/09/11/arch-pattern/&title=透过现象看本质: 常见的前端架构风格和案例"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2019/09/11/arch-pattern/&title=透过现象看本质: 常见的前端架构风格和案例"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2019/09/11/arch-pattern/&name=透过现象看本质: 常见的前端架构风格和案例&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2023 Ivan
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-44571525-2', 'auto');
        ga('send', 'pageview');
    </script>


    <!-- Disqus Comments -->
    <script type="text/javascript">
        var disqus_shortname = 'bobi-ink';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


