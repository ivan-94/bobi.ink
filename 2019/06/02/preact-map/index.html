<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="React 的代码库现在已经比较庞大了，加上 v16 的 Fiber 重构，初学者很容易陷入细节的汪洋大海，搞懂了会让人觉得自己很牛逼，搞不懂很容易让人失去信心, 怀疑自己是否应该继续搞前端。那么尝试在本文这里找回一点自信吧(高手绕路). Preact 是 React 的缩略版, 体积非常小, 但五脏俱全. 如果你想了解 React 的基本原理, 可以去学习学习 Preact 的源码, 这也正是本">
<meta name="keywords" content="Blog,FrontEnd,React,Javascript,Typescript">
<meta property="og:type" content="article">
<meta property="og:title" content="从 Preact 中窥探 React 的节本原理">
<meta property="og:url" content="https://bobi.ink/2019/06/02/preact-map/index.html">
<meta property="og:site_name" content="Bobi.ink">
<meta property="og:description" content="React 的代码库现在已经比较庞大了，加上 v16 的 Fiber 重构，初学者很容易陷入细节的汪洋大海，搞懂了会让人觉得自己很牛逼，搞不懂很容易让人失去信心, 怀疑自己是否应该继续搞前端。那么尝试在本文这里找回一点自信吧(高手绕路). Preact 是 React 的缩略版, 体积非常小, 但五脏俱全. 如果你想了解 React 的基本原理, 可以去学习学习 Preact 的源码, 这也正是本">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://bobi.ink/images/07/vd.png">
<meta property="og:image" content="https://bobi.ink/images/07/setState.png">
<meta property="og:image" content="https://bobi.ink/images/07/diff.png">
<meta property="og:image" content="https://bobi.ink/images/07/diffChildren-base.png">
<meta property="og:image" content="https://bobi.ink/images/07/diffChildren.png">
<meta property="og:image" content="https://bobi.ink/images/07/diffChildren-process.png">
<meta property="og:image" content="https://bobi.ink/images/07/diff-process.png">
<meta property="og:image" content="https://bobi.ink/images/07/diffElementNodes-process.png">
<meta property="og:image" content="https://bobi.ink/images/07/useState.png">
<meta property="og:image" content="https://bobi.ink/images/07/hooks.png">
<meta property="og:updated_time" content="2023-06-01T09:55:14.329Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从 Preact 中窥探 React 的节本原理">
<meta name="twitter:description" content="React 的代码库现在已经比较庞大了，加上 v16 的 Fiber 重构，初学者很容易陷入细节的汪洋大海，搞懂了会让人觉得自己很牛逼，搞不懂很容易让人失去信心, 怀疑自己是否应该继续搞前端。那么尝试在本文这里找回一点自信吧(高手绕路). Preact 是 React 的缩略版, 体积非常小, 但五脏俱全. 如果你想了解 React 的基本原理, 可以去学习学习 Preact 的源码, 这也正是本">
<meta name="twitter:image" content="https://bobi.ink/images/07/vd.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>从 Preact 中窥探 React 的节本原理</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/06/14/react-performance/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/05/29/styled-components-map/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2019/06/02/preact-map/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2019/06/02/preact-map/&text=从 Preact 中窥探 React 的节本原理"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2019/06/02/preact-map/&title=从 Preact 中窥探 React 的节本原理"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2019/06/02/preact-map/&is_video=false&description=从 Preact 中窥探 React 的节本原理"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=从 Preact 中窥探 React 的节本原理&body=Check out this article: https://bobi.ink/2019/06/02/preact-map/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2019/06/02/preact-map/&title=从 Preact 中窥探 React 的节本原理"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2019/06/02/preact-map/&title=从 Preact 中窥探 React 的节本原理"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2019/06/02/preact-map/&title=从 Preact 中窥探 React 的节本原理"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2019/06/02/preact-map/&title=从 Preact 中窥探 React 的节本原理"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2019/06/02/preact-map/&name=从 Preact 中窥探 React 的节本原理&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#virtual-dom"><span class="toc-number">1.</span> <span class="toc-text">Virtual-DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从-createelement-开始"><span class="toc-number">2.</span> <span class="toc-text">从 createElement 开始</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#component-的实现"><span class="toc-number">3.</span> <span class="toc-text">Component 的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#diff-算法"><span class="toc-number">4.</span> <span class="toc-text">diff 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#diffchildren"><span class="toc-number">4.1.</span> <span class="toc-text">diffChildren</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#diff"><span class="toc-number">4.2.</span> <span class="toc-text">diff</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#diffelementnodes"><span class="toc-number">4.3.</span> <span class="toc-text">diffElementNodes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#diffprops"><span class="toc-number">4.4.</span> <span class="toc-text">diffProps</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hooks-的实现"><span class="toc-number">5.</span> <span class="toc-text">Hooks 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#usestate"><span class="toc-number">5.1.</span> <span class="toc-text">useState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useeffect"><span class="toc-number">5.2.</span> <span class="toc-text">useEffect</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#技术地图"><span class="toc-number">6.</span> <span class="toc-text">技术地图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展"><span class="toc-number">7.</span> <span class="toc-text">扩展</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        从 Preact 中窥探 React 的节本原理
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Bobi.ink</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-06-01T16:00:00.000Z" itemprop="datePublished">2019-06-02</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>React 的代码库现在已经比较庞大了，加上 v16 的 Fiber 重构，初学者很容易陷入细节的汪洋大海，搞懂了会让人觉得自己很牛逼，搞不懂很容易让人失去信心, 怀疑自己是否应该继续搞前端。那么尝试在本文这里找回一点自信吧(高手绕路).</p>
<p>Preact 是 React 的缩略版, 体积非常小, 但五脏俱全. 如果你想了解 React 的基本原理, 可以去学习学习 Preact 的源码, 这也正是本文的目的。</p>
<p>关于 React 原理的优秀的文章已经非常多, 本文就是老酒装新瓶, 算是自己的一点总结，也为后面的文章作一下铺垫吧.</p>
<p>文章篇幅较长，阅读时间约 20min，主要被代码占据，另外也画了流程图配合理解代码。</p>
<blockquote>
<p>注意：代码有所简化，忽略掉 svg、replaceNode、context 等特性<br>本文代码基于 Preact v10 版本</p>
</blockquote>
<p><br></p>
<!-- TOC -->
<ul>
<li><a href="#virtual-dom">Virtual-DOM</a></li>
<li><a href="#从-createelement-开始">从 createElement 开始</a></li>
<li><a href="#component-的实现">Component 的实现</a></li>
<li><a href="#diff-算法">diff 算法</a><ul>
<li><a href="#diffchildren">diffChildren</a></li>
<li><a href="#diff">diff</a></li>
<li><a href="#diffelementnodes">diffElementNodes</a></li>
<li><a href="#diffprops">diffProps</a></li>
</ul>
</li>
<li><a href="#hooks-的实现">Hooks 的实现</a><ul>
<li><a href="#usestate">useState</a></li>
<li><a href="#useeffect">useEffect</a></li>
</ul>
</li>
<li><a href="#技术地图">技术地图</a></li>
<li><a href="#扩展">扩展</a></li>
</ul>
<!-- /TOC -->
<p><br></p>
<h2 id="virtual-dom"><a href="#virtual-dom" class="headerlink" title="Virtual-DOM"></a>Virtual-DOM</h2><center><br> <img src="/images/07/vd.png" width="500"><br></center>

<p>Virtual-DOM 其实就是一颗对象树，没有什么特别的，这个对象树最终要映射到图形对象. Virtual-DOM 比较核心的是它的<code>diff算法</code>.</p>
<p>你可以想象这里有一个<code>DOM映射器</code>，见名知义，<strong>这个’DOM 映射器‘的工作就是将 Virtual-DOM 对象树映射浏览器页面的 DOM，只不过为了提高 DOM 的’操作性能’. 它不是每一次都全量渲染整个 Virtual-DOM 树，而是支持接收两颗 Virtual-DOM 对象树(一个更新前，一个更新后), 通过 diff 算法计算出两颗 Virtual-DOM 树差异的地方，然后只应用这些差异的地方到实际的 DOM 树, 从而减少 DOM 变更的成本.</strong></p>
<p>Virtual-DOM 是比较有争议性，推荐阅读<a href="https://www.zhihu.com/question/31809713/answer/53544875" target="_blank" rel="noopener">《网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？》</a> 。切记永远都不要离开场景去评判一个技术的好坏。当初网上把 React 吹得多么牛逼, 一些小白就会觉得 Virtual-DOM 很吊，JQuery 弱爆了。</p>
<p>我觉得两个可比性不大，从性能上看, <strong>框架再怎么牛逼它也是需要操作原生 DOM 的，而且它未必有你使用 JQuery 手动操作 DOM 来得’精细’</strong>. 框架不合理使用也可能出现修改一个小状态，导致渲染雪崩(大范围重新渲染)的情况; 同理 JQuery 虽然可以精细化操作 DOM, 但是不合理的 DOM 更新策略可能也会成为应用的性能瓶颈. 所以关键还得看你怎么用.</p>
<p>那为什么需要 Virtual-DOM？</p>
<p><strong>我个人的理解就是为了解放生产力。现如今硬件的性能越来越好，web 应用也越来越复杂，生产力也是要跟上的</strong>. 尽管手动操作 DOM 可能可以达到更高的性能和灵活性，但是这样对大部分开发者来说太低效了，我们是可以接受牺牲一点性能换取更高的开发效率的.</p>
<p>所以说 Virtual-DOM 更大的意义在于开发方式的改变: 声明式、 数据驱动, 让开发者不需要关心 DOM 的操作细节(属性操作、事件绑定、DOM 节点变更)，也就是说应用的开发方式变成了<code>view=f(state)</code>, 这对生产力的解放是有很大推动作用的.</p>
<p>当然 Virtual-DOM 不是唯一，也不是第一个的这样解决方案. 比如 AngularJS, Vue1.x 这些基于模板的实现方式, 也可以说实现这种开发方式转变的. 那相对于他们 Virtual-DOM 的买点可能就是更高的性能了, 另外 Virtual-DOM 在渲染层上面的抽象更加彻底, 不再耦合于 DOM 本身，比如可以渲染为 ReactNative，PDF，终端 UI 等等。</p>
<p><br></p>
<hr>
<p><br></p>
<h2 id="从-createelement-开始"><a href="#从-createelement-开始" class="headerlink" title="从 createElement 开始"></a>从 createElement 开始</h2><p>很多小白将 <code>JSX</code> 等价为 Virtual-DOM，其实这两者并没有直接的关系, 我们知道 <strong>JSX 不过是一个语法糖</strong>.</p>
<p>例如<code>&lt;a href=&quot;/&quot;&gt;&lt;span&gt;Home&lt;/span&gt;&lt;/a&gt;</code>最终会转换为<code>h(&#39;a&#39;, { href:&#39;/&#39; }, h(&#39;span&#39;, null, &#39;Home&#39;))</code>这种形式, <code>h</code>是 JSX Element 工厂方法.</p>
<p><code>h</code> 在 React 下约定是<code>React.createElement</code>, 而大部分 Virtual-DOM 框架则使用<code>h</code>. <code>h</code> 是 <code>createElement</code> 的别名, Vue 生态系统也是使用这个惯例, 具体为什么没作考究(比较简短？)。</p>
<p>可以使用<code>@jsx</code>注解或 babel 配置项来配置 JSX 工厂：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @jsx h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello jsx<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>, el);</span><br></pre></td></tr></table></figure>
<p>本文不是 React 或 Preact 的入门文章，所以点到为止，更多内容可以查看<a href="https://preactjs.com/guide/getting-started" target="_blank" rel="noopener">官方教程</a>.</p>
<p>现在来看看<code>createElement</code>, <strong>createElement 不过就是构造一个对象(VNode)</strong>:</p>
<!-- prettier-ignore-start -->
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⚛️type 节点的类型，有DOM元素(string)和自定义组件，以及Fragment, 为null时表示文本节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, children</span>) </span>&#123;</span><br><span class="line">  props.children = children;</span><br><span class="line">  <span class="comment">// ⚛️应用defaultProps</span></span><br><span class="line">  <span class="keyword">if</span> (type != <span class="literal">null</span> &amp;&amp; type.defaultProps != <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> type.defaultProps)</span><br><span class="line">      <span class="keyword">if</span> (props[i] === <span class="literal">undefined</span>) props[i] = type.defaultProps[i];</span><br><span class="line">  <span class="keyword">let</span> ref = props.ref;</span><br><span class="line">  <span class="keyword">let</span> key = props.key;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ⚛️构建VNode对象</span></span><br><span class="line">  <span class="keyword">return</span> createVNode(type, props, key, ref);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createVNode</span>(<span class="params">type, props, key, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; type, props, key, ref, <span class="comment">/* ... 忽略部分内置字段 */</span> <span class="keyword">constructor</span>: undefined &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->
<p>通过 JSX 和组件, 可以构造复杂的对象树:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">render(</span><br><span class="line">  &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">    &lt;SideBar /&gt;</span><br><span class="line">    &lt;Body /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">  root,</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h2 id="component-的实现"><a href="#component-的实现" class="headerlink" title="Component 的实现"></a>Component 的实现</h2><p>对于一个视图框架来说，组件就是它的灵魂, 就像函数之于函数式语言，类之于面向对象语言, 没有组件则无法组成复杂的应用.</p>
<p>组件化的思维推荐将一个应用分而治之, 拆分和组合不同级别的组件，这样可以简化应用的开发和维护，让程序更好理解. 从技术上看<strong>组件是一个自定义的元素类型，可以声明组件的输入(props)、有自己的生命周期和状态以及方法、最终输出 Virtual-DOM 对象树, 作为应用 Virtual-DOM 树的一个分支存在</strong>.</p>
<p>Preact 的自定义组件是基于 Component 类实现的. 对组件来说最基本的就是状态的维护, 这个通过 setState 来实现:</p>
<!-- prettier-ignore-start -->
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">props, context</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚛️setState实现</span></span><br><span class="line">Component.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">update, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 克隆下一次渲染的State, _nextState会在一些生命周期方式中用到(例如shouldComponentUpdate)</span></span><br><span class="line">  <span class="keyword">let</span> s = (<span class="keyword">this</span>._nextState !== <span class="keyword">this</span>.state &amp;&amp; <span class="keyword">this</span>._nextState) ||</span><br><span class="line">    (<span class="keyword">this</span>._nextState = assign(&#123;&#125;, <span class="keyword">this</span>.state));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// state更新</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> update !== <span class="string">'function'</span> || (update = update(s, <span class="keyword">this</span>.props)))</span><br><span class="line">    assign(s, update);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._vnode) &#123; <span class="comment">// 已挂载</span></span><br><span class="line">    <span class="comment">// 推入渲染回调队列, 在渲染完成后批量调用</span></span><br><span class="line">    <span class="keyword">if</span> (callback) <span class="keyword">this</span>._renderCallbacks.push(callback);</span><br><span class="line">    <span class="comment">// 放入异步调度队列</span></span><br><span class="line">    enqueueRender(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->
<p><br></p>
<p><code>enqueueRender</code> 将组件放进一个异步的批执行队列中，这样可以归并频繁的 setState 调用，实现也非常简单:</p>
<!-- prettier-ignore-start -->
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> q = [];</span><br><span class="line"><span class="comment">// 异步调度器，用于异步执行一个回调</span></span><br><span class="line"><span class="keyword">const</span> defer = <span class="keyword">typeof</span> <span class="built_in">Promise</span> == <span class="string">'function'</span></span><br><span class="line">    ? <span class="built_in">Promise</span>.prototype.then.bind(<span class="built_in">Promise</span>.resolve()) <span class="comment">// micro task</span></span><br><span class="line">    : setTimeout; <span class="comment">// 回调到setTimeout</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueRender</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不需要重复推入已经在队列的Component</span></span><br><span class="line">  <span class="keyword">if</span> (!c._dirty &amp;&amp; (c._dirty = <span class="literal">true</span>) &amp;&amp; q.push(c) === <span class="number">1</span>)</span><br><span class="line">    defer(process); <span class="comment">// 当队列从空变为非空时，开始调度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量清空队列, 调用Component的forceUpdate</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> p;</span><br><span class="line">  <span class="comment">// 排序队列，从低层的组件优先更新?</span></span><br><span class="line">  q.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b._depth - a._depth);</span><br><span class="line">  <span class="keyword">while</span> ((p = q.pop()))</span><br><span class="line">    <span class="keyword">if</span> (p._dirty) p.forceUpdate(<span class="literal">false</span>); <span class="comment">// false表示不要强制更新，即不要忽略shouldComponentUpdate</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->
<p><br></p>
<p>Ok, 上面的代码可以看出 <code>setState</code> 本质上是调用 <code>forceUpdate</code> 进行组件重新渲染的，来往下挖一挖 forceUpdate 的实现.</p>
<blockquote>
<p>这里暂且忽略 diff, <strong>将 diff 视作一个黑盒，他就是一个 DOM 映射器, 像上面说的 diff 接收两棵 VNode 树, 以及一个 DOM 挂载点, 在比对的过程中它可以会创建、移除或更新组件和 DOM 元素，触发对应的生命周期方法</strong>.</p>
</blockquote>
<!-- prettier-ignore-start -->
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Component.prototype.forceUpdate = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123; <span class="comment">// callback放置渲染完成后的回调</span></span><br><span class="line">  <span class="keyword">let</span> vnode = <span class="keyword">this</span>._vnode, dom = <span class="keyword">this</span>._vnode._dom, parentDom = <span class="keyword">this</span>._parentDom;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parentDom) &#123; <span class="comment">// 已挂载过</span></span><br><span class="line">    <span class="keyword">const</span> force = callback !== <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> mounts = [];</span><br><span class="line">    <span class="comment">// 调用diff对当前组件进行重新渲染和Virtual-DOM比对</span></span><br><span class="line">    <span class="comment">// ⚛️暂且忽略这些参数, 将diff视作一个黑盒，他就是一个DOM映射器，</span></span><br><span class="line">    dom = diff(parentDom, vnode, vnode, mounts, <span class="keyword">this</span>._ancestorComponent, force, dom);</span><br><span class="line">    <span class="keyword">if</span> (dom != <span class="literal">null</span> &amp;&amp; dom.parentNode !== parentDom)</span><br><span class="line">      parentDom.appendChild(dom);</span><br><span class="line">    commitRoot(mounts, vnode);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (callback) callback();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->
<p><br></p>
<p>在看看 <code>render</code> 方法, 实现跟 forceUpdate 差不多, 都是调用 diff 算法来执行 DOM 更新，只不过由外部指定一个 DOM 容器:</p>
<!-- prettier-ignore-start -->
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简化版</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, parentDom</span>) </span>&#123;</span><br><span class="line">  vnode = createElement(Fragment, <span class="literal">null</span>, [vnode]);</span><br><span class="line">  parentDom.childNodes.forEach(<span class="function"><span class="params">i</span> =&gt;</span> i.remove())</span><br><span class="line">  <span class="keyword">let</span> mounts = [];</span><br><span class="line">  diffChildren(parentDom, <span class="literal">null</span> oldVNode, mounts, vnode, EMPTY_OBJ);</span><br><span class="line">  commitRoot(mounts, vnode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->
<p><br></p>
<p>梳理一下上面的流程:</p>
<center><br>  <img src="/images/07/setState.png" width="800"><br></center>

<p>到目前为止没有看到组件的其他功能，如初始化、生命周期函数。这些特性在 diff 函数中定义，也就是说在组件挂载或更新的过程中被调用。下一节就会介绍 diff</p>
<p><br></p>
<hr>
<p><br></p>
<h2 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h2><p>千呼万唤始出来，通过上文可以看出，<code>createElement</code> 和 <code>Component</code> 逻辑都很薄， 主要的逻辑还是集中在 diff 函数中. React 将这个过程称为 <code>Reconciliation</code>, 在 Preact 中称为 <code>Differantiate</code>.</p>
<p>为了简化程序 Preact 的实现将 diff 和 DOM 杂糅在一起, 但逻辑还是很清晰，看下目录结构就知道了:</p>
<p><br></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/diff</span><br><span class="line">├── children.js # 比对children数组</span><br><span class="line">├── index.js    # 比对两个节点</span><br><span class="line">└── props.js    # 比对两个DOM节点的props</span><br></pre></td></tr></table></figure>
<center><br>  <img src="/images/07/diff.png" width="600"><br></center>

<p><br></p>
<p>在深入 diff 程序之前，先看一下基本的对象结构, 方便后面理解程序流程. 先来看下 VNode 的外形:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type ComponentFactory&lt;P&gt; = preact.ComponentClass&lt;P&gt; | FunctionalComponent&lt;P&gt;;</span><br><span class="line"></span><br><span class="line">interface VNode&lt;P = &#123;&#125;&gt; &#123;</span><br><span class="line">  <span class="comment">// 节点类型, 内置DOM元素为string类型，而自定义组件则是Component类型，Preact中函数组件只是特殊的Component类型</span></span><br><span class="line">  type: string | ComponentFactory&lt;P&gt; | <span class="literal">null</span>;</span><br><span class="line">  props: P &amp; &#123; <span class="attr">children</span>: ComponentChildren &#125; | string | number | <span class="literal">null</span>;</span><br><span class="line">  key: Key</span><br><span class="line">  ref: Ref&lt;any&gt; | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 内部缓存信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// VNode子节点</span></span><br><span class="line">  _children: <span class="built_in">Array</span>&lt;VNode&gt; | <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 关联的DOM节点, 对于Fragment来说第一个子节点</span></span><br><span class="line">  _dom: PreactElement | Text | <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// Fragment, 或者组件返回Fragment的最后一个DOM子节点，</span></span><br><span class="line">  _lastDomChild: PreactElement | Text | <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// Component实例</span></span><br><span class="line">  _component: Component | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h3 id="diffchildren"><a href="#diffchildren" class="headerlink" title="diffChildren"></a>diffChildren</h3><p>先从最简单的开始, 上面已经猜出 diffChildren 用于比对两个 VNode 列表.</p>
<center><br>  <img src="/images/07/diffChildren-base.png" width="600"><br></center>

<p>如上图, 首先这里需要维护一个表示当前插入位置的变量 oldDOM, 它一开始指向 DOM childrenNode 的第一个元素, 后面每次插入更新或插入 newDOM，都会指向 newDOM 的下一个兄弟元素.</p>
<p>在遍历 newChildren 列表过程中, 会尝试找出相同 key 的旧 VNode，和它进行 diff. 如果新 VNode 和旧 VNode 位置不一样，这就需要移动它们;对于新增的 DOM，如果插入位置(oldDOM)已经到了结尾，则直接追加到父节点, 否则插入到 oldDOM 之前。</p>
<p>最后卸载旧 VNode 列表中未使用的 VNode.</p>
<p>来详细看看源码:</p>
<!-- prettier-ignore-start -->
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentDom,         <span class="regexp">//</span> children的父DOM元素</span></span></span><br><span class="line"><span class="function"><span class="params">  newParentVNode,    <span class="regexp">//</span> children的新父VNode</span></span></span><br><span class="line"><span class="function"><span class="params">  oldParentVNode,    <span class="regexp">//</span> children的旧父VNode，diffChildren主要比对这两个Vnode的children</span></span></span><br><span class="line"><span class="function"><span class="params">  mounts,            <span class="regexp">//</span> 保存在这次比对过程中被挂载的组件实例，在比对后，会触发这些组件的componentDidMount生命周期函数</span></span></span><br><span class="line"><span class="function"><span class="params">  ancestorComponent, <span class="regexp">//</span> children的直接父<span class="string">'组件'</span>, 即渲染(render</span>)<span class="title">VNode</span>的组件实例</span></span><br><span class="line"><span class="function">  <span class="title">oldDom</span>,            // 当前挂载的<span class="title">DOM</span>，对于<span class="title">diffChildren</span>来说，<span class="title">oldDom</span>一开始指向第一个子节点</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newChildren = newParentVNode._children || toChildArray(newParentVNode.props.children, (newParentVNode._children = []), coerceToVNode, <span class="literal">true</span>,);</span><br><span class="line">  <span class="keyword">let</span> oldChildren = (oldParentVNode &amp;&amp; oldParentVNode._children) || EMPTY_ARR;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️遍历新children</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; newChildren.length; i++) &#123;</span><br><span class="line">    childVNode = newChildren[i] = coerceToVNode(newChildren[i]); <span class="comment">// 规范化VNode</span></span><br><span class="line">    <span class="keyword">if</span> (childVNode == <span class="literal">null</span>) <span class="keyword">continue</span></span><br><span class="line">    <span class="comment">// ⚛️查找oldChildren中是否有对应的元素，如果找到则通过设置为undefined，从oldChildren中移除</span></span><br><span class="line">    <span class="comment">// 如果没有找到则保持为null</span></span><br><span class="line">    oldVNode = oldChildren[i];</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; oldChildrenLength; j++) &#123;</span><br><span class="line">      oldVNode = oldChildren[j];</span><br><span class="line">      <span class="keyword">if</span> (oldVNode &amp;&amp; childVNode.key == oldVNode.key &amp;&amp; childVNode.type === oldVNode.type) &#123;</span><br><span class="line">        oldChildren[j] = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      oldVNode = <span class="literal">null</span>; <span class="comment">// 没有找到任何旧node，表示是一个新的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ⚛️ 递归比对VNode</span></span><br><span class="line">    newDom = diff(parentDom, childVNode, oldVNode, mounts, ancestorComponent, <span class="literal">null</span>, oldDom);</span><br><span class="line">    <span class="comment">// vnode没有被diff卸载掉</span></span><br><span class="line">    <span class="keyword">if</span> (newDom != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (childVNode._lastDomChild != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ⚛️当前VNode是Fragment类型</span></span><br><span class="line">        <span class="comment">// 只有Fragment或组件返回Fragment的Vnode会有非null的_lastDomChild, 从Fragment的结尾的DOM树开始比对:</span></span><br><span class="line">        <span class="comment">// &lt;A&gt;                               &lt;A&gt;</span></span><br><span class="line">        <span class="comment">//  &lt;&gt;                                 &lt;&gt;   👈 Fragment类型，diff会递归比对它的children，所以最后我们只需要将newDom指向比对后的最后一个子节点即可</span></span><br><span class="line">        <span class="comment">//    &lt;a&gt;a&lt;/a&gt;           &lt;- diff -&gt;      &lt;b&gt;b&lt;/b&gt;</span></span><br><span class="line">        <span class="comment">//    &lt;b&gt;b&lt;/b&gt;                           &lt;a&gt;a&lt;/a&gt; ----+</span></span><br><span class="line">        <span class="comment">//  &lt;/&gt;                                &lt;/&gt;             \</span></span><br><span class="line">        <span class="comment">//                                     &lt;div&gt;x&lt;/div&gt;     👈oldDom会指向这里</span></span><br><span class="line">        <span class="comment">// &lt;/A&gt;                              &lt;/A&gt;</span></span><br><span class="line">        newDom = childVNode._lastDomChild;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVNode == <span class="literal">null</span> || newDom != oldDom || newDom.parentNode == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ⚛️ newDom和当前oldDom不匹配，尝试新增或修改位置</span></span><br><span class="line">        outer: <span class="keyword">if</span> (oldDom == <span class="literal">null</span> || oldDom.parentNode !== parentDom) &#123;</span><br><span class="line">          <span class="comment">// ⚛️oldDom指向了结尾, 即后面没有更多元素了，直接插入即可; 首次渲染一般会调用到这里</span></span><br><span class="line">          parentDom.appendChild(newDom);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 这里是一个优化措施，去掉也不会影响正常程序. 为了便于理解可以忽略这段代码</span></span><br><span class="line">          <span class="comment">// 尝试向后查找oldChildLength/2个元素，如果找到则不需要调用insertBefore. 这段代码可以减少insertBefore的调用频率</span></span><br><span class="line">          <span class="keyword">for</span> (sibDom = oldDom, j = <span class="number">0</span>; (sibDom = sibDom.nextSibling) &amp;&amp; j &lt; oldChildrenLength; j += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sibDom == newDom)</span><br><span class="line">              <span class="keyword">break</span> outer;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// ⚛️insertBefore() 将newDom移动到oldDom之前 </span></span><br><span class="line">          parentDom.insertBefore(newDom, oldDom);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ⚛️其他情况，newDom === oldDOM不需要处理</span></span><br><span class="line">      <span class="comment">// ⚛️ oldDom指向下一个DOM节点</span></span><br><span class="line">      oldDom = newDom.nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 卸载掉没有被置为undefined的元素</span></span><br><span class="line">  <span class="keyword">for</span> (i = oldChildrenLength; i--; )</span><br><span class="line">    <span class="keyword">if</span> (oldChildren[i] != <span class="literal">null</span>) unmount(oldChildren[i], ancestorComponent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->
<p><br></p>
<p>配图理解一下 diffChilrend 的调用过程:</p>
<center><br>  <img src="/images/07/diffChildren.png" width="600"><br></center>

<p><br></p>
<p>总结一下流程图</p>
<center><br>  <img src="/images/07/diffChildren-process.png" width="800"><br></center>

<p><br></p>
<hr>
<p><br></p>
<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>diff 用于比对两个 VNode 节点. diff 函数比较冗长, 但是这里面并没有特别复杂逻辑，主要是一些自定义组件生命周期的处理。所以先上流程图，代码不感兴趣可以跳过.</p>
<center><br>  <img src="/images/07/diff-process.png" width="800"><br></center>

<p><br></p>
<p>源代码解析：</p>
<!-- prettier-ignore-start -->
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentDom,         <span class="regexp">//</span> 父DOM节点</span></span></span><br><span class="line"><span class="function"><span class="params">  newVNode,          <span class="regexp">//</span> 新VNode</span></span></span><br><span class="line"><span class="function"><span class="params">  oldVNode,          <span class="regexp">//</span> 旧VNode</span></span></span><br><span class="line"><span class="function"><span class="params">  mounts,            <span class="regexp">//</span> 存放已挂载的组件, 将在diff结束后批量处理</span></span></span><br><span class="line"><span class="function"><span class="params">  ancestorComponent, <span class="regexp">//</span> 直接父组件</span></span></span><br><span class="line"><span class="function"><span class="params">  force,             <span class="regexp">//</span> 是否强制更新, 为true将忽略掉shouldComponentUpdate</span></span></span><br><span class="line"><span class="function"><span class="params">  oldDom,            <span class="regexp">//</span> 当前挂载的DOM节点</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    outer: <span class="keyword">if</span> (oldVNode.type === Fragment || newType === Fragment) &#123;</span><br><span class="line">      <span class="comment">// ⚛️ Fragment类型，使用diffChildren进行比对</span></span><br><span class="line">      diffChildren(parentDom, newVNode, oldVNode, mounts, ancestorComponent, oldDom);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️记录Fragment的起始DOM和结束DOM</span></span><br><span class="line">      <span class="keyword">let</span> i = newVNode._children.length;</span><br><span class="line">      <span class="keyword">if</span> (i &amp;&amp; (tmp = newVNode._children[<span class="number">0</span>]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        newVNode._dom = tmp._dom;</span><br><span class="line">        <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">          tmp = newVNode._children[i];</span><br><span class="line">          <span class="keyword">if</span> (newVNode._lastDomChild = tmp &amp;&amp; (tmp._lastDomChild || tmp._dom))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> newType === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// ⚛️自定义组件类型</span></span><br><span class="line">      <span class="keyword">if</span> (oldVNode._component) &#123;</span><br><span class="line">        <span class="comment">// ⚛️ ️已经存在组件实例</span></span><br><span class="line">        c = newVNode._component = oldVNode._component;</span><br><span class="line">        newVNode._dom = oldVNode._dom;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ⚛️初始化组件实例</span></span><br><span class="line">        <span class="keyword">if</span> (newType.prototype &amp;&amp; newType.prototype.render) &#123;</span><br><span class="line">          <span class="comment">// ⚛️类组件</span></span><br><span class="line">          newVNode._component = c = <span class="keyword">new</span> newType(newVNode.props, cctx); <span class="comment">// eslint-disable-line new-cap</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// ⚛️函数组件</span></span><br><span class="line">          newVNode._component = c = <span class="keyword">new</span> Component(newVNode.props, cctx);</span><br><span class="line">          c.constructor = newType;</span><br><span class="line">          c.render = doRender;</span><br><span class="line">        &#125;</span><br><span class="line">        c._ancestorComponent = ancestorComponent;</span><br><span class="line">        c.props = newVNode.props;</span><br><span class="line">        <span class="keyword">if</span> (!c.state) c.state = &#123;&#125;;</span><br><span class="line">        isNew = c._dirty = <span class="literal">true</span>;</span><br><span class="line">        c._renderCallbacks = [];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      c._vnode = newVNode;</span><br><span class="line">      <span class="keyword">if</span> (c._nextState == <span class="literal">null</span>) c._nextState = c.state;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️getDerivedStateFromProps 生命周期方法</span></span><br><span class="line">      <span class="keyword">if</span> (newType.getDerivedStateFromProps != <span class="literal">null</span>)</span><br><span class="line">        assign(c._nextState == c.state</span><br><span class="line">            ? (c._nextState = assign(&#123;&#125;, c._nextState)) <span class="comment">// 惰性拷贝</span></span><br><span class="line">            : c._nextState,</span><br><span class="line">          newType.getDerivedStateFromProps(newVNode.props, c._nextState),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isNew) &#123;</span><br><span class="line">        <span class="comment">// ⚛️ 调用挂载前的一些生命周期方法</span></span><br><span class="line">        <span class="comment">// ⚛️ componentWillMount</span></span><br><span class="line">        <span class="keyword">if</span> (newType.getDerivedStateFromProps == <span class="literal">null</span> &amp;&amp; c.componentWillMount != <span class="literal">null</span>) c.componentWillMount();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⚛️ componentDidMount</span></span><br><span class="line">        <span class="comment">// 将组件推入mounts数组，在整个组件树diff完成后批量调用, 他们在commitRoot方法中被调用</span></span><br><span class="line">        <span class="comment">// 按照先进后出(栈)的顺序调用, 即子组件的componentDidMount会先调用</span></span><br><span class="line">        <span class="keyword">if</span> (c.componentDidMount != <span class="literal">null</span>) mounts.push(c);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ⚛️ 调用重新渲染相关的一些生命周期方法</span></span><br><span class="line">        <span class="comment">// ⚛️ componentWillReceiveProps</span></span><br><span class="line">        <span class="keyword">if</span> (newType.getDerivedStateFromProps == <span class="literal">null</span> &amp;&amp; force == <span class="literal">null</span> &amp;&amp; c.componentWillReceiveProps != <span class="literal">null</span>)</span><br><span class="line">          c.componentWillReceiveProps(newVNode.props, cctx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⚛️ shouldComponentUpdate</span></span><br><span class="line">        <span class="keyword">if</span> (!force &amp;&amp; c.shouldComponentUpdate != <span class="literal">null</span> &amp;&amp; c.shouldComponentUpdate(newVNode.props, c._nextState, cctx) === <span class="literal">false</span>) &#123;</span><br><span class="line">          <span class="comment">// shouldComponentUpdate返回false，取消渲染更新</span></span><br><span class="line">          c.props = newVNode.props;</span><br><span class="line">          c.state = c._nextState;</span><br><span class="line">          c._dirty = <span class="literal">false</span>;</span><br><span class="line">          newVNode._lastDomChild = oldVNode._lastDomChild;</span><br><span class="line">          <span class="keyword">break</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⚛️ componentWillUpdate</span></span><br><span class="line">        <span class="keyword">if</span> (c.componentWillUpdate != <span class="literal">null</span>) c.componentWillUpdate(newVNode.props, c._nextState, cctx);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️至此props和state已经确定下来，缓存和更新props和state准备渲染</span></span><br><span class="line">      oldProps = c.props;</span><br><span class="line">      oldState = c.state;</span><br><span class="line">      c.props = newVNode.props;</span><br><span class="line">      c.state = c._nextState;</span><br><span class="line">      <span class="keyword">let</span> prev = c._prevVNode || <span class="literal">null</span>;</span><br><span class="line">      c._dirty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️渲染</span></span><br><span class="line">      <span class="keyword">let</span> vnode = (c._prevVNode = coerceToVNode(c.render(c.props, c.state)));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️getSnapshotBeforeUpdate</span></span><br><span class="line">      <span class="keyword">if</span> (!isNew &amp;&amp; c.getSnapshotBeforeUpdate != <span class="literal">null</span>) snapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️组件层级，会影响更新的优先级</span></span><br><span class="line">      c._depth = ancestorComponent ? (ancestorComponent._depth || <span class="number">0</span>) + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// ⚛️递归diff渲染结果</span></span><br><span class="line">      c.base = newVNode._dom = diff(parentDom, vnode, prev, mounts, c, <span class="literal">null</span>, oldDom);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (vnode != <span class="literal">null</span>) &#123;</span><br><span class="line">        newVNode._lastDomChild = vnode._lastDomChild;</span><br><span class="line">      &#125;</span><br><span class="line">      c._parentDom = parentDom;</span><br><span class="line">      <span class="comment">// ⚛️应用ref</span></span><br><span class="line">      <span class="keyword">if</span> ((tmp = newVNode.ref)) applyRef(tmp, c, ancestorComponent);</span><br><span class="line">      <span class="comment">// ⚛️调用renderCallbacks，即setState的回调</span></span><br><span class="line">      <span class="keyword">while</span> ((tmp = c._renderCallbacks.pop())) tmp.call(c);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️componentDidUpdate</span></span><br><span class="line">      <span class="keyword">if</span> (!isNew &amp;&amp; oldProps != <span class="literal">null</span> &amp;&amp; c.componentDidUpdate != <span class="literal">null</span>) c.componentDidUpdate(oldProps, oldState, snapshot);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ⚛️比对两个DOM元素</span></span><br><span class="line">      newVNode._dom = diffElementNodes(oldVNode._dom, newVNode, oldVNode, mounts, ancestorComponent);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((tmp = newVNode.ref) &amp;&amp; oldVNode.ref !== tmp) applyRef(tmp, newVNode._dom, ancestorComponent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// ⚛️捕获渲染错误，传递给上级组件的didCatch生命周期方法</span></span><br><span class="line">    catchErrorInComponent(e, ancestorComponent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newVNode._dom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->
<p><br></p>
<hr>
<p><br></p>
<h3 id="diffelementnodes"><a href="#diffelementnodes" class="headerlink" title="diffElementNodes"></a>diffElementNodes</h3><p>比对两个 DOM 元素, 流程非常简单:</p>
<center><br>  <img src="/images/07/diffElementNodes-process.png" width="600"><br></center>

<!-- prettier-ignore-start -->
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffElementNodes</span>(<span class="params">dom, newVNode, oldVNode, mounts, ancestorComponent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ⚛️创建DOM节点</span></span><br><span class="line">  <span class="keyword">if</span> (dom == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newVNode.type === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ⚛️文本节点, 没有属性和子级，直接返回</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">document</span>.createTextNode(newProps);</span><br><span class="line">    &#125;</span><br><span class="line">    dom = <span class="built_in">document</span>.createElement(newVNode.type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (newVNode.type === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ⚛️文本节点更新</span></span><br><span class="line">    <span class="keyword">if</span> (oldProps !== newProps) dom.data = newProps;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (newVNode !== oldVNode) &#123;</span><br><span class="line">      <span class="comment">// newVNode !== oldVNode 这说明是一个静态节点</span></span><br><span class="line">      <span class="keyword">let</span> oldProps = oldVNode.props || EMPTY_OBJ;</span><br><span class="line">      <span class="keyword">let</span> newProps = newVNode.props;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ dangerouslySetInnerHTML处理</span></span><br><span class="line">      <span class="keyword">let</span> oldHtml = oldProps.dangerouslySetInnerHTML;</span><br><span class="line">      <span class="keyword">let</span> newHtml = newProps.dangerouslySetInnerHTML;</span><br><span class="line">      <span class="keyword">if</span> (newHtml || oldHtml)</span><br><span class="line">        <span class="keyword">if</span> (!newHtml || !oldHtml || newHtml.__html != oldHtml.__html)</span><br><span class="line">          dom.innerHTML = (newHtml &amp;&amp; newHtml.__html) || <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️递归比对子元素</span></span><br><span class="line">      diffChildren(dom, newVNode, oldVNode, context, mounts, ancestorComponent, EMPTY_OBJ);</span><br><span class="line">      <span class="comment">// ⚛️递归比对DOM属性</span></span><br><span class="line">      diffProps(dom, newProps, oldProps, isSvg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->
<p><br></p>
<hr>
<p><br></p>
<h3 id="diffprops"><a href="#diffprops" class="headerlink" title="diffProps"></a>diffProps</h3><p>diffProps 用于更新 DOM 元素的属性</p>
<!-- prettier-ignore-start -->
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diffProps</span>(<span class="params">dom, newProps, oldProps, isSvg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(newProps).sort();</span><br><span class="line">  <span class="comment">// ⚛️比较并设置属性</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> k = keys[i];</span><br><span class="line">    <span class="keyword">if</span> (k !== <span class="string">'children'</span> &amp;&amp; k !== <span class="string">'key'</span> &amp;&amp;</span><br><span class="line">      (!oldProps || (k === <span class="string">'value'</span> || k === <span class="string">'checked'</span> ? dom : oldProps)[k] !== newProps[k])) </span><br><span class="line">      setProperty(dom, k, newProps[k], oldProps[k], isSvg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️清空属性</span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> oldProps)</span><br><span class="line">    <span class="keyword">if</span> (i !== <span class="string">'children'</span> &amp;&amp; i !== <span class="string">'key'</span> &amp;&amp; !(i <span class="keyword">in</span> newProps))</span><br><span class="line">      setProperty(dom, i, <span class="literal">null</span>, oldProps[i], isSvg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->
<p><br></p>
<p>diffProps 实现比较简单，就是遍历一下属性有没有变动，有变动则通过 setProperty 设置属性。对于失效的 props 也会通过 setProperty 置空。这里面稍微有点复杂的是 setProperty. 这里涉及到事件的处理, 命名的转换等等:</p>
<!-- prettier-ignore-start -->
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setProperty</span>(<span class="params">dom, name, value, oldValue, isSvg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">'style'</span>) &#123;</span><br><span class="line">    <span class="comment">// ⚛️样式设置</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">set</span> = assign(assign(&#123;&#125;, oldValue), value);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">set</span>) &#123;</span><br><span class="line">      <span class="comment">// 样式属性没有变动</span></span><br><span class="line">      <span class="keyword">if</span> ((value || EMPTY_OBJ)[i] === (oldValue || EMPTY_OBJ)[i]) <span class="keyword">continue</span>;</span><br><span class="line">      dom.style.setProperty(</span><br><span class="line">        i[<span class="number">0</span>] === <span class="string">'-'</span> &amp;&amp; i[<span class="number">1</span>] === <span class="string">'-'</span> ? i : i.replace(CAMEL_REG, <span class="string">'-$&amp;'</span>),</span><br><span class="line">        value &amp;&amp; i <span class="keyword">in</span> value</span><br><span class="line">          ? <span class="keyword">typeof</span> <span class="keyword">set</span>[i] === 'number' &amp;&amp; IS_NON_DIMENSIONAL.test(i) === false</span><br><span class="line">            ? <span class="keyword">set</span>[i] + 'px'</span><br><span class="line">            : <span class="keyword">set</span>[i]</span><br><span class="line">          : '', // 清空</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (name[0] === 'o' &amp;&amp; name[1] === 'n') &#123;</span><br><span class="line">    <span class="comment">// ⚛️事件绑定</span></span><br><span class="line">    <span class="keyword">let</span> useCapture = name !== (name = name.replace(<span class="regexp">/Capture$/</span>, <span class="string">''</span>));</span><br><span class="line">    <span class="keyword">let</span> nameLower = name.toLowerCase();</span><br><span class="line">    name = (nameLower <span class="keyword">in</span> dom ? nameLower : name).slice(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">      <span class="comment">// ⚛️首次添加事件, 注意这里是eventProxy为事件处理器</span></span><br><span class="line">      <span class="comment">// preact统一将所有事件处理器收集在dom._listeners对象中，统一进行分发</span></span><br><span class="line">      <span class="comment">// function eventProxy(e) &#123;</span></span><br><span class="line">      <span class="comment">//   return this._listeners[e.type](options.event ? options.event(e) : e);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="keyword">if</span> (!oldValue) dom.addEventListener(name, eventProxy, useCapture);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 移除事件</span></span><br><span class="line">      dom.removeEventListener(name, eventProxy, useCapture);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存事件队列</span></span><br><span class="line">    (dom._listeners || (dom._listeners = &#123;&#125;))[name] = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name !== <span class="string">'list'</span> &amp;&amp; name !== <span class="string">'tagName'</span> &amp;&amp; name <span class="keyword">in</span> dom) &#123;</span><br><span class="line">    <span class="comment">// ⚛️DOM对象属性</span></span><br><span class="line">    dom[name] = value == <span class="literal">null</span> ? <span class="string">''</span> : value;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> value !== <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">    name !== <span class="string">'dangerouslySetInnerHTML'</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// ⚛️DOM元素属性</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span> || value === <span class="literal">false</span>) &#123;</span><br><span class="line">      dom.removeAttribute(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dom.setAttribute(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->
<p>OK 至此 Diff 算法介绍完毕，其实这里面的逻辑并不是特别复杂, 当然 Preact 只是一个极度精简的框架，React 复杂度要高得多，尤其 React Fiber 重构之后。你也可以把 Preact 当做 React 的历史回顾，有兴趣再深入了解 React 的最新架构。</p>
<p><br></p>
<hr>
<p><br></p>
<h2 id="hooks-的实现"><a href="#hooks-的实现" class="headerlink" title="Hooks 的实现"></a>Hooks 的实现</h2><p>React16.8 正式引入的 hooks，这玩意带来了全新的 React 组件开发方式，让代码变得更加简洁。 <a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="noopener">React hooks: not magic, just arrays</a>这篇文章已经揭示了 hooks 的基本实现原理, 它不过是基于数组实现的。preact 也实现了 hooks 机制，实现代码也就百来行，让我们来体会体会.</p>
<p>hooks 功能本身是没有集成在 Preact 代码库内部的，而是通过<code>preact/hooks</code>导入</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">'preact'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">'preact/hooks'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'mounted'</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello hooks<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>那 Preact 是如何扩展 diff 算法来实现 hooks 的呢？ 实际上 Preact 提供了<code>options</code>对象来对 Preact diff 进行扩展，options 类似于 Preact 生命周期钩子，在 diff 过程中被调用(为了行文简洁，上面的代码我忽略掉了)。例如:</p>
<!-- prettier-ignore-start -->
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params"><span class="regexp">/*...*/</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ⚛️开始diff</span></span><br><span class="line">  <span class="keyword">if</span> ((tmp = options.diff)) tmp(newVNode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    outer: <span class="keyword">if</span> (oldVNode.type === Fragment || newType === Fragment) &#123;</span><br><span class="line">      <span class="comment">// Fragment diff</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> newType === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// 自定义组件diff</span></span><br><span class="line">      <span class="comment">// ⚛️开始渲染</span></span><br><span class="line">      <span class="keyword">if</span> ((tmp = options.render)) tmp(newVNode);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">        c.render(c.props, c.state, c.context),</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// ⚛️捕获异常</span></span><br><span class="line">        <span class="keyword">if</span> ((tmp = options.catchRender) &amp;&amp; tmp(e, c)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// DOM element diff</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ⚛️diff结束</span></span><br><span class="line">    <span class="keyword">if</span> ((tmp = options.diffed)) tmp(newVNode);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    catchErrorInComponent(e, ancestorComponent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newVNode._dom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->
<p><br></p>
<h3 id="usestate"><a href="#usestate" class="headerlink" title="useState"></a>useState</h3><p>先从最常用的 useState 开始:</p>
<!-- prettier-ignore-start -->
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️OK只是数组，没有Magic，每个hooks调用都会递增currenIndex, 从当前组件中取出状态</span></span><br><span class="line">  <span class="keyword">const</span> hookState = getHookState(currentIndex++);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 初始化</span></span><br><span class="line">  <span class="keyword">if</span> (!hookState._component) &#123;</span><br><span class="line">    hookState._component = currentComponent; <span class="comment">// 当前组件实例</span></span><br><span class="line">    hookState._value = [</span><br><span class="line">      <span class="comment">// ⚛️state, 初始化state</span></span><br><span class="line">      <span class="keyword">typeof</span> initialState === <span class="string">'function'</span> ? initialState() : initialState,</span><br><span class="line">      <span class="comment">// ⚛️dispatch</span></span><br><span class="line">      value =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> nextValue = <span class="keyword">typeof</span> value === <span class="string">'function'</span> ? value(hookState._value[<span class="number">0</span>]) : value;</span><br><span class="line">        <span class="keyword">if</span> (hookState._value[<span class="number">0</span>] !== nextValue) &#123;</span><br><span class="line">          <span class="comment">// ⚛️ 保存状态并调用setState强制更新</span></span><br><span class="line">          hookState._value[<span class="number">0</span>] = nextValue;</span><br><span class="line">          hookState._component.setState(&#123;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hookState._value; <span class="comment">// [state, dispatch]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->
<p><br></p>
<p>从代码可以看到，关键在于<code>getHookState</code>的实现</p>
<!-- prettier-ignore-start -->
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; options &#125; <span class="keyword">from</span> <span class="string">'preact'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentIndex; <span class="comment">// 保存当前hook的索引</span></span><br><span class="line"><span class="keyword">let</span> currentComponent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚛️render 钩子, 在组件开始渲染之前调用</span></span><br><span class="line"><span class="comment">// 因为Preact是同步递归向下渲染的，而且Javascript是单线程的，所以可以安全地引用当前正在渲染的组件实例</span></span><br><span class="line">options.render = <span class="function"><span class="params">vnode</span> =&gt;</span> &#123;</span><br><span class="line">  currentComponent = vnode._component; <span class="comment">// 保存当前正在渲染的组件</span></span><br><span class="line">  currentIndex = <span class="number">0</span>;                    <span class="comment">// 开始渲染时index重置为0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 暂时忽略，下面讲到useEffect就能理解</span></span><br><span class="line">  <span class="comment">// 清空上次渲染未处理的Effect(useEffect)，只有在快速重新渲染时才会出现这种情况，一般在异步队列中被处理</span></span><br><span class="line">  <span class="keyword">if</span> (currentComponent.__hooks) &#123;</span><br><span class="line">    currentComponent.__hooks._pendingEffects = handleEffects(</span><br><span class="line">      currentComponent.__hooks._pendingEffects,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚛️no magic!, 只是一个数组, 状态保存在组件实例的_list数组中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHookState</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取或初始化列表</span></span><br><span class="line">  <span class="keyword">const</span> hooks = currentComponent.__hooks ||</span><br><span class="line">    (currentComponent.__hooks = &#123;</span><br><span class="line">      _list: [],                  <span class="comment">// 放置状态</span></span><br><span class="line">      _pendingEffects: [],        <span class="comment">// 放置待处理的effect，由useEffect保存</span></span><br><span class="line">      _pendingLayoutEffects: [],  <span class="comment">// 放置待处理的layoutEffect，有useLayoutEffect保存</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建状态</span></span><br><span class="line">  <span class="keyword">if</span> (index &gt;= hooks._list.length) &#123;</span><br><span class="line">    hooks._list.push(&#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hooks._list[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->
<p><br></p>
<p>大概的流程如下:</p>
<center><br>  <img src="/images/07/useState.png" width="800"><br></center>

<p><br></p>
<h3 id="useeffect"><a href="#useeffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>再看看 useEffect 和 useLayoutEffect. useEffect 和 useLayouteEffect 差不多, 只是触发 effect 的时机不一样，useEffect 在完成渲染后绘制触发，而 useLayoutEffect 在 diff 完成后触发:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">callback, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state = getHookState(currentIndex++);</span><br><span class="line">  <span class="keyword">if</span> (argsChanged(state._args, args)) &#123;</span><br><span class="line">    <span class="comment">// ⚛️状态变化</span></span><br><span class="line">    state._value = callback;</span><br><span class="line">    state._args = args;</span><br><span class="line">    currentComponent.__hooks._pendingEffects.push(state); <span class="comment">// ⚛️推进_pendingEffects队列</span></span><br><span class="line">    afterPaint(currentComponent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useLayoutEffect</span>(<span class="params">callback, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state = getHookState(currentIndex++);</span><br><span class="line">  <span class="keyword">if</span> (argsChanged(state._args, args)) &#123;</span><br><span class="line">    <span class="comment">// ⚛️状态变化</span></span><br><span class="line">    state._value = callback;</span><br><span class="line">    state._args = args;</span><br><span class="line">    currentComponent.__hooks._pendingLayoutEffects.push(state); <span class="comment">// ⚛️推进_pendingLayoutEffects队列</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>看看如何触发 effect. useEffect 和上面看到的<code>enqueueRender</code>差不多，放进一个异步队列中，由<code>requestAnimationFrame</code>进行调度，批量处理:</p>
<!-- prettier-ignore-start -->
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个类似于上面提到的异步队列</span></span><br><span class="line">afterPaint = <span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!component._afterPaintQueued &amp;&amp; <span class="comment">// 避免组件重复推入</span></span><br><span class="line">    (component._afterPaintQueued = <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">    afterPaintEffects.push(component) === <span class="number">1</span> <span class="comment">// 开始调度</span></span><br><span class="line">  )</span><br><span class="line">    requestAnimationFrame(scheduleFlushAfterPaint);  <span class="comment">// 由requestAnimationFrame调度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleFlushAfterPaint</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(flushAfterPaintEffects);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushAfterPaintEffects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  afterPaintEffects.some(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">    component._afterPaintQueued = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (component._parentDom)</span><br><span class="line">      <span class="comment">// 清空_pendingEffects队列</span></span><br><span class="line">      component.__hooks._pendingEffects = handleEffects(component.__hooks._pendingEffects);</span><br><span class="line">  &#125;);</span><br><span class="line">  afterPaintEffects = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEffects</span>(<span class="params">effects</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先清除后调用effect</span></span><br><span class="line">  effects.forEach(invokeCleanup); <span class="comment">// 请调用清理</span></span><br><span class="line">  effects.forEach(invokeEffect);  <span class="comment">// 再调用effect</span></span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeCleanup</span>(<span class="params">hook</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hook._cleanup) hook._cleanup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeEffect</span>(<span class="params">hook</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = hook._value();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> result === <span class="string">'function'</span>) hook._cleanup = result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->
<p><br></p>
<p>再看看如何触发 LayoutEffect, 很简单，在 diff 完成后触发, 这个过程是同步的.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">options.diffed = <span class="function"><span class="params">vnode</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> c = vnode._component;</span><br><span class="line">  <span class="keyword">if</span> (!c) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> hooks = c.__hooks;</span><br><span class="line">  <span class="keyword">if</span> (hooks) &#123;</span><br><span class="line">    hooks._pendingLayoutEffects = handleEffects(hooks._pendingLayoutEffects);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>👌，hooks 基本原理基本了解完毕, 最后还是用一张图来总结一下吧。</p>
<center><br>  <img src="/images/07/hooks.png" width="800"><br></center>

<h2 id="技术地图"><a href="#技术地图" class="headerlink" title="技术地图"></a>技术地图</h2><p>文章篇幅很长，主要是太多代码了, 我自己也不喜欢看这种文章，所以没期望读者会看到这里. 后面文章再想办法改善改善. 谢谢你阅读到这里。</p>
<p>本期的主角本身是一个小而美的视图框架，没有其他技术栈. 这里就安利一下 Preact 作者<a href="https://github.com/developit" target="_blank" rel="noopener">developit</a>的另外一些小而美的库吧.</p>
<ul>
<li><a href="https://github.com/developit/workerize" target="_blank" rel="noopener">Workerize</a> 优雅地在 webWorker 中执行和调用程序</li>
<li><a href="https://github.com/developit/microbundle" target="_blank" rel="noopener">microbundle</a> 零配置的库打包工具</li>
<li><a href="https://github.com/developit/greenlet" target="_blank" rel="noopener">greenlet</a> 和 workerize 差不多，这个将单个异步函数放到 webworker 中执行，而 workerize 是将一个模块</li>
<li><a href="https://github.com/developit/mitt" target="_blank" rel="noopener">mitt</a> 200byte 的 EventEmitter</li>
<li><a href="https://github.com/developit/dlv" target="_blank" rel="noopener">dlv</a> 安全地访问深嵌套的对象属性，类似于 lodash 的 get 方法</li>
<li><a href="https://github.com/developit/snarkdown" target="_blank" rel="noopener">snarkdown</a> 1kb 的 markdown parser</li>
<li><a href="https://github.com/developit/unistore" target="_blank" rel="noopener">unistore</a> 简洁类 Redux 状态容器，支持 React 和 Preact</li>
<li><a href="https://github.com/developit/stockroom" target="_blank" rel="noopener">stockroom</a> 在 webWorker 支持状态管理器</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul>
<li><a href="https://juejin.im/entry/59b9284a5188257e6571b9b4" target="_blank" rel="noopener">Preact：Into the void 0（译）</a></li>
<li><a href="https://auth0.com/blog/face-off-virtual-dom-vs-incremental-dom-vs-glimmer/" target="_blank" rel="noopener">React Virtual DOM vs Incremental DOM vs Ember’s Glimmer: Fight</a></li>
</ul>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#virtual-dom"><span class="toc-number">1.</span> <span class="toc-text">Virtual-DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从-createelement-开始"><span class="toc-number">2.</span> <span class="toc-text">从 createElement 开始</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#component-的实现"><span class="toc-number">3.</span> <span class="toc-text">Component 的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#diff-算法"><span class="toc-number">4.</span> <span class="toc-text">diff 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#diffchildren"><span class="toc-number">4.1.</span> <span class="toc-text">diffChildren</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#diff"><span class="toc-number">4.2.</span> <span class="toc-text">diff</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#diffelementnodes"><span class="toc-number">4.3.</span> <span class="toc-text">diffElementNodes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#diffprops"><span class="toc-number">4.4.</span> <span class="toc-text">diffProps</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hooks-的实现"><span class="toc-number">5.</span> <span class="toc-text">Hooks 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#usestate"><span class="toc-number">5.1.</span> <span class="toc-text">useState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useeffect"><span class="toc-number">5.2.</span> <span class="toc-text">useEffect</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#技术地图"><span class="toc-number">6.</span> <span class="toc-text">技术地图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展"><span class="toc-number">7.</span> <span class="toc-text">扩展</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2019/06/02/preact-map/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2019/06/02/preact-map/&text=从 Preact 中窥探 React 的节本原理"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2019/06/02/preact-map/&title=从 Preact 中窥探 React 的节本原理"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2019/06/02/preact-map/&is_video=false&description=从 Preact 中窥探 React 的节本原理"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=从 Preact 中窥探 React 的节本原理&body=Check out this article: https://bobi.ink/2019/06/02/preact-map/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2019/06/02/preact-map/&title=从 Preact 中窥探 React 的节本原理"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2019/06/02/preact-map/&title=从 Preact 中窥探 React 的节本原理"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2019/06/02/preact-map/&title=从 Preact 中窥探 React 的节本原理"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2019/06/02/preact-map/&title=从 Preact 中窥探 React 的节本原理"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2019/06/02/preact-map/&name=从 Preact 中窥探 React 的节本原理&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2025 Ivan
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-44571525-2', 'auto');
        ga('send', 'pageview');
    </script>


    <!-- Disqus Comments -->
    <script type="text/javascript">
        var disqus_shortname = 'bobi-ink';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


