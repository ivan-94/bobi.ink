<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="系列引言最近准备培训新人, 为了方便新人较快入手 React 开发并编写高质量的组件代码, 我根据自己的实践经验对React 组件设计的相关实践和规范整理了一些文档, 将部分章节分享了出来. 由于经验有限, 文章可能会有某些错误, 希望大家指出, 互相交流. 由于篇幅太长, 所以拆分为几篇文章. 主要有以下几个主题:  01 类型检查 02 组件的组织 03 样式的管理 04 组件的思维 05 状">
<meta name="keywords" content="Blog,FrontEnd,React,Javascript,Typescript">
<meta property="og:type" content="article">
<meta property="og:title" content="React组件设计实践总结01 - 类型检查">
<meta property="og:url" content="https://bobi.ink/2019/05/10/react-component-design-01/index.html">
<meta property="og:site_name" content="Bobi.ink">
<meta property="og:description" content="系列引言最近准备培训新人, 为了方便新人较快入手 React 开发并编写高质量的组件代码, 我根据自己的实践经验对React 组件设计的相关实践和规范整理了一些文档, 将部分章节分享了出来. 由于经验有限, 文章可能会有某些错误, 希望大家指出, 互相交流. 由于篇幅太长, 所以拆分为几篇文章. 主要有以下几个主题:  01 类型检查 02 组件的组织 03 样式的管理 04 组件的思维 05 状">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://codesandbox.io/static/img/play-codesandbox.svg">
<meta property="og:updated_time" content="2023-06-01T09:55:14.329Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React组件设计实践总结01 - 类型检查">
<meta name="twitter:description" content="系列引言最近准备培训新人, 为了方便新人较快入手 React 开发并编写高质量的组件代码, 我根据自己的实践经验对React 组件设计的相关实践和规范整理了一些文档, 将部分章节分享了出来. 由于经验有限, 文章可能会有某些错误, 希望大家指出, 互相交流. 由于篇幅太长, 所以拆分为几篇文章. 主要有以下几个主题:  01 类型检查 02 组件的组织 03 样式的管理 04 组件的思维 05 状">
<meta name="twitter:image" content="https://codesandbox.io/static/img/play-codesandbox.svg">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>React组件设计实践总结01 - 类型检查</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/05/11/react-component-design-02/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/04/19/rxjs-by-example/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2019/05/10/react-component-design-01/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2019/05/10/react-component-design-01/&text=React组件设计实践总结01 - 类型检查"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2019/05/10/react-component-design-01/&title=React组件设计实践总结01 - 类型检查"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2019/05/10/react-component-design-01/&is_video=false&description=React组件设计实践总结01 - 类型检查"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=React组件设计实践总结01 - 类型检查&body=Check out this article: https://bobi.ink/2019/05/10/react-component-design-01/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2019/05/10/react-component-design-01/&title=React组件设计实践总结01 - 类型检查"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2019/05/10/react-component-design-01/&title=React组件设计实践总结01 - 类型检查"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2019/05/10/react-component-design-01/&title=React组件设计实践总结01 - 类型检查"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2019/05/10/react-component-design-01/&title=React组件设计实践总结01 - 类型检查"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2019/05/10/react-component-design-01/&name=React组件设计实践总结01 - 类型检查&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#系列引言"><span class="toc-number">1.</span> <span class="toc-text">系列引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型检查"><span class="toc-number">2.</span> <span class="toc-text">类型检查</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-函数组件"><span class="toc-number">2.1.</span> <span class="toc-text">1. 函数组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1️⃣-使用componentnameprops-形式命名-props-类型-并导出"><span class="toc-number">2.1.1.</span> <span class="toc-text">1️⃣ 使用ComponentNameProps 形式命名 Props 类型, 并导出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2️⃣-优先使用fc类型来声明函数组件"><span class="toc-number">2.1.2.</span> <span class="toc-text">2️⃣ 优先使用FC类型来声明函数组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3️⃣-不要直接使用export-default导出组件"><span class="toc-number">2.1.3.</span> <span class="toc-text">3️⃣ 不要直接使用export default导出组件.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4️⃣-默认-props-声明"><span class="toc-number">2.1.4.</span> <span class="toc-text">4️⃣ 默认 props 声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5️⃣-泛型函数组件"><span class="toc-number">2.1.5.</span> <span class="toc-text">5️⃣ 泛型函数组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6️⃣-子组件声明"><span class="toc-number">2.1.6.</span> <span class="toc-text">6️⃣ 子组件声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7️⃣-forwarding-refs"><span class="toc-number">2.1.7.</span> <span class="toc-text">7️⃣ Forwarding Refs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8️⃣-配合高阶组件使用"><span class="toc-number">2.1.8.</span> <span class="toc-text">8️⃣ 配合高阶组件使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-类组件"><span class="toc-number">2.2.</span> <span class="toc-text">2. 类组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1️⃣-继承-component-或-purecomponent"><span class="toc-number">2.2.1.</span> <span class="toc-text">1️⃣ 继承 Component 或 PureComponent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2️⃣-使用static-defaultprops定义默认-props"><span class="toc-number">2.2.2.</span> <span class="toc-text">2️⃣ 使用static defaultProps定义默认 props</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3️⃣-子组件声明"><span class="toc-number">2.2.3.</span> <span class="toc-text">3️⃣ 子组件声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4️⃣-泛型"><span class="toc-number">2.2.4.</span> <span class="toc-text">4️⃣ 泛型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-高阶组件"><span class="toc-number">2.3.</span> <span class="toc-text">3. 高阶组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-render-props"><span class="toc-number">2.4.</span> <span class="toc-text">4. Render Props</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-context"><span class="toc-number">2.5.</span> <span class="toc-text">5. Context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-杂项"><span class="toc-number">2.6.</span> <span class="toc-text">6. 杂项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1️⃣-使用handleevent命名事件处理器"><span class="toc-number">2.6.1.</span> <span class="toc-text">1️⃣ 使用handleEvent命名事件处理器.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2️⃣-内置事件处理器的类型"><span class="toc-number">2.6.2.</span> <span class="toc-text">2️⃣ 内置事件处理器的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3️⃣-自定义组件暴露事件处理器类型"><span class="toc-number">2.6.3.</span> <span class="toc-text">3️⃣ 自定义组件暴露事件处理器类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4️⃣-获取原生元素-props-定义"><span class="toc-number">2.6.4.</span> <span class="toc-text">4️⃣ 获取原生元素 props 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5️⃣-不要使用-proptypes"><span class="toc-number">2.6.5.</span> <span class="toc-text">5️⃣ 不要使用 PropTypes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6️⃣-styled-components"><span class="toc-number">2.6.6.</span> <span class="toc-text">6️⃣ styled-components</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7️⃣-为没有提供-typescript-声明文件的第三方库自定义模块声明"><span class="toc-number">2.6.7.</span> <span class="toc-text">7️⃣ 为没有提供 Typescript 声明文件的第三方库自定义模块声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8️⃣-为文档生成做好准备"><span class="toc-number">2.6.8.</span> <span class="toc-text">8️⃣ 为文档生成做好准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9️⃣-开启-strict-模式"><span class="toc-number">2.6.9.</span> <span class="toc-text">9️⃣ 开启 strict 模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展资料"><span class="toc-number">2.7.</span> <span class="toc-text">扩展资料</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        React组件设计实践总结01 - 类型检查
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Bobi.ink</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-05-09T16:00:00.000Z" itemprop="datePublished">2019-05-10</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="系列引言"><a href="#系列引言" class="headerlink" title="系列引言"></a>系列引言</h2><p>最近准备培训新人, 为了方便新人较快入手 React 开发并编写高质量的组件代码, 我根据自己的实践经验对<strong>React 组件设计的相关实践和规范</strong>整理了一些文档, 将部分章节分享了出来. 由于经验有限, 文章可能会有某些错误, 希望大家指出, 互相交流.</p>
<p>由于篇幅太长, 所以拆分为几篇文章. 主要有以下几个主题:</p>
<ul>
<li><a href="/2019/05/10/react-component-design-01/">01 类型检查</a></li>
<li><a href="/2019/05/11/react-component-design-02/">02 组件的组织</a></li>
<li><a href="/2019/05/14/react-component-design-03/">03 样式的管理</a></li>
<li><a href="/2019/05/15/react-component-design-04/">04 组件的思维</a></li>
<li><a href="/2019/05/20/react-component-design-05/">05 状态管理</a></li>
</ul>
<h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><p>静态类型检查对于当今的前端项目越来越不可或缺, 尤其是大型项目. <strong>它可以在开发时就避免许多类型问题, 减少低级错误的; 另外通过类型智能提示, 可以提高编码的效率; 有利于书写自描述的代码(类型即文档); 方便代码重构(配合 IDE 可以自动重构)</strong>. 对于静态类型检查的好处这里就不予赘述, 读者可以查看这个回答<a href="https://www.zhihu.com/question/28016252/answer/39056940" target="_blank" rel="noopener">flow.js/typescript 这类定义参数类型的意义何在？</a>.</p>
<p>Javascript 的类型检查器主要有<a href="https://www.typescriptlang.org" target="_blank" rel="noopener">Typescript</a>和<a href="https://flow.org" target="_blank" rel="noopener">Flow</a>, 笔者两者都用过, Typescript 更强大一些, 可以避免很多坑, 有更好的生态(例如第三方库类型声明), 而且 VSCode 内置支持. 而对于 Flow, 连 Facebook 自己的开源项目(如 Yarn, Jest)都抛弃了它, 所以不建议入坑. 所以本篇文章使用 Typescript(v3.3) 对 React 组件进行类型检查声明</p>
<p>建议通过官方文档来<a href="https://www.typescriptlang.org" target="_blank" rel="noopener">学习 Typescript</a>. 笔者此前也整理了 Typescript 相关的<a href="https://github.com/ivan-94/mindnodes/tree/master/语言/Typescript" target="_blank" rel="noopener">思维导图(mindnode)</a></p>
<blockquote>
<p>当然 Flow 也有某些 Typescript 没有的特性: <a href="https://github.com/niieani/typescript-vs-flowtype" target="_blank" rel="noopener">typescript-vs-flowtype</a></p>
</blockquote>
<blockquote>
<p>React 组件类型检查依赖于<code>@types/react</code>和<code>@types/react-dom</code></p>
</blockquote>
<blockquote>
<p>直接上手使用试用 <br> <a href="https://codesandbox.io/s/5vx5wwmkvx?fontsize=14" target="_blank" rel="noopener"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="Edit typescript-react-playground"></a></p>
</blockquote>
<p><strong>目录</strong></p>
<!-- TOC -->
<ul>
<li><a href="#系列引言">系列引言</a></li>
<li><a href="#类型检查">类型检查</a><ul>
<li><a href="#1-函数组件">1. 函数组件</a><ul>
<li><a href="#1️⃣-使用componentnameprops-形式命名-props-类型-并导出">1️⃣ <strong>使用<code>ComponentNameProps</code> 形式命名 Props 类型, 并导出</strong></a></li>
<li><a href="#2️⃣-优先使用fc类型来声明函数组件">2️⃣ <strong>优先使用<code>FC</code>类型来声明函数组件</strong></a></li>
<li><a href="#3️⃣-不要直接使用export-default导出组件">3️⃣ <strong>不要直接使用<code>export default</code>导出组件</strong>.</a></li>
<li><a href="#4️⃣-默认-props-声明">4️⃣ <strong>默认 props 声明</strong></a></li>
<li><a href="#5️⃣-泛型函数组件">5️⃣ <strong>泛型函数组件</strong></a></li>
<li><a href="#6️⃣-子组件声明">6️⃣ <strong>子组件声明</strong></a></li>
<li><a href="#7️⃣-forwarding-refs">7️⃣ <strong>Forwarding Refs</strong></a></li>
<li><a href="#8️⃣-配合高阶组件使用">8️⃣ <strong>配合高阶组件使用</strong></a></li>
</ul>
</li>
<li><a href="#2-类组件">2. 类组件</a><ul>
<li><a href="#1️⃣-继承-component-或-purecomponent">1️⃣ <strong>继承 Component 或 PureComponent</strong></a></li>
<li><a href="#2️⃣-使用static-defaultprops定义默认-props">2️⃣ <strong>使用<code>static defaultProps</code>定义默认 props</strong></a></li>
<li><a href="#3️⃣-子组件声明">3️⃣ <strong>子组件声明</strong></a></li>
<li><a href="#4️⃣-泛型">4️⃣ <strong>泛型</strong></a></li>
</ul>
</li>
<li><a href="#3-高阶组件">3. 高阶组件</a></li>
<li><a href="#4-render-props">4. Render Props</a></li>
<li><a href="#5-context">5. Context</a></li>
<li><a href="#6-杂项">6. 杂项</a><ul>
<li><a href="#1️⃣-使用handleevent命名事件处理器">1️⃣ <strong>使用<code>handleEvent</code>命名事件处理器</strong>.</a></li>
<li><a href="#2️⃣-内置事件处理器的类型">2️⃣ <strong>内置事件处理器的类型</strong></a></li>
<li><a href="#3️⃣-自定义组件暴露事件处理器类型">3️⃣ <strong>自定义组件暴露事件处理器类型</strong></a></li>
<li><a href="#4️⃣-获取原生元素-props-定义">4️⃣ <strong>获取原生元素 props 定义</strong></a></li>
<li><a href="#5️⃣-不要使用-proptypes">5️⃣ <strong>不要使用 PropTypes</strong></a></li>
<li><a href="#6️⃣-styled-components">6️⃣ <strong>styled-components</strong></a></li>
<li><a href="#7️⃣-为没有提供-typescript-声明文件的第三方库自定义模块声明">7️⃣ <strong>为没有提供 Typescript 声明文件的第三方库自定义模块声明</strong></a></li>
<li><a href="#8️⃣-为文档生成做好准备">8️⃣ <strong>为文档生成做好准备</strong></a></li>
<li><a href="#9️⃣-开启-strict-模式">9️⃣ <strong>开启 strict 模式</strong></a></li>
</ul>
</li>
<li><a href="#扩展资料">扩展资料</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<p><br></p>
<hr>
<p><br></p>
<h3 id="1-函数组件"><a href="#1-函数组件" class="headerlink" title="1. 函数组件"></a>1. 函数组件</h3><p>React Hooks 出现后, 函数组件有了更多出镜率. 由于函数组件只是普通函数, 它非常容易进行类型声明</p>
<p><br></p>
<h4 id="1️⃣-使用componentnameprops-形式命名-props-类型-并导出"><a href="#1️⃣-使用componentnameprops-形式命名-props-类型-并导出" class="headerlink" title="1️⃣ 使用ComponentNameProps 形式命名 Props 类型, 并导出"></a>1️⃣ <strong>使用<code>ComponentNameProps</code> 形式命名 Props 类型, 并导出</strong></h4><p><br></p>
<h4 id="2️⃣-优先使用fc类型来声明函数组件"><a href="#2️⃣-优先使用fc类型来声明函数组件" class="headerlink" title="2️⃣ 优先使用FC类型来声明函数组件"></a>2️⃣ <strong>优先使用<code>FC</code>类型来声明函数组件</strong></h4><p><code>FC</code>是<code>FunctionComponent</code>的简写, 这个类型定义了默认的 props(如 children)以及一些静态属性(如 defaultProps)</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明Props类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MyComponentProps &#123;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MyComponent: FC&lt;MyComponentProps&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;hello react&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>你也可以直接使用普通函数来进行组件声明, 下文会看到这种形式更加灵活:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MyComponentProps &#123;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">  <span class="comment">// 手动声明children</span></span><br><span class="line">  children?: React.ReactNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props: MyComponentProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;hello react&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="3️⃣-不要直接使用export-default导出组件"><a href="#3️⃣-不要直接使用export-default导出组件" class="headerlink" title="3️⃣ 不要直接使用export default导出组件."></a>3️⃣ <strong>不要直接使用<code>export default</code>导出组件</strong>.</h4><p>这种方式导出的组件在<code>React Inspector</code>查看时会显示为<code>Unknown</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (props: &#123;&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;hello react&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>如果非得这么做, 请使用<code>命名 function</code> 定义:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">props: &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;xxx&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="4️⃣-默认-props-声明"><a href="#4️⃣-默认-props-声明" class="headerlink" title="4️⃣ 默认 props 声明"></a>4️⃣ <strong>默认 props 声明</strong></h4><p>实际上截止目前对于上面的使用<code>FC</code>类型声明的函数组件并<a href="https://github.com/Microsoft/TypeScript/issues/27425" target="_blank" rel="noopener">不能完美支持 defaultProps</a>:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HelloProps &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Hello: FC&lt;HelloProps&gt; = <span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> &lt;div&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Hello.defaultProps = &#123; name: 'TJ' &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ❌! missing name</span></span><br><span class="line"><span class="regexp">&lt;Hello /</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>笔者一般喜欢这样子声明默认 props:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HelloProps &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>; <span class="comment">// 声明为可选属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用对象默认属性值语法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Hello: FC&lt;HelloProps&gt; = <span class="function">(<span class="params">&#123; name = 'TJ' &#125;</span>) =&gt;</span> &lt;div&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/div&gt;;</span></span><br></pre></td></tr></table></figure>
<p>如果非得使用 defaultProps, 可以这样子声明 👇. Typescript 可以推断和在函数上定义的属性, 这个特性在 Typescript <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html#properties-declarations-on-functions" target="_blank" rel="noopener">3.1</a>开始支持.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PropsWithChildren &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HelloProps &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用函数参数声明</span></span><br><span class="line"><span class="comment">// PropsWithChildren只是扩展了children, 完全可以自己声明</span></span><br><span class="line"><span class="comment">// type PropsWithChildren&lt;P&gt; = P &amp; &#123;</span></span><br><span class="line"><span class="comment">//    children?: ReactNode;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">const</span> Hello = <span class="function">(<span class="params">&#123; name &#125;: PropsWithChildren&lt;HelloProps&gt;</span>) =&gt;</span> &lt;div&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Hello.defaultProps = &#123; name: 'TJ' &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ✅ ok!</span></span><br><span class="line"><span class="regexp">&lt;Hello /</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>这种方式也非常简洁, 只不过 defaultProps 的类型和组件本身的 props 没有关联性, 这会使得 defaultProps 无法得到类型约束, 所以必要时进一步显式声明 defaultProps 的类型:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">Hello.defaultProps = &#123; name: <span class="string">'TJ'</span> &#125; <span class="keyword">as</span> Partial&lt;HelloProps&gt;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="5️⃣-泛型函数组件"><a href="#5️⃣-泛型函数组件" class="headerlink" title="5️⃣ 泛型函数组件"></a>5️⃣ <strong>泛型函数组件</strong></h4><p>泛型在一下列表型或容器型的组件中比较常用, 直接使用<code>FC</code>无法满足需求:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ListProps&lt;T&gt; &#123;</span><br><span class="line">  visible: <span class="built_in">boolean</span>;</span><br><span class="line">  list: T[];</span><br><span class="line">  renderItem: <span class="function">(<span class="params">item: T, index: <span class="built_in">number</span></span>) =&gt;</span> React.ReactNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt;(<span class="params">props: ListProps&lt;T&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;List</span><br><span class="line">      list=&#123;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</span><br><span class="line">      renderItem=&#123;<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">/*自动推断i为number类型*/</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要配合高阶组件使用可以这样子声明:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const List = React.memo(props =&gt; &#123;</span><br><span class="line">  return &lt;div /&gt;;</span><br><span class="line">&#125;) as (&lt;T&gt;(props: ListProps&lt;T&gt;) =&gt; React.ReactElement)</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="6️⃣-子组件声明"><a href="#6️⃣-子组件声明" class="headerlink" title="6️⃣ 子组件声明"></a>6️⃣ <strong>子组件声明</strong></h4><p>使用<code>Parent.Child</code>形式的 JSX 可以让节点父子关系更加直观, 它类似于一种命名空间的机制, 可以避免命名冲突. 相比<code>ParentChild</code>这种命名方式, <code>Parent.Child</code>更为优雅些. 当然也有可能让代码变得啰嗦.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PropsWithChildren &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> LayoutProps &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> LayoutHeaderProps &#123;&#125; <span class="comment">// 采用ParentChildProps形式命名</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> LayoutFooterProps &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Layout</span>(<span class="params">props: PropsWithChildren&lt;LayoutProps&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div className=<span class="string">"layout"</span>&gt;&#123;props.children&#125;&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 作为父组件的属性</span></span><br><span class="line"><span class="regexp">Layout.Header = (props: PropsWithChildren&lt;LayoutHeaderProps&gt;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return &lt;div className="header"&gt;&#123;props.children&#125;&lt;/</span>div&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Layout.Footer = <span class="function">(<span class="params">props: PropsWithChildren&lt;LayoutFooterProps&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div className=<span class="string">"footer"</span>&gt;&#123;props.children&#125;&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Test</span></span><br><span class="line"><span class="regexp">&lt;Layout&gt;</span></span><br><span class="line"><span class="regexp">  &lt;Layout.Header&gt;header&lt;/</span>Layout.Header&gt;</span><br><span class="line">  &lt;Layout.Footer&gt;footer&lt;<span class="regexp">/Layout.Footer&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Layout&gt;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="7️⃣-forwarding-refs"><a href="#7️⃣-forwarding-refs" class="headerlink" title="7️⃣ Forwarding Refs"></a>7️⃣ <strong>Forwarding Refs</strong></h4><p><code>React.forwardRef</code> 在 16.3 新增, 可以用于转发 ref, 适用于 HOC 和函数组件.</p>
<p>函数组件在 16.8.4 之前是不支持 ref 的, 配合 forwardRef 和 useImperativeHandle 可以让函数组件向外暴露方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************************</span></span><br><span class="line"><span class="comment"> * MyModal.tsx</span></span><br><span class="line"><span class="comment"> ****************************/</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState, useImperativeHandle, FC, useRef, useCallback &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MyModalProps &#123;</span><br><span class="line">  title?: React.ReactNode;</span><br><span class="line">  onOk?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  onCancel?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴露的方法, 适用`&#123;ComponentName&#125;Methods`形式命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MyModalMethods &#123;</span><br><span class="line">  show(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MyModal = React.forwardRef&lt;MyModalMethods, MyModalProps&gt;<span class="function">(<span class="params">(<span class="params">props, ref</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> [visible, setVisible] = useState(<span class="params"></span>);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 初始化ref暴露的方法</span></span></span></span><br><span class="line"><span class="function"><span class="params">  useImperativeHandle(<span class="params">ref, (<span class="params"></span>) =&gt; (<span class="params">&#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">    show: (<span class="params"></span>) =&gt; setVisible(<span class="params"><span class="literal">true</span></span>),</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">  &#125;</span>)</span>);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">return</span> &lt;Modal visible=&#123;visible&#125;&gt;...&lt;/Modal&gt;;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">/*******************</span></span><br><span class="line"><span class="function"> * <span class="params">Test</span>.<span class="params">tsx</span></span></span><br><span class="line"><span class="function"> *******************/</span></span><br><span class="line"><span class="function"><span class="params">const</span> <span class="params">Test</span>: <span class="params">FC</span>&lt;&#123;&#125;&gt; = <span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 引用</span></span><br><span class="line">  <span class="keyword">const</span> modal = useRef&lt;MyModalMethods | <span class="literal">null</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> confirm = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (modal.current) &#123;</span><br><span class="line">      modal.current.show();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleOk = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;confirm&#125;&gt;show&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;MyModal ref=&#123;modal&#125; onOk=&#123;handleOk&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>
<h4 id="8️⃣-配合高阶组件使用"><a href="#8️⃣-配合高阶组件使用" class="headerlink" title="8️⃣ 配合高阶组件使用"></a>8️⃣ <strong>配合高阶组件使用</strong></h4><p>经常看到新手写出这样的代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Foo.tsx</span><br><span class="line">const Foo: FC&lt;FooProps&gt; = props =&gt; &#123;/* .. */&#125;)</span><br><span class="line">export default React.memo(Foo)</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">// Demo.tsx</span><br><span class="line">import &#123; Foo &#125; from &apos;./Foo&apos; // -&gt; 这里面误使用命名导入语句，导致React.memo没有起作用</span><br></pre></td></tr></table></figure>
<p>所以笔者一般这样子组织:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Foo.tsx</span><br><span class="line">const Foo: FC&lt;FooProps&gt; = React.memo(props =&gt; &#123;/* .. */&#125;))</span><br><span class="line">export default Foo</span><br></pre></td></tr></table></figure>
<p>上面的代码还是有一个缺陷, 即你在React开发者工具看到的节点名称是这样的<code>&lt;Memo(wrappedComponent)&gt;&lt;/Memo(wrappedComponent)&gt;</code>, 只是因为React Babel插件无法从匿名函数中推导出displayName导致的. 解决方案是显式添加displayName:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Foo: FC&lt;FooProps&gt; = React.memo(props =&gt; &#123;/* .. */&#125;))</span><br><span class="line">Foo.displayName = &apos;Foo&apos;</span><br><span class="line">export default Foo</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h3 id="2-类组件"><a href="#2-类组件" class="headerlink" title="2. 类组件"></a>2. 类组件</h3><p>相比函数, 基于类的类型检查可能会更好理解(例如那些熟悉传统面向对象编程语言的开发者).</p>
<h4 id="1️⃣-继承-component-或-purecomponent"><a href="#1️⃣-继承-component-或-purecomponent" class="headerlink" title="1️⃣ 继承 Component 或 PureComponent"></a>1️⃣ <strong>继承 Component 或 PureComponent</strong></h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先导出Props声明, 同样是&#123;ComponentName&#125;Props形式命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> CounterProps &#123;</span><br><span class="line">  defaultCount: <span class="built_in">number</span>; <span class="comment">// 可选props, 不需要?修饰</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组件状态, 不需要暴露</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> State &#123;</span><br><span class="line">  count: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类注释</span></span><br><span class="line"><span class="comment"> * 继承React.Component, 并声明Props和State类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Counter <span class="keyword">extends</span> React.Component&lt;CounterProps, State&gt; &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 默认参数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    defaultCount: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化State</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> state = &#123;</span><br><span class="line">    count: <span class="keyword">this</span>.props.defaultCount,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 声明周期方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> componentDidMount() &#123;&#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 建议靠近componentDidMount, 资源消费和资源释放靠近在一起, 方便review</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> componentWillUnmount() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentDidCatch() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentDidUpdate(prevProps: CounterProps, prevState: State) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 渲染函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.count&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.increment&#125;&gt;Increment&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.decrement&#125;&gt;Decrement&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span>**</span><br><span class="line">   * ① 组件私有方法, 不暴露</span><br><span class="line">   * ② 使用类实例属性+箭头函数形式绑定<span class="keyword">this</span></span><br><span class="line">   *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">  private increment = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    this.setState((&#123; count &#125;) =&gt; (&#123; count: count + 1 &#125;));</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  private decrement = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    this.setState((&#123; count &#125;) =&gt; (&#123; count: count - 1 &#125;));</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="2️⃣-使用static-defaultprops定义默认-props"><a href="#2️⃣-使用static-defaultprops定义默认-props" class="headerlink" title="2️⃣ 使用static defaultProps定义默认 props"></a>2️⃣ <strong>使用<code>static defaultProps</code>定义默认 props</strong></h4><p>Typescript <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#support-for-defaultprops-in-jsx" target="_blank" rel="noopener">3.0</a>开始支持对使用 defaultProps 对 JSX props 进行推断, 在 defaultProps 中定义的 props 可以不需要’?’可选操作符修饰. 代码如上 👆</p>
<p><br></p>
<h4 id="3️⃣-子组件声明"><a href="#3️⃣-子组件声明" class="headerlink" title="3️⃣ 子组件声明"></a>3️⃣ <strong>子组件声明</strong></h4><p>类组件可以使用静态属性形式声明子组件</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Layout <span class="keyword">extends</span> React.Component&lt;LayoutProps&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Header = Header;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Footer = Footer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div className=<span class="string">"layout"</span>&gt;&#123;<span class="keyword">this</span>.props.children&#125;&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="4️⃣-泛型"><a href="#4️⃣-泛型" class="headerlink" title="4️⃣ 泛型"></a>4️⃣ <strong>泛型</strong></h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> List&lt;T&gt; <span class="keyword">extends</span> React.Component&lt;ListProps&lt;T&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> render() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h3 id="3-高阶组件"><a href="#3-高阶组件" class="headerlink" title="3. 高阶组件"></a>3. 高阶组件</h3><p>在 React Hooks 出来之前, 高阶组件是 React 的一个重要逻辑复用方式. 相比较而言高阶组件比较重, 且难以理解, 容易造成<code>嵌套地狱(wrapper)</code>. 另外对 Typescript 类型化也不友好(以前会使用<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/9c1c7e78a9a2b4af8e2cda842c3693f67bb9e42d/types/react-router/index.d.ts#L137" target="_blank" rel="noopener">Omit</a>来计算导出的 props). 所以新项目还是建议使用 React Hooks.</p>
<p>一个简单的高阶组件:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明注入的Props</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ThemeProps &#123;</span><br><span class="line">  primary: <span class="built_in">string</span>;</span><br><span class="line">  secondary: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给指定组件注入'主题'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">withTheme</span>&lt;<span class="title">P</span>&gt;(<span class="params">Component: React.ComponentType&lt;P &amp; ThemeProps&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * WithTheme 自己暴露的Props</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">interface</span> OwnProps &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 高阶组件的props, 忽略ThemeProps, 外部不需要传递这些属性</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">type</span> WithThemeProps = P &amp; OwnProps;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 高阶组件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> WithTheme = <span class="function">(<span class="params">props: WithThemeProps</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 假设theme从context中获取</span></span><br><span class="line">    <span class="keyword">const</span> fakeTheme: ThemeProps = &#123;</span><br><span class="line">      primary: <span class="string">'red'</span>,</span><br><span class="line">      secondary: <span class="string">'blue'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &lt;Component &#123;...fakeTheme&#125; &#123;...props&#125; /&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  WithTheme.displayName = <span class="string">`withTheme<span class="subst">$&#123;Component.displayName&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> WithTheme;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="keyword">const</span> Foo: FC&lt;&#123; a: <span class="built_in">number</span> &#125; &amp; ThemeProps&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &lt;div style=&#123;&#123; color: props.primary &#125;&#125; /&gt;;</span><br><span class="line"><span class="keyword">const</span> FooWithTheme = withTheme(Foo);</span><br><span class="line">() =&gt; &#123;</span><br><span class="line">  &lt;FooWithTheme a=&#123;<span class="number">1</span>&#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再重构一下:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽取出通用的高阶组件类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> HOC&lt;InjectedProps, OwnProps = &#123;&#125;&gt; = &lt;P&gt;(</span><br><span class="line">  Component: React.ComponentType&lt;P &amp; InjectedProps&gt;,</span><br><span class="line">) =&gt; React.ComponentType&lt;P &amp; OwnProps&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明注入的Props</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ThemeProps &#123;</span><br><span class="line">  primary: <span class="built_in">string</span>;</span><br><span class="line">  secondary: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> withTheme: HOC&lt;ThemeProps&gt; = <span class="function"><span class="params">Component</span> =&gt;</span> props =&gt; &#123;</span><br><span class="line">  <span class="comment">// 假设theme从context中获取</span></span><br><span class="line">  <span class="keyword">const</span> fakeTheme: ThemeProps = &#123;</span><br><span class="line">    primary: <span class="string">'red'</span>,</span><br><span class="line">    secondary: <span class="string">'blue'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &lt;Component &#123;...fakeTheme&#125; &#123;...props&#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用高阶组件还有一些痛点:</p>
<ul>
<li>无法完美地使用 ref(这已不算什么痛点)<ul>
<li>在 React.forwardRef 发布之前, 有一些库会使用 innerRef 或者 wrapperRef, 转发给封装的组件的 ref.</li>
<li>无法推断 ref 引用组件的类型, 需要显式声明.</li>
</ul>
</li>
<li>高阶组件类型报错很难理解</li>
</ul>
<p><br></p>
<hr>
<p><br></p>
<h3 id="4-render-props"><a href="#4-render-props" class="headerlink" title="4. Render Props"></a>4. Render Props</h3><p>React 的 props(包括 children)并没有限定类型, 它可以是一个函数. 于是就有了 render props, 这是和高阶组件一样常见的模式:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ThemeConsumerProps &#123;</span><br><span class="line">  children: <span class="function">(<span class="params">theme: Theme</span>) =&gt;</span> React.ReactNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeConsumer = <span class="function">(<span class="params">props: ThemeConsumerProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fakeTheme = &#123; primary: <span class="string">'red'</span>, secondary: <span class="string">'blue'</span> &#125;;</span><br><span class="line">  <span class="keyword">return</span> props.children(fakeTheme);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line">&lt;ThemeConsumer&gt;</span><br><span class="line">  &#123;<span class="function">(<span class="params">&#123; primary &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div style=&#123;&#123; color: primary &#125;&#125; /&gt;;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/ThemeConsumer&gt;;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h3 id="5-context"><a href="#5-context" class="headerlink" title="5. Context"></a>5. Context</h3><p>Context 提供了一种跨组件间状态共享机制</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC, useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Theme &#123;</span><br><span class="line">  primary: <span class="built_in">string</span>;</span><br><span class="line">  secondary: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明Context的类型, 以&#123;Name&#125;ContextValue命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ThemeContextValue &#123;</span><br><span class="line">  theme: Theme;</span><br><span class="line">  onThemeChange: <span class="function">(<span class="params">theme: Theme</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Context, 并设置默认值, 以&#123;Name&#125;Context命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeContext = React.createContext&lt;ThemeContextValue&gt;(&#123;</span><br><span class="line">  theme: &#123;</span><br><span class="line">    primary: <span class="string">'red'</span>,</span><br><span class="line">    secondary: <span class="string">'blue'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  onThemeChange: noop,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Provider, 以&#123;Name&#125;Provider命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeProvider: FC&lt;&#123; theme: Theme; onThemeChange: <span class="function">(<span class="params">theme: Theme</span>) =&gt;</span> <span class="built_in">void</span> &#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeContext.Provider value=&#123;&#123; theme: props.theme, onThemeChange: props.onThemeChange &#125;&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 暴露hooks, 以use&#123;Name&#125;命名</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">export function useTheme() &#123;</span></span><br><span class="line"><span class="regexp">  return useContext(ThemeContext);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h3 id="6-杂项"><a href="#6-杂项" class="headerlink" title="6. 杂项"></a>6. 杂项</h3><h4 id="1️⃣-使用handleevent命名事件处理器"><a href="#1️⃣-使用handleevent命名事件处理器" class="headerlink" title="1️⃣ 使用handleEvent命名事件处理器."></a>1️⃣ <strong>使用<code>handleEvent</code>命名事件处理器</strong>.</h4><p>如果存在多个相同事件处理器, 则按照<code>handle{Type}{Event}</code>命名, 例如 handleNameChange.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventDemo: FC&lt;&#123;&#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback&lt;React.MouseEventHandler&gt;(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">    evt.preventDefault();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;button onClick=&#123;handleClick&#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="2️⃣-内置事件处理器的类型"><a href="#2️⃣-内置事件处理器的类型" class="headerlink" title="2️⃣ 内置事件处理器的类型"></a>2️⃣ <strong>内置事件处理器的类型</strong></h4><p><code>@types/react</code>内置了以下事件处理器的类型 👇</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> EventHandler&lt;E <span class="keyword">extends</span> SyntheticEvent&lt;<span class="built_in">any</span>&gt;&gt; = &#123; bivarianceHack(event: E): <span class="built_in">void</span> &#125;[<span class="string">'bivarianceHack'</span>];</span><br><span class="line"><span class="keyword">type</span> ReactEventHandler&lt;T = Element&gt; = EventHandler&lt;SyntheticEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> ClipboardEventHandler&lt;T = Element&gt; = EventHandler&lt;ClipboardEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> CompositionEventHandler&lt;T = Element&gt; = EventHandler&lt;CompositionEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> DragEventHandler&lt;T = Element&gt; = EventHandler&lt;DragEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> FocusEventHandler&lt;T = Element&gt; = EventHandler&lt;FocusEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> FormEventHandler&lt;T = Element&gt; = EventHandler&lt;FormEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> ChangeEventHandler&lt;T = Element&gt; = EventHandler&lt;ChangeEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> KeyboardEventHandler&lt;T = Element&gt; = EventHandler&lt;KeyboardEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> MouseEventHandler&lt;T = Element&gt; = EventHandler&lt;MouseEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> TouchEventHandler&lt;T = Element&gt; = EventHandler&lt;TouchEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> PointerEventHandler&lt;T = Element&gt; = EventHandler&lt;PointerEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> UIEventHandler&lt;T = Element&gt; = EventHandler&lt;UIEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> WheelEventHandler&lt;T = Element&gt; = EventHandler&lt;WheelEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> AnimationEventHandler&lt;T = Element&gt; = EventHandler&lt;AnimationEvent&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> TransitionEventHandler&lt;T = Element&gt; = EventHandler&lt;TransitionEvent&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure>
<p>可以简洁地声明事件处理器类型:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ChangeEventHandler &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventDemo: FC&lt;&#123;&#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 可以限定具体Target的类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> handleChange = useCallback&lt;ChangeEventHandler&lt;HTMLInputElement&gt;&gt;(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(evt.target.value);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;input onChange=&#123;handleChange&#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="3️⃣-自定义组件暴露事件处理器类型"><a href="#3️⃣-自定义组件暴露事件处理器类型" class="headerlink" title="3️⃣ 自定义组件暴露事件处理器类型"></a>3️⃣ <strong>自定义组件暴露事件处理器类型</strong></h4><p>和原生 html 元素一样, 自定义组件应该暴露自己的事件处理器类型, 尤其是较为复杂的事件处理器, 这样可以避免开发者手动为每个事件处理器的参数声明类型</p>
<p>自定义事件处理器类型以<code>{ComponentName}{Event}Handler</code>命名. 为了和原生事件处理器类型区分, 不使用<code>EventHandler</code>形式的后缀</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC, useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> UploadValue &#123;</span><br><span class="line">  url: <span class="built_in">string</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴露事件处理器类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> UploadChangeHandler = <span class="function">(<span class="params">value?: UploadValue, file?: File</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> UploadProps &#123;</span><br><span class="line">  value?: UploadValue;</span><br><span class="line">  onChange?: UploadChangeHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Upload: FC&lt;UploadProps&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;...&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="4️⃣-获取原生元素-props-定义"><a href="#4️⃣-获取原生元素-props-定义" class="headerlink" title="4️⃣ 获取原生元素 props 定义"></a>4️⃣ <strong>获取原生元素 props 定义</strong></h4><p>有些场景我们希望原生元素扩展一下一些 props. 所有原生元素 props 都继承了<code>React.HTMLAttributes</code>, 某些特殊元素也会扩展了自己的属性, 例如<code>InputHTMLAttributes</code>. 具体可以参考<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/eafef8bd049017b3998939de2edbab5d8a96423b/types/react/index.d.ts#L203" target="_blank" rel="noopener"><code>React.createElement</code></a>方法的实现</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fixClass</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">T</span> <span class="title">extends</span> <span class="title">Element</span> = <span class="title">HTMLDivElement</span>,</span></span><br><span class="line"><span class="function">  <span class="title">Attribute</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">HTMLAttributes</span>&lt;<span class="title">T</span>&gt; = <span class="title">React</span>.<span class="title">HTMLAttributes</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">&gt;(<span class="params">cls: <span class="built_in">string</span>, <span class="keyword">type</span>: keyof React.ReactHTML = 'div'</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> FixedClassName: FC&lt;Attribute&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> React.createElement(<span class="keyword">type</span>, &#123; ...props, className: <span class="string">`<span class="subst">$&#123;cls&#125;</span> <span class="subst">$&#123;props.className&#125;</span>`</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> FixedClassName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> Container = fixClass(<span class="string">'card'</span>);</span><br><span class="line"><span class="keyword">const</span> Header = fixClass(<span class="string">'card__header'</span>, <span class="string">'header'</span>);</span><br><span class="line"><span class="keyword">const</span> Body = fixClass(<span class="string">'card__body'</span>, <span class="string">'main'</span>);</span><br><span class="line"><span class="keyword">const</span> Footer = fixClass(<span class="string">'card__body'</span>, <span class="string">'footer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Test = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Container&gt;</span><br><span class="line">      &lt;Header&gt;header&lt;<span class="regexp">/Header&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Body&gt;header&lt;/</span>Body&gt;</span><br><span class="line">      &lt;Footer&gt;footer&lt;<span class="regexp">/Footer&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Container&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="5️⃣-不要使用-proptypes"><a href="#5️⃣-不要使用-proptypes" class="headerlink" title="5️⃣ 不要使用 PropTypes"></a>5️⃣ <strong>不要使用 PropTypes</strong></h4><p>有了 Typescript 之后可以安全地约束 Props 和 State, 没有必要引入 React.PropTypes, 而且它的表达能力比较弱</p>
<p><br></p>
<h4 id="6️⃣-styled-components"><a href="#6️⃣-styled-components" class="headerlink" title="6️⃣ styled-components"></a>6️⃣ <strong>styled-components</strong></h4><p>styled-components 是目前最流行的<code>CSS-in-js</code>库, Typescript 在 2.9 支持泛型<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#generic-type-arguments-in-generic-tagged-templates" target="_blank" rel="noopener"><code>标签模板</code></a>. 这意味着可以简单地对 styled-components 创建的组件进行类型约束</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依赖于@types/styled-components</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components/macro'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Title = styled.h1&lt;&#123; active?: <span class="built_in">boolean</span> &#125;&gt;<span class="string">`</span></span><br><span class="line"><span class="string">  color: <span class="subst">$&#123;props =&gt; (props.active ? 'red' : 'gray')&#125;</span>;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展已有组件</span></span><br><span class="line"><span class="keyword">const</span> NewHeader = styled(Header)&lt;&#123; customColor: <span class="built_in">string</span> &#125;&gt;<span class="string">`</span></span><br><span class="line"><span class="string">  color: <span class="subst">$&#123;props =&gt; props.customColor&#125;</span>;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>
<p>了解更多<a href="https://www.styled-components.com/docs/api#typescript" target="_blank" rel="noopener">styled-components 和 Typescript</a></p>
<p><br></p>
<h4 id="7️⃣-为没有提供-typescript-声明文件的第三方库自定义模块声明"><a href="#7️⃣-为没有提供-typescript-声明文件的第三方库自定义模块声明" class="headerlink" title="7️⃣ 为没有提供 Typescript 声明文件的第三方库自定义模块声明"></a>7️⃣ <strong>为没有提供 Typescript 声明文件的第三方库自定义模块声明</strong></h4><p>笔者一般习惯在项目根目录下(和 tsconfig.json 同在一个目录下)放置一个<code>global.d.ts</code>. 放置项目的全局声明文件</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /global.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义模块声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'awesome-react-component' &#123;</span><br><span class="line">  <span class="comment">// 依赖其他模块的声明文件</span></span><br><span class="line">  <span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> Foo: React.FC&lt;&#123; a: <span class="built_in">number</span>; b: <span class="built_in">string</span> &#125;&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>了解更多<a href="https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html" target="_blank" rel="noopener">如何定义声明文件</a></p>
<p><br></p>
<h4 id="8️⃣-为文档生成做好准备"><a href="#8️⃣-为文档生成做好准备" class="headerlink" title="8️⃣ 为文档生成做好准备"></a>8️⃣ <strong>为文档生成做好准备</strong></h4><p>目前社区有多种 react 组件文档生成方案, 例如<a href="https://www.docz.site" target="_blank" rel="noopener"><code>docz</code></a>, <a href="https://github.com/styleguidist/react-docgen-typescript" target="_blank" rel="noopener"><code>styleguidist</code></a>还有<a href="https://github.com/storybooks/storybook" target="_blank" rel="noopener">storybook</a>. 它们底层都使用<a href="https://github.com/styleguidist/react-docgen-typescript" target="_blank" rel="noopener">react-docgen-typescript</a>对 Typescript 进行解析. 就目前而言, 它还有些坑, 而且解析比较慢. 不管不妨碍我们使用它的风格对代码进行注释:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Props注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ColumnProps <span class="keyword">extends</span> React.HTMLAttributes&lt;any&gt; &#123;</span><br><span class="line">  <span class="comment">/** prop1 description */</span></span><br><span class="line">  prop1?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">/** prop2 description */</span></span><br><span class="line">  prop2: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * prop3 description</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  prop3: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">/** prop4 description */</span></span><br><span class="line">  prop4: <span class="string">'option1'</span> | <span class="string">'option2'</span> | <span class="string">'option3'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对组件进行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Column <span class="keyword">extends</span> Component&lt;ColumnProps, &#123;&#125;&gt; &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;Column&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="9️⃣-开启-strict-模式"><a href="#9️⃣-开启-strict-模式" class="headerlink" title="9️⃣ 开启 strict 模式"></a>9️⃣ <strong>开启 strict 模式</strong></h4><p>为了真正把 Typescript 用起来, 应该始终开启 strict 模式, 避免使用 any 类型声明.</p>
<p><br></p>
<hr>
<p><br></p>
<h3 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h3><ul>
<li><a href="https://github.com/piotrwitek/react-redux-typescript-guide" target="_blank" rel="noopener">piotrwitek/react-redux-typescript-guide</a></li>
<li><a href="https://www.zhihu.com/question/279911703" target="_blank" rel="noopener">TypeScript 如何完美地书写 React 中的 HOC？</a></li>
<li><a href="https://www.typescriptlang.org/docs/home.html" target="_blank" rel="noopener">Typescript 官方文档</a></li>
<li><a href="https://basarat.gitbooks.io/typescript/docs/why-typescript.html" target="_blank" rel="noopener">Typescript-deep-dive</a></li>
<li><a href="https://github.com/ivan-94/mindnodes/tree/master/语言/Typescript" target="_blank" rel="noopener">Typescript 思维导图</a></li>
</ul>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#系列引言"><span class="toc-number">1.</span> <span class="toc-text">系列引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型检查"><span class="toc-number">2.</span> <span class="toc-text">类型检查</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-函数组件"><span class="toc-number">2.1.</span> <span class="toc-text">1. 函数组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1️⃣-使用componentnameprops-形式命名-props-类型-并导出"><span class="toc-number">2.1.1.</span> <span class="toc-text">1️⃣ 使用ComponentNameProps 形式命名 Props 类型, 并导出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2️⃣-优先使用fc类型来声明函数组件"><span class="toc-number">2.1.2.</span> <span class="toc-text">2️⃣ 优先使用FC类型来声明函数组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3️⃣-不要直接使用export-default导出组件"><span class="toc-number">2.1.3.</span> <span class="toc-text">3️⃣ 不要直接使用export default导出组件.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4️⃣-默认-props-声明"><span class="toc-number">2.1.4.</span> <span class="toc-text">4️⃣ 默认 props 声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5️⃣-泛型函数组件"><span class="toc-number">2.1.5.</span> <span class="toc-text">5️⃣ 泛型函数组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6️⃣-子组件声明"><span class="toc-number">2.1.6.</span> <span class="toc-text">6️⃣ 子组件声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7️⃣-forwarding-refs"><span class="toc-number">2.1.7.</span> <span class="toc-text">7️⃣ Forwarding Refs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8️⃣-配合高阶组件使用"><span class="toc-number">2.1.8.</span> <span class="toc-text">8️⃣ 配合高阶组件使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-类组件"><span class="toc-number">2.2.</span> <span class="toc-text">2. 类组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1️⃣-继承-component-或-purecomponent"><span class="toc-number">2.2.1.</span> <span class="toc-text">1️⃣ 继承 Component 或 PureComponent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2️⃣-使用static-defaultprops定义默认-props"><span class="toc-number">2.2.2.</span> <span class="toc-text">2️⃣ 使用static defaultProps定义默认 props</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3️⃣-子组件声明"><span class="toc-number">2.2.3.</span> <span class="toc-text">3️⃣ 子组件声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4️⃣-泛型"><span class="toc-number">2.2.4.</span> <span class="toc-text">4️⃣ 泛型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-高阶组件"><span class="toc-number">2.3.</span> <span class="toc-text">3. 高阶组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-render-props"><span class="toc-number">2.4.</span> <span class="toc-text">4. Render Props</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-context"><span class="toc-number">2.5.</span> <span class="toc-text">5. Context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-杂项"><span class="toc-number">2.6.</span> <span class="toc-text">6. 杂项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1️⃣-使用handleevent命名事件处理器"><span class="toc-number">2.6.1.</span> <span class="toc-text">1️⃣ 使用handleEvent命名事件处理器.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2️⃣-内置事件处理器的类型"><span class="toc-number">2.6.2.</span> <span class="toc-text">2️⃣ 内置事件处理器的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3️⃣-自定义组件暴露事件处理器类型"><span class="toc-number">2.6.3.</span> <span class="toc-text">3️⃣ 自定义组件暴露事件处理器类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4️⃣-获取原生元素-props-定义"><span class="toc-number">2.6.4.</span> <span class="toc-text">4️⃣ 获取原生元素 props 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5️⃣-不要使用-proptypes"><span class="toc-number">2.6.5.</span> <span class="toc-text">5️⃣ 不要使用 PropTypes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6️⃣-styled-components"><span class="toc-number">2.6.6.</span> <span class="toc-text">6️⃣ styled-components</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7️⃣-为没有提供-typescript-声明文件的第三方库自定义模块声明"><span class="toc-number">2.6.7.</span> <span class="toc-text">7️⃣ 为没有提供 Typescript 声明文件的第三方库自定义模块声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8️⃣-为文档生成做好准备"><span class="toc-number">2.6.8.</span> <span class="toc-text">8️⃣ 为文档生成做好准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9️⃣-开启-strict-模式"><span class="toc-number">2.6.9.</span> <span class="toc-text">9️⃣ 开启 strict 模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展资料"><span class="toc-number">2.7.</span> <span class="toc-text">扩展资料</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2019/05/10/react-component-design-01/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2019/05/10/react-component-design-01/&text=React组件设计实践总结01 - 类型检查"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2019/05/10/react-component-design-01/&title=React组件设计实践总结01 - 类型检查"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2019/05/10/react-component-design-01/&is_video=false&description=React组件设计实践总结01 - 类型检查"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=React组件设计实践总结01 - 类型检查&body=Check out this article: https://bobi.ink/2019/05/10/react-component-design-01/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2019/05/10/react-component-design-01/&title=React组件设计实践总结01 - 类型检查"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2019/05/10/react-component-design-01/&title=React组件设计实践总结01 - 类型检查"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2019/05/10/react-component-design-01/&title=React组件设计实践总结01 - 类型检查"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2019/05/10/react-component-design-01/&title=React组件设计实践总结01 - 类型检查"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2019/05/10/react-component-design-01/&name=React组件设计实践总结01 - 类型检查&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2023 Ivan
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-44571525-2', 'auto');
        ga('send', 'pageview');
    </script>


    <!-- Disqus Comments -->
    <script type="text/javascript">
        var disqus_shortname = 'bobi-ink';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


