<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="前几篇文章都在讲 React 的 Concurrent 模式, 很多读者都看懵了，这一篇来点轻松的，蹭了一下 Vue 3.0 的热度。讲讲如何在 React 下实现 Vue Composition API(下面简称VCA)，只是个玩具，别当真。 实现 ‘React’ Composition API？看起来很吊，确实也是，通过本文你可以体会到这两种思想的碰撞, 你可以深入学习三样东西：React H">
<meta name="keywords" content="Blog,FrontEnd,React,Javascript,Typescript">
<meta property="og:type" content="article">
<meta property="og:title" content="[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香">
<meta property="og:url" content="https://bobi.ink/2019/11/04/react-composition/index.html">
<meta property="og:site_name" content="Bobi.ink">
<meta property="og:description" content="前几篇文章都在讲 React 的 Concurrent 模式, 很多读者都看懵了，这一篇来点轻松的，蹭了一下 Vue 3.0 的热度。讲讲如何在 React 下实现 Vue Composition API(下面简称VCA)，只是个玩具，别当真。 实现 ‘React’ Composition API？看起来很吊，确实也是，通过本文你可以体会到这两种思想的碰撞, 你可以深入学习三样东西：React H">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://bobi.ink/images/react-composition/pass-by-reference-vs-pass-by-value-animation.gif">
<meta property="og:image" content="https://bobi.ink/images/sponsor.jpg">
<meta property="og:updated_time" content="2023-06-01T09:55:14.330Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香">
<meta name="twitter:description" content="前几篇文章都在讲 React 的 Concurrent 模式, 很多读者都看懵了，这一篇来点轻松的，蹭了一下 Vue 3.0 的热度。讲讲如何在 React 下实现 Vue Composition API(下面简称VCA)，只是个玩具，别当真。 实现 ‘React’ Composition API？看起来很吊，确实也是，通过本文你可以体会到这两种思想的碰撞, 你可以深入学习三样东西：React H">
<meta name="twitter:image" content="https://bobi.ink/images/react-composition/pass-by-reference-vs-pass-by-value-animation.gif">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/11/17/fe-load/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/10/28/concurrent-mode-transition/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2019/11/04/react-composition/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2019/11/04/react-composition/&text=[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2019/11/04/react-composition/&title=[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2019/11/04/react-composition/&is_video=false&description=[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香&body=Check out this article: https://bobi.ink/2019/11/04/react-composition/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2019/11/04/react-composition/&title=[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2019/11/04/react-composition/&title=[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2019/11/04/react-composition/&title=[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2019/11/04/react-composition/&title=[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2019/11/04/react-composition/&name=[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#对比-react-hooks-和-vue-composition-api"><span class="toc-number">1.</span> <span class="toc-text">对比 React Hooks 和 Vue Composition API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本-api-类比"><span class="toc-number">1.1.</span> <span class="toc-text">基本 API 类比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#api-设计概览"><span class="toc-number">2.</span> <span class="toc-text">API 设计概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#响应式数据和-ref"><span class="toc-number">3.</span> <span class="toc-text">响应式数据和 ref</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关于-vue-composition-api-ref"><span class="toc-number">3.1.</span> <span class="toc-text">关于 Vue Composition API ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么需要-ref"><span class="toc-number">3.2.</span> <span class="toc-text">为什么需要 ref?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref-和-useref"><span class="toc-number">3.3.</span> <span class="toc-text">ref 和 useRef</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生命周期方法"><span class="toc-number">4.</span> <span class="toc-text">生命周期方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#watch"><span class="toc-number">5.</span> <span class="toc-text">watch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#包装-props-为响应式数据"><span class="toc-number">6.</span> <span class="toc-text">包装 Props 为响应式数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#支持-context-注入"><span class="toc-number">7.</span> <span class="toc-text">支持 Context 注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#跟踪组件依赖并触发重新渲染"><span class="toc-number">8.</span> <span class="toc-text">跟踪组件依赖并触发重新渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#forwardref-处理"><span class="toc-number">9.</span> <span class="toc-text">forwardRef 处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">10.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考-扩展"><span class="toc-number">11.</span> <span class="toc-text">参考/扩展</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        [实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Bobi.ink</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-11-03T16:00:00.000Z" itemprop="datePublished">2019-11-04</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p><a href="https://juejin.im/post/5dadc6045188255a270a0f85" target="_blank" rel="noopener">前几篇文章</a>都在讲 React 的 Concurrent 模式, 很多读者都看懵了，这一篇来点轻松的，蹭了一下 Vue 3.0 的热度。讲讲如何在 React 下实现 <a href="https://vue-composition-api-rfc.netlify.com/#type-issues-with-class-api" target="_blank" rel="noopener"><code>Vue Composition API</code></a>(下面简称<strong>VCA</strong>)，只是个玩具，别当真。</p>
<p>实现 ‘React’ Composition API？看起来很吊，确实也是，通过本文你可以体会到这两种思想的碰撞, 你可以深入学习三样东西：<code>React Hooks</code>、<code>Vue Composition API</code>、<a href="https://mobx.js.org/refguide/api.html" target="_blank" rel="noopener"><code>Mobx</code></a>。篇幅很长(主要是代码)，当然干货也很多。</p>
<p><br></p>
<p><strong>目录</strong></p>
<p><br></p>
<!-- TOC -->
<ul>
<li><a href="#对比-react-hooks-和-vue-composition-api">对比 React Hooks 和 Vue Composition API</a><ul>
<li><a href="#基本-api-类比">基本 API 类比</a></li>
</ul>
</li>
<li><a href="#api-设计概览">API 设计概览</a></li>
<li><a href="#响应式数据和-ref">响应式数据和 ref</a><ul>
<li><a href="#关于-vue-composition-api-ref">关于 Vue Composition API ref</a></li>
<li><a href="#为什么需要-ref">为什么需要 ref?</a></li>
<li><a href="#ref-和-useref">ref 和 useRef</a></li>
</ul>
</li>
<li><a href="#生命周期方法">生命周期方法</a></li>
<li><a href="#watch">watch</a></li>
<li><a href="#包装-props-为响应式数据">包装 Props 为响应式数据</a></li>
<li><a href="#支持-context-注入">支持 Context 注入</a></li>
<li><a href="#跟踪组件依赖并触发重新渲染">跟踪组件依赖并触发重新渲染</a></li>
<li><a href="#forwardref-处理">forwardRef 处理</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#参考扩展">参考/扩展</a></li>
</ul>
<!-- /TOC -->
<p><br></p>
<p>Vue Composition API 是 Vue 3.0 的一个重要特性，和 React Hooks 一样，这是一种非常棒的<strong>逻辑组合/复用机制</strong>。尽管初期受到不少<a href="https://juejin.im/post/5d0f64d4f265da1b67211893" target="_blank" rel="noopener">争议</a>，<strong>我个人还是比较看好这个 API 提案，因为确实解决了 Vue 以往的很多痛点</strong>, 这些痛点在它的<a href="https://vue-composition-api-rfc.netlify.com/#motivation" target="_blank" rel="noopener"> RFC 文档</a>中说得很清楚。动机和 React Hooks 差不多，无非就是三点:</p>
<p><br></p>
<ul>
<li>① 逻辑组合和复用</li>
<li>② 更好的类型推断。完美支持 Typescript</li>
<li>③ Tree-shakable 和 代码压缩友好</li>
</ul>
<p><br></p>
<p>如果你了解 React Hooks 你会觉得 VCA 身上有很多 Hooks 的影子, 毕竟官方也承认 React Hooks 是 VCA 的主要灵感来源，但是 Vue 没有完全照搬 React Hooks，而是基于自己的数据响应式机制，创建出了自己特色的逻辑复用原语, 辨识度也是非常高的。</p>
<p><br><br><br></p>
<h2 id="对比-react-hooks-和-vue-composition-api"><a href="#对比-react-hooks-和-vue-composition-api" class="headerlink" title="对比 React Hooks 和 Vue Composition API"></a>对比 React Hooks 和 Vue Composition API</h2><p>对于 React 开发者来说, VCA 还解决了 React Hooks 的一些有点稍微让人难受、新手不友好的问题。这是驱动我写这篇文章原因之一，来尝试把 VCA 抄过来, 除了学习 VCA，还可以加深对 React Hooks 的理解。</p>
<p>VCA 官方 RFC 文档已经很详细列举了它和 React Hooks 的差异:</p>
<p><br></p>
<p><strong>① 总的来说，更符合惯用的 JavaScript 代码直觉</strong>。这主要是 Immutable 和 Mutable 的数据操作习惯的不同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue: 响应式数据, 更符合 JavaScript 代码的直觉, 就是普通的对象操作</span></span><br><span class="line"><span class="keyword">const</span> data = reactive(&#123;<span class="attr">count</span>: <span class="number">1</span>&#125;)</span><br><span class="line">data.count++</span><br><span class="line"></span><br><span class="line"><span class="comment">// React: 不可变数据, JavaScript 原生不支持不可变数据，因此数据操作会 verbose 一点</span></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">1</span>)</span><br><span class="line">setCount(count + <span class="number">1</span>)</span><br><span class="line">setCoung(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// React: 或者使用 Reducer, 适合进行一些复杂的数据操作</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>, <span class="comment">/* 假设还有其他状态 */</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState)</span><br><span class="line">dispatch(&#123;<span class="attr">type</span>: <span class="string">'increment'</span>&#125;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>不过, 不能说可变数据就一定好于不可变数据, 反之亦然。 <strong>不可变数据也给 React 发挥和优化的空间, 尤其在 Concurrent 模式下, 不可变数据可以更好地被跟踪和 reduce</strong>。 例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React</span></span><br><span class="line"><span class="keyword">const</span> [state, setState] = useState(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> [startTransition] = useTransition()</span><br><span class="line"></span><br><span class="line">setState(<span class="number">1</span>)              <span class="comment">// 高优先级变更</span></span><br><span class="line">startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  <span class="comment">// 低优先级状态变更</span></span><br><span class="line">  setState(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>React 中状态变更可以有不同的优先级，实际上这些变更会放入一个队列中，界面可能先显示 <code>1</code>, 然后才是 <code>2</code>。<strong>你可以认为这个队列就是这个状态的历史快照，由 React 来调度进行状态的前进，有点类似于 Redux 的’时间旅行’</strong>。如果是可变数据，实现这种‘时间旅行’会相对比较麻烦。</p>
<p><br></p>
<hr>
<p><br></p>
<p><strong>② 不关心调用顺序和条件化</strong>。React Hooks <a href="https://juejin.im/post/5cfa29e151882539c33e4f5e" target="_blank" rel="noopener">基于数组实现</a>，每次重新渲染必须保证调用的顺序，否则会出现数据错乱。VCA 不依赖数组，不存在这些限制。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyHooks</span>(<span class="params">someCondition, antherCondition</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="comment">/* ... */</span>&#125;, []) <span class="comment">// 💥</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (anotherCondition) &#123;</span><br><span class="line">    <span class="keyword">return</span> something      <span class="comment">// 提前返回 💥</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [someState] = useState(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<p><strong>③ 不用每次渲染重复调用，减低 GC 的压力</strong>。 每次渲染所有 Hooks 都会重新执行一遍，这中间可能会重复创建一些临时的变量、对象以及闭包。而 VCA 的setup 只调用一次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComp</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> add = <span class="function"><span class="params">()</span> =&gt;</span> setCount(<span class="function"><span class="params">c</span> =&gt;</span> c+<span class="number">1</span>)  <span class="comment">// 这些内联函数每次渲染都会创建</span></span><br><span class="line">  <span class="keyword">const</span> decr = <span class="function"><span class="params">()</span> =&gt;</span> setCount(<span class="function"><span class="params">c</span> =&gt;</span> c<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(count)</span><br><span class="line">  &#125;, [count])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    count: &#123;count&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">onClick</span>=<span class="string">&#123;add&#125;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">onClick</span>=<span class="string">&#123;decr&#125;</span>&gt;</span>decr<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<p><strong>④ 不用考虑 useCallback/useMemo 问题</strong>。 因为问题 ③ , 在 React 中，为了避免子组件 diff 失效导致无意义的重新渲染，我们几乎总会使用 useCallback 或者 useMemo 来缓存传递给下级的事件处理器或对象。</p>
<p>VCA 中我们可以安全地引用对象，随时可以存取最新的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComp</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> add = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> setCount(<span class="function"><span class="params">c</span> =&gt;</span> c+<span class="number">1</span>), [])</span><br><span class="line">  <span class="keyword">const</span> decr = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> setCount(<span class="function"><span class="params">c</span> =&gt;</span> c<span class="number">-1</span>), [])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(count)</span><br><span class="line">  &#125;, [count])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">SomeComplexComponent</span> <span class="attr">count</span>=<span class="string">&#123;count&#125;</span> <span class="attr">onAdd</span>=<span class="string">&#123;add&#125;</span> <span class="attr">onDecr</span>=<span class="string">&#123;decr&#125;/</span>&gt;</span>)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// Vue: 没有此问题, 通过对象引用存取最新值</span></span><br><span class="line"><span class="xml">createComponent(&#123;</span></span><br><span class="line"><span class="xml">  setup((props) =&gt; &#123;</span></span><br><span class="line"><span class="xml">    const count = ref(0)</span></span><br><span class="line"><span class="xml">    const add = () =&gt; count.value++</span></span><br><span class="line"><span class="xml">    const decr = () =&gt; count.value--</span></span><br><span class="line"><span class="xml">    watch(count, c =&gt; console.log(c))</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line">    return () =&gt; &lt;SomeComplexComponent count=&#123;count&#125; onAdd=&#123;add&#125; onDecr=&#123;decr&#125;/&gt;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<p><strong>⑤ 不必手动管理数据依赖</strong>。在 React Hooks 中，使用 <code>useCallback</code>、<code>useMemo</code>、<code>useEffect</code> 这些 Hooks，都需要手动维护一个数据依赖数组。当这些依赖项变动时，才让缓存失效。</p>
<p>这往往是新手接触 React Hooks 的第一道坎。你要理解好闭包，理解好 Memoize 函数 ，才能理解这些 Hooks 的行为。这还不是问题，问题是这些数据依赖需要开发者手动去维护，很容易漏掉什么，导致bug。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComp</span>(<span class="params">&#123;anotherCount, onClick&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setState] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    onClick(anotherCount + count)</span><br><span class="line">  &#125;, [count]) <span class="comment">// 🐞漏掉了 antherCount 和 onClick</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此 React 团队开发了 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noopener">eslint-plugin-react-hooks</a>插件，辅助检查 React Hooks 的用法, 可以避免漏掉某些依赖。不过这个插件太死了，搞不好要写很多 <code>//eslint-disable-next-line</code> 😂</p>
<p>VCA 由于不存在 ④ 问题，当然也不存在 ⑤问题。 Vue 的响应式机制可以自动、精确地跟踪数据依赖，而且基于对象引用的不变性，我们不需要关心闭包问题。</p>
<p><br></p>
<hr>
<p><br></p>
<p>如果你长期被这些问题困扰，你会觉得 VCA 很有吸引力。而且它简单易学, 这简直是 Vue 开发者的‘福报‘啊！ 是不是也想自己动手写一个？把 VCA 搬到 React 这边来，解决这些问题？那请继续往下读</p>
<p><br><br><br></p>
<h3 id="基本-api-类比"><a href="#基本-api-类比" class="headerlink" title="基本 API 类比"></a>基本 API 类比</h3><p>首先，你得先了解 React Hooks 和 VCA。最好的学习资料是它们的官方文档。下面简单类比一下两者的 API:</p>
<p><br></p>
<table>
<thead>
<tr>
<th></th>
<th>React Hooks</th>
<th>Vue Composition API</th>
</tr>
</thead>
<tbody>
<tr>
<td>状态</td>
<td><code>const [value, setValue] = useState(0)</code> <br> <code>useReducer</code></td>
<td><code>const state = reactive({value: 0})</code> <br> <code>ref(0)</code></td>
</tr>
<tr>
<td>状态变更</td>
<td><code>setValue(1)</code> <br> <code>setValue(n =&gt; n + 1)</code> <br> <code>dispatch</code></td>
<td><code>state.value = 1</code> <br> <code>state.value++</code></td>
</tr>
<tr>
<td>状态衍生</td>
<td><code>useMemo(() =&gt; derived, [deps])</code></td>
<td><code>computed(() =&gt; derived)</code></td>
</tr>
<tr>
<td>对象引用</td>
<td><code>const foo = useRef(0);</code> <br> <code>foo.current = 1</code></td>
<td><code>const foo = ref(0)</code> <br> <code>foo.value = 1</code></td>
</tr>
<tr>
<td>挂载</td>
<td><code>useEffect(() =&gt; {/*挂载*/}, [])</code></td>
<td><code>onBeforeMount(() =&gt; {/*挂载前*/})</code> <br> <code>onMounted(() =&gt; {/*挂载后*/})</code></td>
</tr>
<tr>
<td>卸载</td>
<td><code>useEffect(() =&gt; () =&gt; {/*卸载*/}}, [])</code></td>
<td><code>onBeforeUnmount(() =&gt; {/*卸载前*/})</code> <br> <code>onUnmounted(() =&gt; {/*卸载后*/})</code></td>
</tr>
<tr>
<td>重新渲染</td>
<td><code>useEffect(() =&gt; {/*更新*/})</code></td>
<td><code>onBeforeUpdate(() =&gt; {/*更新前*/})</code> <br> <code>onUpdated(() =&gt; {/*更新后*/})</code></td>
</tr>
<tr>
<td>异常处理</td>
<td>目前只有类组件支持(<code>componentDidCatch</code>, <br> <code>static getDerivedStateFromError</code>)</td>
<td><code>onErrorCaptured((err) =&gt; {/*异常处理*/})</code></td>
</tr>
<tr>
<td>依赖监听</td>
<td><code>useEffect(() =&gt; {/*依赖更新*/}, [deps])</code></td>
<td><code>const stop = watch(() =&gt; {/*自动检测数据依赖, 更新...*/})</code></td>
</tr>
<tr>
<td>依赖监听 + 清理</td>
<td><code>useEffect(() =&gt; {/*...*/; return () =&gt; {/*清理*/}}, [deps])</code></td>
<td><code>watch(() =&gt; [deps], (newVal, oldVal, clean) =&gt; {/*更新*/; clean(() =&gt; {/* 清理*/})})</code></td>
</tr>
<tr>
<td>Context 注入</td>
<td><code>useContext(YouContext)</code></td>
<td><code>inject(key)</code> <br> <code>provider(key, value)</code></td>
</tr>
</tbody>
</table>
<p><br></p>
<p>对比上表，我们发现两者非常相似，每个功能都可以在对方身上找到等价物。 React Hooks 和 VCA 的主要差别如下:</p>
<p><br></p>
<ul>
<li><strong>数据方面</strong>。<code>Mutable</code> vs <code>Immutable</code>，<code>Reactive</code> vs <code>Diff</code>。</li>
<li><strong>更新响应方面</strong>。React Hooks 和其组件思维一脉相承，它依赖数据的比对来确定依赖的更新。而Vue 则基于自动的依赖订阅。这点可以通过对比 useEffect 和 watch 体会。</li>
<li><strong>生命周期钩子</strong>。React Hooks 已经弱化了组件生命周期的概念，类组件也废弃了<code>componentWillMount</code>、 <code>componentWillUpdate</code>、   <code>componentWillReceiveProps</code> 这些生命周期方法。 一则我们确实不需要这么多生命周期方法，React 做了减法；二则，Concurrent 模式下，Reconciliation 阶段组件可能会被重复渲染，这些生命周期方法不能保证只被调用一次，如果在这些生命周期方法中包含副作用，会导致应用异常, 所以废弃会比较好。Vue Composition API 继续沿用 Vue 2.x 的生命周期方法.</li>
</ul>
<p><br></p>
<p>其中第一点是最重要的，也是最大的区别(思想)。这也是为什么 VCA 的 ‘Hooks’ 只需要初始化一次，不需要在每次渲染时都去调用的主要原因: <strong>基于Mutable 数据，可以保持数据的引用，不需要每次都去重新计算</strong>。</p>
<p><br><br><br></p>
<h2 id="api-设计概览"><a href="#api-设计概览" class="headerlink" title="API 设计概览"></a>API 设计概览</h2><p>先来看一下，我们的玩具(随便取名叫<strong>mpos</strong>吧)的大体设计:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 就随便取名叫 mpos 吧</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  reactive,</span><br><span class="line">  box,</span><br><span class="line">  createRef,</span><br><span class="line">  computed,</span><br><span class="line">  inject,</span><br><span class="line">  watch,</span><br><span class="line">  onMounted,</span><br><span class="line">  onUpdated,</span><br><span class="line">  onUnmount,</span><br><span class="line">  createComponent,</span><br><span class="line">  Box</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'mpos'</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface CounterProps &#123;</span><br><span class="line">  initial: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MultiplyContext = React.createContext(&#123; <span class="attr">value</span>: <span class="number">0</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 Hooks</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTitle</span>(<span class="params">title: Box&lt;string&gt;</span>) </span>&#123;</span><br><span class="line">  watch(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">document</span>.title = title.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// createComponent 创建组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createComponent&lt;CounterProps&gt;(&#123;</span><br><span class="line">  <span class="comment">// 组件名</span></span><br><span class="line">  name: <span class="string">'Counter'</span>,</span><br><span class="line">  <span class="comment">// ⚛️ 和 Vue Composition API 一样的setup，只会被调用一次</span></span><br><span class="line">  <span class="comment">// 接受组件的 props 对象, 这也是响应式对象, 可以被watch，可以获取最新值</span></span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️创建一个响应式数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> data = reactive(&#123; <span class="attr">count</span>: props.initial, <span class="attr">tick</span>: <span class="number">0</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️等价于 Vue Composition API 的 ref</span></span><br><span class="line"><span class="comment">     * 由于reactive 不能包装原始类型，box 可以帮到我们</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> name = box(<span class="string">'kobe'</span>)</span><br><span class="line">    name.set(<span class="string">'curry'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(name.get()) <span class="comment">// curry</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️衍生数据计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> derivedCount = computed(<span class="function"><span class="params">()</span> =&gt;</span> data.count * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(derivedCount.get()) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️等价于 React.createRef()，用于引用Virtual DOM 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> containerRef = createRef&lt;HTMLDivElement&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️依赖注入，获取 React.Context 值, 类似于 useContext，只不过返回一个响应式数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> ctx = inject(MultiplyContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️可以复合其他 Hooks，实现逻辑组合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    useTitle(computed(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`title: <span class="subst">$&#123;data.count&#125;</span>`</span>))</span><br><span class="line">    <span class="keyword">const</span> awesome = useYourImagination()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️生命周期方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"mounted"</span>, container.current);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 支持类似 useEffect 的方式，返回一个函数，这个函数会在卸载前被调用</span></span><br><span class="line">      <span class="comment">// 因为一般资源获取和资源释放逻辑放在一起，代码会更清晰</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"unmount"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    onUpdated(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"update"</span>, data.count, props);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里是 onUnmount，而 VCA 是 onUnmounted</span></span><br><span class="line">    onUnmount(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"unmount"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️监听数据变动, 类似于 useEffect</span></span><br><span class="line"><span class="comment">     * 返回一个disposer，可以用于显式取消监听，默认会在组件卸载时自动取消</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> stop = watch(</span><br><span class="line">      () =&gt; [data.count], <span class="comment">// 可选</span></span><br><span class="line">      ([count]) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"count change"</span>, count);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 副作用</span></span><br><span class="line">        <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> data.tick++, count)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 副作用清理（可选）, 和useEffect 保持一致，在组件卸载或者当前函数被重新调用时，调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          clearInterval(timer)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// props 是一个响应式数据</span></span><br><span class="line">    watch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"initial change"</span>, props.initial);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// context 是一个响应式数据</span></span><br><span class="line">    watch(</span><br><span class="line">      () =&gt; [ctx.value],</span><br><span class="line">      ([ctxValue], [oldCtxValue]) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"context change"</span>, ctxValue);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️方法，不需要 useCallback，永久不变</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      data.count++;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️返回一个渲染函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 在这里你也可以调用 React Hooks, 就跟普通函数组件一样</span></span><br><span class="line">      useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br><span class="line">      &#125;, [])</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">"counter"</span> onClick=&#123;add&#125; ref=&#123;containerRef&#125;&gt;</span><br><span class="line">          &#123;data.count&#125; : &#123;derivedCount.get()&#125; : &#123;data.tick&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>我不打算完全照搬 VCA，因此略有简化和差异。以下是实现的要点:</p>
<ul>
<li>① 如何确保 setup 只初始化一次?</li>
<li>② 因为 ①，我们需要将 Context、Props 这些对象进行包装成响应式数据, 确保我们总是可以拿到最新的值，避免类似 React Hook 的闭包问题.</li>
<li>③ 生命周期钩子, watch 如何绑定到组件上？我们要实现一个调用上下文</li>
<li>④ watch 数据监听和释放</li>
<li>④ Context 支持, inject 怎么实现？</li>
<li>⑤ 如何触发组件重新渲染?</li>
</ul>
<p><br></p>
<p>我们带着这些问题，一步一步来实现这个 <strong>‘React Composition API’</strong></p>
<p><br><br><br></p>
<h2 id="响应式数据和-ref"><a href="#响应式数据和-ref" class="headerlink" title="响应式数据和 ref"></a>响应式数据和 ref</h2><p>如何实现数据的响应式？不需要我们自己去造轮子，现成最好库的是 <a href="https://mobx.js.org/refguide/observable.html" target="_blank" rel="noopener"><code>MobX</code></a>。</p>
<p><code>reactive</code> 和 <code>computed</code> 以及 <code>watch</code> 都可以在 Mobx 中找到等价的API。以下是 Mobx API 和 VCA 的对照表:</p>
<p><br></p>
<table>
<thead>
<tr>
<th>Mobx</th>
<th>Vue Composition API</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>observable(object/map/array/set)</td>
<td>reactive()</td>
<td>转换响应式对象</td>
</tr>
<tr>
<td>box(原始类型)</td>
<td>ref()</td>
<td>转换原始类型为响应式对象</td>
</tr>
<tr>
<td>computed() + 返回 box 类型</td>
<td>computed() + 返回 ref 类型</td>
<td>响应式衍生状态计算</td>
</tr>
<tr>
<td>autorun(), reaction()</td>
<td>watch()</td>
<td>监听响应式对象变动</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>所以我们不需要自己去实现这些 API, 简单设置个别名:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mpos.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; observable, computed, isBoxedObservable &#125; <span class="keyword">from</span> <span class="string">'mobx'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type Box&lt;T&gt; = IObservableValue&lt;T&gt;</span><br><span class="line"><span class="keyword">export</span> type Boxes&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: T[K] extends Box&lt;infer V&gt; ? Box&lt;V&gt; : Box&lt;T[K]&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reactive = observable</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> box = reactive.box        <span class="comment">// 等价于 VCA 的 ref</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isBox = isBoxedObservabl</span><br><span class="line"><span class="keyword">export</span> &#123; computed &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于 VCA 的 toRefs, 见下文</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toBoxes</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>&gt;(<span class="params">obj: T</span>): <span class="title">Boxes</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res: Boxes&lt;T&gt; = &#123;&#125; <span class="keyword">as</span> any</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">k</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isBox(obj[k])) &#123;</span><br><span class="line">      res[k] = obj[k]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res[k] = &#123;</span><br><span class="line">        <span class="keyword">get</span>: () =&gt; obj[k],</span><br><span class="line">        <span class="keyword">set</span>: (v: any) =&gt; (obj[k] = v),</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>下面是它们的简单用法介绍(详细用法见<a href="https://mobx.js.org/refguide/observable.html" target="_blank" rel="noopener">官方文档</a>)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, box, computed &#125; <span class="keyword">from</span> <span class="string">'mpos'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ⚛️ reactive 可以用于转换 Map、Set、数组、对象为响应式数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> data = reactive(&#123;<span class="attr">foo</span>: <span class="string">'bar'</span>&#125;)</span><br><span class="line">data.foo = <span class="string">'baz'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reactive 内部使用Proxy 实现数据响应，他会返回一个新的对象，不会影响原始对象</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">firstName</span>: <span class="string">"Clive Staples"</span>, <span class="attr">lastName</span>: <span class="string">"Lewis"</span> &#125;</span><br><span class="line"><span class="keyword">const</span> person = reactive(initialState)</span><br><span class="line">person.firstName = <span class="string">'Kobe'</span></span><br><span class="line">person.firstName <span class="comment">// "Kobe"</span></span><br><span class="line">initialState.firstName <span class="comment">// "Clive Staples"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换数组</span></span><br><span class="line"><span class="keyword">const</span> arr = reactive([])</span><br><span class="line">arr.push(<span class="number">1</span>)</span><br><span class="line">arr[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ⚛️ 一般情况下都使用reactive，如果你要转换原始类型为响应式数据</span></span><br><span class="line"><span class="comment"> * 或者进行数据传递，可以用 box</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> temperature = box(<span class="number">20</span>)</span><br><span class="line">temperature.set(<span class="number">37</span>)</span><br><span class="line">temperature.get() <span class="comment">// 37</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ⚛️ 衍生数据计算, 它们也具有响应特性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> fullName = computed(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;person.firstName&#125;</span> <span class="subst">$&#123;person.lastName&#125;</span>`</span>)</span><br><span class="line">fullName.get() <span class="comment">// "Kobe Lewis"</span></span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="关于-vue-composition-api-ref"><a href="#关于-vue-composition-api-ref" class="headerlink" title="关于 Vue Composition API ref"></a>关于 Vue Composition API ref</h3><p>上面说了，<strong>VCA 的 ref 函数等价于 Mobx 的 box 函数</strong>。可以将原始类型包装为’响应式数据’(本质上就是创建一个reactive对象，监听getter/setter方法), 因此 ref 也被 称为<strong>包装对象</strong>(Mobx 的 box 命名更贴切):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>你可以这样理解, ref 内部就是一个 <code>computed</code> 封装(当然是假的):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = reactive(&#123;value&#125;)</span><br><span class="line">  <span class="keyword">return</span> computed(&#123;</span><br><span class="line">    <span class="keyword">get</span>: () =&gt; data.value,</span><br><span class="line">    <span class="keyword">set</span>: val =&gt; data.value = val</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者这样理解也可以</span><br><span class="line">function ref(value) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = reactive(&#123;value&#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> value() &#123; <span class="keyword">return</span> data.value &#125;,</span><br><span class="line">    <span class="keyword">set</span> value(val) &#123; data.value = val &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>只不过它们需要通过 <code>value</code> 属性来存取值，有时候代码显得有点啰嗦。<strong>因此 VCA 在某些地方支持对 ref 对象进行<code>自动解包(Unwrap, 也称自动展开)</code></strong>, 不过目前自动解包，仅限于读取。 例如:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1️⃣ 作为reactive 值时</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">  count                  <span class="comment">// 可以赋值给 reactive 属性</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(state.count) <span class="comment">// 0 等价于 state.count.value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动展开有时候会让人困惑，这里有个陷阱，会导致原有的 ref 对象被覆盖</span></span><br><span class="line">state.count = <span class="number">1</span>          <span class="comment">// 被覆盖掉了, count 属性现在是 1, 而不是 Ref&lt;count&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2️⃣ 传递给模板时，模板可以自动解包</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// &lt;button @click="increment"&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// &lt;button @click="increment"&gt;&#123;&#123; count.value &#125;&#125;&lt;/button&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3️⃣ 支持直接 watch</span></span><br><span class="line">watch(count, (cur, prev) =&gt; &#123; <span class="comment">// 等价于 watch(() =&gt; count.value, (cur, prev) =&gt; &#123;&#125;)</span></span><br><span class="line">  <span class="built_in">console</span>.log(cur) <span class="comment">// 直接拿到的是 ref 的值，所以不需要 cur.value 这样获取</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>另外 VCA 的 computed 实际上就是返回 ref 对象:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> double = computed(<span class="function"><span class="params">()</span> =&gt;</span> state.count * <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(double.value) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>🤔 VSA 和 Mobx 的 API 惊人的相似。想必 Vue 不少借鉴了 Mobx.</p>
<p><br><br><br></p>
<h3 id="为什么需要-ref"><a href="#为什么需要-ref" class="headerlink" title="为什么需要 ref?"></a>为什么需要 ref?</h3><p>响应式对象有一个广为人知的陷阱，如果你对响应式对象进行解构、展开，或者将具体的属性传递给变量或参数，那么可能会导致响应丢失。 看下面的例子, 思考一下响应是怎么丢失的:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = reactive(&#123;<span class="attr">count</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构, 响应丢失了.</span></span><br><span class="line"><span class="comment">// 这时候 count 只是一个普通的、值为1的变量.</span></span><br><span class="line"><span class="comment">// reactive 对象变动不会传导到 count</span></span><br><span class="line"><span class="comment">// 修改变量本身，更不会影响到原本的reactive 对象</span></span><br><span class="line"><span class="keyword">let</span> &#123; count &#125; = data</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>因为 Javascript <strong>原始值</strong>是<strong>按值传递</strong>的，这时候传递给变量、对象属性或者函数参数，引用就会丢失。<strong>为了保证 ‘安全引用’, 我们才需要用’对象’来包裹这些值，我们总是可以通过这个对象获取到最新的值</strong>:</p>
<p><img src="/images/react-composition/pass-by-reference-vs-pass-by-value-animation.gif" alt></p>
<p><br></p>
<p>关于 VCA 的 ref，还有 <a href="https://vue-composition-api-rfc.netlify.com/api.html#torefs" target="_blank" rel="noopener"><code>toRefs</code></a> 值得提一下。 <strong>toRefs 可以将 reactive 对象的每个属性都转换为 ref 对象，这样可以实现对象被解构或者展开的情况下，不丢失响应</strong>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用toRefs 转换</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123;<span class="attr">count</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> stateRef = toRefs(state) <span class="comment">// 转换成了 Reactive&lt;&#123;count: Ref&lt;state.count&gt;&#125;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时候可以安全地进行解构和传递属性</span></span><br><span class="line"><span class="keyword">const</span> &#123; count &#125; = stateRef</span><br><span class="line"></span><br><span class="line">count.value    <span class="comment">// 1</span></span><br><span class="line">state.count    <span class="comment">// 1 三者指向同一个值</span></span><br><span class="line">stateRef.count.value <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">state.count++ <span class="comment">// 更新源 state</span></span><br><span class="line">count.value   <span class="comment">// 2 响应到 ref</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>简单实现一下 toRefs, 没什么黑魔法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toRefs</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isRef(obj[key])) &#123;</span><br><span class="line">      res[key] = obj[key]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res[key] = &#123;</span><br><span class="line">        <span class="keyword">get</span> value() &#123;</span><br><span class="line">          <span class="keyword">return</span> obj[key]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span> value(val) &#123;</span><br><span class="line">          obj[key] = val</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>toRefs 解决 reactive 对象属性值解构和展开导致响应丢失问题。配合<strong>自动解包</strong>，不至于让代码变得啰嗦(尽管有限制).</p>
<p><br></p>
<p> <strong>对于 VCA 来说，① ref 除了可以用于封装原始类型，更重要的一点是：② 它是一个’规范’的数据载体，它可以在 Hooks 之间进行数据传递；也可以暴露给组件层，用于引用一些对象，例如引用DOM组件实例</strong>。</p>
<p>举个例子, 下面的 <code>useOnline</code> Hook, 这个 Hooks 只返回一个状态:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useOnline</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> online = ref(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  online.value = navigator.onLine</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleOnline = <span class="function"><span class="params">()</span> =&gt;</span> (online.value = <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">const</span> handleOffline = <span class="function"><span class="params">()</span> =&gt;</span> (online.value = <span class="literal">false</span>)</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'online'</span>, handleOnline)</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'offline'</span>, handleOffline)</span><br><span class="line"></span><br><span class="line">  onUnmounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'online'</span>, handleOnline)</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'offline'</span>, handleOffline)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个 ref</span></span><br><span class="line">  <span class="comment">// 如果这时候返回一个 reactive 对象，会显得有点奇怪</span></span><br><span class="line">  <span class="keyword">return</span> online</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>如果 useOnline 返回一个 reactive 对象, 会显得有点怪:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样子？ online 可能会丢失响应</span></span><br><span class="line"><span class="keyword">const</span> &#123; online &#125; = useOnline() <span class="comment">// 返回 Reactive&lt;&#123;online: boolean&#125;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 怎么确定属性命名？</span></span><br><span class="line"><span class="keyword">const</span> online = useOnline()</span><br><span class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> online.online)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以我们需要规范，这个规范可以帮我们规避陷阱，也统一了使用方式</span></span><br><span class="line"><span class="comment">// 更规范的返回一个 ref，使用 value 来获取值</span></span><br><span class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> online.value)</span><br><span class="line"><span class="comment">// 可以更方便地进行监听</span></span><br><span class="line">wacth(online, (ol) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 直接拿到 online.value</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>再看另一个返回多个值的例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMousePosition</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pos = reactive(&#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;)</span><br><span class="line">  <span class="keyword">const</span> update = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    pos.x = e.pageX</span><br><span class="line">    pos.y = e.pageY</span><br><span class="line">  &#125;</span><br><span class="line">  onMounted(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">window</span>.addEventListener(<span class="string">'mousemove'</span>, update))</span><br><span class="line">  onUnmounted(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">window</span>.removeEventListener(<span class="string">'mousemove'</span>, update))</span><br><span class="line">  <span class="comment">// 返回多个值，可以使用 toRefs 批量转换</span></span><br><span class="line">  <span class="keyword">return</span> toRefs(pos)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyHook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 安全地使用解构表达式</span></span><br><span class="line">  <span class="keyword">const</span> &#123; x, y &#125; = useMousePosition()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... do something</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 安全地输出</span></span><br><span class="line">  <span class="keyword">return</span> &#123; x, y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>因此官方也推荐使用 ref 对象来进行数据传递，同时保持响应的传导</strong>。就到这吧，不然写着写着就变成 VCA 的文档了🌚。</p>
<p><br><br><br></p>
<h3 id="ref-和-useref"><a href="#ref-和-useref" class="headerlink" title="ref 和 useRef"></a>ref 和 useRef</h3><p>VCA ref 这个命名会让 React 开发者将其和 <code>useRef</code> 联想在一起。的确，VCA 的 ref 在结构、功能和职责上跟 React 的 useRef 很像。例如 <a href="https://vue-composition-api-rfc.netlify.com/api.html#template-refs" target="_blank" rel="noopener">ref 也可以用于引用 Virtual DOM的节点实例</a>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> root = ref(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with JSX</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &lt;div ref=&#123;root&#125;/&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>为了避免和现有的 useRef 冲突，而且在我们也不打算实现 ref 自动解包诸如此类的功能。因此在我们会沿用 Mobx 的 box 命名，对应的还有isBox, toBoxes 函数。</p>
<p><br></p>
<p>那怎么引用 Virtual DOM 节点呢？ 我们可以使用 React 的 <a href="https://reactjs.org/docs/react-api.html#reactcreateref" target="_blank" rel="noopener"><code>createRef()</code></a> 函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React 代码</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRef &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line">createComponent(&#123;</span><br><span class="line">  setup(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> containerRef = createRef()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &lt;div className=<span class="string">"container"</span> ref=&#123;containerRef&#125;&gt;?...?<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h2><p>接下来看看怎么实现 useMounted 这些生命周期方法。这些方法是全局、通用的，怎么关联到具体的组件上呢？</p>
<p>这个可以借鉴 React Hooks 的实现，当 setup() 被调用时，在一个全局变量中保存当前组件的上下文，生命周期方法再从这个上下文中存取信息。</p>
<p>来看一下 initial 的大概实现:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⚛️ 全局变量, 表示当前正在执行的 setup 的上下文</span></span><br><span class="line"><span class="keyword">let</span> compositionContext: CompositionContext | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * initial 方法接受一个 setup 方法， 返回一个 useComposition Hooks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initial</span>&lt;<span class="title">Props</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">Rtn</span>, <span class="title">Ref</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  setup: (props: Props</span>) =&gt; <span class="title">Rtn</span>,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">useComposition</span>(<span class="params">props: Props, ref?: React.RefObject&lt;Ref&gt;</span>): <span class="title">Rtn</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ⚛️ 使用 useRef 用来保存当前的上下文信息。 useRef，可以保证引用不变</span></span><br><span class="line">    <span class="keyword">const</span> context = useRef&lt;CompositionContext | <span class="literal">undefined</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前上下文为空，则开始初始化</span></span><br><span class="line">    <span class="comment">// ⚛️ 我们这样实现了 setup 只被调用一次!</span></span><br><span class="line">    <span class="keyword">if</span> (context.current == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 创建 Composition 上下文</span></span><br><span class="line">      <span class="keyword">const</span> ctx = (context.current = createCompositionContext(props));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ 进入当前组件的上下文作用域</span></span><br><span class="line">      <span class="keyword">const</span> prevCtx = compositionContext;</span><br><span class="line">      compositionContext = ctx;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ **调用 setup, 并缓存返回值**</span></span><br><span class="line">      ctx._instance = setup(ctx._props);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ 离开当前组件的上下文作用域, 恢复</span></span><br><span class="line">      compositionContext = prevCtx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他，下文展开</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 setup 的返回值</span></span><br><span class="line">    <span class="keyword">return</span> context.current._instance!;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>Ok，现在生命周期方法实现原理已经浮出水面, 当这些方法被调用时，只是简单地在 compositionContext 中注册回调, 例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">onMounted</span>(<span class="params">cb: (</span>) =&gt; <span class="title">any</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️ 获取当前上下文</span></span><br><span class="line">  <span class="keyword">const</span> ctx = assertCompositionContext();</span><br><span class="line">  <span class="comment">// 注册回调</span></span><br><span class="line">  ctx.addMounted(cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">onUnmount</span>(<span class="params">cb: (</span>) =&gt; <span class="title">void</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = assertCompositionContext();</span><br><span class="line">  ctx.addDisposer(cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">onUpdated</span>(<span class="params">cb: (</span>) =&gt; <span class="title">void</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = assertCompositionContext();</span><br><span class="line">  ctx.addUpdater(cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>assertCompositionContext 获取 compositionContext，如果不在 <code>setup</code> 作用域下调用则抛出异常.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertCompositionContext</span>(<span class="params"></span>): <span class="title">CompositionContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (compositionContext == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`请在 setup 作用域使用`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> compositionContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>看一下 CompositionContext 接口的外形:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface CompositionContext&lt;P = any, R = any&gt; &#123;</span><br><span class="line">  <span class="comment">// 添加挂载回调</span></span><br><span class="line">  addMounted: <span class="function">(<span class="params">cb: (</span>) =&gt;</span> any) =&gt; <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 添加重新渲染回调</span></span><br><span class="line">  addUpdater: <span class="function">(<span class="params">cb: (</span>) =&gt;</span> <span class="keyword">void</span>) =&gt; <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 添加卸载回调</span></span><br><span class="line">  addDisposer: <span class="function">(<span class="params">cb: (</span>) =&gt;</span> <span class="keyword">void</span>) =&gt; <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 注册 React.Context 下文会介绍</span></span><br><span class="line">  addContext: &lt;T&gt;(ctx: React.Context&lt;T&gt;) =&gt; T;</span><br><span class="line">  // 添加通过ref暴露给外部的对象, 下文会介绍</span><br><span class="line">  addExpose: (value: any) =&gt; void</span><br><span class="line"></span><br><span class="line">  /** 私有属性 **/</span><br><span class="line">  // props 引用</span><br><span class="line">  _props: P;</span><br><span class="line">  // 表示是否已挂载</span><br><span class="line">  _isMounted: boolean;</span><br><span class="line">  // setup() 的返回值</span><br><span class="line">  _instance?: R;</span><br><span class="line">  _disposers: Array&lt;() =&gt; void&gt;;</span><br><span class="line">  _mounted: Array&lt;() =&gt; any&gt;;</span><br><span class="line">  _updater: Array&lt;() =&gt; void&gt;;</span><br><span class="line">  _contexts: Map&lt;React.Context&lt;any&gt;, &#123; value: any; updater: () =&gt; void &#125;&gt;</span><br><span class="line">  _exposer?: () =&gt; any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><code>addMounted</code>、<code>addUpdater</code> 这些方法实现都很简单, 只是简单添加到队列中:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCompositionContext</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt;(<span class="params">props: P</span>): <span class="title">CompositionContext</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = &#123;</span><br><span class="line">    addMounted: <span class="function"><span class="params">cb</span> =&gt;</span> ctx._mounted.push(cb),</span><br><span class="line">    addUpdater: <span class="function"><span class="params">cb</span> =&gt;</span> ctx._updater.push(cb),</span><br><span class="line">    addDisposer: <span class="function"><span class="params">cb</span> =&gt;</span> ctx._disposers.push(cb),</span><br><span class="line">    addContext: <span class="function"><span class="params">c</span> =&gt;</span> &#123;<span class="comment">/* ...  */</span>&#125; ,</span><br><span class="line">    _isMounted: <span class="literal">false</span>,</span><br><span class="line">    _instance: <span class="literal">undefined</span>,</span><br><span class="line">    _mounted: [],</span><br><span class="line">    _updater: [],</span><br><span class="line">    _disposers: [],</span><br><span class="line">    _contexts: <span class="keyword">new</span> <span class="built_in">Map</span>(),</span><br><span class="line">    _props: observable(props, &#123;&#125;, &#123; <span class="attr">deep</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">"props"</span> &#125;)</span><br><span class="line">    _exposer: <span class="literal">undefined</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>关键实现还是得回到 initial 方法中:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initial</span>&lt;<span class="title">Props</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">Rtn</span>, <span class="title">Ref</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  setup: (props: Props</span>) =&gt; <span class="title">Rtn</span>,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">useComposition</span>(<span class="params">props: Props, ref?: React.RefObject&lt;Ref&gt;</span>): <span class="title">Rtn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = useRef&lt;CompositionContext | <span class="literal">undefined</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context.current == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 初始化....</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 每次重新渲染, 调用 onUpdated 生命周期钩子</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> ctx = context.current;</span><br><span class="line">      <span class="comment">// 首次挂载时不调用</span></span><br><span class="line">      <span class="keyword">if</span> (ctx._isMounted) executeCallbacks(ctx._updater);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 挂载</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> ctx = context.current;</span><br><span class="line">      ctx._isMounted = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ 调用 useMounted 生命周期钩子</span></span><br><span class="line">      <span class="keyword">if</span> (ctx._mounted.length) &#123;</span><br><span class="line">        ctx._mounted.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// ⚛️ useMounted 如果返回一个函数，则添加到disposer中，卸载前调用</span></span><br><span class="line">          <span class="keyword">const</span> rt = cb();</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> rt === <span class="string">"function"</span>) &#123;</span><br><span class="line">            ctx.addDisposer(rt);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ctx._mounted = EMPTY_ARRAY; <span class="comment">// 释放掉</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ 调用 onUnmount 生命周期钩子</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> executeCallbacks(ctx._disposers);</span><br><span class="line">    &#125;, []);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>没错，这些生命周期方法，最终还是用 useEffect 来实现。</p>
<p><br><br><br></p>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>接下来看看 watch 方法的实现。watch 估计是除了 reactive 和 ref 之外调用的最频繁的函数了。</p>
<p>watch 方法可以通过 Mobx 的 <code>authrun</code> 和 <code>reaction</code> 方法来实现。我们进行简单的封装，让它更接近 Vue 的watch 函数的行为。</p>
<p>这里有一个要点是: watch 即可以在setup 上下文中调用，也可以裸露调用。在setup 上下文调用时，支持组件卸载前自动释放监听。 如果裸露调用，则需要开发者自己来释放监听:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 setup 上下文中调用，watch 会在组件卸载后自动解除监听</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyHook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = reactive(&#123;<span class="attr">count</span>: <span class="number">0</span>&#125;)</span><br><span class="line">  watch(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'count change'</span>, data.count))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 裸露调用，需要手动管理资源释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> stop = watch(<span class="function"><span class="params">()</span> =&gt;</span> someReactiveData, (data) =&gt; &#123;<span class="comment">/* reactiveData change */</span>&#125;)</span><br><span class="line">dosomething(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 手动释放</span></span><br><span class="line">  stop()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 另外watch 回调内部也可以获取到 stop 方法</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">wacth(<span class="function">(<span class="params">stop</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (someReactiveData === <span class="number">0</span>) &#123;</span><br><span class="line">    stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> someReactiveData, (data, stop) =&gt; &#123;<span class="comment">/* reactiveData change */</span>&#125;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>另外 watch 的回调支持返回一个函数，用来释放副作用资源，这个行为和 useEffect 保持一致。VCA 的 watch 使用onClean 回调来释放资源，因为考虑到 async/await 函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="comment">/* do something*/</span>&#125;, time)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearInterval(timer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [time])</span><br><span class="line"></span><br><span class="line"><span class="comment">// watch</span></span><br><span class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="comment">/* do something*/</span>&#125;, time)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearInterval(timer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>看看实现代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reaction, autorun&#125; <span class="keyword">from</span> <span class="string">'mobx'</span></span><br><span class="line"><span class="keyword">export</span> type WatchDisposer = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">watch</span>(<span class="params">view: (stop: WatchDisposer</span>) =&gt; <span class="title">any</span>, <span class="title">options</span>?: <span class="title">IAutorunOptions</span>): <span class="title">WatchDisposer</span>;</span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">function</span> <span class="title">watch</span>&lt;<span class="title">T</span>&gt;(<span class="params">expression: (</span>) =&gt; <span class="title">T</span>, <span class="title">effect</span>: (<span class="params">arg: T, stop: WatchDisposer</span>) =&gt; <span class="title">any</span>, <span class="title">options</span>?: <span class="title">IReactionOptions</span>): <span class="title">WatchDisposer</span>;</span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">function</span> <span class="title">watch</span>(<span class="params">expression: any, effect: any, options?: any</span>): <span class="title">WatchDisposer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 放置 autorun 或者 reactive 返回的释放函数</span></span><br><span class="line">  <span class="keyword">let</span> nativeDisposer: WatchDisposer;</span><br><span class="line">  <span class="comment">// 放置上一次 watch 回调返回的副作用释放函数</span></span><br><span class="line">  <span class="keyword">let</span> effectDisposer: WatchDisposer | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 是否已经释放</span></span><br><span class="line">  <span class="keyword">let</span> disposed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装释放函数，支持被重复调用</span></span><br><span class="line">  <span class="keyword">const</span> stop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (disposed) <span class="keyword">return</span>;</span><br><span class="line">    disposed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (effectDisposer) effectDisposer();</span><br><span class="line">    nativeDisposer();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装回调方法</span></span><br><span class="line">  <span class="keyword">const</span> effectWrapper = <span class="function">(<span class="params">effect: (...args: any[]</span>) =&gt;</span> any, <span class="attr">argnum</span>: number) =&gt; (</span><br><span class="line">    ...args: any[]</span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 重新执行了回调，释放上一个回调返回的释放方法</span></span><br><span class="line">    <span class="keyword">if</span> (effectDisposer != <span class="literal">null</span>) effectDisposer();</span><br><span class="line">    <span class="keyword">const</span> rtn = effect.apply(<span class="literal">null</span>, args.slice(<span class="number">0</span>, argnum).concat(stop));</span><br><span class="line">    effectDisposer = <span class="keyword">typeof</span> rtn === <span class="string">"function"</span> ? rtn : <span class="literal">undefined</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> expression === <span class="string">"function"</span> &amp;&amp; <span class="keyword">typeof</span> effect === <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="comment">// reaction</span></span><br><span class="line">    nativeDisposer = reaction(expression, effectWrapper(effect, <span class="number">1</span>), options);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// autorun</span></span><br><span class="line">    nativeDisposer = autorun(effectWrapper(expression, <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果在 setup 上下文则添加到disposer 队列，在组件卸载时自动释放</span></span><br><span class="line">  <span class="keyword">if</span> (compositionContext) &#123;</span><br><span class="line">    compositionContext.addDisposer(stop);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> stop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>DONE!</p>
<p><br><br><br></p>
<h2 id="包装-props-为响应式数据"><a href="#包装-props-为响应式数据" class="headerlink" title="包装 Props 为响应式数据"></a>包装 Props 为响应式数据</h2><p>React 组件每次重新渲染都会生成一个新的 Props 对象，所以无法直接在 setup 中使用，我们需要将其转换为一个可以安全引用的对象，然后在每次重新渲染时更新这个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">set</span> &#125; from 'mobx'</span><br><span class="line"></span><br><span class="line">export function initial&lt;Props extends object, Rtn, Ref&gt;(setup: (props: Props) =&gt; Rtn) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">useComposition</span>(<span class="params">props: Props, ref?: React.RefObject&lt;Ref&gt;</span>): <span class="title">Rtn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = useRef&lt;CompositionContext | <span class="literal">undefined</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">if</span> (context.current == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ⚛️ createCompositoonContext 会将props 转换为一个响应式数据, 而且这里是浅层转换</span></span><br><span class="line">      <span class="comment">// _props: observable(props, &#123;&#125;, &#123; deep: false, name: "props" &#125;)</span></span><br><span class="line">      <span class="keyword">const</span> ctx = (context.current = createCompositionContext(props));</span><br><span class="line">      <span class="keyword">const</span> prevCtx = compositionContext;</span><br><span class="line">      compositionContext = ctx;</span><br><span class="line">      ctx._instance = setup(ctx._props);</span><br><span class="line">      compositionContext = prevCtx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 每次重新渲染时更新, props 属性</span></span><br><span class="line">    <span class="keyword">set</span>(context.current._props, props);</span><br><span class="line"></span><br><span class="line">    return context.current._instance!;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="支持-context-注入"><a href="#支持-context-注入" class="headerlink" title="支持 Context 注入"></a>支持 Context 注入</h2><p>和 VCA 一样，我们通过 <code>inject</code> 支持依赖注入，不同的是我们的 <code>inject</code> 方法接收一个 <a href="https://reactjs.org/docs/context.html#contextprovider" target="_blank" rel="noopener"><code>React.Context</code></a> 对象。<code>inject</code> 可以从 Context 对象中推断出注入的类型。</p>
<p>另外受限于 React 的 Context 机制，我们没有实现 provider 函数，用户直接使用 Context.Provider 组件即可。</p>
<p>实现 Context 的注入还是得费点事，我们会利用 React 的 <a href="https://reactjs.org/docs/hooks-reference.html#usecontext" target="_blank" rel="noopener"><code>useContext</code></a> Hook 来实现，因此必须保证 <code>useContext</code> 的调用顺序。</p>
<p>和生命周期方法一样，调用 inject 时，将 Context 推入队列中, 只不过我们会立即调用一次 useContext 获取到值:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">inject</span>&lt;<span class="title">T</span>&gt;(<span class="params">Context: React.Context&lt;T&gt;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = assertCompositionContext();</span><br><span class="line">  <span class="comment">// ⚛️ 马上获取值</span></span><br><span class="line">  <span class="keyword">return</span> ctx.addContext(Context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>为了避免重复的 useContext 调用, 同时保证插入的顺序，我们使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="noopener"><code>Map</code></a> 来保存 Context 引用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCompositionContext</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt;(<span class="params">props: P</span>): <span class="title">CompositionContext</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = &#123;</span><br><span class="line">    _isMounted: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// ⚛️ 使用 Map 保存</span></span><br><span class="line">    _contexts: <span class="keyword">new</span> <span class="built_in">Map</span>(),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 注册Context</span></span><br><span class="line">    addContext: <span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ⚛️ 已添加</span></span><br><span class="line">      <span class="keyword">if</span> (ctx._contexts.has(c)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx._contexts.get(c)!.value</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ 首次使用立即调用 useContext 获取 Context 的值</span></span><br><span class="line">      <span class="keyword">let</span> value = useContext(c)</span><br><span class="line">      <span class="comment">// ⚛️ 和 Props 一样转换为 响应式数据, 让 setup 可以安全地引用</span></span><br><span class="line">      <span class="keyword">const</span> wrapped = observable(value, &#123;&#125;, &#123; <span class="attr">deep</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">"context"</span> &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ 插入到队列</span></span><br><span class="line">      ctx._contexts.set(c, &#123;</span><br><span class="line">        value: wrapped,</span><br><span class="line">        <span class="comment">// ⚛️ 更新器，这个会在组件挂载之后的每次重新渲染时调用</span></span><br><span class="line">        <span class="comment">// 我们需要保证 useContext 的调用顺序</span></span><br><span class="line">        updater: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// ⚛️ 依旧是调用 useContetxt 重新获取 Context 值</span></span><br><span class="line">          <span class="keyword">const</span> newValue = useContext(c)</span><br><span class="line">          <span class="keyword">if</span> (newValue !== value) &#123;</span><br><span class="line">            <span class="keyword">set</span>(wrapped, newValue)</span><br><span class="line">            value = newValue</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      return wrapped as any</span><br><span class="line">    &#125;,</span><br><span class="line">    // ....</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>回到 setup 函数，我们必须保证每一次渲染时都按照一样的次序调用 useContext：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initial</span>&lt;<span class="title">Props</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">Rtn</span>, <span class="title">Ref</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  setup: (props: Props</span>) =&gt; <span class="title">Rtn</span>,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">useComposition</span>(<span class="params">props: Props, ref?: React.RefObject&lt;Ref&gt;</span>): <span class="title">Rtn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = useRef&lt;CompositionContext | <span class="literal">undefined</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">if</span> (context.current == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> ctx = (context.current = createCompositionContext(props))</span><br><span class="line">      <span class="keyword">const</span> prevCtx = compositionContext</span><br><span class="line">      compositionContext = ctx</span><br><span class="line">      ctx._instance = setup(ctx._props)</span><br><span class="line">      compositionContext = prevCtx</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 一定要在其他 React Hooks 之前调用</span></span><br><span class="line">    <span class="comment">// 因为在 setup 调用的过程中已经调用了 useContext，所以只在挂载之后的重新渲染中才调用更新</span></span><br><span class="line">    <span class="keyword">if</span> (context.current._contexts.size &amp;&amp; context.current._isMounted) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> &#123; updater &#125; <span class="keyword">of</span> context.current._contexts.values()) &#123;</span><br><span class="line">        updater()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>DONE!</p>
<p><br><br><br></p>
<h2 id="跟踪组件依赖并触发重新渲染"><a href="#跟踪组件依赖并触发重新渲染" class="headerlink" title="跟踪组件依赖并触发重新渲染"></a>跟踪组件依赖并触发重新渲染</h2><p>基本接口已经准备就绪了，现在如何和 React 组件建立关联，在响应式数据更新后触发组件重新渲染?</p>
<p>Mobx 有一个库可以用来绑定 React 组件, 它就是 <a href="https://github.com/mobxjs/mobx-react-lite" target="_blank" rel="noopener"><code>mobx-react-lite</code></a>, 有了它, 我们可以监听响应式变化并触发组件重新渲染。用法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">'mobx-react-lite'</span></span><br><span class="line"><span class="keyword">import</span> &#123; initial &#125; <span class="keyword">from</span> <span class="string">'mpos'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useComposition = initial(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;<span class="comment">/* setup */</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> YouComponent = observer(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> state = useComposition(props)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;state.data.count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>How it work? 如果这样一笔带过，估计很多读者会很扫兴，自己写一个 <code>observer</code> 也不难。我们可以参考 <a href="https://github.com/mobxjs/mobx-react" target="_blank" rel="noopener">mobx-react</a> 或者 mobx-react-lite 的实现。</p>
<p>它们都将渲染函数放在 <code>track</code> 函数的上下文下，track函数可以跟踪渲染函数依赖了哪些数据，当这些数据变动时，强制进行组件更新:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC , useRef, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Reaction &#125; <span class="keyword">from</span> <span class="string">'mobx'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span>&lt;<span class="title">Props</span> <span class="title">extends</span> </span>&#123;&#125;, Ref = <span class="keyword">void</span>&gt;(options: &#123;</span><br><span class="line">  name?: string</span><br><span class="line">  setup: <span class="function">(<span class="params">props: Props</span>) =&gt;</span> () =&gt; React.ReactElement</span><br><span class="line">  forwardRef?: boolean</span><br><span class="line">&#125;): FC&lt;Props&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; setup, name, forwardRef &#125; = options</span><br><span class="line">  <span class="comment">// ⚛️ 创建 useComposition Hook</span></span><br><span class="line">  <span class="keyword">const</span> useComposition = initial(setup)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Comp = <span class="function">(<span class="params">props: Props, ref: React.RefObject&lt;Ref&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 用于强制更新组件, 实现很简单，就是递增 useState 的值</span></span><br><span class="line">    <span class="keyword">const</span> forceUpdate = useForceUpdate()</span><br><span class="line">    <span class="keyword">const</span> reactionRef = useRef&lt;&#123; <span class="attr">reaction</span>: Reaction, <span class="attr">disposer</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span> &#125; | <span class="literal">null</span>&gt;(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> render = useComposition(props, forwardRef ? ref : <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建跟踪器</span></span><br><span class="line">    <span class="keyword">if</span> (reactionRef.current == <span class="literal">null</span>) &#123;</span><br><span class="line">      reactionRef.current = &#123;</span><br><span class="line">        <span class="comment">// ⚛️ 在依赖更新时，调用 forceUpdate 强制重新渲染</span></span><br><span class="line">        reaction: <span class="keyword">new</span> Reaction(<span class="string">`observer(<span class="subst">$&#123;name || <span class="string">"Unknown"</span>&#125;</span>)`</span>, () =&gt;  forceUpdate()),</span><br><span class="line">        <span class="comment">// 释放跟踪器</span></span><br><span class="line">        disposer: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (reactionRef.current &amp;&amp; !reactionRef.current.reaction.isDisposed) &#123;</span><br><span class="line">            reactionRef.current.reaction.dispose()</span><br><span class="line">            reactionRef.current = <span class="literal">null</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> () =&gt; reactionRef.current &amp;&amp; reactionRef.current.disposer(), [])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> rendering</span><br><span class="line">    <span class="keyword">let</span> error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 将 render 函数放在track 作用域下，收集 render 函数的数据依赖</span></span><br><span class="line">    reactionRef.current.reaction.track(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        rendering = render(props, inst)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        error = err</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      reactionRef.current.disposer()</span><br><span class="line">      <span class="keyword">throw</span> error</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rendering</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>接着，我们将 Comp 组件包裹在 React.memo 下，避免不必要重新渲染:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span>&lt;<span class="title">Props</span> <span class="title">extends</span> </span>&#123;&#125;, Ref = <span class="keyword">void</span>&gt;(options: &#123;</span><br><span class="line">  name?: string</span><br><span class="line">  setup: <span class="function">(<span class="params">props: Props</span>) =&gt;</span> () =&gt; React.ReactElement</span><br><span class="line">  forwardRef?: boolean</span><br><span class="line">&#125;): FC&lt;Props&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; setup, name, forwardRef &#125; = options</span><br><span class="line">  <span class="comment">// 创建 useComposition Hook</span></span><br><span class="line">  <span class="keyword">const</span> useComposition = initial(setup)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Comp = <span class="function">(<span class="params">props: Props, ref: React.RefObject&lt;Ref&gt;</span>) =&gt;</span> &#123;<span class="comment">/**/</span>&#125;</span><br><span class="line"></span><br><span class="line">  Comp.displayName = <span class="string">`Composition(<span class="subst">$&#123;name || <span class="string">"Unknown"</span>&#125;</span>)`</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> finalComp</span><br><span class="line">  <span class="keyword">if</span> (forwardRef) &#123;</span><br><span class="line">    <span class="comment">// 支持转发 ref</span></span><br><span class="line">    finalComp = React.memo(React.forwardRef(Comp))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    finalComp = React.memo(Comp)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  finalComp.displayName = name</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> finalComp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="forwardref-处理"><a href="#forwardref-处理" class="headerlink" title="forwardRef 处理"></a>forwardRef 处理</h2><p>最后一步了，有些时候我们的组件需要通过 ref 向外部暴露一些状态和方法。在Hooks 中我们使用 <code>useImperativeHandle</code> 来实现:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyInput</span>(<span class="params">props, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class="line">    focus: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">...</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">FancyInput = forwardRef(FancyInput);</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>在我们的玩具中，我们自定义一个新的函数 <code>expose</code> 来暴露我们的公开接口：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  expose(&#123;</span><br><span class="line">    somePublicAPI: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">expose</span>(<span class="params">value: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = assertCompositionContext();</span><br><span class="line">  ctx.addExpose(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>关键是 useComposition 的处理:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initial</span>&lt;<span class="title">Props</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">Rtn</span>, <span class="title">Ref</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  setup: (props: Props</span>) =&gt; <span class="title">Rtn</span>,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">useComposition</span>(<span class="params">props: Props, ref?: React.RefObject&lt;Ref&gt;</span>): <span class="title">Rtn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = useRef&lt;CompositionContext | <span class="literal">undefined</span>&gt;()</span><br><span class="line">    <span class="keyword">if</span> (context.current == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 初始化...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... useContext</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 如果传递了ref 且 调用了 expose 函数</span></span><br><span class="line">    <span class="comment">// 则使用useImperativeHandle 暴露给 ref</span></span><br><span class="line">    <span class="keyword">if</span> (ref &amp;&amp; context.current._exposer != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 只在 _exposer 变动后更新</span></span><br><span class="line">      useImperativeHandle(ref, context.current._exposer, [context.current._exposer]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>🎉🎉 搞定，<strong>所有代码都在这个 <a href="https://codesandbox.io/s/mobx-vue-composition-api-ft9mv?fontsize=14" target="_blank" rel="noopener">CodeSandbox</a> 中，大家可以自行体验</strong>. 🎉🎉 </p>
<p><br><br><br></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，这只是一个玩具🎃！整个过程也不过百来行代码。</p>
<p>就如标题所说的，通过这个玩具，学到很多奇淫巧技，你对 React Hooks 以及 Vue Composition API 的了解应该更深了吧？ <strong>之所以是个玩具，是因为它还有一些缺陷，不够 ’React‘, 又不够 ‘Vue’！只能以学习的目的自个玩玩! 而且搞这玩意, 搞不好可能在两个社区都会被喷</strong>。所以我话就撂这了，你们就不要在评论区喷了。</p>
<p><br></p>
<p>如果你了解过 <a href="https://juejin.im/post/5dadc6045188255a270a0f85#heading-13" target="_blank" rel="noopener">React Concurrent 模式</a>，你会发现这个架构是 React 自身的状态更新机制是深入绑定的。React 自身的setState 状态更新粒度更小、可以进行优先级调度、Suspense、可以通过 useTransition + Suspense 配合进入 Pending 状态、在’平行宇宙’中进行渲染。 <strong>React 自身的状态更新机制和组件的渲染体系是深度集成</strong>。</p>
<p>因此我们现在监听响应式数据，然后粗暴地 <code>forceUpdate</code>，会让我们丢失部分 React Concurrent 模式带来的红利。除此之外、开发者工具的集成、生态圈、Benchmark…</p>
<p>说到生态圈，如果你将这个玩具的 API 保持和 VCA 完全兼容，那么以后 Vue 社区的 Hooks 库也可以为你所用，想想脑洞挺大。</p>
<p><br></p>
<p><strong>搞这一套还不如直接上 Vue 是吧</strong>？毕竟 Vue 天生集成响应式数据，跟 React 的不可变数据一样, <strong>Vue 的响应式更新机制和其组件渲染体系是深度集成的</strong>。 整个工作链路自顶向下, 从数据到模板、再到底层组件渲染, 对响应式数据有更好、更高效地融合。</p>
<p>尽管如此，React 的灵活性、开放、多范式编程方式、创造力还是让人赞叹。(仅代表我作为React爱好者的立场)</p>
<p><br></p>
<p><strong>另外响应式机制也不是完全没有心智负担</strong>，最起码你要了解响应式数据的原理，知道什么可以被响应，什么不可以：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如不能使用解构和展开表达式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyHook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将count 拷贝给(按值传递) count变量，这会导致响应丢失，下游无法响应count 的变化</span></span><br><span class="line">  <span class="keyword">const</span> &#123; count &#125; = reactive(&#123;<span class="attr">count</span>: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; count &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有响应式数据转换成本，诸如此类的，网上也有大量的资料, 这里就不赘述了。 关于响应式数据需要注意的东西可以参考这些资料:</p>
<ul>
<li><a href="https://vue-composition-api-rfc.netlify.com/#plugin-development" target="_blank" rel="noopener">Vue Composition API Drawbacks</a></li>
<li><a href="https://mobx.js.org/best/react.html" target="_blank" rel="noopener">What does MobX react to?</a></li>
<li><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">Vue: 深入响应式原理</a></li>
</ul>
<p>除此之外，你有时候会纠结什么时候应该使用 reactive，什么时候应该使用 ref…</p>
<p>没有银弹，没有银弹。</p>
<p><br></p>
<p>最后的最后， <strong>useYourImagination</strong>, React Hooks 早已在 React 社区玩出了花🌸，Vue Composition API 完全可以将这些模式拿过来用，两个从结构和逻辑上都是差不多的，只不过换一下 ‘Mutable’ 的数据操作方式。安利 <a href="https://juejin.im/post/5d594ea5518825041301bbcb" target="_blank" rel="noopener">2019年了，整理了N个实用案例帮你快速迁移到React Hooks</a></p>
<p><br></p>
<p>我是荒山，觉得文章可以，请点个赞，下篇文章见！</p>
<p><br><br><br></p>
<h2 id="参考-扩展"><a href="#参考-扩展" class="headerlink" title="参考/扩展"></a>参考/扩展</h2><ul>
<li><a href="https://codesandbox.io/s/mobx-vue-composition-api-ft9mv?fontsize=14" target="_blank" rel="noopener"><strong>🎉本文源码：CodeSandbox</strong></a></li>
<li><a href="https://vue-composition-api-rfc.netlify.com/" target="_blank" rel="noopener"><strong>Vue Composition API RFC</strong></a></li>
<li><a href="https://zhuanlan.zhihu.com/p/68477600" target="_blank" rel="noopener">Vue Function-based API RFC 中文</a> 有点过时，不影响理解</li>
<li><a href="https://github.com/vuejs/composition-api" target="_blank" rel="noopener">@vue/composition-api</a></li>
<li><a href="https://mobx.js.org/" target="_blank" rel="noopener">Mobx</a></li>
<li><a href="https://github.com/kefranabg/awesome-vue-composition-api" target="_blank" rel="noopener">awesome-vue-composition-api</a></li>
<li><a href="https://codesandbox.io/s/github/nuxt/typescript/tree/master/examples/composition-api/minimal" target="_blank" rel="noopener">Vue Composition API CodeSandbox Playground</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/71667382" target="_blank" rel="noopener">精读《Vue3.0 Function API》</a></li>
</ul>
<p><br></p>
<p><img src="/images/sponsor.jpg" alt></p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#对比-react-hooks-和-vue-composition-api"><span class="toc-number">1.</span> <span class="toc-text">对比 React Hooks 和 Vue Composition API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本-api-类比"><span class="toc-number">1.1.</span> <span class="toc-text">基本 API 类比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#api-设计概览"><span class="toc-number">2.</span> <span class="toc-text">API 设计概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#响应式数据和-ref"><span class="toc-number">3.</span> <span class="toc-text">响应式数据和 ref</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关于-vue-composition-api-ref"><span class="toc-number">3.1.</span> <span class="toc-text">关于 Vue Composition API ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么需要-ref"><span class="toc-number">3.2.</span> <span class="toc-text">为什么需要 ref?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref-和-useref"><span class="toc-number">3.3.</span> <span class="toc-text">ref 和 useRef</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生命周期方法"><span class="toc-number">4.</span> <span class="toc-text">生命周期方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#watch"><span class="toc-number">5.</span> <span class="toc-text">watch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#包装-props-为响应式数据"><span class="toc-number">6.</span> <span class="toc-text">包装 Props 为响应式数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#支持-context-注入"><span class="toc-number">7.</span> <span class="toc-text">支持 Context 注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#跟踪组件依赖并触发重新渲染"><span class="toc-number">8.</span> <span class="toc-text">跟踪组件依赖并触发重新渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#forwardref-处理"><span class="toc-number">9.</span> <span class="toc-text">forwardRef 处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">10.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考-扩展"><span class="toc-number">11.</span> <span class="toc-text">参考/扩展</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2019/11/04/react-composition/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2019/11/04/react-composition/&text=[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2019/11/04/react-composition/&title=[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2019/11/04/react-composition/&is_video=false&description=[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香&body=Check out this article: https://bobi.ink/2019/11/04/react-composition/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2019/11/04/react-composition/&title=[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2019/11/04/react-composition/&title=[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2019/11/04/react-composition/&title=[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2019/11/04/react-composition/&title=[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2019/11/04/react-composition/&name=[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2025 Ivan
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-44571525-2', 'auto');
        ga('send', 'pageview');
    </script>


    <!-- Disqus Comments -->
    <script type="text/javascript">
        var disqus_shortname = 'bobi-ink';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


