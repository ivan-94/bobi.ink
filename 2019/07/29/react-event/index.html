<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="当我们在组件上设置事件处理器时，React并不会在该DOM元素上直接绑定事件处理器. React内部自定义了一套事件系统，在这个系统上统一进行事件订阅和分发.  具体来讲，React利用事件委托机制在Document上统一监听DOM事件，再根据触发的target将事件分发到具体的组件实例。另外上面e是一个合成事件对象(SyntheticEvent), 而不是原始的DOM事件对象.  文章大纲">
<meta name="keywords" content="Blog,FrontEnd,React,Javascript,Typescript">
<meta property="og:type" content="article">
<meta property="og:title" content="谈谈React事件机制和未来(react-events)">
<meta property="og:url" content="https://bobi.ink/2019/07/29/react-event/index.html">
<meta property="og:site_name" content="Bobi.ink">
<meta property="og:description" content="当我们在组件上设置事件处理器时，React并不会在该DOM元素上直接绑定事件处理器. React内部自定义了一套事件系统，在这个系统上统一进行事件订阅和分发.  具体来讲，React利用事件委托机制在Document上统一监听DOM事件，再根据触发的target将事件分发到具体的组件实例。另外上面e是一个合成事件对象(SyntheticEvent), 而不是原始的DOM事件对象.  文章大纲">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://bobi.ink/images/react-event/sample.png">
<meta property="og:image" content="https://bobi.ink/images/react-event/st.png">
<meta property="og:image" content="https://bobi.ink/images/react-event/dispatch-config.png">
<meta property="og:image" content="https://bobi.ink/images/react-event/listento.png">
<meta property="og:image" content="https://bobi.ink/images/react-event/binding.png">
<meta property="og:image" content="https://bobi.ink/images/react-event/binding.png">
<meta property="og:image" content="https://bobi.ink/images/react-event/event-delivery.png">
<meta property="og:image" content="https://bobi.ink/images/react-event/dispatch.png">
<meta property="og:image" content="https://bobi.ink/images/react-event/responder.png">
<meta property="og:image" content="https://codesandbox.io/static/img/play-codesandbox.svg">
<meta property="og:image" content="https://bobi.ink/images/react-event/react-events.png">
<meta property="og:updated_time" content="2023-06-01T09:55:14.330Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="谈谈React事件机制和未来(react-events)">
<meta name="twitter:description" content="当我们在组件上设置事件处理器时，React并不会在该DOM元素上直接绑定事件处理器. React内部自定义了一套事件系统，在这个系统上统一进行事件订阅和分发.  具体来讲，React利用事件委托机制在Document上统一监听DOM事件，再根据触发的target将事件分发到具体的组件实例。另外上面e是一个合成事件对象(SyntheticEvent), 而不是原始的DOM事件对象.  文章大纲">
<meta name="twitter:image" content="https://bobi.ink/images/react-event/sample.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>谈谈React事件机制和未来(react-events)</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/08/04/electron-remote/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/07/19/frontend-standard/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2019/07/29/react-event/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2019/07/29/react-event/&text=谈谈React事件机制和未来(react-events)"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2019/07/29/react-event/&title=谈谈React事件机制和未来(react-events)"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2019/07/29/react-event/&is_video=false&description=谈谈React事件机制和未来(react-events)"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=谈谈React事件机制和未来(react-events)&body=Check out this article: https://bobi.ink/2019/07/29/react-event/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2019/07/29/react-event/&title=谈谈React事件机制和未来(react-events)"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2019/07/29/react-event/&title=谈谈React事件机制和未来(react-events)"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2019/07/29/react-event/&title=谈谈React事件机制和未来(react-events)"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2019/07/29/react-event/&title=谈谈React事件机制和未来(react-events)"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2019/07/29/react-event/&name=谈谈React事件机制和未来(react-events)&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#那为什么要自定义一套事件系统"><span class="toc-number">1.</span> <span class="toc-text">那为什么要自定义一套事件系统?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本概念"><span class="toc-number">2.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#整体的架构"><span class="toc-number">2.1.</span> <span class="toc-text">整体的架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件分类与优先级"><span class="toc-number">2.2.</span> <span class="toc-text">事件分类与优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现细节"><span class="toc-number">3.</span> <span class="toc-text">实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#事件是如何绑定的？"><span class="toc-number">3.1.</span> <span class="toc-text">事件是如何绑定的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件是如何分发的？"><span class="toc-number">3.2.</span> <span class="toc-text">事件是如何分发的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#事件触发调度"><span class="toc-number">3.2.1.</span> <span class="toc-text">事件触发调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插件是如何处理事件"><span class="toc-number">3.2.2.</span> <span class="toc-text">插件是如何处理事件?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#批量执行"><span class="toc-number">3.2.3.</span> <span class="toc-text">批量执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#未来"><span class="toc-number">4.</span> <span class="toc-text">未来</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初探responder的创建"><span class="toc-number">4.1.</span> <span class="toc-text">初探Responder的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react-events意义何在"><span class="toc-number">4.2.</span> <span class="toc-text">react-events意义何在?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展阅读"><span class="toc-number">5.</span> <span class="toc-text">扩展阅读</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        谈谈React事件机制和未来(react-events)
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Bobi.ink</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-07-28T16:00:00.000Z" itemprop="datePublished">2019-07-29</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p><img src="/images/react-event/sample.png" alt></p>
<p>当我们在组件上设置事件处理器时，React并不会在该DOM元素上直接绑定事件处理器. React内部自定义了一套事件系统，在这个系统上统一进行事件订阅和分发. </p>
<p>具体来讲，React利用事件委托机制在Document上统一监听DOM事件，再根据触发的target将事件分发到具体的组件实例。另外上面e是一个合成事件对象(SyntheticEvent), 而不是原始的DOM事件对象.</p>
<p><br></p>
<p><strong>文章大纲</strong></p>
<!-- TOC -->
<ul>
<li><a href="#那为什么要自定义一套事件系统">那为什么要自定义一套事件系统?</a></li>
<li><a href="#基本概念">基本概念</a><ul>
<li><a href="#整体的架构">整体的架构</a></li>
<li><a href="#事件分类与优先级">事件分类与优先级</a></li>
</ul>
</li>
<li><a href="#实现细节">实现细节</a><ul>
<li><a href="#事件是如何绑定的">事件是如何绑定的？</a></li>
<li><a href="#事件是如何分发的">事件是如何分发的？</a><ul>
<li><a href="#事件触发调度">事件触发调度</a></li>
<li><a href="#插件是如何处理事件">插件是如何处理事件?</a></li>
<li><a href="#批量执行">批量执行</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#未来">未来</a><ul>
<li><a href="#初探responder的创建">初探Responder的创建</a></li>
<li><a href="#react-events意义何在">react-events意义何在?</a></li>
</ul>
</li>
<li><a href="#扩展阅读">扩展阅读</a></li>
</ul>
<!-- /TOC -->
<blockquote>
<p>截止本文写作时，React版本是16.8.6</p>
</blockquote>
<p><br></p>
<h2 id="那为什么要自定义一套事件系统"><a href="#那为什么要自定义一套事件系统" class="headerlink" title="那为什么要自定义一套事件系统?"></a>那为什么要自定义一套事件系统?</h2><p>如果了解过Preact(笔者之前写过一篇文章<a href="https://juejin.im/post/5cfa29e151882539c33e4f5e" target="_blank" rel="noopener">解析Preact的源码</a>)，Preact裁剪了很多React的东西，其中包括事件机制，Preact是直接在DOM元素上进行事件绑定的。</p>
<p>在研究一个事物之前，我首先要问为什么？了解它的动机，才有利于你对它有本质的认识。</p>
<p>React自定义一套事件系统的动机有以下几个:</p>
<ul>
<li><p><strong>1. 抹平浏览器之间的兼容性差异</strong>。 这是估计最原始的动机，React根据<a href="https://www.w3.org/TR/DOM-Level-3-Events/" target="_blank" rel="noopener">W3C 规范</a>来定义这些合成事件(SyntheticEvent), 意在抹平浏览器之间的差异。</p>
<p>另外React还会试图通过其他相关事件来模拟一些低版本不兼容的事件, 这才是‘合成’的本来意思吧？。</p>
</li>
<li><p><strong>2. 事件‘合成’, 即事件自定义</strong>。事件合成除了处理兼容性问题，还可以用来自定义高级事件，比较典型的是React的onChange事件，它为表单元素定义了统一的值变动事件。另外第三方也可以通过React的事件插件机制来合成自定义事件，尽管很少人这么做。</p>
</li>
<li><p><strong>3. 抽象跨平台事件机制</strong>。 和VirtualDOM的意义差不多，VirtualDOM抽象了跨平台的渲染方式，那么对应的SyntheticEvent目的也是想提供一个抽象的跨平台事件机制。</p>
</li>
<li><p><strong>4. React打算做更多优化</strong>。比如利用事件委托机制，大部分事件最终绑定到了Document，而不是DOM节点本身. 这样简化了DOM事件处理逻辑，减少了内存开销. 但这也意味着，<strong>React需要自己模拟一套事件冒泡的机制</strong>。</p>
</li>
<li><p><strong>5. React打算干预事件的分发</strong>。v16引入Fiber架构，React为了优化用户的交互体验，会干预事件的分发。不同类型的事件有不同的优先级，比如高优先级的事件可以中断渲染，让用户代码可以及时响应用户交互。</p>
</li>
</ul>
<p><br></p>
<p>Ok, 后面我们会深入了解React的事件实现，我会尽量不贴代码，用流程图说话。</p>
<p><br></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="整体的架构"><a href="#整体的架构" class="headerlink" title="整体的架构"></a>整体的架构</h3><p><img src="/images/react-event/st.png" alt></p>
<ul>
<li><strong>ReactEventListener</strong> - 事件处理器. 在这里进行事件处理器的绑定。当DOM触发事件时，会从这里开始调度分发到React组件树</li>
<li><strong>ReactEventEmitter</strong> - 暴露接口给React组件层用于添加事件订阅</li>
<li><strong>EventPluginHub</strong> - 如其名，这是一个‘插件插槽’，负责管理和注册各种插件。在事件分发时，调用插件来生成合成事件</li>
<li><p><strong>Plugin</strong> - React事件系统使用了插件机制来管理不同行为的事件。这些插件会处理自己感兴趣的事件类型，并生成合成事件对象。目前ReactDOM有以下几种插件类型:</p>
<ul>
<li><strong>SimpleEventPlugin</strong> - 简单事件, 处理一些比较通用的事件类型，例如click、input、keyDown、mouseOver、mouseOut、pointerOver、pointerOut</li>
<li><p><strong>EnterLeaveEventPlugin</strong> - mouseEnter/mouseLeave和pointerEnter/pointerLeave这两类事件比较特殊, 和<code>*over/*leave</code>事件相比, 它们不支持事件冒泡, <code>*enter</code>会给所有进入的元素发送事件, 行为有点类似于<code>:hover</code>; 而<code>*over</code>在进入元素后，还会冒泡通知其上级. 可以通过这个<a href="https://codesandbox.io/s/enter-and-over-608cl" target="_blank" rel="noopener">实例</a>观察enter和over的区别.</p>
<p>如果树层次比较深，大量的mouseenter触发可能导致性能问题。另外其不支持冒泡，无法在Document完美的监听和分发, 所以ReactDOM使用<code>*over/*out</code>事件来模拟这些<code>*enter/*leave</code>。</p>
</li>
<li><p><strong>ChangeEventPlugin</strong> - change事件是React的一个自定义事件，旨在规范化表单元素的变动事件。</p>
<p>它支持这些表单元素: input, textarea, select </p>
</li>
<li><p><strong>SelectEventPlugin</strong> - 和change事件一样，React为表单元素规范化了select(选择范围变动)事件，适用于input、textarea、contentEditable元素.</p>
</li>
<li><strong>BeforeInputEventPlugin</strong> - beforeinput事件以及<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionstart" target="_blank" rel="noopener">composition</a>事件处理。</li>
</ul>
<p>本文主要会关注<code>SimpleEventPlugin</code>的实现，有兴趣的读者可以自己阅读React的源代码.</p>
</li>
<li><p><strong>EventPropagators</strong> 按照DOM事件传播的两个阶段，遍历React组件树，并收集所有组件的事件处理器.</p>
</li>
<li><strong>EventBatching</strong> 负责批量执行事件队列和事件处理器，处理事件冒泡。</li>
<li><p><strong>SyntheticEvent</strong> 这是‘合成’事件的基类，可以对应DOM的Event对象。只不过React为了减低内存损耗和垃圾回收，使用一个对象池来构建和释放事件对象， 也就是说SyntheticEvent不能用于异步引用，它在同步执行完事件处理器后就会被释放。</p>
<p>SyntheticEvent也有子类，和DOM具体事件类型一一匹配:</p>
<ul>
<li>SyntheticAnimationEvent</li>
<li>SyntheticClipboardEvent</li>
<li>SyntheticCompositionEvent</li>
<li>SyntheticDragEvent</li>
<li>SyntheticFocusEvent</li>
<li>SyntheticInputEvent</li>
<li>SyntheticKeyboardEvent</li>
<li>SyntheticMouseEvent</li>
<li>SyntheticPointerEvent</li>
<li>SyntheticTouchEvent</li>
<li>….</li>
</ul>
</li>
</ul>
<p><br></p>
<h3 id="事件分类与优先级"><a href="#事件分类与优先级" class="headerlink" title="事件分类与优先级"></a>事件分类与优先级</h3><p>SimpleEventPlugin将事件类型划分成了三类, 对应不同的优先级(<strong>优先级由低到高</strong>):</p>
<ul>
<li><strong>DiscreteEvent</strong> 离散事件. 例如blur、focus、 click、 submit、 touchStart. 这些事件都是离散触发的</li>
<li><strong>UserBlockingEvent</strong> 用户阻塞事件. 例如touchMove、mouseMove、scroll、drag、dragOver等等。这些事件会’阻塞’用户的交互。</li>
<li><strong>ContinuousEvent</strong> 可连续事件。例如load、error、loadStart、abort、animationEnd. 这个优先级最高，也就是说它们应该是立即同步执行的，这就是Continuous的意义，即可连续的执行，不被打断.</li>
</ul>
<p>可能要先了解一下React调度(Schedule)的优先级，才能理解这三种事件类型的区别。截止到本文写作时，React有5个优先级级别:</p>
<ul>
<li><code>Immediate</code> - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断</li>
<li><code>UserBlocking</code>(250ms timeout) 这些任务一般是用户交互的结果, 需要即时得到反馈 .</li>
<li><code>Normal</code> (5s timeout) 应对哪些不需要立即感受到的任务，例如网络请求</li>
<li><code>Low</code> (10s timeout) 这些任务可以放后，但是最终应该得到执行. 例如分析通知</li>
<li><code>Idle</code> (no timeout) 一些没有必要做的任务 (e.g. 比如隐藏的内容).</li>
</ul>
<p>目前ContinuousEvent对应的是Immediate优先级; UserBlockingEvent对应的是UserBlocking(需要手动开启); 而DiscreteEvent对应的也是UserBlocking, 只不过它在执行之前，先会执行完其他Discrete任务。</p>
<p>本文不会深入React Fiber架构的细节，有兴趣的读者可以阅读文末的扩展阅读列表.</p>
<p><br><br><br></p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>现在开始进入文章正题，React是怎么实现事件机制？主要分为两个部分: <strong>绑定</strong>和<strong>分发</strong>.</p>
<h3 id="事件是如何绑定的？"><a href="#事件是如何绑定的？" class="headerlink" title="事件是如何绑定的？"></a>事件是如何绑定的？</h3><p>为了避免后面绕晕了，有必要先了解一下React事件机制中的插件协议。 每个插件的结构如下:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> EventTypes = &#123;[key: <span class="built_in">string</span>]: DispatchConfig&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> PluginModule&lt;NativeEvent&gt; = &#123;</span><br><span class="line">  eventTypes: EventTypes,          <span class="comment">// 声明插件支持的事件类型</span></span><br><span class="line">  extractEvents: (                 <span class="comment">// 对事件进行处理，并返回合成事件对象</span></span><br><span class="line">    topLevelType: TopLevelType,</span><br><span class="line">    targetInst: <span class="literal">null</span> | Fiber,</span><br><span class="line">    nativeEvent: NativeEvent,</span><br><span class="line">    nativeEventTarget: EventTarget,</span><br><span class="line">  ) =&gt; ?ReactSyntheticEvent,</span><br><span class="line">  tapMoveThreshold?: <span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>eventTypes</strong>声明该插件负责的事件类型, 它通过<code>DispatchConfig</code>来描述:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> DispatchConfig = &#123;</span><br><span class="line">  dependencies: <span class="built_in">Array</span>&lt;TopLevelType&gt;, <span class="comment">// 依赖的原生事件，表示关联这些事件的触发. ‘简单事件’一般只有一个，复杂事件如onChange会监听多个, 如下图👇</span></span><br><span class="line">  phasedRegistrationNames?: &#123;    <span class="comment">// 两阶段props事件注册名称, React会根据这些名称在组件实例中查找对应的props事件处理器</span></span><br><span class="line">    bubbled: <span class="built_in">string</span>,             <span class="comment">// 冒泡阶段, 如onClick</span></span><br><span class="line">    captured: <span class="built_in">string</span>,            <span class="comment">// 捕获阶段，如onClickCapture</span></span><br><span class="line">  &#125;,</span><br><span class="line">  registrationName?: <span class="built_in">string</span>      <span class="comment">// props事件注册名称, 比如onMouseEnter这些不支持冒泡的事件类型，只会定义  registrationName，不会定义phasedRegistrationNames</span></span><br><span class="line">  eventPriority: EventPriority,  <span class="comment">// 事件的优先级，上文已经介绍过了</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>看一下实例:</p>
<p><img src="/images/react-event/dispatch-config.png" alt></p>
<p>上面列举了三个典型的EventPlugin：</p>
<ul>
<li><p><strong>SimpleEventPlugin</strong> - 简单事件最好理解，它们的行为都比较通用，没有什么Trick, 例如不支持事件冒泡、不支持在Document上绑定等等. 和原生DOM事件是一一对应的关系，比较好处理.</p>
</li>
<li><p><strong>EnterLeaveEventPlugin</strong> - 从上图可以看出来，<code>mouseEnter</code>和<code>mouseLeave</code>依赖的是<code>mouseout</code>和<code>mouseover</code>事件。也就是说<code>*Enter/*Leave</code>事件在React中是通过<code>*Over/*Out</code>事件来模拟的。这样做的好处是可以在document上面进行委托监听，还有避免<code>*Enter/*Leave</code>一些奇怪而不实用的行为。</p>
</li>
<li><p><strong>ChangeEventPlugin</strong> - onChange是React的一个自定义事件，可以看出它依赖了多种原生DOM事件类型来模拟onChange事件.</p>
</li>
</ul>
<p><br></p>
<p>另外每个插件还会定义<code>extractEvents</code>方法，这个方法接受事件名称、原生DOM事件对象、事件触发的DOM元素以及React组件实例, 返回一个合成事件对象，如果返回空则表示不作处理. 关于extractEvents的细节会在下一节阐述.</p>
<p><br></p>
<p>在ReactDOM启动时就会向<code>EventPluginHub</code>注册这些插件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">EventPluginHubInjection.injectEventPluginsByName(&#123;</span><br><span class="line">  SimpleEventPlugin: SimpleEventPlugin,</span><br><span class="line">  EnterLeaveEventPlugin: EnterLeaveEventPlugin,</span><br><span class="line">  ChangeEventPlugin: ChangeEventPlugin,</span><br><span class="line">  SelectEventPlugin: SelectEventPlugin,</span><br><span class="line">  BeforeInputEventPlugin: BeforeInputEventPlugin,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>Ok, 回到正题，事件是怎么绑定的呢？ 打个断点看一下调用栈:</p>
<p><img src="/images/react-event/listento.png" alt></p>
<p>前面调用栈关于React树如何更新和渲染就不在本文的范围内了，通过调用栈可以看出React在props初始化和更新时会进行事件绑定。这里先看一下流程图，忽略杂乱的跳转：</p>
<p><img src="/images/react-event/binding.png" alt></p>
<ul>
<li><strong>1. 在props初始化和更新时会进行事件绑定</strong>。首先React会判断元素是否是<code>媒体类型</code>，<strong>媒体类型的事件是无法在Document监听的，所以会直接在元素上进行绑定</strong></li>
<li><strong>2. 反之就在Document上绑定</strong>. 这里面需要两个信息，一个就是上文提到的’事件依赖列表’, 比如<code>onMouseEnter</code>依赖<code>mouseover/mouseout</code>; 第二个是ReactBrowserEventEmitter维护的’已订阅事件表’。<strong>事件处理器只需在Document订阅一次，所以相比在每个元素上订阅事件会节省很多资源</strong>.</li>
</ul>
<p>代码大概如下:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">listenTo</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  registrationName: <span class="built_in">string</span>,           <span class="comment">// 注册名称，如onClick</span></span></span></span><br><span class="line"><span class="function"><span class="params">  mountAt: Document | Element | Node, <span class="comment">// 组件树容器，一般是Document</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> listeningSet = getListeningSetForElement(mountAt);             <span class="comment">// 已订阅事件表</span></span><br><span class="line">  <span class="keyword">const</span> dependencies = registrationNameDependencies[registrationName]; <span class="comment">// 事件依赖</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dependencies.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> dependency = dependencies[i];</span><br><span class="line">    <span class="keyword">if</span> (!listeningSet.has(dependency)) &#123;                               <span class="comment">// 未订阅</span></span><br><span class="line">      <span class="keyword">switch</span> (dependency) &#123;</span><br><span class="line">        <span class="comment">// ... 特殊的事件监听处理</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">const</span> isMediaEvent = mediaEventTypes.indexOf(dependency) !== <span class="number">-1</span>;</span><br><span class="line">          <span class="keyword">if</span> (!isMediaEvent) &#123;</span><br><span class="line">            trapBubbledEvent(dependency, mountAt);                     <span class="comment">// 设置事件处理器</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      listeningSet.add(dependency);                                    <span class="comment">// 更新已订阅表</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>接下来就是根据事件的’优先级’和’捕获阶段’(是否是capture)来设置事件处理器</strong>:</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trapEventForPluginEventSystem</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  element: Document | Element | Node,   <span class="comment">// 绑定到元素，一般是Document</span></span></span></span><br><span class="line"><span class="function"><span class="params">  topLevelType: DOMTopLevelEventType,   <span class="comment">// 事件名称</span></span></span></span><br><span class="line"><span class="function"><span class="params">  capture: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> listener;</span><br><span class="line">  <span class="keyword">switch</span> (getEventPriority(topLevelType)) &#123;</span><br><span class="line">    <span class="comment">// 不同优先级的事件类型，有不同的事件处理器进行分发, 下文会详细介绍</span></span><br><span class="line">    <span class="keyword">case</span> DiscreteEvent:                      <span class="comment">// ⚛️离散事件</span></span><br><span class="line">      listener = dispatchDiscreteEvent.bind(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        topLevelType,</span><br><span class="line">        PLUGIN_EVENT_SYSTEM,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> UserBlockingEvent:                 <span class="comment">// ⚛️用户阻塞事件</span></span><br><span class="line">      listener = dispatchUserBlockingUpdate.bind(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        topLevelType,</span><br><span class="line">        PLUGIN_EVENT_SYSTEM,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ContinuousEvent:                   <span class="comment">// ⚛️可连续事件</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      listener = dispatchEvent.bind(<span class="literal">null</span>, topLevelType, PLUGIN_EVENT_SYSTEM);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> rawEventName = getRawEventName(topLevelType);</span><br><span class="line">  <span class="keyword">if</span> (capture) &#123;                            <span class="comment">// 绑定事件处理器到元素</span></span><br><span class="line">    addEventCaptureListener(element, rawEventName, listener);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    addEventBubbleListener(element, rawEventName, listener);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件绑定的过程还比较简单, 接下来看看事件是如何分发的。</p>
<p><br></p>
<h3 id="事件是如何分发的？"><a href="#事件是如何分发的？" class="headerlink" title="事件是如何分发的？"></a>事件是如何分发的？</h3><p>按惯例还是先上流程图:</p>
<p><img src="/images/react-event/binding.png" alt></p>
<h4 id="事件触发调度"><a href="#事件触发调度" class="headerlink" title="事件触发调度"></a>事件触发调度</h4><p>通过上面的<code>trapEventForPluginEventSystem</code>函数可以知道，不同的事件类型有不同的事件处理器, 它们的区别是调度的优先级不一样:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 离散事件</span></span><br><span class="line"><span class="comment">// discrentUpdates 在UserBlocking优先级中执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchDiscreteEvent</span>(<span class="params">topLevelType, eventSystemFlags, nativeEvent</span>) </span>&#123;</span><br><span class="line">  flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);</span><br><span class="line">  discreteUpdates(dispatchEvent, topLevelType, eventSystemFlags, nativeEvent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchUserBlockingUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  topLevelType,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventSystemFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果开启了enableUserBlockingEvents, 则在UserBlocking优先级中调度，</span></span><br><span class="line">  <span class="comment">// 开启enableUserBlockingEvents可以防止饥饿问题，因为阻塞事件中有scroll、mouseMove这类频繁触发的事件</span></span><br><span class="line">  <span class="comment">// 否则同步执行</span></span><br><span class="line">  <span class="keyword">if</span> (enableUserBlockingEvents) &#123;</span><br><span class="line">    runWithPriority(</span><br><span class="line">      UserBlockingPriority,</span><br><span class="line">      dispatchEvent.bind(<span class="literal">null</span>, topLevelType, eventSystemFlags, nativeEvent),</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dispatchEvent(topLevelType, eventSystemFlags, nativeEvent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可连续事件则直接同步调用dispatchEvent</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>最终不同的事件类型都会调用<code>dispatchEvent</code>函数. <code>dispatchEvent</code>中会从DOM原生事件对象获取事件触发的target，再根据这个target获取关联的React节点实例.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatchEvent</span>(<span class="params">topLevelType: DOMTopLevelEventType, eventSystemFlags: EventSystemFlags, nativeEvent: AnyNativeEvent</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取事件触发的目标DOM</span></span><br><span class="line">  <span class="keyword">const</span> nativeEventTarget = getEventTarget(nativeEvent);</span><br><span class="line">  <span class="comment">// 获取离该DOM最近的组件实例(只能是DOM元素组件)</span></span><br><span class="line">  <span class="keyword">let</span> targetInst = getClosestInstanceFromNode(nativeEventTarget);</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  dispatchEventForPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>接着(中间还有一些步骤，这里忽略)会调用<code>EventPluginHub</code>的<code>runExtractedPluginEventsInBatch</code>，这个方法遍历插件列表来处理事件，生成一个SyntheticEvent列表:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">runExtractedPluginEventsInBatch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  topLevelType: TopLevelType,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetInst: <span class="literal">null</span> | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent: AnyNativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEventTarget: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历插件列表, 调用插件的extractEvents，生成SyntheticEvent列表</span></span><br><span class="line">  <span class="keyword">const</span> events = extractPluginEvents(</span><br><span class="line">    topLevelType,</span><br><span class="line">    targetInst,</span><br><span class="line">    nativeEvent,</span><br><span class="line">    nativeEventTarget,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事件处理器执行, 见后文批量执行</span></span><br><span class="line">  runEventsInBatch(events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="插件是如何处理事件"><a href="#插件是如何处理事件" class="headerlink" title="插件是如何处理事件?"></a>插件是如何处理事件?</h4><p>现在来看看插件是如何处理事件的，我们以<code>SimpleEventPlugin</code>为例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SimpleEventPlugin: PluginModule&lt;MouseEvent&gt; &amp; &#123;</span><br><span class="line">  getEventPriority: <span class="function">(<span class="params">topLevelType: TopLevelType</span>) =&gt;</span> EventPriority,</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  eventTypes: eventTypes,</span><br><span class="line">  <span class="comment">// 抽取事件对象</span></span><br><span class="line">  extractEvents: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    topLevelType: TopLevelType,</span></span></span><br><span class="line"><span class="function"><span class="params">    targetInst: null | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    nativeEvent: MouseEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">    nativeEventTarget: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">null</span> | <span class="title">ReactSyntheticEvent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 事件配置</span></span><br><span class="line">    <span class="keyword">const</span> dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1️⃣ 根据事件类型获取SyntheticEvent子类事件构造器</span></span><br><span class="line">    <span class="keyword">let</span> EventConstructor;</span><br><span class="line">    <span class="keyword">switch</span> (topLevelType) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_KEY_DOWN:</span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_KEY_UP:</span><br><span class="line">        EventConstructor = SyntheticKeyboardEvent;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_BLUR:</span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_FOCUS:</span><br><span class="line">        EventConstructor = SyntheticFocusEvent;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// ... 省略</span></span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_GOT_POINTER_CAPTURE:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_POINTER_UP:</span><br><span class="line">        EventConstructor = SyntheticPointerEvent;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        EventConstructor = SyntheticEvent;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2️⃣ 构造事件对象, 从对象池中获取</span></span><br><span class="line">    <span class="keyword">const</span> event = EventConstructor.getPooled(</span><br><span class="line">      dispatchConfig,</span><br><span class="line">      targetInst,</span><br><span class="line">      nativeEvent,</span><br><span class="line">      nativeEventTarget,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3️⃣ 根据DOM事件传播的顺序获取用户事件处理器</span></span><br><span class="line">    accumulateTwoPhaseDispatches(event);</span><br><span class="line">    <span class="keyword">return</span> event;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>SimpleEventPlugin</code>的<code>extractEvents</code>主要做以下三个事情:</p>
<ul>
<li>1️⃣ 根据事件的类型确定SyntheticEvent构造器</li>
<li>2️⃣ 构造SyntheticEvent对象。</li>
<li>3️⃣ 根据DOM事件传播的顺序获取用户事件处理器列表</li>
</ul>
<p><br></p>
<p><strong>为了避免频繁创建和释放事件对象导致性能损耗(对象创建和垃圾回收)，React使用一个事件池来负责管理事件对象，使用完的事件对象会放回池中，以备后续的复用</strong>。</p>
<p>这也意味着，<strong>在事件处理器同步执行完后，SyntheticEvent对象就会马上被回收</strong>，所有属性都会无效。所以一般不会在异步操作中访问SyntheticEvent事件对象。你也可以通过以下方法来保持事件对象的引用：</p>
<ul>
<li>调用<code>SyntheticEvent#persist()</code>方法，告诉React不要回收到对象池</li>
<li>直接引用<code>SyntheticEvent#nativeEvent</code>, nativeEvent是可以持久引用的，不过为了不打破抽象，建议不要直接引用nativeEvent</li>
</ul>
<p><br></p>
<p>构建完SyntheticEvent对象后，就需要<strong>遍历组件树来获取订阅该事件的用户事件处理器</strong>了:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">accumulateTwoPhaseDispatchesSingle</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以_targetInst为基点, 按照DOM事件传播的顺序遍历组件树</span></span><br><span class="line">  traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历方法其实很简单：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">traverseTwoPhase</span>(<span class="params">inst, fn, arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> path = [];</span><br><span class="line">  <span class="keyword">while</span> (inst) &#123;           <span class="comment">// 从inst开始，向上级回溯</span></span><br><span class="line">    path.push(inst);</span><br><span class="line">    inst = getParent(inst);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="comment">// 捕获阶段，先从最顶层的父组件开始, 向下级传播</span></span><br><span class="line">  <span class="keyword">for</span> (i = path.length; i-- &gt; <span class="number">0</span>; ) &#123;</span><br><span class="line">    fn(path[i], <span class="string">'captured'</span>, arg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 冒泡阶段，从inst，即事件触发点开始, 向上级传播</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; path.length; i++) &#123;</span><br><span class="line">    fn(path[i], <span class="string">'bubbled'</span>, arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>accumulateDirectionalDispatches</code>函数则是简单查找当前节点是否有对应的事件处理器:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">accumulateDirectionalDispatches</span>(<span class="params">inst, phase, event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检查是否存在事件处理器</span></span><br><span class="line">  <span class="keyword">const</span> listener = listenerAtPhase(inst, event, phase);</span><br><span class="line">  <span class="comment">// 所有处理器都放入到_dispatchListeners队列中，后续批量执行这个队列</span></span><br><span class="line">  <span class="keyword">if</span> (listener) &#123;</span><br><span class="line">    event._dispatchListeners = accumulateInto(</span><br><span class="line">      event._dispatchListeners,</span><br><span class="line">      listener,</span><br><span class="line">    );</span><br><span class="line">    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>例如下面的组件树, 遍历过程是这样的：</p>
<p><img src="/images/react-event/event-delivery.png" alt></p>
<p>最终计算出来的<code>_dispatchListeners</code>队列是这样的：<code>[handleB, handleC, handleA]</code></p>
<p><br></p>
<h4 id="批量执行"><a href="#批量执行" class="headerlink" title="批量执行"></a>批量执行</h4><p>遍历执行插件后，会得到一个SyntheticEvent列表，<code>runEventsInBatch</code>就是批量执行这些事件中的<code>_dispatchListeners</code>事件队列</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">runEventsInBatch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  events: Array&lt;ReactSyntheticEvent&gt; | ReactSyntheticEvent | null,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 👇</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> executeDispatchesAndRelease = <span class="function"><span class="keyword">function</span>(<span class="params">event: ReactSyntheticEvent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event) &#123;</span><br><span class="line">    <span class="comment">// 按顺序执行_dispatchListeners</span></span><br><span class="line">    <span class="comment">// 👇</span></span><br><span class="line">    executeDispatchesInOrder(event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有调用persist()方法则直接回收</span></span><br><span class="line">    <span class="keyword">if</span> (!event.isPersistent()) &#123;</span><br><span class="line">      event.constructor.release(event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">executeDispatchesInOrder</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历dispatchListeners</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dispatchListeners.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 通过调用 stopPropagation 方法可以禁止执行下一个事件处理器</span></span><br><span class="line">    <span class="keyword">if</span> (event.isPropagationStopped()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行事件处理器</span></span><br><span class="line">    executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/react-event/dispatch.png" alt></p>
<p>OK, 到这里React的事件机制就基本介绍完了，这里只是简单了介绍了一下<code>SimpleEventPlugin</code>, 实际代码中还有很多事件处理的细节，限于篇幅，本文就不展开去讲了。有兴趣的读者可以亲自去观摩React的源代码.</p>
<p><br><br><br></p>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>React内部有一个实验性的事件API，React内部称为<code>React Flare</code>、正式名称是<a href="https://github.com/facebook/react/tree/master/packages/react-events" target="_blank" rel="noopener"><code>react-events</code></a>, <strong>通过这个API可以实现跨平台、跨设备的高级事件封装</strong>.</p>
<p>react-events定义了一个<strong>事件响应器(Event Responders)</strong>的概念，这个事件响应器可以捕获子组件树或应用根节点的事件，然后转换为自定义事件.</p>
<p>比较典型的高级事件是press、longPress、swipe这些手势。通常我们需要自己或者利用第三方库来实现这一套手势识别, 例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Gesture <span class="keyword">from</span> <span class="string">'rc-gesture'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Gesture</span><br><span class="line">    onTap=&#123;handleTap&#125;</span><br><span class="line">    onSwipe=&#123;onSwipe&#125;</span><br><span class="line">    onPinch=&#123;handlePinch&#125;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;div&gt;container&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Gesture&gt;,</span><br><span class="line">container);</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>那么react-events的目的就是<strong>提供一套通用的事件机制给开发者来实现’高级事件’的封装, 甚至实现事件的跨平台、跨设备</strong>, 现在你可以通过react-events来封装这些手势事件.</p>
<p>react-events除了核心的<code>Responder</code>接口，还封装了一些内置模块, 实现跨平台的、常用的高级事件封装：</p>
<ul>
<li>Focus module</li>
<li>Hover module</li>
<li>Press module</li>
<li>FocusScope module</li>
<li>Input module</li>
<li>KeyBoard module</li>
<li>Drag module</li>
<li>Pan module</li>
<li>Scroll module</li>
<li>Swipe module</li>
</ul>
<p>举<code>Press</code>模块作为例子, <a href="https://github.com/facebook/react/blob/master/packages/react-events/docs/Press.md" target="_blank" rel="noopener">Press模块</a>会响应它包裹的元素的press事件。press事件包括onContextMenu、onLongPress、onPress、onPressEnd、onPressMove、onPressStart等等. 其底层通过mouse、pen、touch、trackpad等事件来转换.</p>
<p>看看使用示例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PressResponder, usePressListener &#125; <span class="keyword">from</span> <span class="string">'react-events/press'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">props</span>) =&gt;</span> (</span><br><span class="line">  <span class="keyword">const</span> listener = usePressListener(&#123;  <span class="comment">// ⚛️通过hooks创建Responder</span></span><br><span class="line">    onPressStart,</span><br><span class="line">    onPress,</span><br><span class="line">    onPressEnd,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div listeners=&#123;listener&#125;&gt;</span><br><span class="line">      &#123;subtrees&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>react-events的运作流程图如下, <strong>事件响应器(Event Responders)会挂载到host节点，它会在host节点监听host或子节点分发的原生事件(DOM或React Native), 并将它们转换/合并成高级的事件</strong>:</p>
<p><img src="/images/react-event/responder.png" alt></p>
<p><br></p>
<blockquote>
<p>你可以通过这个Codesanbox玩一下<code>react-events</code>: <a href="https://codesandbox.io/s/github/ivan-94/react-events-playground" target="_blank" rel="noopener"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="Edit react-events-playground"></a></p>
</blockquote>
<p><br></p>
<h3 id="初探responder的创建"><a href="#初探responder的创建" class="headerlink" title="初探Responder的创建"></a>初探Responder的创建</h3><p>我们挑一个简单的模块来了解一些react-events的核心API, 目前最简单的是Keyboard模块. Keyboard模块的目的就是规范化keydown和keyup事件对象的key属性(部分浏览器key属性的行为不一样)，它的实现如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义Responder的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> keyboardResponderImpl = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 1️⃣定义Responder需要监听的子树的DOM事件，对于Keyboard来说是['keydown', 'keyup';]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  targetEventTypes,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 2️⃣监听子树触发的事件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onEvent(</span><br><span class="line">    event: ReactDOMResponderEvent,     <span class="comment">// 包含了当前触发事件的相关信息，如原生事件对象，事件触发的节点，事件类型等等</span></span><br><span class="line">    context: ReactDOMResponderContext, <span class="comment">// Responder的上下文，给Responder提供了一些方法来驱动事件分发</span></span><br><span class="line">    props: KeyboardResponderProps,     <span class="comment">// 传递给Responder的props</span></span><br><span class="line">  ): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;responderTarget, type&#125; = event;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (props.disabled) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">'keydown'</span>) &#123;</span><br><span class="line">      dispatchKeyboardEvent(</span><br><span class="line">        <span class="string">'onKeyDown'</span>,</span><br><span class="line">        event,</span><br><span class="line">        context,</span><br><span class="line">        <span class="string">'keydown'</span>,</span><br><span class="line">        ((responderTarget: any): Element | Document),</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'keyup'</span>) &#123;</span><br><span class="line">      dispatchKeyboardEvent(</span><br><span class="line">        <span class="string">'onKeyUp'</span>,</span><br><span class="line">        event,</span><br><span class="line">        context,</span><br><span class="line">        <span class="string">'keyup'</span>,</span><br><span class="line">        ((responderTarget: any): Element | Document),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再来看看dispatchKeyboardEvent:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchKeyboardEvent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  eventPropName: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  event: ReactDOMResponderEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  context: ReactDOMResponderContext,</span></span></span><br><span class="line"><span class="function"><span class="params">  type: KeyboardEventType,</span></span></span><br><span class="line"><span class="function"><span class="params">  target: Element | Document,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️创建合成事件对象，在这个函数中会规范化事件的key属性</span></span><br><span class="line">  <span class="keyword">const</span> syntheticEvent = createKeyboardEvent(event, context, type, target);</span><br><span class="line">  <span class="comment">// ⚛️通过Responder上下文分发事件</span></span><br><span class="line">  context.dispatchEvent(eventPropName, syntheticEvent, DiscreteEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>导出Responder:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⚛️createResponder把keyboardResponderImpl转换为组件形式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> KeyboardResponder = React.unstable_createResponder(</span><br><span class="line">  <span class="string">'Keyboard'</span>,</span><br><span class="line">  keyboardResponderImpl,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚛️创建hooks形式</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useKeyboardListener</span>(<span class="params">props: KeyboardListenerProps</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  React.unstable_useListener(KeyboardResponder, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>现在读者应该对<strong>Responder的职责</strong>有了一些基本的了解，它主要做以下几件事情:</p>
<ul>
<li>声明要监听的原生事件(如DOM), 如上面的<code>targetEventTypes</code></li>
<li>处理和转换合成事件，如上面的<code>onEvent</code></li>
<li>创建并分发自定义事件。如上面的<code>context.dispatchEvent</code></li>
</ul>
<p><br></p>
<p>和上面的Keyboard模块相比，现实中的很多高级事件，如longPress, 它们的实现则要复杂得多. 它们可能要维持一定的<strong>状态</strong>、也可能要独占响应的<strong>所有权</strong>(即同一时间只能有一个Responder可以对事件进行处理, 这个常用于移动端触摸手势，例如React Native的<a href="https://reactnative.cn/docs/gesture-responder-system/" target="_blank" rel="noopener">GestureResponderSystem</a>)。</p>
<p>react-events目前都考虑了这些场景, 看一下API概览:</p>
<p><img src="/images/react-event/react-events.png" alt></p>
<p><br></p>
<p>详细可以看react-events<a href="https://github.com/facebook/react/tree/master/packages/react-events" target="_blank" rel="noopener">官方仓库</a></p>
<p><br></p>
<h3 id="react-events意义何在"><a href="#react-events意义何在" class="headerlink" title="react-events意义何在?"></a>react-events意义何在?</h3><p>上文提到了React事件内部采用了插件机制，来实现事件处理和合成，比较典型的就是onChange事件。onChange事件其实就是所谓的‘高级事件’，它是通过表单组件的各种原生事件来模拟的。</p>
<p>也就是说，React通过插件机制本质上是可以实现高级事件的封装的。但是如果读者看过源代码，就会觉得里面逻辑比较绕，而且依赖React的很多内部实现。<strong>所以这种内部的插件机制并不是面向普通开发者的</strong>。</p>
<p><code>react-events</code>接口就简单很多了，它屏蔽了很多内部细节，面向普通开发者。我们可以利用它来实现高性能的自定义事件分发，更大的意义是通过它可以实现跨平台/设备的事件处理方式.</p>
<p>目前react-events还是实验阶段，特性是默认关闭，API可能会出现变更, 所以不建议在生产环境使用。可以通过这个<a href="https://github.com/facebook/react/issues/15257" target="_blank" rel="noopener">Issue</a>来关注它的进展。</p>
<p><br></p>
<p>最后赞叹一下React团队的创新能力！</p>
<p><br></p>
<p>完！</p>
<p><br></p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a href="https://segmentfault.com/a/1190000013094932" target="_blank" rel="noopener">input事件中文触发多次问题研究</a></li>
<li><a href="http://www.ayqy.net/blog/dive-into-react-fiber/" target="_blank" rel="noopener">完全理解React Fiber</a></li>
<li><a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">Lin Clark – A Cartoon Intro to Fiber – React Conf 2017</a></li>
<li><a href="https://philippspiess.com/scheduling-in-react/" target="_blank" rel="noopener">Scheduling in React</a></li>
<li><a href="https://github.com/facebook/react/issues/15257" target="_blank" rel="noopener">[Umbrella] React Flare</a></li>
<li><a href="https://github.com/facebook/react/tree/master/packages/react-events" target="_blank" rel="noopener">react-events</a></li>
</ul>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#那为什么要自定义一套事件系统"><span class="toc-number">1.</span> <span class="toc-text">那为什么要自定义一套事件系统?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本概念"><span class="toc-number">2.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#整体的架构"><span class="toc-number">2.1.</span> <span class="toc-text">整体的架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件分类与优先级"><span class="toc-number">2.2.</span> <span class="toc-text">事件分类与优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现细节"><span class="toc-number">3.</span> <span class="toc-text">实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#事件是如何绑定的？"><span class="toc-number">3.1.</span> <span class="toc-text">事件是如何绑定的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件是如何分发的？"><span class="toc-number">3.2.</span> <span class="toc-text">事件是如何分发的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#事件触发调度"><span class="toc-number">3.2.1.</span> <span class="toc-text">事件触发调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插件是如何处理事件"><span class="toc-number">3.2.2.</span> <span class="toc-text">插件是如何处理事件?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#批量执行"><span class="toc-number">3.2.3.</span> <span class="toc-text">批量执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#未来"><span class="toc-number">4.</span> <span class="toc-text">未来</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初探responder的创建"><span class="toc-number">4.1.</span> <span class="toc-text">初探Responder的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react-events意义何在"><span class="toc-number">4.2.</span> <span class="toc-text">react-events意义何在?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展阅读"><span class="toc-number">5.</span> <span class="toc-text">扩展阅读</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2019/07/29/react-event/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2019/07/29/react-event/&text=谈谈React事件机制和未来(react-events)"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2019/07/29/react-event/&title=谈谈React事件机制和未来(react-events)"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2019/07/29/react-event/&is_video=false&description=谈谈React事件机制和未来(react-events)"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=谈谈React事件机制和未来(react-events)&body=Check out this article: https://bobi.ink/2019/07/29/react-event/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2019/07/29/react-event/&title=谈谈React事件机制和未来(react-events)"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2019/07/29/react-event/&title=谈谈React事件机制和未来(react-events)"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2019/07/29/react-event/&title=谈谈React事件机制和未来(react-events)"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2019/07/29/react-event/&title=谈谈React事件机制和未来(react-events)"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2019/07/29/react-event/&name=谈谈React事件机制和未来(react-events)&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2023 Ivan
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-44571525-2', 'auto');
        ga('send', 'pageview');
    </script>


    <!-- Disqus Comments -->
    <script type="text/javascript">
        var disqus_shortname = 'bobi-ink';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


