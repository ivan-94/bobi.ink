<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="万字长文，继续刷新我的文章长度记录，涉及前端开发的方方面面。本文将持续更新和完善, 文章部分观点可能比较武断或不完整，欢迎评论和补充，一起完善该文章. 谢谢   笔者长期单枪匹马在前端领域厮杀(言外之意就是团队就一个人)，自己就是规范。随着公司业务的扩展，扩充了一些人员，这时候就要开始考虑协作和编码规范问题了。本文记录了笔者在制定前端协作规范时的一些思考，希望能给你们也带来一些帮助. 一个人走的">
<meta name="keywords" content="Blog,FrontEnd,React,Javascript,Typescript">
<meta property="og:type" content="article">
<meta property="og:title" content="if 我是前端团队Leader，怎么制定前端协作规范?">
<meta property="og:url" content="https://bobi.ink/2019/07/19/frontend-standard/index.html">
<meta property="og:site_name" content="Bobi.ink">
<meta property="og:description" content="万字长文，继续刷新我的文章长度记录，涉及前端开发的方方面面。本文将持续更新和完善, 文章部分观点可能比较武断或不完整，欢迎评论和补充，一起完善该文章. 谢谢   笔者长期单枪匹马在前端领域厮杀(言外之意就是团队就一个人)，自己就是规范。随着公司业务的扩展，扩充了一些人员，这时候就要开始考虑协作和编码规范问题了。本文记录了笔者在制定前端协作规范时的一些思考，希望能给你们也带来一些帮助. 一个人走的">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/branch.png">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/commit.png">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/pub.png">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/ci.png">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/continous.png">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/devops.png">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/kanban.png">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/vue-vs-react.png">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/g-p.jpg">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/brw-levl.gif">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/cpt.png">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/bdtj.png">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/prt.png">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/code-review.png">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/issue.png">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/ui-design.png">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/testing.png">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/test-proc.png">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/f-b.png">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/api-mock.png">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/org.png">
<meta property="og:image" content="https://bobi.ink/images/frontend-standard/dev-proc.png">
<meta property="og:image" content="https://bobi.ink/images/sponsor.jpg">
<meta property="og:updated_time" content="2023-06-01T09:55:14.328Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="if 我是前端团队Leader，怎么制定前端协作规范?">
<meta name="twitter:description" content="万字长文，继续刷新我的文章长度记录，涉及前端开发的方方面面。本文将持续更新和完善, 文章部分观点可能比较武断或不完整，欢迎评论和补充，一起完善该文章. 谢谢   笔者长期单枪匹马在前端领域厮杀(言外之意就是团队就一个人)，自己就是规范。随着公司业务的扩展，扩充了一些人员，这时候就要开始考虑协作和编码规范问题了。本文记录了笔者在制定前端协作规范时的一些思考，希望能给你们也带来一些帮助. 一个人走的">
<meta name="twitter:image" content="https://bobi.ink/images/frontend-standard/branch.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>if 我是前端团队Leader，怎么制定前端协作规范?</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/07/29/react-event/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/07/18/why-vue-cli3/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2019/07/19/frontend-standard/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2019/07/19/frontend-standard/&text=if 我是前端团队Leader，怎么制定前端协作规范?"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2019/07/19/frontend-standard/&title=if 我是前端团队Leader，怎么制定前端协作规范?"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2019/07/19/frontend-standard/&is_video=false&description=if 我是前端团队Leader，怎么制定前端协作规范?"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=if 我是前端团队Leader，怎么制定前端协作规范?&body=Check out this article: https://bobi.ink/2019/07/19/frontend-standard/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2019/07/19/frontend-standard/&title=if 我是前端团队Leader，怎么制定前端协作规范?"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2019/07/19/frontend-standard/&title=if 我是前端团队Leader，怎么制定前端协作规范?"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2019/07/19/frontend-standard/&title=if 我是前端团队Leader，怎么制定前端协作规范?"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2019/07/19/frontend-standard/&title=if 我是前端团队Leader，怎么制定前端协作规范?"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2019/07/19/frontend-standard/&name=if 我是前端团队Leader，怎么制定前端协作规范?&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-工作流规范"><span class="toc-number">1.</span> <span class="toc-text">1 工作流规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-开发"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-版本规范"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1 版本规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-版本控制系统规范"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2 版本控制系统规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-提交信息规范"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.1.3 提交信息规范</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-构建规范"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 构建规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-发布工作流规范"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 发布工作流规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-持续集成"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 持续集成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-任务管理"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 任务管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-技术栈规范"><span class="toc-number">2.</span> <span class="toc-text">2 技术栈规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-技术选型"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 技术选型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-迎接新技术"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 迎接新技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-浏览器兼容规范"><span class="toc-number">3.</span> <span class="toc-text">3 浏览器兼容规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-确定兼容策略"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 确定兼容策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-确定浏览器分级"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 确定浏览器分级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-获取统计数据"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 获取统计数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-项目组织规范"><span class="toc-number">4.</span> <span class="toc-text">4 项目组织规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-通用的项目组织规范"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 通用的项目组织规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-目录组织的风格"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 目录组织的风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-脚手架和项目模板"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 脚手架和项目模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-编码规范"><span class="toc-number">5.</span> <span class="toc-text">5 编码规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-javascript"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 Javascript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-html"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 HTML</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-css"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 CSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-代码格式化"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 代码格式化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-集大成的"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 集大成的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-特定框架风格指南"><span class="toc-number">5.6.</span> <span class="toc-text">5.6 特定框架风格指南</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-code-review"><span class="toc-number">5.7.</span> <span class="toc-text">5.7 Code Review</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-文档规范"><span class="toc-number">6.</span> <span class="toc-text">6 文档规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-建立文档中心"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 建立文档中心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-文档格式"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 文档格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-定义文档的模板"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 定义文档的模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-讨论即文档"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 讨论即文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-注释即文档"><span class="toc-number">6.5.</span> <span class="toc-text">6.5 注释即文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-代码即文档"><span class="toc-number">6.6.</span> <span class="toc-text">6.6 代码即文档</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-ui设计规范"><span class="toc-number">7.</span> <span class="toc-text">7 UI设计规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-测试规范"><span class="toc-number">8.</span> <span class="toc-text">8 测试规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-测试的流程"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 测试的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-单元测试"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 单元测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-异常处理、监控和调试规范"><span class="toc-number">9.</span> <span class="toc-text">9 异常处理、监控和调试规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-异常处理"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-日志"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-异常监控"><span class="toc-number">9.3.</span> <span class="toc-text">9.3 异常监控</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-前后端协作规范"><span class="toc-number">10.</span> <span class="toc-text">10 前后端协作规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-协作流程规范"><span class="toc-number">10.1.</span> <span class="toc-text">10.1 协作流程规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-接口规范"><span class="toc-number">10.2.</span> <span class="toc-text">10.2 接口规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-接口文档规范"><span class="toc-number">10.3.</span> <span class="toc-text">10.3 接口文档规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-接口测试与模拟"><span class="toc-number">10.4.</span> <span class="toc-text">10.4 接口测试与模拟</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-培训-知识管理-技术沉淀"><span class="toc-number">11.</span> <span class="toc-text">11 培训/知识管理/技术沉淀</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-新人培训"><span class="toc-number">11.1.</span> <span class="toc-text">11.1 新人培训</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-营造技术氛围"><span class="toc-number">11.2.</span> <span class="toc-text">11.2 营造技术氛围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-反馈"><span class="toc-number">12.</span> <span class="toc-text">12 反馈</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        if 我是前端团队Leader，怎么制定前端协作规范?
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Bobi.ink</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-07-18T16:00:00.000Z" itemprop="datePublished">2019-07-19</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <blockquote>
<p>万字长文，继续刷新我的文章长度记录，涉及前端开发的方方面面。本文将持续更新和完善, 文章部分观点可能比较武断或不完整，欢迎评论和补充，一起完善该文章. 谢谢</p>
</blockquote>
<p><br></p>
<p>笔者长期单枪匹马在前端领域厮杀(言外之意就是团队就一个人)，自己就是规范。随着公司业务的扩展，扩充了一些人员，这时候就要开始考虑协作和编码规范问题了。本文记录了笔者在制定<code>前端协作规范</code>时的一些思考，希望能给你们也带来一些帮助.</p>
<p><strong>一个人走的更快，一群人可以走得更远，前提是统一的策略，还要不断地反省和优化</strong>。</p>
<p><br></p>
<p><strong>以下是目录概览, 看出这是一篇浩浩荡荡的长文</strong></p>
<!-- TOC -->
<ul>
<li><a href="#1-工作流规范">1 工作流规范</a><ul>
<li><a href="#11-开发">1.1 开发</a><ul>
<li><a href="#111-版本规范">1.1.1 版本规范</a></li>
<li><a href="#112-版本控制系统规范">1.1.2 版本控制系统规范</a></li>
<li><a href="#113-提交信息规范">1.1.3 提交信息规范</a></li>
</ul>
</li>
<li><a href="#12-构建规范">1.2 构建规范</a></li>
<li><a href="#13-发布工作流规范">1.3 发布工作流规范</a></li>
<li><a href="#14-持续集成">1.4 持续集成</a></li>
<li><a href="#15-任务管理">1.5 任务管理</a></li>
</ul>
</li>
<li><a href="#2-技术栈规范">2 技术栈规范</a><ul>
<li><a href="#21-技术选型">2.1 技术选型</a></li>
<li><a href="#22-迎接新技术">2.2 迎接新技术</a></li>
</ul>
</li>
<li><a href="#3-浏览器兼容规范">3 浏览器兼容规范</a><ul>
<li><a href="#31-确定兼容策略">3.1 确定兼容策略</a></li>
<li><a href="#32-确定浏览器分级">3.2 确定浏览器分级</a></li>
<li><a href="#33-获取统计数据">3.3 获取统计数据</a></li>
</ul>
</li>
<li><a href="#4-项目组织规范">4 项目组织规范</a><ul>
<li><a href="#41-通用的项目组织规范">4.1 通用的项目组织规范</a></li>
<li><a href="#42-目录组织的风格">4.2 目录组织的风格</a></li>
<li><a href="#43-脚手架和项目模板">4.3 脚手架和项目模板</a></li>
</ul>
</li>
<li><a href="#5-编码规范">5 编码规范</a><ul>
<li><a href="#51-javascript">5.1 Javascript</a></li>
<li><a href="#52-html">5.2 HTML</a></li>
<li><a href="#53-css">5.3 CSS</a></li>
<li><a href="#54-代码格式化">5.4 代码格式化</a></li>
<li><a href="#55-集大成的">5.5 集大成的</a></li>
<li><a href="#56-特定框架风格指南">5.6 特定框架风格指南</a></li>
<li><a href="#57-code-review">5.7 Code Review</a></li>
</ul>
</li>
<li><a href="#6-文档规范">6 文档规范</a><ul>
<li><a href="#61-建立文档中心">6.1 建立文档中心</a></li>
<li><a href="#62-文档格式">6.2 文档格式</a></li>
<li><a href="#63-定义文档的模板">6.3 定义文档的模板</a></li>
<li><a href="#64-讨论即文档">6.4 讨论即文档</a></li>
<li><a href="#65-注释即文档">6.5 注释即文档</a></li>
<li><a href="#66-代码即文档">6.6 代码即文档</a></li>
</ul>
</li>
<li><a href="#7-ui设计规范">7 UI设计规范</a></li>
<li><a href="#8-测试规范">8 测试规范</a><ul>
<li><a href="#81-测试的流程">8.1 测试的流程</a></li>
<li><a href="#82-单元测试">8.2 单元测试</a></li>
</ul>
</li>
<li><a href="#9-异常处理监控和调试规范">9 异常处理、监控和调试规范</a><ul>
<li><a href="#91-异常处理">9.1 异常处理</a></li>
<li><a href="#92-日志">9.2 日志</a></li>
<li><a href="#93-异常监控">9.3 异常监控</a></li>
</ul>
</li>
<li><a href="#10-前后端协作规范">10 前后端协作规范</a><ul>
<li><a href="#101-协作流程规范">10.1 协作流程规范</a></li>
<li><a href="#102-接口规范">10.2 接口规范</a></li>
<li><a href="#103-接口文档规范">10.3 接口文档规范</a></li>
<li><a href="#104-接口测试与模拟">10.4 接口测试与模拟</a></li>
</ul>
</li>
<li><a href="#11-培训知识管理技术沉淀">11 培训/知识管理/技术沉淀</a><ul>
<li><a href="#111-新人培训">11.1 新人培训</a></li>
<li><a href="#112-营造技术氛围">11.2 营造技术氛围</a></li>
</ul>
</li>
<li><a href="#12-反馈">12 反馈</a></li>
</ul>
<!-- /TOC -->
<p><br></p>
<p><strong>CHANGELOG</strong></p>
<ul>
<li>2019.7.28<br>新增<a href="#tech-select">技术选型</a></li>
<li>2019.7.29<br>新增<a href="#brw-anly">浏览器统计数据获取</a></li>
<li>2019.9.6<br>建立技术氛围一节 新增面试题库</li>
<li>2019.9.27<br>更新系列文章</li>
</ul>
<p><br></p>
<p><strong>系列文章</strong></p>
<ul>
<li><a href="https://juejin.im/post/5d3a7134f265da1b5d57f1ed" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么制定前端协作规范? 🔥</a></li>
<li><a href="https://juejin.im/post/5d71cec6e51d4561b674c4d0" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么做好概要设计</a></li>
<li><a href="https://juejin.im/post/5d8d4557e51d4577fe41b62d" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么用好看板进行任务管理?</a></li>
</ul>
<p><br></p>
<p><strong>什么是规范?</strong></p>
<p>规范，名词意义上：即明文规定或约定俗成的标准，如：道德规范、技术规范等。 动词意义上：是指按照既定标准、规范的要求进行操作，使某一行为或活动达到或超越规定的标准，如：规范管理、规范操作.</p>
<p><br></p>
<p><strong>为什么需要规范?</strong></p>
<ul>
<li>降低新成员融入团队的成本, 同时也一定程度避免挖坑</li>
<li>提高开发效率、团队协作效率, 降低沟通成本</li>
<li>实现高度统一的代码风格，方便review, 另外一方面可以提高项目的可维护性</li>
<li>规范是实现自动化的基础</li>
<li>规范是一个团队知识沉淀的直接输出</li>
</ul>
<p><br></p>
<p><strong>规范包含哪些内容?</strong></p>
<p>如文章标题，<strong>前端协作规范并不单单指‘编码规范’，这个规范涉及到前端开发活动的方方面面</strong>，例如代码库的管理、前后端协作、代码规范、兼容性规范；</p>
<p>不仅仅是前端团队内部需要协作，一个完整的软件生命周期内，我们需要和产品/设计、后端(或者原生客户端团队)、测试进行协作, 我们需要覆盖这些内容.</p>
<p><br></p>
<p>下面就开始介绍，<strong>如果我是前端团队的Leader，我会怎么制定前端规范，这个规范需要包含哪些内容</strong>?</p>
<p><br></p>
<h2 id="1-工作流规范"><a href="#1-工作流规范" class="headerlink" title="1 工作流规范"></a>1 工作流规范</h2><h3 id="1-1-开发"><a href="#1-1-开发" class="headerlink" title="1.1 开发"></a>1.1 开发</h3><h4 id="1-1-1-版本规范"><a href="#1-1-1-版本规范" class="headerlink" title="1.1.1 版本规范"></a>1.1.1 版本规范</h4><p>项目的版本号应该根据某些规则进行迭代, 这里推荐使用<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本</a>规范, <strong>通过这个规范，用户可以了解版本变更的影响范围</strong>。 规则如下:</p>
<ul>
<li>主版本号：当你做了不兼容的 API 修改，</li>
<li>次版本号：当你做了向下兼容的功能性新增，</li>
<li>修订号：当你做了向下兼容的问题修正。</li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h4 id="1-1-2-版本控制系统规范"><a href="#1-1-2-版本控制系统规范" class="headerlink" title="1.1.2 版本控制系统规范"></a>1.1.2 版本控制系统规范</h4><p>大部分团队都使用git作为版本库，管理好代码也是一种学问。尤其是涉及多人并发协作、需要管理多个软件版本的情况下，定义良好的版本库管理规范，可以让大型项目更有组织性，也可以提高成员协作效率.</p>
<p>比较流行的git分支模型/工作流是<a href="https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow" target="_blank" rel="noopener">git-flow</a>, 但是大部分团队会根据自己的情况制定自己的git工作流规范, 例如我们团队的<a href="https://github.com/GDJiaMi/frontend-standards/blob/master/development.md#git-%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">分支规范</a></p>
<p><strong>Git 有很多工作流方法论，这些工作流的选择可能依赖于项目的规模、项目的类型以及团队成员的结构</strong>.</p>
<p>比如一个简单的个人项目可能不需要复杂的分支划分，我们的变更都是直接提交到 master 分支;</p>
<p>再比如开源项目，除了核心团队成员，其他贡献者是没有提交的权限的，而且我们也需要一定的手段来验证和讨论贡献的代码是否合理。 所以对于开源项目 fork 工作流更为适合.</p>
<p>了解常见的工作流有利于组织或创建适合自己团队的工作流, 提交团队协作的效率:</p>
<p><img src="/images/frontend-standard/branch.png" alt></p>
<ul>
<li><a href="https://github.com/ivan-94/git-guide/blob/master/branch/centralized.md" target="_blank" rel="noopener">简单的集中式</a></li>
<li><a href="https://github.com/ivan-94/git-guide/blob/master/branch/feature.md" target="_blank" rel="noopener">基于功能分支的工作流</a></li>
<li><a href="https://github.com/ivan-94/git-guide/blob/master/branch/gitflow.md" target="_blank" rel="noopener">Git Flow</a> 🔥</li>
<li><a href="https://github.com/ivan-94/git-guide/blob/master/branch/fork.md" target="_blank" rel="noopener">Fork/Pull Request 工作流</a></li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h4 id="1-1-3-提交信息规范"><a href="#1-1-3-提交信息规范" class="headerlink" title="1.1.3 提交信息规范"></a>1.1.3 提交信息规范</h4><p><img src="/images/frontend-standard/commit.png" alt></p>
<p>组织好的提交信息, 可以提高项目的整体质量. 至少具有下面这些优点:</p>
<ul>
<li><strong>格式统一的提交信息有助于自动化生成CHANGELOG</strong></li>
<li><strong>版本库不只是存放代码的仓库, 它记录项目的开发日志, 它应该要清晰表达这次提交的做了什么</strong>. 这些记录应该可以帮助后来者快速地学习和回顾代码, 也应该方便其他协作者review你的代码</li>
<li><strong>规范化提交信息可以促进提交者提交有意义的、粒度合适的’提交’</strong>. 提交者要想好要怎么描述这个提交，这样被动促进了他们去把控<strong>提交的粒度</strong></li>
</ul>
<p><br></p>
<p>社区上比较流行的提交信息规范是<a href="https://github.com/angular/angular/blob/master/CONTRIBUTING.md#commit" target="_blank" rel="noopener">Angular的提交信息规范</a>, 除此之外，这些也很不错:</p>
<ul>
<li><a href="https://github.com/atom/atom/blob/master/CONTRIBUTING.md#git-commit-messages" target="_blank" rel="noopener">Atom</a></li>
<li><a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-ember" target="_blank" rel="noopener">Ember</a></li>
<li><a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-eslint" target="_blank" rel="noopener">Eslint</a></li>
<li><a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-jquery" target="_blank" rel="noopener">JQuery</a></li>
</ul>
<p><br></p>
<p>另外这些工具可以帮助你检验提交信息, 以及生成CHANGELOG:</p>
<ul>
<li><a href="https://github.com/conventional-changelog/conventional-changelog" target="_blank" rel="noopener">conventional-changelog</a> - 从项目的提交信息中生成CHANGELOG和发布信息</li>
<li><a href="https://github.com/conventional-changelog/commitlint" target="_blank" rel="noopener">commitlint</a> - 检验提交信息</li>
<li><a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">commitizen</a> - 🔥简单的提交规范和提交帮助工具，推荐</li>
<li><a href="https://github.com/conventional-changelog/commitlint" target="_blank" rel="noopener">standard-changelog</a> - angular风格的提交命令行工具 </li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="1-2-构建规范"><a href="#1-2-构建规范" class="headerlink" title="1.2 构建规范"></a>1.2 构建规范</h3><p>对于团队、或者需要维护多个项目场景，统一的构建工具链很重要, <strong>这套工具应该强调”约定大于配置”，让开发者更专注于业务的开发</strong>。笔者在<a href="https://juejin.im/post/5d2fcaacf265da1b95708f63" target="_blank" rel="noopener">&lt;为什么要用vue-cli3?&gt;</a>文章中提出了<code>vue-cli3</code>更新有很多亮点，非常适合作为团队构建工具链的基础:</p>
<ul>
<li><strong>首先这类工具是推崇’约定大于配置’</strong>。即按照他们的规范，可以实现开箱即用，快速开发业务. 在团队协作中这点很重要，我们不推荐团队成员去关心又臭又长的webpack构建配置</li>
<li><strong><code>vue-cli3</code>抽离了<code>cli service层</code>，可以独立更新工具链</strong>。也就是说项目的构建脚本和配置在一个独立的service项目中维护，而不是像以前一样在每个项目目录下都有webpack配置和依赖. 这样做的好处是独立地、简单地升级整个构建链</li>
<li><strong>灵活的插件机制</strong>。对于团队的定制化构建应该封装到插件中，这样也可以实现独立的更新。</li>
</ul>
<p><strong>我们可以选择第三方CLI, 当然也定制自己的构建链，按照上面说的这个构建链应该有以下特点</strong>:</p>
<ul>
<li><strong>强约定，体现团队的规范</strong>。首先它应该避免团队成员去关心或更改构建的配置细节，暴露最小化的配置接口。 <em>另外构建工具不仅仅是构建，通常它还会集成代码检查、测试等功能</em>。</li>
<li><strong>方便升级</strong>。尤其是团队需要维护多个项目场景, 这一点很有意义</li>
</ul>
<p>下面是社区上比较流行的构建工具. 当然，你也可以根据自己的团队情况开发自己的CLI, 但是下面的工具依然很有<em>参考价值</em>：</p>
<ul>
<li><a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a> - 🔥零配置开始React开发</li>
<li><a href="https://cli.vuejs.org/" target="_blank" rel="noopener">vue-cli</a> - 🔥零配置、渐进增强的项目构建CLI</li>
<li><a href="https://parceljs.org/" target="_blank" rel="noopener">parcel</a> - 零配置的Web应用打包工具</li>
<li><a href="https://github.com/fuse-box/fuse-box" target="_blank" rel="noopener">Fusebox</a> - 高速易用的打包工具</li>
<li><a href="https://github.com/developit/microbundle" target="_blank" rel="noopener">microbundle</a> - 零配置, 基于Rollup，适合用于打包‘库’</li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="1-3-发布工作流规范"><a href="#1-3-发布工作流规范" class="headerlink" title="1.3 发布工作流规范"></a>1.3 发布工作流规范</h3><p>发布工作流指的是将‘软件成品’对外发布(如测试或生产)的一套流程, 将这套流程规范化后，可以实现自动化.</p>
<p>举个例子, 一个典型的发布工作流如下：</p>
<p><img src="/images/frontend-standard/pub.png" alt></p>
<ul>
<li>代码变更</li>
<li>提交代码变更到远程版本库</li>
<li>程序通过CI测试(例如Travis变绿)</li>
<li>提升package.json中的版本</li>
<li>生成CHANGELOG</li>
<li>提交package.json和CHANGELOG.md文件</li>
<li>打上Tag</li>
<li>推送</li>
</ul>
<p>如果你遵循上面的规范，那么就可以利用社区上现有的工具来自动化这个流程. 这些工具有:</p>
<ul>
<li><a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-cli" target="_blank" rel="noopener">conventional-changelog-cli</a></li>
<li><a href="https://github.com/conventional-changelog/conventional-github-releaser" target="_blank" rel="noopener">conventional-github-releaser</a></li>
<li>实际上自己开发一个也不是特别难的事情.</li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="1-4-持续集成"><a href="#1-4-持续集成" class="headerlink" title="1.4 持续集成"></a>1.4 持续集成</h3><p>将整套开发工作流确定下来之后, 就可以使用<code>持续集成服务</code>来自动化执行整个流程。比如一个典型的CI流程:</p>
<p><img src="/images/frontend-standard/ci.png" alt></p>
<p><strong>持续集成是什么，有什么意义呢</strong>?</p>
<p>我们需要<code>持续集成</code>拆成两个词分别来理解, 什么是<code>持续</code>? 什么是<code>集成</code>?</p>
<p><strong>持续(Continuous), 可以理解为’频繁’或者‘连续性’</strong>. 不管是持续集成还是敏捷开发思维、看板，都认为‘持续’是它们的基础。</p>
<p>举一个通俗的例子，<strong>比如代码检查，‘持续的’的代码检查就是代码一变动(如保存，或者IDE实时检查、或者提交到版本库时)就马上检查代码，而‘非持续’的代码检查就是在完成所有编码后，再进行检查</strong>。对比两者可以发现，持续性的代码检查可以尽早地发现错误，而且错误也比较容易理解和处理，反之非持续性的代码检查，可能会发现一堆的错误，失之毫厘谬以千里，错误相互牵连，最终会变得难以收拾。</p>
<p><strong>‘持续’的概念，可以用于软件开发的方方面面，本质上就是把传统瀑布式的软件开发流程打碎，形成一个个更小的开发闭环，持续地输出产品，同时产品也持续地给上游反馈和纠正</strong>。</p>
<p><img src="/images/frontend-standard/continous.png" alt></p>
<p><strong>那什么是‘集成’呢</strong>？狭义的集成可以简单认为是<a href="https://juejin.im/post/5d2c515d6fb9a07ead5a2bbe#heading-26" target="_blank" rel="noopener">‘集成测试’</a>吧. 集成测试可以对代码静态测试、单元测试、通过单元测试后可以进行集成测试，在应用组成一个整体后在模拟环境中跑E2E测试等等。也就是说，在这里进行一系列的自动化测试来验证软件系统。</p>
<p>广义的持续集成服务，不仅仅是测试，它还衍生出很多概念，例如持续交付、持续部署，如下图</p>
<p><img src="/images/frontend-standard/devops.png" alt></p>
<p>OK, <strong>总结一下为什么持续集成的好处</strong>:</p>
<ul>
<li>尽早发现错误，快速试错。越早发现错误，处理错误的成本越低</li>
<li>自动化工作流，减少人工干预。人类比机器容易犯错, 而且机器擅长做重复的事情</li>
</ul>
<p><br></p>
<p><strong>对于持续集成规范一般会定义这些内容</strong>:</p>
<ul>
<li>执行的环境. 比如容器、Node版本、操作系统等等</li>
<li>触发的条件。比如定时触发、在哪个分支触发、会触发什么任务等等</li>
<li>执行的任务</li>
<li>划分持续集成的阶段. 比如<ul>
<li>检查：包括单元测试和代码lint. 所有push到版本库的代码都会跑这个阶段. 一般可以在提交title中包含[ci skip]来跳过这个阶段</li>
<li>构建: 对前端项目进行构建. 只有打上版本tag的提交或release分支会跑构建任务</li>
<li>发布: 将前端的构建结果进行交付/发布.  只有打上版本tag的提交或者release分支在构建成功后会跑发布任务</li>
</ul>
</li>
<li>定义持续集成脚本模板</li>
</ul>
<p><br></p>
<p>常用的CI服务:</p>
<ul>
<li>Github<ul>
<li><a href="https://github.com/marketplace/travis-ci" target="_blank" rel="noopener">Travis CI</a></li>
<li><a href="https://github.com/marketplace/circleci" target="_blank" rel="noopener">CircleCI</a></li>
<li><a href="https://github.com/marketplace/category/continuous-integration" target="_blank" rel="noopener">完整列表</a></li>
</ul>
</li>
<li>GitLab: <a href="https://docs.gitlab.com/ee/ci/" target="_blank" rel="noopener">Gitlab-CI</a></li>
<li>通用<ul>
<li><a href="https://jenkins.io" target="_blank" rel="noopener">Jenkins</a></li>
</ul>
</li>
</ul>
<p><br></p>
<p>扩展</p>
<ul>
<li><a href="https://juejin.im/post/58f9ee860ce46300611be392" target="_blank" rel="noopener">持续集成是什么</a></li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="1-5-任务管理"><a href="#1-5-任务管理" class="headerlink" title="1.5 任务管理"></a>1.5 任务管理</h3><p><img src="/images/frontend-standard/kanban.png" alt></p>
<p>作为前端Leader少不了任务管理。<strong>看板是目前最为流行的任务管理工具，它可以帮助我们了解项目的进度、资源的分配情况、还原开发现场</strong>.</p>
<p>笔者毕业第一年在一家很小的外包公司中工作，初生牛犊不怕虎，我竟然给老板推销起了看板和敏捷项目管理，想要改善项目管理这块效率低下问题，老板表示很支持，但是其他成员积极性并不高, 结果当然是失败的。</p>
<p>当时还起草了一份<a href="https://github.com/ivan-94/kanban_enforcement/blob/master/README.md#%E4%BB%80%E4%B9%88%E6%98%AF%E7%9C%8B%E6%9D%BF" target="_blank" rel="noopener">‘看板实施细则’</a>, 所以任务管理这一块也算小有心得吧.</p>
<p>说说一些比较好用的工具吧：</p>
<ul>
<li><strong>基于issue看板</strong> - 可以基于Gitlab或Github的Issue来做任务管理，它们都支持看板。很Geek，推荐</li>
<li><a href="https://tower.im/" target="_blank" rel="noopener"><strong>Tower</strong></a> - 专门做看板任务管理的。小团队基本够用。我们现在就使用这款产品</li>
<li><a href="https://www.teambition.com/" target="_blank" rel="noopener"><strong>teambition</strong></a> - 和Tower差不多，没有深入使用过</li>
<li><a href="https://trello.com/" target="_blank" rel="noopener"><strong>Trello</strong></a> - 颜值高.</li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<p><br></p>
<h2 id="2-技术栈规范"><a href="#2-技术栈规范" class="headerlink" title="2 技术栈规范"></a>2 技术栈规范</h2><p>笔者现在所在的公司之前前端技术栈就非常混乱，Vue、React和AngularJS三大框架都有, 而且风格相差也很大. 当时我就想收包裹走人. 关于技术栈不规范的下场可以参考印度的飞机: <a href="https://www.zhihu.com/question/26042167/answer/690035402" target="_blank" rel="noopener">&lt;为什么印度的飞机频繁被摔？&gt;</a></p>
<p>很少有人能精通这三个框架的，更别说是一个团队。</p>
<p><strong>三大框架跟编程语言一样都有自己的设计哲学，这跟库是不一样, 一个库的替换成本很低；而框架的背后是一个架构、一个生态。每个框架背后牵涉着开发思维、生态系统、配套工具、最佳实践、性能调优。要精通和熟练一个框架需要付出的成本是很高</strong>。</p>
<p><strong>所以说团队的开发效率是基于稳定且熟练的技术栈的</strong>。稳定的技术栈规范有利于团队协作和沟通; 另外如果团队精通这个技术栈，当出现问题或者需要深入调优, 会相对轻松。</p>
<p>前端技术栈规范主要包含下面这些类型:</p>
<ul>
<li>编程语言 - Typescript或Javascript</li>
<li>UI框架及其配套生态, 以及备选方案。其背后的生态非常庞大:<ul>
<li>UI框架</li>
<li>路由</li>
<li>状态管理</li>
<li>组件库</li>
<li>国际化</li>
<li>动画</li>
<li>服务端渲染</li>
<li>脚手架、CLI工具</li>
<li>组件测试</li>
</ul>
</li>
<li>样式. 包含了命名规范、预处理器、方法论等等</li>
<li>动画引擎</li>
<li>QA. 包含了测试、Lint、格式化工具、监控</li>
<li>项目构建工具流. 例如webpack、vue-cli</li>
<li>包管理器。npm、yarn</li>
<li>项目管理工具</li>
<li>时间处理。例如Moment.js</li>
<li>模板引擎</li>
<li>开发工具</li>
<li>后端开发框架</li>
<li>工具库</li>
<li>开发/调试工具</li>
<li>等等</li>
</ul>
<p>可以参考一下我们团队的<a href="https://github.com/GDJiaMi/frontend-standards/blob/master/tech-stack.md" target="_blank" rel="noopener">技术栈规范</a></p>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="2-1-技术选型"><a href="#2-1-技术选型" class="headerlink" title="2.1 技术选型"></a>2.1 技术选型</h3><p><a id="tech-select"></a></p>
<p><strong>如何从零对团队的技术栈进行规范, 或者说怎么进行选型呢</strong>？举个例子, 先确定备选项, 你现在要选Vue还是选React(一个可能引起论战的主题)？</p>
<p>恰好前几天在SegmentFault回答了一个问题: <a href="https://segmentfault.com/q/1010000019762657/a-1020000019775888" target="_blank" rel="noopener">&lt;什么时候用vue什么时候用react？&gt;</a>, 我讲了一个我们<strong>几年前</strong>是如何决定要使用React还是Vue的例子(注意结果不重要！)：</p>
<p><img src="/images/frontend-standard/vue-vs-react.png" alt></p>
<p><br></p>
<p><a href="https://www.infoq.cn/article/points-for-attention-with-technology-choice" target="_blank" rel="noopener">&lt;谈谈技术选型的注意事项&gt;</a>这篇文章写得非常好，给了我一些启发。结合上面的回答的例子, 来讲一讲在对相关技术进行选型的一些方法(评分项):</p>
<ul>
<li><p><strong>选择你最熟悉的技术</strong>。上面说到团队如果熟悉该技术，则可以很好地控制使用过程中的风险，方便对程序进行调优。所以成员熟悉、或至少Leader熟悉程度，是技术选型的一个打分项。</p>
<p>我们团队最终选择React的一个原因，就是我们熟悉它，它已经在现有的几个应用中良好的运行了，所以 React + 1</p>
</li>
<li><p><strong>选择拥有强大生态和社区支撑的开源技术</strong>。有强大的生态和社区意味着，很多东西你不需要重复去造轮子，或者遇到问题可以很快解决，有更多的选择。从公司层面、使用活跃的技术也比较好招人。</p>
<p>上面的例子也提到了这点，几年前React的生态是强于Vue的，所以 React + 1</p>
</li>
<li><p><strong>选择成长期的技术</strong>。<a href="https://www.infoq.cn/article/points-for-attention-with-technology-choice" target="_blank" rel="noopener">&lt;谈谈技术选型的注意事项&gt;</a>里面有一句话：’选择一个技术的最低标准是，技术的生命周期必须显著长于项目的生命周期’</p>
<p> 我们选择的技术应该是向前发展的、面向未来的, 这是选型的基本原则。所以我们一般不会去选择那些’过气’的技术，比如<code>AngularJS</code>(1.x)、<code>Backbone</code>. 因为现在有更好的选择，不必过于保守。</p>
<p> ‘向前’还意味着Leader要能够预判该技术未来走向，这里有很多参考因素，比如大厂的支撑、目前社区的活跃度、开发活跃度等等</p>
<p> React、Vue都非常有动力，比如React最近的React Hook、还有未来的ConcurrentMode、Async Rendering… 在这点上Vue和React打成平手吧</p>
</li>
<li><p><strong>API的稳定性</strong>。比较典型的例子就是Angular和Python，API不稳定会导致社区的割裂，也会导致项目升级成本变高、或者无法升级, 最终成为技术债。</p>
<p>不过值得庆幸的是因为有这么多历史教训，现在开源项目在API变更上面是非常谨慎的，参考<a href="https://juejin.im/post/5d0f64d4f265da1b67211893" target="_blank" rel="noopener">[译] Vue 最黑暗的一天</a>事件. </p>
<p>这点上React和Vue依旧打平</p>
</li>
<li><p><strong>基础设施配合</strong>。一个技术往往不是孤立存在的，它需要和其他技术相互配合，这种技术之间的融合度也是需要考虑的。</p>
<p>这个根据团队使用情况来定，比如我们团队统一使用Typescript，Vue跟Typescript配合使用其实不理想，所以 React + 1</p>
</li>
<li><p><strong>业务考虑</strong> <a href="https://www.infoq.cn/article/points-for-attention-with-technology-choice" target="_blank" rel="noopener">&lt;谈谈技术选型的注意事项&gt;</a> 提到一点就是‘学会从业务端开始思考’. 意思<strong>就是选型需要充分地理解业务，理解用户需求，当下需要解决的首要问题，以及可能的风险有哪些，再将目标进行分解，进行具体的技术选型、模型设计、架构设计</strong>.</p>
<p>一个典型的例子就是10年前火遍世界的<code>Rails</code>, 后端是使用Rails还是Java/C#/PHP这些传统后端技术? 很多初创公司(如Github、Gitlab、Twitter)选择了前者，他们需要快速开发原型、快速占领市场, Rails开发很爽很快啊, 这种选型就是符合‘业务需求的’。</p>
<p>那么前端好像跟业务离得有点远? 随着‘大前端’的发展，我们的工作对公司业务的影响只会越来越大。</p>
<p>比如上面提到的React Native，我们当时有考虑在移动端应用React Native技术，实现客户端的跨平台，这就是业务影响啊。这时候React是不是又要 +1? 同理还有什么服务端渲染、Serverless等等，期待前端的地位会越来越高</p>
</li>
</ul>
<p>综上，在这个案例中，React是胜出的。</p>
<p>扩展:</p>
<ul>
<li><a href="https://www.infoq.cn/article/2017/02/Technology-selection" target="_blank" rel="noopener">谈谈技术选型</a></li>
<li><a href="https://www.infoq.cn/article/points-for-attention-with-technology-choice" target="_blank" rel="noopener">谈谈技术选型的注意事项</a></li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="2-2-迎接新技术"><a href="#2-2-迎接新技术" class="headerlink" title="2.2 迎接新技术"></a>2.2 迎接新技术</h3><p>当然，对于团队而言也要鼓励学习新的技术、淘汰旧的技术栈。因为一般而言新的技术或解决方案，是为了更高的生产力而诞生的。<strong>当团队容纳一个新的技术选型需要考虑以下几点</strong>：</p>
<ul>
<li><strong>学习成本</strong>。考虑团队成员的接纳能力。如果成本小于收获的利益，在团队里面推行估计阻力会比较大</li>
<li><strong>收益</strong>。是否能够解决当前的某些痛点</li>
<li><strong>考虑风险</strong>。一般我们不能将一个实验阶段的技术使用的生产环境中</li>
</ul>
<p>就我们团队而言，每个成员都有自己感兴趣的方向和领域，所以我们可以分工合作，探索各自的领域，再将成果分享出来，如果靠谱的话则可以在实验项目中先试验一下，最后才推广到其他项目.</p>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<p><br></p>
<h2 id="3-浏览器兼容规范"><a href="#3-浏览器兼容规范" class="headerlink" title="3 浏览器兼容规范"></a>3 浏览器兼容规范</h2><p>前端团队应该根据针对应用所面对的用户情况、应用类型、开发成本、浏览器市场统计数据等因素，来制定自己的浏览器兼容规范，并写入应用使用手册中.</p>
<p><strong>有了浏览器兼容规范，前端开发和兼容性测试就有理有据，避免争议; 同时它也是前端团队的一种对外声明，除非特殊要求，不符合浏览器兼容规范的浏览器，前端开发人员可以选择忽略</strong>。</p>
<p><br></p>
<h3 id="3-1-确定兼容策略"><a href="#3-1-确定兼容策略" class="headerlink" title="3.1 确定兼容策略"></a>3.1 确定兼容策略</h3><p><img src="/images/frontend-standard/g-p.jpg" alt></p>
<p><strong>渐进增强</strong>还是<strong>优雅降级</strong>. 这是两个不同方向策略，<strong>渐进增强保证低版本浏览器的体验，对于支持新特性的新浏览器提供稍好的体验</strong>；<strong>优雅降级则是相反的，为现代浏览器提供最好的体验，而旧浏览器则退而求之次，保证大概的功能</strong>.</p>
<p>选择不同的策略对前端开发的影响是比较大的，但是开发者没有选择权。<strong>确定哪种兼容策略，应该取决于用户比重，如果大部分用户使用的是现代浏览器，就应该使用优雅降级，反之选择渐进增强</strong>.</p>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="3-2-确定浏览器分级"><a href="#3-2-确定浏览器分级" class="headerlink" title="3.2 确定浏览器分级"></a>3.2 确定浏览器分级</h3><p><img src="/images/frontend-standard/brw-levl.gif" alt></p>
<p>YUI就曾提出浏览器分级原则，到今天这个原则依然适用。简单说就是将浏览器划分为多个等级，不同等级表示不同的支持程度. 比如我们团队就将浏览器划分为以下<a href="https://github.com/GDJiaMi/frontend-standards/blob/master/browser-compatibility.md" target="_blank" rel="noopener">三个等级</a>:</p>
<ul>
<li><strong>完全兼容</strong>: 保证百分百功能正常</li>
<li><strong>部分兼容</strong>: 只能保证功能、样式与需求大致一致。对于一些不影响主体需求和功能的bug，会做降低优先级处理或者不处理。</li>
<li><strong>不兼容</strong>: 不考虑兼容性</li>
</ul>
<p>一般而言, 根据浏览器市场分布情况、用户占比、开发成本等因素划分等级.</p>
<p>举个例子，下面是我们对管理系统的兼容规范:</p>
<p><img src="/images/frontend-standard/cpt.png" alt></p>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="3-3-获取统计数据"><a href="#3-3-获取统计数据" class="headerlink" title="3.3 获取统计数据"></a>3.3 获取统计数据</h3><p><a id="brw-anly"></a></p>
<p><img src="/images/frontend-standard/bdtj.png" alt></p>
<p><br></p>
<p><a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener">百度统计</a>是中文网站使用最为广泛的、免费的流量分析平台. 如上图，通过这些统计平台可以获取到终端真实的浏览器使用情况, 点击<a href="https://tongji.baidu.com/web/demo/visit/client?siteId=5503017" target="_blank" rel="noopener">查看示例</a>。</p>
<p>如果公司没有开发自己监控服务，还是建议使用这些免费的，有大厂支持的监控工具:</p>
<ul>
<li><a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener">百度统计</a></li>
<li><a href="https://web.umeng.com/main.php?spm=a211g2.211692.0.0.3a437d23sjzEPv&amp;c=user&amp;a=index" target="_blank" rel="noopener">友盟</a></li>
<li><a href="https://analytics.google.com/analytics/web/" target="_blank" rel="noopener">Google Analytics</a> 需要kx上网</li>
</ul>
<p><br></p>
<p><strong>可以从这些地方获取通用的浏览器统计数据</strong>:</p>
<ul>
<li><a href="http://tongji.baidu.com/data/browser" target="_blank" rel="noopener">百度流量研究院</a>：主要提供国内浏览器统计</li>
<li><a href="http://gs.statcounter.com/" target="_blank" rel="noopener">statcounter</a>: 国际浏览器统计</li>
<li><a href="https://en.wikipedia.org/wiki/Timeline_of_web_browsers" target="_blank" rel="noopener">浏览器发布年份统计</a></li>
</ul>
<p><br></p>
<p><strong>确定浏览器是否支持某个特性</strong>:</p>
<ul>
<li><a href="https://caniuse.com" target="_blank" rel="noopener">caniuse</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">MDN</a></li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<p><br></p>
<h2 id="4-项目组织规范"><a href="#4-项目组织规范" class="headerlink" title="4 项目组织规范"></a>4 项目组织规范</h2><p>项目组织规范定义了如何组织一个前端项目, 例如项目的命名、项目的文件结构、版本号规范等等。尤其对于开源项目，规范化的项目组织就更重要了。</p>
<h3 id="4-1-通用的项目组织规范"><a href="#4-1-通用的项目组织规范" class="headerlink" title="4.1 通用的项目组织规范"></a>4.1 通用的项目组织规范</h3><p>一个典型的项目组织规范如下:</p>
<ul>
<li><strong>README.md</strong>: 项目说明, 这个是最重要。你必须在这里提供关于项目的关键信息或者相关信息的入口. 一般包含下列信息:<ul>
<li>简要描述、项目主要特性</li>
<li>运行环境/依赖、安装和构建、测试指南</li>
<li>简单示例代码</li>
<li>文档或文档入口, 其他版本或相关资源入口</li>
<li>联系方式、讨论群</li>
<li>许可、贡献/开发指南</li>
</ul>
</li>
<li><strong>CHANGELOG.md</strong>: 放置每个版本的变动内容, 通常要描述每个版本变更的内容。方便使用者确定应该使用哪个版本. 关于CHANGELOG的规范可以参考<a href="https://keepachangelog.com/en/1.0.0/" target="_blank" rel="noopener">keep a changelog</a></li>
<li><strong>package.json</strong>: 前端项目必须. 描述当前的版本、<strong>可用的命令</strong>、包名、依赖、环境约束、项目配置等信息.</li>
<li><strong>.gitignore</strong>: 忽略不必要的文件，避免将自动生成的文件提交到版本库</li>
<li><strong>.gitattributes</strong>: git配置，有一些跨平台差异的行为可能需要在这里配置一下，如换行规则</li>
<li><strong>docs/</strong>: 项目的细化文档, 可选.</li>
<li><strong>examples/</strong>: 项目的示例代码，可选.</li>
<li><strong>build</strong>: 项目工具类脚本放置在这里，非必须。如果使用统一构建工具，则没有这个目录</li>
<li><strong>dist/</strong>: 项目构建结果输出目录</li>
<li><strong>src/</strong>: 源代码目录</li>
<li><p><strong><strong>tests</strong>/</strong>: 单元测试目录. 按照<a href="http://jestjs.io" target="_blank" rel="noopener">Jest</a>规范, <code>__tests__</code>目录通常和被测试的模块在同一个父目录下, 例如:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/src</span><br><span class="line">  __tests__/</span><br><span class="line">    index.ts</span><br><span class="line">    a.ts</span><br><span class="line">  index.ts</span><br><span class="line">  a.ts</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>tests</strong>: 全局的测试目录，通常放应用的集成测试或E2E测试等用例</p>
</li>
<li><p><strong>.env*</strong>: 项目中我们通常会使用<code>环境变量</code>来影响应用在不同运行环境下的行为. 可以通过<a href="https://github.com/motdotla/dotenv" target="_blank" rel="noopener">dotEnv</a>来从文件中读取环境变量. 通常有三个文件:</p>
<ul>
<li><code>.env</code> 通用的环境变量</li>
<li><code>.env.development</code> 开发环境的环境变量</li>
<li><code>.env.production</code> 生成环境的环境变量</li>
</ul>
<p>基本上这些文件的变动的频率很少，团队成员应该不要随意变动，以免影响其他成员。所以通常会使用<code>.env.*.local</code>文件来覆盖上述的配置, 另外会设置版本库来忽略<code>*.local</code>文件.</p>
</li>
</ul>
<p><br></p>
<p><strong>对于开源项目通常还包括这些目录</strong>:</p>
<ul>
<li><strong>LICENSE</strong>: 说明项目许可</li>
<li><strong>.github</strong>: 开源贡献规范和指南<ul>
<li>CONTRIBUTING: 贡献指南, 这里一般会说明贡献的规范、以及项目的基本组织、架构等信息</li>
<li>CODE_OF_CONDUCT: 行为准则</li>
<li>COMMIT_CONVENTION: 提交信息规范，上文已经提及</li>
<li>ISSUE_TEMPLATE: Issue的模板，github可以自动识别这个模板</li>
<li>PULL_REQUEST_TEMPLATE: PR模板</li>
</ul>
</li>
</ul>
<p>任意一个优秀的开源项目都是你的老师，例如<a href="https://github.com/facebook/react" target="_blank" rel="noopener">React</a>、<a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">Vue</a>…</p>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="4-2-目录组织的风格"><a href="#4-2-目录组织的风格" class="headerlink" title="4.2 目录组织的风格"></a>4.2 目录组织的风格</h3><p>上面只是一个通用的项目组织规范，具体源代码如何组织还取决于你们使用的技术栈和团队喜好。网上有很多教程，具体可以搜索<code>怎么组织XX项目</code>. 总结一下项目组织主要有三种风格:</p>
<ul>
<li><p><strong>Rails-style</strong>: 按照文件的类型划分为不同的目录，例如<code>components</code>、<code>constants</code>、 <code>typings</code>、<code>views</code>. 这个来源于Ruby-on-Rails框架，它按照MVC架构来划分不同的目录类型，典型的目录结构如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">app</span><br><span class="line">  models # 模型</span><br><span class="line">  views # 视图</span><br><span class="line">  controllers # 控制器</span><br><span class="line">  helpers # 帮助程序</span><br><span class="line">  assets  # 静态资源</span><br><span class="line">config     # 配置</span><br><span class="line">  application.rb</span><br><span class="line">  database.yml</span><br><span class="line">  routes.rb      # 路由控制</span><br><span class="line">  locales        # 国际化配置</span><br><span class="line">  environments/</span><br><span class="line">db        # 数据库相关</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>Domain-style</strong>:  按照一个功能特性或业务创建单独的目录，这个目录就近包含多种类型的文件或目录. 比如一个典型的Redux项目，所有项目的文件就近放置在同一个目录下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Users/</span><br><span class="line">Home/</span><br><span class="line">  components/</span><br><span class="line">  actions.js</span><br><span class="line">  actionTypes.js</span><br><span class="line">  constants.js</span><br><span class="line">  index.js</span><br><span class="line">  model.js</span><br><span class="line">  reducer.js</span><br><span class="line">  selectors.js</span><br><span class="line">  style.css</span><br><span class="line">index.js</span><br><span class="line">rootReducer.js</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Ducks-style</strong>: 优点类似于Domain-style，不过更彻底, 它通常将相关联的元素定义在一个文件下。Vue的单文件组件就是一个典型的例子，除此之外Vuex也是使用这种风格:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h1&gt;My Todo App!&lt;/h1&gt;</span><br><span class="line">    &lt;TodoList/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import TodoList from &apos;./components/TodoList.vue&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    TodoList</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">@import &apos;./variables.scss&apos;;</span><br><span class="line">/* ... */</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<p>大部分情况下, 我们都是使用混合两种方式的目录结构，例如:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  components/      # 🔴 项目通用的‘展示组件’</span><br><span class="line">    Button/</span><br><span class="line">      index.tsx    # 组件的入口, 导出组件</span><br><span class="line">      Groups.tsx   # 子组件</span><br><span class="line">      loading.svg  # 静态资源</span><br><span class="line">      style.css    # 组件样式</span><br><span class="line">    ...</span><br><span class="line">    index.ts       # 到处所有组件</span><br><span class="line">  containers/      # 🔴 包含'容器组件'和'页面组件'</span><br><span class="line">    LoginPage/     # 页面组件, 例如登录</span><br><span class="line">      components/  # 页面级别展示组件，这些组件不能复用与其他页面组件。</span><br><span class="line">        Button.tsx # 组件未必是一个目录形式，对于一个简单组件可以是一个单文件形式. 但还是推荐使用目录，方便扩展</span><br><span class="line">        Panel.tsx</span><br><span class="line">      reducer.ts   # redux reduces</span><br><span class="line">      useLogin.ts  # (可选)放置'逻辑', 按照👆分离逻辑和视图的原则，将逻辑、状态处理抽取到hook文件</span><br><span class="line">      types.ts     # typescript 类型声明</span><br><span class="line">      style.css</span><br><span class="line">      logo.png</span><br><span class="line">      message.ts</span><br><span class="line">      constants.ts</span><br><span class="line">      index.tsx</span><br><span class="line">    HomePage/</span><br><span class="line">    ...</span><br><span class="line">    index.tsx      # 🔴应用根组件</span><br><span class="line">  hooks/           # 🔴可复用的hook</span><br><span class="line">    useList.ts</span><br><span class="line">    usePromise.ts</span><br><span class="line">  ...</span><br><span class="line">  index.tsx        # 应用入口, 在这里使用ReactDOM对跟组件进行渲染</span><br><span class="line">  stores.ts        # redux stores</span><br><span class="line">  contants.ts      # 全局常量</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>框架官方很少会去干预项目的组织方式，读者可以参考下面这些资源来建立自己项目组织规范:</p>
<ul>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fcn.redux.js.org%2Fdocs%2Ffaq%2FCodeStructure.html" target="_blank" rel="noopener">Redux 常见问题：代码结构</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Freact-boilerplate%2Freact-boilerplate" target="_blank" rel="noopener">react-boilerplate</a></li>
<li><a href="https://vuex.vuejs.org/zh/guide/structure.html" target="_blank" rel="noopener">vuex 项目结构</a></li>
<li><a href="https://juejin.im/post/5cd8fb916fb9a03218556fc1#heading-11" target="_blank" rel="noopener">React组件设计实践总结02 - 组件的组织</a></li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="4-3-脚手架和项目模板"><a href="#4-3-脚手架和项目模板" class="headerlink" title="4.3 脚手架和项目模板"></a>4.3 脚手架和项目模板</h3><p>在将项目结构规范确定下来后，可以创建自己的脚手架工具或者项目模板，用于快速初始化一个项目或代码模板。</p>
<p>相关资源:</p>
<ul>
<li><a href="https://yeoman.io" target="_blank" rel="noopener">yeoman</a> - 老牌的项目脚手架工具</li>
<li><a href="https://github.com/amwmedia/plop" target="_blank" rel="noopener">plop</a> - 代码生成辅助CLI</li>
<li><a href="https://github.com/jondot/hygen" target="_blank" rel="noopener">hygen</a> - 类似于plop</li>
<li><a href="https://github.com/diegohaz/generact" target="_blank" rel="noopener">generact</a> - 生成React组件, 大部分组件的文件结构差不多, 这个工具就是帮助你生成这些重复的代码</li>
<li><a href="https://babeljs.io/docs/en/babel-generator" target="_blank" rel="noopener">babel-code-generator</a> - 利用babel来实现更高级的代码编辑和自动生成</li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<p><br></p>
<h2 id="5-编码规范"><a href="#5-编码规范" class="headerlink" title="5 编码规范"></a>5 编码规范</h2><p>网络上大部分‘前端规范’指的都是编码规范, 这是一种‘狭义’的前端规范. </p>
<p><strong>统一的编码规范对团队项目的长远维护不无裨益. 一致性的代码规范可以增强团队开发协作效率、提高代码质量、减少遗留系统维护的负担</strong>。</p>
<p>最直接的好处就是避免写出糟糕的代码, 糟糕的代码与新手和老手关系不大，我也见过好处工作很多年的‘资深’工程师写出恶心的代码. 这样的代码随着项目的迭代会变得难以控制。</p>
<p><strong>现代的Lint工具已经非常先进，几乎可以约束各种编码行为</strong>. 比如约束一个文件的长度、函数的复杂度、命名规范、注释规范、接口黑名单、DeadCode、检查简单的逻辑错误…</p>
<p>每一个程序员心目中对‘好代码’都有自己的主见，统一的编码规范可以像秦始皇统一战国一样，避免不必要的论战和争议。</p>
<p><br></p>
<p><strong>其实与其自己建立前端编码规范，笔者推荐选择社区沉淀下来的规范</strong>. 这方面的资源非常多，所以本文也不武断地提出自己的规范建议. 推荐下面这些资源:</p>
<p><br></p>
<h3 id="5-1-javascript"><a href="#5-1-javascript" class="headerlink" title="5.1 Javascript"></a>5.1 Javascript</h3><ul>
<li>Lint工具<ul>
<li><a href="https://cn.eslint.org" target="_blank" rel="noopener">ESLint</a> - 🔥目前是社区最流行的、通用的Javascript Lint工具，Lint界的Babel。支持定制插件、preset。如果不想折腾可以选择它的一些预定义配置</li>
<li><a href="https://github.com/palantir/tslint" target="_blank" rel="noopener">TSLint</a> - Typescript Lint工具。不过即将<a href="https://github.com/palantir/tslint/issues/4534" target="_blank" rel="noopener">废弃</a>了, 推荐使用ESLint</li>
</ul>
</li>
<li>规范<ul>
<li><a href="https://standardjs.com/readme-zhcn.html#why-should-i-use-javascript-standard-style" target="_blank" rel="noopener">JavaScript Standard Style</a> - 🔥 零配置的、‘标准’的Javascript编码规范. 底层基于Eslint。目前不支持Typescript</li>
<li><a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">Airbnb JavaScript Style Guide</a> - Airbnb的编码规范，业界标杆</li>
</ul>
</li>
<li>类型检查. 暂时将它们归类到这里，因为它们同属于<a href="https://juejin.im/post/5d2c515d6fb9a07ead5a2bbe#heading-39" target="_blank" rel="noopener">‘静态测试’</a><ul>
<li><a href="https://www.typescriptlang.org" target="_blank" rel="noopener">Typescript</a> - 🔥 Javascript语言的超集，这是一门‘新’的语言，而不是简单的类型检查器. 不过<strong>它也支持<a href="https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html" target="_blank" rel="noopener">原生Javascript的类型检查</a></strong></li>
<li><a href="https://flow.org" target="_blank" rel="noopener">Flow</a> - Facebook出品的类型检查器，语法和Typescript类似. 个人推荐使用Typescript</li>
</ul>
</li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="5-2-html"><a href="#5-2-html" class="headerlink" title="5.2 HTML"></a>5.2 HTML</h3><ul>
<li>Lint工具<ul>
<li><a href="https://htmlhint.io" target="_blank" rel="noopener">HTMLHint</a></li>
<li><a href="https://github.com/twbs/bootlint" target="_blank" rel="noopener">bootlint</a></li>
</ul>
</li>
<li>规范<ul>
<li><a href="https://codeguide.co" target="_blank" rel="noopener">Code Guide</a></li>
</ul>
</li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="5-3-css"><a href="#5-3-css" class="headerlink" title="5.3 CSS"></a>5.3 CSS</h3><ul>
<li>Lint工具<ul>
<li><a href="https://stylelint.docschina.org" target="_blank" rel="noopener">stylelint</a> - 🔥 通用的CSS编码检查工具，支持最新的CSS语法、CSS-in-js、以及其他类CSS语法(如SCSS、Less). 它也有预定义配置，推荐使用</li>
</ul>
</li>
<li>规范<ul>
<li><a href="https://github.com/airbnb/css" target="_blank" rel="noopener">Airbnb CSS / Sass Styleguide</a></li>
<li><a href="https://codeguide.co" target="_blank" rel="noopener">Code Guide</a></li>
<li><a href="https://css-tricks.com/css-style-guides/" target="_blank" rel="noopener">更多</a></li>
</ul>
</li>
<li>方法论<ul>
<li><a href="https://css-tricks.com/bem-101/" target="_blank" rel="noopener">BEM</a> - 🔥 BEM命名规范</li>
<li><a href="https://github.com/stubbornella/oocss/wiki" target="_blank" rel="noopener">OOCSS</a></li>
<li><a href="http://smacss.com" target="_blank" rel="noopener">smacss</a></li>
</ul>
</li>
</ul>
<p><br></p>
<p>关于CSS可以学习<a href="http://twitter.github.com/bootstrap/" target="_blank" rel="noopener">Bootstrap</a>这些传统UI框架，他们的代码组织性非常好, 值得学习</p>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="5-4-代码格式化"><a href="#5-4-代码格式化" class="headerlink" title="5.4 代码格式化"></a>5.4 代码格式化</h3><p><img src="/images/frontend-standard/prt.png" alt></p>
<ul>
<li><a href="https://prettier.io" target="_blank" rel="noopener">Prettier</a> - 🔥 关于代码格式化的所有东西都交给它吧！</li>
</ul>
<p>基本上，所有代码格式相关的工作都可以交给Prettier来做，在这个基础上再使用Eslint覆盖语义相关的检查</p>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="5-5-集大成的"><a href="#5-5-集大成的" class="headerlink" title="5.5 集大成的"></a>5.5 集大成的</h3><ul>
<li><a href="https://coderlmn.github.io/code-standards/#_code_reviews" target="_blank" rel="noopener">isobar 前端代码规范及最佳实践</a></li>
<li><a href="https://guide.aotu.io/index.html" target="_blank" rel="noopener">凹凸实验室代码规范</a></li>
<li><a href="https://github.com/fex-team/styleguide" target="_blank" rel="noopener">百度FEX规范</a></li>
<li><a href="http://nec.netease.com/standard" target="_blank" rel="noopener">老牌的NEC规范</a> - 有点老</li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="5-6-特定框架风格指南"><a href="#5-6-特定框架风格指南" class="headerlink" title="5.6 特定框架风格指南"></a>5.6 特定框架风格指南</h3><ul>
<li><a href="https://vue.docschina.org/v2/style-guide/" target="_blank" rel="noopener">vue-style-guide</a></li>
<li><a href="https://github.com/airbnb/javascript/tree/master/react" target="_blank" rel="noopener">Airbnb React/JSX Style Guide</a></li>
<li><a href="https://juejin.im/post/5cd7f2c4e51d453a7d63b715" target="_blank" rel="noopener">React组件设计实践总结</a> - 自荐一下笔者写的React组件设计相关实践</li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="5-7-code-review"><a href="#5-7-code-review" class="headerlink" title="5.7 Code Review"></a>5.7 Code Review</h3><p><img src="/images/frontend-standard/code-review.png" alt></p>
<p>上述的Lint工具和类型检查器, 可以约束代码风格、避免低级的语法错误。但是即使通过上面的Lint和类型检查，代码也可能未必是‘好代码’。</p>
<p><strong>很多代码设计的‘最佳实践’是无法通过具象化的自动化工具或文档覆盖的, 这时候，’经验’或者’群体智慧’就派上用场了</strong>. 比如Code Review阶段会检查这些东西:</p>
<ul>
<li>编程原则、设计思想. 例如符合SOLID原则? 是否足够DRY？接口设计是否简洁易扩展、</li>
<li>模块耦合程度、代码重复</li>
<li>代码健壮性。是否存在内存泄露、是否线程安全、是否有潜在性能问题和异常、错误是否被处理</li>
<li>代码的性能和效率。</li>
<li>是否有没有考虑到的场景？</li>
</ul>
<p>如果你们是第一次推行Code Review, 可以建立一个检查列表，对照着进行检查。熟练后，心中自然无码。</p>
<p><br></p>
<p>Code Review有很多好处，比如：</p>
<ul>
<li><strong>Code Review可以让其他成员都熟悉代码</strong>。这样保证其他人都可以较快地接手你的工作，或者帮你解决某些问题</li>
<li><strong>提高代码质量</strong>。毫无疑问. 一方面是<em>主动性</em>的代码质量提升，比如你的代码需要被人Review，会自觉尽量的提高代码质量；另一方面，其他成员可以检查提交方的代码质量</li>
<li><strong>检查或提高新成员的编程水平</strong>。培养新人时，由于不信任它们提交的代码，我们会做一次Review检查代码是否过关。另一方面这是一次真实的案例讲解, 可以较快提高他们的能力</li>
</ul>
<p><br></p>
<p><strong>Code Review有两种方式: 一个<code>提交时</code>、一个是<code>定时</code></strong>:</p>
<ul>
<li><code>提交时</code>. 大部分开源项目采用这种方式。通俗讲就是Pull Request。只有代码通过测试、和其他成员的Review才可以合进正式版本库。这种方式也称为‘阻塞式’代码检查，一般配合GitFlow使用。</li>
<li><code>定时</code>. 在项目完结后、项目的某个里程碑、或者固定的时间(每天、每个星期..). 团队成员聚在一起，回顾自己写的代码, 让其他成员进行审查</li>
</ul>
<p>Code Review是比较难以推行的，不过这个也要看你们团队的情况，向我们钱少活多的团队，很少的时间去立马去兼顾其他成员的代码. 这时候<code>定时Review</code>会更有用，因为看起来更‘节省时间’.</p>
<p>而<code>提交时Review</code>则可以针对新人，比如你不信任他们的代码或者希望帮助他们提高编码能力。</p>
<p><br></p>
<p><strong>相关资源</strong>:</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIwMTQwNTA3Nw==&amp;mid=400946871&amp;idx=1&amp;sn=5a125337833768d705f9d87ba8cd9fff&amp;scene=1&amp;srcid=0104FLyeXIS6N0EShgDseIfI&amp;key=41ecb04b051110031290b34976240e650f0169d239c89f125162a89c8d3412f2087198612e71fd7685cae9eebe08e295&amp;ascene=0&amp;uin=MTYyMDMzMTAwMA%3D%3D&amp;devicetype=iMac+MacBookPro11%2C5+OSX+OSX+10.10.5+build(14F1509" target="_blank" rel="noopener">Code Review最佳实践</a>&amp;version=11020201&amp;pass_ticket=dc5bBckt1XSthRKTIsukYHIcAvKfv0jninbMlYQ5TWnE6XS%2FrRkdHKlJjNTI2Wsg)</li>
<li><a href="https://juejin.im/post/5c9740ba6fb9a071090d6a37" target="_blank" rel="noopener">是否要做Code Review？与BAT资深架构师争论之后的思考</a></li>
<li><a href="https://richardcao.me/2016/09/30/Talk-About-Codereview/" target="_blank" rel="noopener">一些Code Review工具</a></li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<p><br></p>
<h2 id="6-文档规范"><a href="#6-文档规范" class="headerlink" title="6 文档规范"></a>6 文档规范</h2><p>文档对于项目开发和维护、学习、重构、以及知识管理非常重要。</p>
<p>和写测试一样、大部分开发人员会觉得写文档是一件痛苦的事情，不过只有时间能够证明它的价值。比如对于人员流动比较大的公司，如果有规范的文档体系，转交工作就会变动非常轻松.</p>
<p><strong>广义的文档不单指‘说明文件’本身，它有很多形式、来源和载体，可以描述一个知识、以及知识形成和迭代的过程</strong>。例如版本库代码提交记录、代码注释、决策和讨论记录、CHANGELOG、示例代码、规范、传统文档等等</p>
<p><br></p>
<h3 id="6-1-建立文档中心"><a href="#6-1-建立文档中心" class="headerlink" title="6.1 建立文档中心"></a>6.1 建立文档中心</h3><p>我们公司是做IM的，所以之前我们优先使用’自己的’通讯工具来分享文档，这种方式有很大问题:</p>
<ol>
<li>如果没有存档习惯(比如后端的API文档，因为由后端维护，一般不会主动去存档), 文档就可能丢失，而且通讯工具是不会永久保存你的文档的。当丢失文件就需要重新和文档维护者索要</li>
<li>糟糕的是文档维护者也是自己手动在本地存档的，这样导致的问题是: 如果工作转交，其他开发者需要花费一点时间来查找; 丢失了就真的没了</li>
<li>每一次文档更新要重新发一份, 这很麻烦，而且可能出现漏发的情况, 导致前后不一致.</li>
<li>关于知识的学习、以及有意义的讨论记录无法归档。</li>
</ol>
<p>上面介绍的是一种非常原始的文档共享方式，很多小团队就是这么干的。</p>
<p><strong>对于项目本身的文档建议放置在关联项目版本库里面，跟随项目代码进行迭代, 当我们在检索或跟踪文档的历史记录时，这种方式是最方便的</strong>。</p>
<p>然而很多应用是跨越多个团队的，每个团队都会有自己的文档输出(比如需求文档、系统设计文档、API文档、配置文档等等)，而且通常也不会在一个版本库里。这时候文档就比较分散。所以一个统一的文档中心是很有必要。</p>
<p>我们公司现在选择的方案是<code>Git+Markdown</code>，也就是说所有的文档都放置在一个git版本库下。之前也考虑过商业的方案，譬如<a href="https://shimo.im/welcome" target="_blank" rel="noopener">石墨文档</a>、<a href="https://docs.qq.com" target="_blank" rel="noopener">腾讯文档</a>, 但管理层并不信任这些服务。</p>
<p>大概的git项目组织如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">规范/</span><br><span class="line">A应用/</span><br><span class="line">  产品/</span><br><span class="line">  设计/</span><br><span class="line">  API文档/</span><br><span class="line">  测试/</span><br><span class="line">  其他/</span><br><span class="line">B应用/</span><br></pre></td></tr></table></figure>
<p><strong>Git版本库(例如Gitlab)有很多优势，例如历史记录跟踪、版本化、问题讨论(可以关联issue、或者提交)、多人协作、搜索、权限管理(针对不同的版本库或分组为不同人员设置权限)等等</strong>。</p>
<p><code>Git+Markdown</code>可以满足开发者的大部分需求。但是<strong>Git最擅长的是处理纯文本文件、对于二进制是无能为力的，无法针对这些类型的文档进行在线预览和编辑</strong>。</p>
<p>所以<code>Git+Markdown</code>并不能满足多样化的文档处理需求，比如思维导图、图表、表格、PPT、白板等需求. 毕竟它不是专业的文档处理工具。所以对于产品、设计人员这些富文档需求场景，通常会按照传统方式或者更专业的工具对文档进行管理.</p>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="6-2-文档格式"><a href="#6-2-文档格式" class="headerlink" title="6.2 文档格式"></a>6.2 文档格式</h3><p>毫无疑问，对于开发者来说，<a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">Markdown</a>是最适合的、最通用的文档格式。支持版本库在线预览和变更历史跟踪。</p>
<p>下面这些工具可以提高Markdown的开发效率:</p>
<ul>
<li>可视化编辑器<ul>
<li><strong>Visual Code</strong>: 大部分代码编辑都支持Markdown编辑和预览</li>
<li><a href="https://link.jianshu.com/?t=http://mouapp.com/" target="_blank" rel="noopener"><strong>Mou</strong></a>: Mac下的老牌编辑器</li>
<li><a href="https://typora.io" target="_blank" rel="noopener"><strong>typora</strong></a>: 跨平台的Markdown编辑器，推荐</li>
</ul>
</li>
<li><strong>markdownlint</strong>: 编码检查器</li>
<li>扩展(Visual Studio Code):<ul>
<li><strong>Markdown All in One</strong>: All you need to write Markdown (keyboard shortcuts, table of contents, auto preview and more)</li>
<li><strong>Markdown TOC</strong>: markdown 目录生成，我最常用的markdown插件</li>
</ul>
</li>
<li>图表绘制工具:<ul>
<li><a href="https://www.draw.io" target="_blank" rel="noopener"><strong>drawio</strong></a> 基于Web的图表绘制工具、也有离线客户端</li>
<li><strong>KeyNote/PPT</strong> 临时绘图也不错</li>
</ul>
</li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="6-3-定义文档的模板"><a href="#6-3-定义文档的模板" class="headerlink" title="6.3 定义文档的模板"></a>6.3 定义文档的模板</h3><p>关于如何写好文档，很难通过标准或规范来进行约束，因为它的主观性比较强, 好的文档取决于编辑者的逻辑总结能力、表达能力、以及有没有站在读者的角度去思考问题。</p>
<p>所以大部分情况下，我们可以为不同类型的文档提供一个模板，通过模板来说明一个文档需要包含哪些内容, 对文档的编写者进行引导.</p>
<p>例如一个API文档可能需要这些内容:</p>
<ul>
<li>接口的索引</li>
<li>接口的版本、变更记录</li>
<li>用法和整体描述, 认证鉴权等等</li>
<li>描述具体的接口<ul>
<li>功能说明</li>
<li>方法名称或者URI</li>
<li>参数和返回值定义</li>
<li>调用示例</li>
<li>注意事项等等</li>
</ul>
</li>
</ul>
<p>具体规范内容因团队而异，这里点到为止.</p>
<p><br></p>
<p>扩展:</p>
<ul>
<li><a href="https://github.com/ruanyf/document-style-guide/blob/master/docs/reference.md" target="_blank" rel="noopener">中文技术文档的写作规范</a></li>
<li><a href="https://github.com/reactjs/rfcs/blob/master/0000-template.md" target="_blank" rel="noopener">React RFC模板</a></li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="6-4-讨论即文档"><a href="#6-4-讨论即文档" class="headerlink" title="6.4 讨论即文档"></a>6.4 讨论即文档</h3><p><strong>一般情况下，对于一个开源项目来说除了官方文档，Issues也是一个很重要的信息来源。在Issue中我们可以获取其他开发者遇到的问题和解决方案、给官方反馈/投票、关注官方的最新动态、和其他开发者头脑风暴唇枪舌战等等</strong>。</p>
<p>所以相对于使用IM，笔者更推荐Issue这种沟通模式，因为<strong>它方便归档组织，索引和查找</strong>。而IM上的讨论就像流水一样，一去不复返。</p>
<p>当然两种工具的适用场景不一样，你拿IM的使用方式来使用Issue，Issue就会变得很水。<strong>Issue适合做有意义的、目的明确的讨论</strong>。 所以要谴责一下在Github Issue上灌水的开发者。</p>
<p>关于Issue有很多妙用，推荐阅读这篇文章<a href="http://www.ruanyifeng.com/blog/2017/08/issue.html" target="_blank" rel="noopener">&lt;如何使用 Issue 管理软件项目？&gt;</a></p>
<p>现在很多开源项目都引入了RFC(请求意见稿)流程(参考<a href="https://www.infoq.cn/article/2017/12/react-rfc-process" target="_blank" rel="noopener">React采用新的RFC流程</a>, 以及<a href="https://juejin.im/post/5d0f64d4f265da1b67211893" target="_blank" rel="noopener">Vue 最黑暗的一天</a>), 这让开发者有‘翻身农奴、当家做主’的感觉，任何人都可以参与到一个开源项目重大事件的决策之中。<strong>每个RFC会说明决策的动机、详细设计、优缺点。除了官方文档之外，这些RFC是很有价值的学习资料</strong>。</p>
<p>我觉得如果不涉及机密，团队应该要让更多人参与到项目的设计和决策中，对于新手可以学到很多东西，而对于发起者也可能有考虑不周的情况。</p>
<p>那对于企业应用开发, Issue有用吗?</p>
<p>当然有用, 比如我们可以将这类话题从IM转移到Issue:</p>
<ul>
<li>设计方案</li>
<li>决策/建议<ul>
<li>新功能、新技术引入</li>
<li>重构</li>
<li>性能优化</li>
<li>规范</li>
</ul>
</li>
<li>问题讨论</li>
<li>重大事件</li>
<li>计划或进度跟踪</li>
<li>…</li>
</ul>
<p><br></p>
<p>另外Issue通常通过标签来进行分类，方便组织和检索:</p>
<p><img src="/images/frontend-standard/issue.png" alt></p>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="6-5-注释即文档"><a href="#6-5-注释即文档" class="headerlink" title="6.5 注释即文档"></a>6.5 注释即文档</h3><p><strong>必要和适量的注释对阅读源代码的人来说就是一个路牌, 可以少走很多弯路</strong>.</p>
<p>关于注释的一些准则，<a href="https://github.com/alibaba/p3c/blob/master/p3c-gitbook/%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6/%E6%B3%A8%E9%87%8A%E8%A7%84%E7%BA%A6.md" target="_blank" rel="noopener">&lt;阿里巴巴Java开发手册&gt;</a>总结得非常好, 推荐基于这个来建立注释规范。另外通过ESlint是可以对注释进行一定程度的规范。</p>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="6-6-代码即文档"><a href="#6-6-代码即文档" class="headerlink" title="6.6 代码即文档"></a>6.6 代码即文档</h3><p>现在有很多种工具支持从代码中解析和生成文档, 这可以给开发者简化很多文档维护的工作。</p>
<p>举个例子，我们经常会遇到修改了代码，但是文档忘记同步的情况。通过‘代码即文档’的方式至少可以<strong>保持文档和代码同步更新</strong>；另外<strong>很多工具会分析代码的数据类型</strong>，自动帮我们生成参数和返回值定义，这也可以减少很多文档编写工作以及出错率。</p>
<p>比如可以通过下面注释方式来生成组件文档:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Props注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> interface ColumnProps extends React.HTMLAttributes&lt;any&gt; &#123;</span><br><span class="line">  <span class="comment">/** prop1 description */</span></span><br><span class="line">  prop1?: string;</span><br><span class="line">  <span class="comment">/** prop2 description */</span></span><br><span class="line">  prop2: number;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * prop3 description</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  prop3: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">/** prop4 description */</span></span><br><span class="line">  prop4: <span class="string">'option1'</span> | <span class="string">'option2'</span> | <span class="string">'option3'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对组件进行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Column</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">ColumnProps</span>, </span>&#123;&#125;&gt; &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Column<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>相关的工具有:</p>
<ul>
<li>API文档<ul>
<li>Typescript<ul>
<li><a href="https://github.com/microsoft/tsdoc" target="_blank" rel="noopener">tsdoc</a> Typescript官方的注释文档标准</li>
<li><a href="https://github.com/TypeStrong/typedoc" target="_blank" rel="noopener">typedoc</a> 基于tsdoc标准的文档生成器</li>
</ul>
</li>
<li>Javascript<ul>
<li><a href="https://github.com/jsdoc/jsdoc" target="_blank" rel="noopener">jsdoc</a> Javascript文档注释标准和生成器</li>
</ul>
</li>
</ul>
</li>
<li>后端接口文档<ul>
<li><a href="https://swagger.io" target="_blank" rel="noopener">Swagger</a> Restful接口文档规范</li>
<li>GraphQL: 这个有很多工具，例如<a href="https://github.com/graphql/graphiql" target="_blank" rel="noopener">graphiql</a>, 集成了Playground和文档，很先进</li>
<li><a href="https://easy-mock.com/login" target="_blank" rel="noopener">Easy Mock</a> 一个可视化，并且能快速生成模拟数据的服务</li>
</ul>
</li>
<li>组件文档<ul>
<li><a href="https://storybook.js.org" target="_blank" rel="noopener">StoryBook</a> 通用的组件开发、测试、文档工具</li>
<li>React<ul>
<li><a href="http://docz.site" target="_blank" rel="noopener">Docz</a></li>
<li><a href="https://github.com/styleguidist/react-styleguidist" target="_blank" rel="noopener">Styleguidist</a></li>
</ul>
</li>
<li>Vue<ul>
<li><a href="https://github.com/vue-styleguidist/vue-styleguidist" target="_blank" rel="noopener">vue-styleguidist</a></li>
<li>有更好的工具请评论告诉我</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<p><br></p>
<h2 id="7-ui设计规范"><a href="#7-ui设计规范" class="headerlink" title="7 UI设计规范"></a>7 UI设计规范</h2><p><img src="/images/frontend-standard/ui-design.png" alt></p>
<p>这是一个容易被忽略的规范类型。笔者就深受其苦，我们公司初期UI并不专业，没有所谓的设计规范，这就导致他们设计出来的产品都是东借西凑，前后不统一，多个应用之间的组件不能复用。这搞得我们不得不浪费时间，写很多定制化样式和组件，为他们的不专业买单.</p>
<p>关于UI设计规范的重要性有兴趣的读者可以看这篇文章<a href="https://juejin.im/post/5b766ac56fb9a009aa154c27" target="_blank" rel="noopener">&lt;开发和设计沟通有多难？ - 你只差一个设计规范&gt;</a>. </p>
<p>简单总结一下UI设计规范的意义：</p>
<ul>
<li>提供团队协作效率(产品和开发)</li>
<li>提高组件的复用率. 统一的组件规范可以让组件更好管理</li>
<li>保持产品迭代过程中品牌一致性</li>
</ul>
<p>建立一个定义良好的设计规范需要<code>UI设计和开发</code>的紧密配合，有时候也可以由我们前端来推动。</p>
<p>比如很多开源的UI框架，一开始都是开发者YY出来的，并没有设计参与，后来组件库慢慢沉淀成型，UI设计师才介入规范一下。</p>
<p>如果你们团队不打算制定自己的UI设计规范，则推荐使用现成的开源组件库：</p>
<ul>
<li><a href="https://ant.design/index-cn" target="_blank" rel="noopener">Ant Design</a></li>
<li><a href="https://material-ui.com" target="_blank" rel="noopener">Material-UI</a></li>
<li><a href="https://element.eleme.io" target="_blank" rel="noopener">Element UI</a></li>
<li><a href="https://weui.io" target="_blank" rel="noopener">WeUI</a></li>
<li><a href="https://developer.microsoft.com/en-us/fabric#/" target="_blank" rel="noopener">Microsoft Fabric</a></li>
</ul>
<p>这些开源组件库都经过良好的设计和沉淀, 而且配套了完善的设计原则、最佳实践和设计资源文件（Sketch 和 Axure），可以帮助业务快速设计出高质量的产品原型。</p>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<p><br></p>
<h2 id="8-测试规范"><a href="#8-测试规范" class="headerlink" title="8 测试规范"></a>8 测试规范</h2><p>测试是保障代码质量的重要手段，但是很少有人愿意在这里花太多时间。</p>
<p>比如笔者，我很少会去给业务代码和组件写单元测试，除非自己对代码非常没有信心，按照我的理念写测试不如将代码写得更简单一点，比如把一个函数拆分为更小的函数，保持单一职责。</p>
<p>但是<strong>对于一些底层、共享的代码模块还是有测试的必要的</strong>。</p>
<p>我在<a href="https://juejin.im/post/5d2c515d6fb9a07ead5a2bbe" target="_blank" rel="noopener">不知道测试什么？这些是你需要知道的软件测试类型和常识</a>文章中，列举了一些开发者需要关注的测试类型和常识, 如果按照测试的阶段进行分类，大概是这样子的:</p>
<p><img src="/images/frontend-standard/testing.png" alt></p>
<p><br></p>
<p>其中前端开发者需要关注的主要有以下几种测试类型:</p>
<ul>
<li><strong>单元测试</strong>: 对独立的软件模块进行测试<ul>
<li><strong>UI组件测试</strong>: 包括了快照(Snapshot)测试</li>
</ul>
</li>
<li><strong>集成测试</strong>: 在单元测试的基础上，将模块组合起来，测试它们的组合性</li>
<li><strong>E2E测试</strong>: 在完整、真实的运行环境下模拟真实用户对应用进行测试。<strong>主要测试前端和后端的协调性</strong></li>
<li><strong>兼容性测试</strong>: 上面提到了浏览器兼容规范，在将版本提交给测试/发布之前，需要确保能符合兼容性要求</li>
<li><strong>性能测试</strong>: 测试和分析是否存在性能问题</li>
<li><strong>其他</strong>:<ul>
<li>安全测试</li>
<li>SEO测试</li>
</ul>
</li>
</ul>
<p>因为对于小公司来说整个软件开发流程可能没有那么规范，比如很难构建一个完整的端对端测试环境，这些都不是前端团队可以操作的范围, 所以自动化测试很难推行。但是可以根据团队和业务情况逐步进行开展。</p>
<p>可实施性比较高的, 也比较简单是单元测试，所以本文也重点关注单元测试.</p>
<p><br></p>
<h3 id="8-1-测试的流程"><a href="#8-1-测试的流程" class="headerlink" title="8.1 测试的流程"></a>8.1 测试的流程</h3><p>首先要定义一个合适的软件测试流程, 合适的测试流程可以降低开发和测试团队之间的沟通协作成本、提高测试效率。例如我们团队目前的测试流程:</p>
<p><img src="/images/frontend-standard/test-proc.png" alt></p>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="8-2-单元测试"><a href="#8-2-单元测试" class="headerlink" title="8.2 单元测试"></a>8.2 单元测试</h3><p>单元测试有很多<strong>好处</strong>, 比如:</p>
<ul>
<li><strong>提高信心，适应变化和迭代</strong>. 如果现有代码有较为完善的单元测试，在代码重构时，可以检验模块是否依然可以工作, 一旦变更导致错误，单元测试也可以帮助我们快速定位并修复错误</li>
<li><strong>单元测试是集成测试的基础</strong></li>
<li><strong>测试即文档</strong>。如果文档不能解决你的问题，在你打算看源码之前，可以查看单元测试。通过这些测试用例，开发人员可以直观地理解程序单元的基础API</li>
<li><strong>提升代码质量。易于测试的代码，一般都是好代码</strong></li>
</ul>
<p><br></p>
<p><strong>测什么?</strong></p>
<p>业务代码或业务组件是比较难以实施单元测试的，一方面它们比较多变、另一方面很多团队很少有精力维护这部分单元测试。所以<strong>通常只要求对一些基础/底层的组件、框架或者服务进行测试, 视情况考虑是否要测试业务代码</strong></p>
<p><br></p>
<p><strong>测试的准则</strong>:</p>
<ul>
<li>推荐Petroware的<a href="https://petroware.no/unittesting.html" target="_blank" rel="noopener">Unit Testing Guidelines</a>, 总结了27条单元测试准则，非常受用.</li>
<li>另外&lt;阿里巴巴的Java开发手册&gt;中总结的<a href="https://github.com/alibaba/p3c/blob/master/p3c-gitbook/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.md" target="_blank" rel="noopener">单元测试准则</a>, 也不错，虽然书名是Java，准则是通用的.</li>
</ul>
<p><br></p>
<p><strong>单元测试指标</strong>:</p>
<p>一般使用<a href="https://zh.wikipedia.org/wiki/代碼覆蓋率" target="_blank" rel="noopener"><code>测试覆盖率</code></a>来量化，尽管对于覆盖率能不能衡量单元测试的有效性存在较多争议。</p>
<p>大部分情况下还是推荐尽可能提高覆盖率, 比如要求<code>语句覆盖率达到70%；核心模块的语句覆盖率和分支覆盖率都要达到100%</code>. 视团队情况而定</p>
<p>扩展:</p>
<ul>
<li><a href="https://www.infoq.cn/article/test-coverage-rate-role" target="_blank" rel="noopener">测试覆盖（率）到底有什么用？</a></li>
</ul>
<p><br></p>
<p><strong>相关工具</strong></p>
<ul>
<li>Headless Browsers: 无头浏览器是网页自动化的重要运行环境。 常用于功能测试、单元测试、网络爬虫<ul>
<li><a href="https://github.com/GoogleChrome/puppeteer" target="_blank" rel="noopener">puppeteer</a></li>
<li><a href="https://chromium.googlesource.com/chromium/src/+/lkgr/headless/README.md" target="_blank" rel="noopener">Headless Chromium</a></li>
</ul>
</li>
<li>测试框架<ul>
<li><a href="http://jest.io/" target="_blank" rel="noopener">Jest</a> 🔥Facebook的单元测试框架. 零配置, 支持组件快照测试、模块Mock、Spy. 一般场景, 单元测试学它一个就行了<ul>
<li>组件测试<ul>
<li><a href="https://github.com/testing-library" target="_blank" rel="noopener">testing-library</a> 🔥</li>
<li><a href="https://github.com/airbnb/enzyme" target="_blank" rel="noopener">Enzyme</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://theintern.github.io/" target="_blank" rel="noopener">Intern</a></li>
</ul>
</li>
<li>单元测试<ul>
<li><a href="https://github.com/avajs/ava" target="_blank" rel="noopener">AVA</a></li>
<li><a href="http://jasmine.github.io/" target="_blank" rel="noopener">Jasmine</a></li>
<li><a href="http://mochajs.org/" target="_blank" rel="noopener">Mocha</a></li>
<li><a href="https://github.com/substack/tape" target="_blank" rel="noopener">Tape</a></li>
</ul>
</li>
<li>断言库<ul>
<li><a href="http://chaijs.com/" target="_blank" rel="noopener">Chai</a></li>
<li><a href="https://github.com/Automattic/expect.js" target="_blank" rel="noopener">expect.js</a></li>
<li><a href="http://shouldjs.github.io/" target="_blank" rel="noopener">should.js</a></li>
</ul>
</li>
<li>Mock/Stubs/Spies<ul>
<li><a href="http://sinonjs.org/" target="_blank" rel="noopener">sinon.js</a></li>
</ul>
</li>
<li>代码覆盖率<ul>
<li><a href="https://github.com/gotwarlost/istanbul" target="_blank" rel="noopener">istanbul</a></li>
</ul>
</li>
<li>基准测试<ul>
<li><a href="http://benchmarkjs.com/" target="_blank" rel="noopener">benchmark.js</a></li>
<li><a href="https://jsperf.com/" target="_blank" rel="noopener">jsperf.com</a></li>
</ul>
</li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<p><br></p>
<h2 id="9-异常处理、监控和调试规范"><a href="#9-异常处理、监控和调试规范" class="headerlink" title="9 异常处理、监控和调试规范"></a>9 异常处理、监控和调试规范</h2><p>很多开发者常常误用或者轻视异常的处理, 合理有效的异常处理可以提高应用的健壮性和可用性，另外还可以帮助开发者快速定位异常.</p>
<h3 id="9-1-异常处理"><a href="#9-1-异常处理" class="headerlink" title="9.1 异常处理"></a>9.1 异常处理</h3><p>&lt;阿里巴巴的Java开发手册&gt;中总结的<a href="https://github.com/alibaba/p3c/blob/master/p3c-gitbook/%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.md" target="_blank" rel="noopener">异常处理规范</a>对JavaScript的异常处理也很有参考意义，比如:</p>
<ul>
<li>异常不要用来做流程控制，条件控制。</li>
<li>捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</li>
<li>catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。不要对大段代码进行try-catch</li>
<li>…</li>
</ul>
<p>然后再根据JavaScript本身的异常处理特点总结一些规范行为, 例如:</p>
<ul>
<li>不要throw非Error对象</li>
<li>不要忽略异步异常</li>
<li>全局监控Javascript异常</li>
<li>…</li>
</ul>
<p><br></p>
<p>资源:</p>
<ul>
<li><a href="https://rollbar.com/blog/top-10-javascript-errors/" target="_blank" rel="noopener">从1000+个项目中总结出来的前10个JavaScript错误, 以及如何避免它们</a></li>
<li><a href="https://levelup.gitconnected.com/the-definite-guide-to-handling-errors-gracefully-in-javascript-58424d9c60e6" target="_blank" rel="noopener">Javascript异常处理‘权威’指南</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/63698500" target="_blank" rel="noopener">前端异常处理最佳实践</a></li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="9-2-日志"><a href="#9-2-日志" class="headerlink" title="9.2 日志"></a>9.2 日志</h3><p>对于前端来说，日志也不是毫无意义(很多框架性能优化建议在生产环境移除console)。尤其是在<strong>生产现场</strong>调试代码时，这时候可贵的控制台日志可以帮助你快速找到异常的线索.</p>
<p>不过通常我们<strong>只要保留必要的、有意义的日志输出</strong>，比如你不应该将console.log放到一个React渲染函数中、或者放到一个循环中, <strong>DDos式的日志信息并不能帮助我们定位问题，反而会影响运行的性能</strong>. 所以需要一个规范来约束日志输出行为, 比如:</p>
<ul>
<li>避免重复打印日志</li>
<li>谨慎地记录日志, 划分日志级别。比如生产环境禁止输出debug日志；有选择地输出info日志；</li>
<li>使用前缀对日志进行分类, 例如: <code>[User] xxxx</code></li>
<li>只记录关键信息, 这些信息可以帮助你诊断问题</li>
<li>…</li>
</ul>
<p>扩展资源</p>
<ul>
<li><a href="https://github.com/visionmedia/debug" target="_blank" rel="noopener">debug</a> 适合Node.js和浏览器的debug日志工具, 支持动态开启日志打印</li>
<li><a href="https://github.com/Tencent/vConsole" target="_blank" rel="noopener">vConsole</a> 移动端调试利器</li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="9-3-异常监控"><a href="#9-3-异常监控" class="headerlink" title="9.3 异常监控"></a>9.3 异常监控</h3><p>因为程序跑在不受控的环境，所以对于客户端应用来说，异常监控在生产环境是非常重要的，它可以收集各种意料之外生产环境问题，帮助开发者快速定位异常。</p>
<p><br></p>
<p>异常监控通常会通过三种方式来收集异常数据:</p>
<ol>
<li>全局捕获。例如使用window.onerror, 或者<code>unhandledrejection</code></li>
<li>主动上报。在try/catch中主动上报. </li>
<li>用户反馈。比如弹窗让用户填写反馈信息.</li>
</ol>
<p>和日志一样，<strong>不是所有‘异常’都应该上报给异常监控系统，譬如一些预料之内的‘异常’</strong>，比如用户输入错误、鉴权失败、网络错误等等. <strong>异常监控主要用来上报一些意料之外的、或者致命性的异常</strong>.</p>
<p><br></p>
<p>要做好前端的异常监控其实并不容易，它需要处理这些东西:</p>
<ul>
<li>浏览器兼容性。</li>
<li>碎片收集(breadcrumbs)。 收集‘灾难’现场的一些线索，这些线索对问题诊断很重要。例如当前用户信息、版本、运行环境、打印的日志、函数调用栈等等</li>
<li>调用栈的转换。通常在浏览器运行的压缩优化过的代码，这种调用栈基本没什么可读性，通常需要通过SourceMap映射到原始代码. 可以使用这个库: <a href="https://github.com/mozilla/source-map#sourcemapconsumer" target="_blank" rel="noopener">source-map</a></li>
<li>数据的聚合。后端监控系统需要对前端上报的信息进行分析和聚合</li>
</ul>
<p><br></p>
<p>对于小团队未必有能力开发这一套系统，所以推荐使用一些第三方工具。例如</p>
<ul>
<li><a href="https://sentry.io/welcome/" target="_blank" rel="noopener">Sentry</a> 🔥免费基本够用</li>
<li><a href="https://www.fundebug.com/price" target="_blank" rel="noopener">FunDebug</a> 付费增强</li>
</ul>
<p><strong>扩展</strong>:</p>
<ul>
<li><a href="https://cdc.tencent.com/2018/09/13/frontend-exception-monitor-research/" target="_blank" rel="noopener">前端异常监控解决方案研究</a></li>
<li><a href="https://www.cnblogs.com/warm-stranger/p/9417084.html" target="_blank" rel="noopener">搭建前端监控系统</a></li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<p><br></p>
<h2 id="10-前后端协作规范"><a href="#10-前后端协作规范" class="headerlink" title="10 前后端协作规范"></a>10 前后端协作规范</h2><p>前端是Web的一个细分领域，往往不能脱离后端而存在。所以和后端协作的时间是最长的.</p>
<h3 id="10-1-协作流程规范"><a href="#10-1-协作流程规范" class="headerlink" title="10.1 协作流程规范"></a>10.1 协作流程规范</h3><p>前后端团队经过长期的合作，一般可以总结出一条对于双方开发效率最优的协作流程. 将这个落实为规范，后面的团队成员都遵循这个步调进行协作。</p>
<p>一个典型的前后端协作流程如下:</p>
<p><img src="/images/frontend-standard/f-b.png" alt></p>
<ol>
<li>需求分析。参与者一般有前后端、测试、以及产品. 由产品主持，对需求进行宣贯，接受开发和测试的反馈，确保大家对需求有一致的认知</li>
<li>前后端开发讨论。讨论应用的一些开发设计，沟通技术点、难点、以及分工问题.</li>
<li>设计接口文档。可以由前后端一起设计；或者由后端设计、前端确认是否符合要求</li>
<li>并行开发。前后端并行开发，在这个阶段，前端可以先实现静态页面; 或者根据接口文档对接口进行Mock, 来模拟对接后端接口</li>
<li>在联调之前，要求后端做好接口测试</li>
<li>真实环境联调。前端将接口请求代理到后端服务，进行真实环境联调。</li>
</ol>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="10-2-接口规范"><a href="#10-2-接口规范" class="headerlink" title="10.2 接口规范"></a>10.2 接口规范</h3><p>首先应该确定下来的是接口规范。其实使用哪种接口标准是其次，重要的是统一，且要满足前后端的开发效率要求.</p>
<p>笔者不建议后端去定义自己的接口标准，而应该去选择一些通用的、有标准定义接口形式, 例如:</p>
<ul>
<li><p><a href="https://zh.wikipedia.org/zh-hans/表现层状态转换" target="_blank" rel="noopener">RESTful</a>: RESTful是目前使用最为广泛的API设计规范, 基于HTTP本身的机制来实现. </p>
<p>笔者个人是比较喜欢这个API规范，但是我发现很多开发者并不能真正(或者说没心思)理解它，设计出来的接口，跟我想象的相差甚远。换句话说，对于RESTful，开发者之间很难达成一致的理解，容易产生分歧。</p>
<p>因为是使用最广泛的API形式，所以社区上有很多工具来对RESTful接口进行文档化、测试和模拟.</p>
</li>
<li><p><a href="http://wiki.geekdream.com/Specification/json-rpc_2.0.html" target="_blank" rel="noopener">JSONRPC</a> 这是一种非常简单、容易理解的接口规范。相对于RESTful我更推荐这个，简单则不容易产生分歧，新手也可以很快接受.</p>
</li>
<li><a href="https://graphql.org/learn/" target="_blank" rel="noopener">GraphQL</a> 🔥更为先进、更有前景的API规范。但是你要说服后端配合你使用这种标准可能很有难度</li>
</ul>
<p><br></p>
<p><strong>接口设计需要注意的点</strong>:</p>
<ul>
<li>明确区分是正常还是异常, 严格遵循接口的异常原语. 上述接口形式都有明确的异常原语，比如JSONRPC，当出现异常时应该返回<code>错误对象</code>响应，而不是在正常的响应体中返回错误代码. 另外要规范化的错误码, HTTP响应码就是一个不错的学习对象</li>
<li>明确数据类型。很多后端写的接口都是string和number不分的，如果妥协的话、前端就需要针对这个属性做特殊处理，这也可能是潜在的bug</li>
<li>明确空值的意义。比如在做更新操作是，空值是表示重置，还是忽略更新？</li>
<li>响应避免冗余的嵌套。</li>
<li>接口版本化，保持向下兼容。就像我们上文的‘语义化版本规范’说的，对于后端来说，API就是公共的接口. 公共暴露的接口应该有一个版本号，来说明当前描述的接口做了什么变动，是否向下兼容。<br>现在前端代码可能会在客户端被缓存，例如小程序。如果后端做了break change，就会影响这部分用户。</li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="10-3-接口文档规范"><a href="#10-3-接口文档规范" class="headerlink" title="10.3 接口文档规范"></a>10.3 接口文档规范</h3><p>后端通过接口文档向前端暴露接口相关的信息。通常需要包含这些信息：</p>
<ul>
<li>版本号</li>
<li>文档描述</li>
<li>服务的入口. 例如基本路径</li>
<li>测试服务器. 可选</li>
<li>简单使用示例</li>
<li>安全和认证</li>
<li>具体接口定义<ul>
<li>方法名称或者URL</li>
<li>方法描述</li>
<li>请求参数及其描述，必须说明类型(数据类型、是否可选等)</li>
<li>响应参数及其描述, 必须说明类型(数据类型、是否可选等)</li>
<li>可能的异常情况、错误代码、以及描述</li>
<li>请求示例，可选</li>
</ul>
</li>
</ul>
<p><strong>人工维护导致的问题</strong>:</p>
<p>上文‘代码即文档’就提到了人工维护接口文档可能导致代码和文档不同步问题。</p>
<p>如果可以从代码或者规范文档(例如OpenAPI这类API描述规范)中生成接口文档，可以解决实现和文档不一致问题, 同时也可以减少文档编写和维护的投入.</p>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="10-4-接口测试与模拟"><a href="#10-4-接口测试与模拟" class="headerlink" title="10.4 接口测试与模拟"></a>10.4 接口测试与模拟</h3><p>为了做到高效率的前后端并行开发，接口的测试与模拟是必要的。</p>
<ul>
<li>前端要求后端在联调之前，需要测试验证好自己的接口是否可以正常工作。而不是在联调期间，把前端当‘接口测试员’，阻塞接口联调进度</li>
<li>另外前端需要在后端接口未准备好之前，通过接口模拟的方式，来编写业务逻辑代码。</li>
</ul>
<p>针对接口测试与模拟，存在下图这样一个理想的模型:</p>
<p><img src="/images/frontend-standard/api-mock.png" alt></p>
<p>一切从定义良好的接口文档出发，生成<code>Mock Server</code>和<code>Mock Client</code>, Mock Server给前端提供模拟数据，而Mock Client则辅助后端对它们的接口进行测试.</p>
<p>资源:</p>
<ul>
<li>RESTful<ul>
<li><a href="https://swagger.io/" target="_blank" rel="noopener">Swagger</a> 这是最为接近上面理想模型的一个解决方案</li>
<li><a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">JSON Server</a> 快速生成JSON mock服务器</li>
<li><a href="https://easy-mock.com" target="_blank" rel="noopener">Easy Mock</a> 可视化的、在线的接口mock服务</li>
</ul>
</li>
<li>GraphQl<ul>
<li><a href="https://github.com/APIs-guru/graphql-faker" target="_blank" rel="noopener">GraphQL Faker</a></li>
<li><a href="https://www.apollographql.com/docs/graphql-tools/mocking/" target="_blank" rel="noopener">graphql-tools</a></li>
</ul>
</li>
<li>模拟数据生成<ul>
<li><a href="https://github.com/Marak/faker.js" target="_blank" rel="noopener">faker.js</a> 🔥强大的模拟数据生成工具，支持Node和浏览器</li>
<li><a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">Mock.js</a> 数据生成和模拟工具</li>
</ul>
</li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<p><br></p>
<h2 id="11-培训-知识管理-技术沉淀"><a href="#11-培训-知识管理-技术沉淀" class="headerlink" title="11 培训/知识管理/技术沉淀"></a>11 培训/知识管理/技术沉淀</h2><p>我觉得一个团队的知识管理是非常重要的. 你要问一个刚入行的新手加入团队希望得到什么？很多人的回答是’学习’,  希望自己的技术可以更加精进, 钱倒还是其次。</p>
<p>然而现实是目前很多公司的氛围并不是这样的，一天到晚写业务代码、工作量大、每天做重复的事情，而且还加班，工作多年技术也没感觉有多少进步, 确实会让人非常沮丧。包括笔者也是这样的。</p>
<p>所以为了改善这种情况，我来聊聊最近在‘小团队’做的一些尝试.</p>
<h3 id="11-1-新人培训"><a href="#11-1-新人培训" class="headerlink" title="11.1 新人培训"></a>11.1 新人培训</h3><p>如果团队有规范的新成员培训手册，可以节省很多培训的时间，避免每次重复口述一样的内容。培训手册包含以下内容:</p>
<ul>
<li><p><strong>产品架构与组织架构</strong>. 介绍公司背景和产品，一般组织的团队结构和产品的架构是相关联的. 以笔者所在公司为例, 主要产品是即时通信:</p>
<p><img src="/images/frontend-standard/org.png" alt></p>
</li>
<li><p><strong>产品研发流程</strong>: 介绍产品开发和迭代会涉及到的流程、以及团队之间的协作衔接，例如:</p>
<p><img src="/images/frontend-standard/dev-proc.png" alt></p>
</li>
<li><p><strong>工作范围</strong>: 团队成员的职责范围</p>
</li>
<li><strong>建立资源索引</strong>: 开发需要设计到的资源，比如各种文档地址、研发系统入口(例如gitlab、bug跟踪系统、文件共享、发布平台、开发/测试环境、监控系统)、协作规范等等。将这些资源整理好可以减少不必要的沟通成本</li>
<li><strong>规范</strong>: 即本文的主体’前端协作规范’。有规范可循，可以让成员以较快的速度入手开发、同时也减少培训成本投入。</li>
</ul>
<p>培训手册将可以文档具象化的内容整理为文档，和上文说到的Code Review一样，一些东西无法通过文档来说明，所以我们一般会搭配一个‘培训导师’，在试用期间，一对一辅导。</p>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<h3 id="11-2-营造技术氛围"><a href="#11-2-营造技术氛围" class="headerlink" title="11.2 营造技术氛围"></a>11.2 营造技术氛围</h3><ul>
<li><strong>鼓励成员写技术博客，或者建立自己的团队专栏</strong>. 写一篇好的文章不容易</li>
<li><strong>鼓励参与开源项目</strong></li>
<li><strong>建立面试题库</strong> 组织一起解一些面试题或算法题，加深对知识点的理解</li>
<li><p><strong>定期的专题分享</strong>. 鼓励团队成员定期进行专题学习和研究，编写技术博客，并将学习的成果分享给其他成员. 这是一种抱团取暖的学习方式，旨在帮助团队成员一起学习和成长。</p>
<p>比如开发老手可以分享自己的经验，研究更深层次的技术；新手则可以研究某些开发技巧、新技术，例如CSS Grid，svg动画等等。推荐团队成员有个明确的研究领域，这样分工合作可以学习到更多东西.</p>
<p><strong>专题怎么来?</strong></p>
<ul>
<li>专题请求. 可以请求其他成员完成专题，比如比较深的知识，可以要求团队比较有经验的进行学习分享</li>
<li>学习总结.</li>
<li>项目回顾</li>
<li>难点攻克</li>
<li>项目规范</li>
<li>工具使用</li>
</ul>
</li>
<li><p><strong>落实和完善开发规范</strong>. 规范本身就是团队知识沉淀的一种直接输出</p>
</li>
<li><strong>图书分享</strong>. 和离散的文章或教程相比，图书的知识会比较系统，另外很多经典的图书是要静下来好好欣赏的。</li>
<li><strong>鼓励重构和持续优化代码</strong></li>
<li><strong>抽象一套基础库或框架，减少重复工作, 提高工作效率</strong>. 不加班先从提高工作效率开始</li>
</ul>
<p><br></p>
<p><a href="#">⬆️回到顶部</a></p>
<p><br></p>
<h2 id="12-反馈"><a href="#12-反馈" class="headerlink" title="12 反馈"></a>12 反馈</h2><p>大家有什么要补充或意见可以在下方评论, 一起来完善这篇文章, 谢谢！</p>
<p><img src="/images/sponsor.jpg" alt></p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-工作流规范"><span class="toc-number">1.</span> <span class="toc-text">1 工作流规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-开发"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-版本规范"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1 版本规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-版本控制系统规范"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2 版本控制系统规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-提交信息规范"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.1.3 提交信息规范</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-构建规范"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 构建规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-发布工作流规范"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 发布工作流规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-持续集成"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 持续集成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-任务管理"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 任务管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-技术栈规范"><span class="toc-number">2.</span> <span class="toc-text">2 技术栈规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-技术选型"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 技术选型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-迎接新技术"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 迎接新技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-浏览器兼容规范"><span class="toc-number">3.</span> <span class="toc-text">3 浏览器兼容规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-确定兼容策略"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 确定兼容策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-确定浏览器分级"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 确定浏览器分级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-获取统计数据"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 获取统计数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-项目组织规范"><span class="toc-number">4.</span> <span class="toc-text">4 项目组织规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-通用的项目组织规范"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 通用的项目组织规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-目录组织的风格"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 目录组织的风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-脚手架和项目模板"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 脚手架和项目模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-编码规范"><span class="toc-number">5.</span> <span class="toc-text">5 编码规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-javascript"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 Javascript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-html"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 HTML</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-css"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 CSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-代码格式化"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 代码格式化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-集大成的"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 集大成的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-特定框架风格指南"><span class="toc-number">5.6.</span> <span class="toc-text">5.6 特定框架风格指南</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-code-review"><span class="toc-number">5.7.</span> <span class="toc-text">5.7 Code Review</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-文档规范"><span class="toc-number">6.</span> <span class="toc-text">6 文档规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-建立文档中心"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 建立文档中心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-文档格式"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 文档格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-定义文档的模板"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 定义文档的模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-讨论即文档"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 讨论即文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-注释即文档"><span class="toc-number">6.5.</span> <span class="toc-text">6.5 注释即文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-代码即文档"><span class="toc-number">6.6.</span> <span class="toc-text">6.6 代码即文档</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-ui设计规范"><span class="toc-number">7.</span> <span class="toc-text">7 UI设计规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-测试规范"><span class="toc-number">8.</span> <span class="toc-text">8 测试规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-测试的流程"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 测试的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-单元测试"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 单元测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-异常处理、监控和调试规范"><span class="toc-number">9.</span> <span class="toc-text">9 异常处理、监控和调试规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-异常处理"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-日志"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-异常监控"><span class="toc-number">9.3.</span> <span class="toc-text">9.3 异常监控</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-前后端协作规范"><span class="toc-number">10.</span> <span class="toc-text">10 前后端协作规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-协作流程规范"><span class="toc-number">10.1.</span> <span class="toc-text">10.1 协作流程规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-接口规范"><span class="toc-number">10.2.</span> <span class="toc-text">10.2 接口规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-接口文档规范"><span class="toc-number">10.3.</span> <span class="toc-text">10.3 接口文档规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-接口测试与模拟"><span class="toc-number">10.4.</span> <span class="toc-text">10.4 接口测试与模拟</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-培训-知识管理-技术沉淀"><span class="toc-number">11.</span> <span class="toc-text">11 培训/知识管理/技术沉淀</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-新人培训"><span class="toc-number">11.1.</span> <span class="toc-text">11.1 新人培训</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-营造技术氛围"><span class="toc-number">11.2.</span> <span class="toc-text">11.2 营造技术氛围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-反馈"><span class="toc-number">12.</span> <span class="toc-text">12 反馈</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2019/07/19/frontend-standard/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2019/07/19/frontend-standard/&text=if 我是前端团队Leader，怎么制定前端协作规范?"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2019/07/19/frontend-standard/&title=if 我是前端团队Leader，怎么制定前端协作规范?"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2019/07/19/frontend-standard/&is_video=false&description=if 我是前端团队Leader，怎么制定前端协作规范?"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=if 我是前端团队Leader，怎么制定前端协作规范?&body=Check out this article: https://bobi.ink/2019/07/19/frontend-standard/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2019/07/19/frontend-standard/&title=if 我是前端团队Leader，怎么制定前端协作规范?"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2019/07/19/frontend-standard/&title=if 我是前端团队Leader，怎么制定前端协作规范?"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2019/07/19/frontend-standard/&title=if 我是前端团队Leader，怎么制定前端协作规范?"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2019/07/19/frontend-standard/&title=if 我是前端团队Leader，怎么制定前端协作规范?"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2019/07/19/frontend-standard/&name=if 我是前端团队Leader，怎么制定前端协作规范?&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2025 Ivan
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-44571525-2', 'auto');
        ga('send', 'pageview');
    </script>


    <!-- Disqus Comments -->
    <script type="text/javascript">
        var disqus_shortname = 'bobi-ink';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


