<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="本文主要探讨现阶段浏览器端可行的实时通信方案，以及它们的发展历史。 这里以sockjs作为切入点，这是一个流行的浏览器实时通信库，提供了’类Websocket’、一致性、跨平台的API，旨在浏览器和服务器之间创建一个低延迟、全双工、支持跨域的实时通信信道. 主要特点就是仿生Websocket，它会优先使用Websocket作为传输层，在不支持WebSocket的环境回退使用其他解决方案，例如XHR">
<meta name="keywords" content="Blog,FrontEnd,React,Javascript,Typescript">
<meta property="og:type" content="article">
<meta property="og:title" content="你可能不知道的浏览器实时通信方案">
<meta property="og:url" content="https://bobi.ink/2019/07/07/sockjs/index.html">
<meta property="og:site_name" content="Bobi.ink">
<meta property="og:description" content="本文主要探讨现阶段浏览器端可行的实时通信方案，以及它们的发展历史。 这里以sockjs作为切入点，这是一个流行的浏览器实时通信库，提供了’类Websocket’、一致性、跨平台的API，旨在浏览器和服务器之间创建一个低延迟、全双工、支持跨域的实时通信信道. 主要特点就是仿生Websocket，它会优先使用Websocket作为传输层，在不支持WebSocket的环境回退使用其他解决方案，例如XHR">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://bobi.ink/images/sockjs/base-http.png">
<meta property="og:image" content="https://bobi.ink/images/sockjs/http-keep-alive.png">
<meta property="og:image" content="https://bobi.ink/images/sockjs/websocket.png">
<meta property="og:image" content="https://bobi.ink/images/sockjs/http-req.png">
<meta property="og:image" content="https://bobi.ink/images/sockjs/http-pending-req.png">
<meta property="og:image" content="https://bobi.ink/images/sockjs/http-stream-ping.png">
<meta property="og:image" content="https://bobi.ink/images/sockjs/xhr-stream.png">
<meta property="og:image" content="https://bobi.ink/images/sockjs/eventsource.png">
<meta property="og:image" content="https://bobi.ink/images/sockjs/eventsource-inspect.png">
<meta property="og:image" content="https://bobi.ink/images/sockjs/htmlfile.png">
<meta property="og:image" content="https://bobi.ink/images/sockjs/htmlfile-progress.png">
<meta property="og:image" content="https://bobi.ink/images/sockjs/polling2.png">
<meta property="og:image" content="https://bobi.ink/images/sockjs/polling.png">
<meta property="og:updated_time" content="2023-06-01T09:55:14.330Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="你可能不知道的浏览器实时通信方案">
<meta name="twitter:description" content="本文主要探讨现阶段浏览器端可行的实时通信方案，以及它们的发展历史。 这里以sockjs作为切入点，这是一个流行的浏览器实时通信库，提供了’类Websocket’、一致性、跨平台的API，旨在浏览器和服务器之间创建一个低延迟、全双工、支持跨域的实时通信信道. 主要特点就是仿生Websocket，它会优先使用Websocket作为传输层，在不支持WebSocket的环境回退使用其他解决方案，例如XHR">
<meta name="twitter:image" content="https://bobi.ink/images/sockjs/base-http.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>你可能不知道的浏览器实时通信方案</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/07/10/typeof-testing/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/07/06/css-variable/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2019/07/07/sockjs/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2019/07/07/sockjs/&text=你可能不知道的浏览器实时通信方案"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2019/07/07/sockjs/&title=你可能不知道的浏览器实时通信方案"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2019/07/07/sockjs/&is_video=false&description=你可能不知道的浏览器实时通信方案"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=你可能不知道的浏览器实时通信方案&body=Check out this article: https://bobi.ink/2019/07/07/sockjs/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2019/07/07/sockjs/&title=你可能不知道的浏览器实时通信方案"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2019/07/07/sockjs/&title=你可能不知道的浏览器实时通信方案"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2019/07/07/sockjs/&title=你可能不知道的浏览器实时通信方案"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2019/07/07/sockjs/&title=你可能不知道的浏览器实时通信方案"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2019/07/07/sockjs/&name=你可能不知道的浏览器实时通信方案&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#websocket"><span class="toc-number">1.</span> <span class="toc-text">WebSocket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xhr-streaming"><span class="toc-number">2.</span> <span class="toc-text">XHR-streaming</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eventsource"><span class="toc-number">3.</span> <span class="toc-text">EventSource</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#htmlfile"><span class="toc-number">4.</span> <span class="toc-text">HtmlFile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#polling"><span class="toc-number">5.</span> <span class="toc-text">Polling</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#long-polling"><span class="toc-number">6.</span> <span class="toc-text">Long polling</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展"><span class="toc-number">7.</span> <span class="toc-text">扩展</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        你可能不知道的浏览器实时通信方案
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Bobi.ink</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-07-06T16:00:00.000Z" itemprop="datePublished">2019-07-07</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>本文主要探讨现阶段浏览器端可行的实时通信方案，以及它们的发展历史。</p>
<p>这里以<a href="https://github.com/sockjs/sockjs-client" target="_blank" rel="noopener"><code>sockjs</code></a>作为切入点，这是一个流行的浏览器实时通信库，提供了’类Websocket’、一致性、跨平台的API，旨在浏览器和服务器之间创建一个低延迟、全双工、支持跨域的实时通信信道. <strong>主要特点就是仿生Websocket，它会优先使用Websocket作为传输层，在不支持WebSocket的环境回退使用其他解决方案，例如XHR-Stream、轮询</strong>. </p>
<p>所以<code>sockjs</code>本身就是浏览器实时通信方案的编年史, 本文也是按照由新到老这样的顺序来介绍这些解决方案. </p>
<blockquote>
<p>类似sockjs的解决方案还有 <a href="https://socket.io/" target="_blank" rel="noopener">socket.io</a></p>
</blockquote>
<blockquote>
<p>如果你觉得文章不错，请不要吝惜你的点赞👍，鼓励笔者写出更精彩的文章</p>
</blockquote>
<p><br></p>
<p><strong>目录</strong></p>
<!-- TOC -->
<ul>
<li><a href="#websocket">WebSocket</a></li>
<li><a href="#xhr-streaming">XHR-streaming</a></li>
<li><a href="#eventsource">EventSource</a></li>
<li><a href="#htmlfile">HtmlFile</a></li>
<li><a href="#polling">Polling</a></li>
<li><a href="#long-polling">Long polling</a></li>
<li><a href="#扩展">扩展</a></li>
</ul>
<!-- /TOC -->
<p><br></p>
<hr>
<p><br></p>
<h2 id="websocket"><a href="#websocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket其实不是本文的主角，而且网上已经有很多教程，本文的目的是介绍WebSocket之外的一些回退方案，在浏览器不支持Websocket的情况下, 可以选择回退到这些方案.</p>
<p>在此介绍Websocket之前，先来了解一些HTTP的基础知识，毕竟WebSocket本身是借用HTTP协议实现的。</p>
<p>HTTP协议是基于TCP/IP之上的应用层协议，也就是说HTTP在TCP连接中进行请求和响应的，<strong>浏览器会为每个请求建立一个TCP连接，请求等待服务端响应，在服务端响应后关闭连接</strong>:</p>
<p><img src="/images/sockjs/base-http.png" alt></p>
<p>后来人们发现为每个HTTP请求都建立一个TCP连接，太浪费资源了，能不能不要着急关闭TCP连接，而是将它复用起来, 在一个TCP连接中进行多次请求。</p>
<p><strong>这就有了HTTP持久连接(HTTP persistent connection, 也称为HTTP keep-alive), 它利用同一个TCP连接来发送和接收多个HTTP请求/响应。持久连接的方式可以大大减少等待时间, 双方不需要重新运行TCP握手，这对前端静态资源的加载也有很大意义</strong>:</p>
<p><img src="/images/sockjs/http-keep-alive.png" alt></p>
<p>Ok, 现在回到WebSocket, <strong>浏览器端用户程序并不支持和服务端直接建立TCP连接，但是上面我们看到每个HTTP请求都会建立TCP连接, TCP是可靠的、全双工的数据通信通道，那我们何不直接利用它来进行实时通信？ 这就是Websocket的原理!</strong> </p>
<p>我们这里通过一张图，通俗地理解一下Websocket的原理:</p>
<p><img src="/images/sockjs/websocket.png" alt></p>
<p>通过上图可以看到，<strong>WebSocket除最初建立连接时需要借助于现有的HTTP协议，其他时候直接基于TCP完成通信</strong>。这是浏览器中最靠近套接字的API，可以实时和服务端进行全双工通信. WebSocket相比传统的浏览器的<a href="https://en.wikipedia.org/wiki/Comet_(programming" target="_blank" rel="noopener">Comet</a>)(下文介绍)技术, 有很多优势：</p>
<ul>
<li>更强的实时性。基于TCP协议的全双工通信</li>
<li>更高效。一方面是数据包相对较小，另一方面相比传统XHR-Streaming和轮询方式更加高效，不需要重复建立TCP连接</li>
<li>更好的二进制支持。 Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容</li>
<li>保持连接状态。 相比HTTP无状态的协议，WebSocket只需要在建立连接时携带认证信息，后续的通信都在这个会话内进行</li>
<li>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等</li>
</ul>
<p><br></p>
<p>它的接口也非常简单：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080/socket'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line">ws.onerror = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123; ... &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接关闭</span></span><br><span class="line">ws.onclose = <span class="function"><span class="params">()</span> =&gt;</span> &#123; ... &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接建立</span></span><br><span class="line">ws.onopen = <span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 向服务端发送消息</span></span><br><span class="line">  ws.send(<span class="string">"ping"</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收服务端发送的消息</span></span><br><span class="line">ws.onmessage = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">if</span>(msg.data <span class="keyword">instanceof</span> Blob) &#123; </span><br><span class="line">  <span class="comment">// 处理二进制信息</span></span><br><span class="line">    processBlob(msg.data);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理文本信息</span></span><br><span class="line">    processText(msg.data); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本文不会深入解析Websocket的协议细节，有兴趣的读者可以看下列文章:</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">WebSocket</a></li>
<li><a href="https://mp.weixin.qq.com/s/7aXMdnajINt0C5dcJy2USg?" target="_blank" rel="noopener">WebSocket 浅析</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">阮一峰：WebSocket 教程</a></li>
</ul>
<p><br></p>
<p>如果不考虑低版本IE，基本上WebSocket不会有什么兼容性上面的顾虑. 下面列举了Websocket一些常见的问题, 当无法正常使用Websocket时，可以利用sockjs或者socket.io这些方案回退到传统的Comet技术方案.</p>
<ol>
<li>浏览器兼容性。<ul>
<li>IE10以下不支持</li>
<li>Safari 下不允许使用非标准接口建立连接</li>
</ul>
</li>
<li>心跳. WebSocket本身不会维护心跳机制，一些Websocket实现在空闲一段时间会自动断开。所以sockjs这些库会帮你维护心跳</li>
<li>一些负载均衡或代理不支持Websocket。</li>
<li>会话和消息队列维护。这些不是Websocket协议的职责，而是应用的职责。sockjs会为每个Websocket连接维护一个会话，且这个会话里面会维护一个消息队列，当Websocket意外断开时，不至于丢失数据</li>
</ol>
<p><br></p>
<hr>
<p><br></p>
<h2 id="xhr-streaming"><a href="#xhr-streaming" class="headerlink" title="XHR-streaming"></a>XHR-streaming</h2><p>XHR-Streming, 中文名称‘XHR流’, 这是WebSocket的最佳替补方案. XHR-streaming的原理也比较简单：<strong>服务端使用分块传输编码(Chunked transfer encoding)的HTTP传输机制进行响应，并且服务器端不终止HTTP响应流，让HTTP始终处于持久连接状态，当有数据需要发送给客户端时再进行写入数据</strong>。</p>
<p>没理解？没关系，我们一步一步来, 先来看一下正常的HTTP请求处理是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Node.js代码</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>, <span class="comment">// 设置内容格式</span></span><br><span class="line">    <span class="string">'Content-Length'</span>: <span class="number">11</span>, <span class="comment">// 设置内容长度</span></span><br><span class="line">  &#125;)</span><br><span class="line">  res.end(<span class="string">'hello world'</span>) <span class="comment">// 响应 </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>客户端会立即接收到响应:</p>
<p><img src="/images/sockjs/http-req.png" alt></p>
<p><br></p>
<p>那么什么是<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81" target="_blank" rel="noopener"><strong>分块传输编码</strong></a>呢?</p>
<p><strong>在HTTP/1.0之前, 响应是必须作为一整块数据返回客户端的(如上例)，这要求服务端在发送响应之前必须设置<code>Content-Length</code>, 浏览器知道数据的大小后才能确定响应的结束时间</strong>。这让服务器响应动态的内容变得非常低效，它必须等待所有动态内容生成完，再计算Content-Length, 才可以发送给客户端。如果响应的内容体积很大，需要占用很多内存空间.</p>
<p><strong>HTTP/1.1引入了<code>Transfer-Encoding: chunked;</code>报头。 它允许服务器发送给客户端应用的数据可以分为多个部分, 并以一个或多个块发送，这样服务器可以发送数据而不需要提前计算发送内容的总大小</strong>。</p>
<p><strong>有了分块传输机制后，动态生成内容的服务器就可以维持HTTP长连接, 也就是说服务器响应流不结束，TCP连接就不会断开</strong>. </p>
<p><br></p>
<p>现在我们切换为分块传输编码模式， 且我们不终止响应流，看会有什么情况:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span></span><br><span class="line">    <span class="comment">// 'Content-Length': 11, // 🔴将Content-Length报头去掉，Node.js默认就是使用分块编码传输的</span></span><br><span class="line">  &#125;)</span><br><span class="line">  res.write(<span class="string">'hello world'</span>)</span><br><span class="line">  <span class="comment">// res.end() // 🔴不终止输出流</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们会发现请求会一直处于Pending状态(绿色下载图标)，<strong>除非出现异常、服务器关闭或显式关闭连接(比如设置超时机制)，请求是永远不会终止的。但是即使处于Pending状态客户端还是可以接收数据，不必等待请求结束</strong>:</p>
<p><img src="/images/sockjs/http-pending-req.png" alt></p>
<p><br></p>
<p>基于这个原理我们再来创建一个简单的ping-pong服务器:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.url === <span class="string">'/ping'</span>) &#123;</span><br><span class="line">    <span class="comment">// ping请求</span></span><br><span class="line">    <span class="keyword">if</span> (pendingResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      res.writeHead(<span class="number">500</span>);</span><br><span class="line">      res.write(<span class="string">'session not found'</span>);</span><br><span class="line">      res.end();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.writeHead(<span class="number">200</span>)</span><br><span class="line">    res.end()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给客户端推流</span></span><br><span class="line">    pendingResponse.write(<span class="string">'pong\n'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 保存句柄</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(<span class="string">'welcome to ping\n'</span>);</span><br><span class="line">    pendingResponse = res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>测试一下，在另一个窗口访问<code>/ping</code>路径：</p>
<p><img src="/images/sockjs/http-stream-ping.png" alt></p>
<p>Ok! 这就是XHR-Streaming!</p>
<p><br></p>
<p>那么Ajax怎么接收这些数据呢？ ①一种做法是在<code>XMLHttpRequest</code>的<code>onreadystatechange</code>事件处理器中判断<code>readyState</code>是否等于<code>XMLHttpRequest.LOADING</code>；②另外一种做法是在<code>xhr.onprogress</code>事件处理器中处理。下面是ping客户端实现:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.onprogress = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 注意responseText是获取服务端发送的所有数据，如果要获取未读数据，则需要进行划分</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'progress'</span>, xhr.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.open(<span class="string">'POST'</span>, HOST);</span><br><span class="line">  xhr.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ping</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">'POST'</span>, HOST + <span class="string">'/ping'</span>);</span><br><span class="line">  xhr.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listen();</span><br><span class="line">setInterval(ping, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>慢着，不要高兴得太早😰. 如果运行上面的代码会发现<code>onprogress</code>并没有被正常的触发, 具体原因笔者也没有深入研究，我发现sockjs的服务器源码里面会预先写入2049个字节，这样就可以正常触发onprogress事件了:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.url === <span class="string">'/ping'</span>) &#123;</span><br><span class="line">    <span class="comment">// ping请求</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 保存句柄</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(<span class="built_in">Array</span>(<span class="number">2049</span>).join(<span class="string">'h'</span>) + <span class="string">'\n'</span>);</span><br><span class="line">    pendingResponse = res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>最后再图解一下XHR-streaming的原理:</p>
<p><img src="/images/sockjs/xhr-stream.png" alt></p>
<p>总结一下XHR-Streaming的特点:</p>
<ul>
<li>利用分块传输编码机制实现持久化连接(persistent connection): 服务器不关闭响应流，连接就不会关闭</li>
<li>单工(unidirectional): 只允许服务器向浏览器单向的推送数据</li>
</ul>
<p><strong>通过XHR-Streaming，可以允许服务端连续地发送消息，无需每次响应后再去建立一个连接, 所以它是除了Websocket之外最为高效的实时通信方案. 但它也并不是完美无缺</strong>。</p>
<p>比如XHR-streaming连接的时间越长，浏览器会占用过多内存，而且在每一次新的数据到来时，需要对消息进行划分，剔除掉已经接收的数据. 因此sockjs对它进行了一点优化, 例如sockjs默认只允许每个xhr-streaming连接输出128kb数据，超过这个大小时会关闭输出流，让浏览器重新发起请求.</p>
<p><br></p>
<hr>
<p><br></p>
<h2 id="eventsource"><a href="#eventsource" class="headerlink" title="EventSource"></a>EventSource</h2><p>了解了XHR-Streaming, 就会觉得<a href="https://developer.mozilla.org/zh-CN/docs/Server-sent_events/EventSource" target="_blank" rel="noopener"><code>EventSource</code></a>并不是什么新鲜玩意: 它就是上面讲的<code>XHR-streaming</code>, 只不过浏览器给它提供了标准的API封装和协议, 你抓包一看和XHR-streaming没有太大的区别:</p>
<p><img src="/images/sockjs/eventsource.png" alt></p>
<p><br></p>
<p>上面可以看到请求的<code>Accept</code>为<code>text/event-stream</code>, 且服务端写入的数据都有标准的约定, 即载荷需要这样组织:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="string">`data: <span class="subst">$&#123;payload&#125;</span>\r\n\r\n`</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>EventSource的API和Websocket类似, 实例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> evtSource = <span class="keyword">new</span> EventSource(<span class="string">'sse.php'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接打开</span></span><br><span class="line">evtSource.onopen = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受消息</span></span><br><span class="line">evtSource.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"message: "</span> + e.data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭流</span></span><br><span class="line">  evtSource.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常</span></span><br><span class="line">evtSource.onerror = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>因为是标准的，浏览器调试也比较方便，不需要借助第三方抓包工具:</p>
<p><img src="/images/sockjs/eventsource-inspect.png" alt></p>
<p><br></p>
<hr>
<p><br></p>
<h2 id="htmlfile"><a href="#htmlfile" class="headerlink" title="HtmlFile"></a>HtmlFile</h2><p>这是一种古老的‘秘术’😂，虽然我们可能永远都不会再用到它，但是它的实现方式比较有意思(类似于JSONP这种黑科技), 所以还是值得讲一下。</p>
<p>HtmlFile的另一个名字叫做<code>永久帧(forever-frame)</code>, 顾名思义, 浏览器会打开一个隐藏的iframe，这个iframe会请求一个分块传输编码的html文件(Transfer-Encoding: chunked), 和XHR-Streaming一样，这个请求永远都不会结束，服务器会不断在这个文档上输出内容。<strong>这里面的要点是现代浏览器都会增量渲染html文件，所以服务器可以通过添加script标签在客户端执行某些代码</strong>，先来看个抓包的实例:</p>
<p><img src="/images/sockjs/htmlfile.png" alt></p>
<p><br></p>
<p>从上图可以看出:</p>
<ul>
<li>① 这里会给服务器传递一个callback，通过这个callback将数据传递给父文档</li>
<li>② 服务器每当有新的数据，就向文档追加一个<code>&lt;script&gt;</code>标签，script的代码就是将数据传递给callback。利用浏览器会被下载边解析HTML文档的特性，新增的script会马上被执行</li>
</ul>
<p><br></p>
<p>最后还是用流程图描述一下：</p>
<p><img src="/images/sockjs/htmlfile-progress.png" alt></p>
<p>除了IE6、7以下不支持，大部分浏览器都支持这个方案，当浏览器不支持<code>XHR-streaming</code>时，可以作为最佳备胎。</p>
<p><br></p>
<hr>
<p><br></p>
<h2 id="polling"><a href="#polling" class="headerlink" title="Polling"></a>Polling</h2><p>轮询是最粗暴(或者说最简单)，也是效率最低下的‘实时’通信方案，这种方式的原理就是定期向服务器发起请求, 拉取最新的消息队列:</p>
<p><img src="/images/sockjs/polling2.png" alt></p>
<p>这种轮询方式比较合适<strong>服务器的信息定期更新</strong>的场景，如天气和股票行情信息。举个例子股票信息每隔5分钟更新一次，这时候客户端定期轮询, 且轮询间隔和服务端更新频率保持一致是一种理想的方式。</p>
<p>但是如果追求实时性，轮询会导致一些严重的问题:</p>
<ul>
<li>资源浪费。比如轮询的间隔小于服务器信息更新的频率，这会浪费很多HTTP请求, 消耗宝贵的CPU时间和带宽</li>
<li>容易导致请求轰炸。比如当服务器负载比较高时，第一个请求还没处理完成，这时候第二、第三个请求接踵而来，无用的额外请求对服务端进行了轰炸。</li>
</ul>
<p><br></p>
<hr>
<p><br></p>
<h2 id="long-polling"><a href="#long-polling" class="headerlink" title="Long polling"></a>Long polling</h2><p>还有一种优化的轮询方法，称为长轮询(Long Polling)，sockjs就是使用这种轮询方式, <strong>长轮询指的是浏览器发送一个请求到服务器，服务器只有在有可用的新数据时才响应</strong>：</p>
<p><img src="/images/sockjs/polling.png" alt></p>
<p>客户端向服务端发起一个消息获取请求，服务端会将当前的消息队列返回给客户端，然后关闭连接。<strong>当消息队列为空时，服务端不会立即关闭连接，而是等待指定的时间间隔，如果在这个时间间隔内没有新的消息，则由客户端主动超时关闭连接</strong>。</p>
<p>另外一个要点是，<strong>客户端的轮询请求只有在上一个请求连接关闭后才会重新发起</strong>。这就解决了上文的请求轰炸问题。服务端可以控制客户端的请求时序，因为在服务端未响应之前，客户端不会发送额外的请求(在超时期间内)。</p>
<p><br><br><br></p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API" target="_blank" rel="noopener">WebRTC</a> 这是浏览器的实时通信技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。</li>
<li><a href="https://github.com/meteor/meteor/tree/devel/packages/ddp" target="_blank" rel="noopener">metetor DDP</a> DDP(Distributed Data Protocol), 这是一个’有状态的’实时通信协议，这个是<a href="https://github.com/meteor/meteor" target="_blank" rel="noopener">Meteor</a>框架的基础, 它就是使用这个协议来进行客户端和服务端通信. 他只是一个协议，而不是通信技术，比如它的底层可以基于Websocket、XHR-Streaming、长轮询甚至是WebRTC</li>
<li><a href="https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html" target="_blank" rel="noopener">Server-Sent Events 教程</a></li>
<li><a href="https://medium.com/@chijianqiang/程序员怎么会不知道-c10k-问题呢-d024cb7880f3" target="_blank" rel="noopener">程序员怎么会不知道C10K 问题呢？ - 池建强- Medium</a></li>
</ul>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#websocket"><span class="toc-number">1.</span> <span class="toc-text">WebSocket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xhr-streaming"><span class="toc-number">2.</span> <span class="toc-text">XHR-streaming</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eventsource"><span class="toc-number">3.</span> <span class="toc-text">EventSource</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#htmlfile"><span class="toc-number">4.</span> <span class="toc-text">HtmlFile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#polling"><span class="toc-number">5.</span> <span class="toc-text">Polling</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#long-polling"><span class="toc-number">6.</span> <span class="toc-text">Long polling</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展"><span class="toc-number">7.</span> <span class="toc-text">扩展</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2019/07/07/sockjs/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2019/07/07/sockjs/&text=你可能不知道的浏览器实时通信方案"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2019/07/07/sockjs/&title=你可能不知道的浏览器实时通信方案"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2019/07/07/sockjs/&is_video=false&description=你可能不知道的浏览器实时通信方案"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=你可能不知道的浏览器实时通信方案&body=Check out this article: https://bobi.ink/2019/07/07/sockjs/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2019/07/07/sockjs/&title=你可能不知道的浏览器实时通信方案"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2019/07/07/sockjs/&title=你可能不知道的浏览器实时通信方案"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2019/07/07/sockjs/&title=你可能不知道的浏览器实时通信方案"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2019/07/07/sockjs/&title=你可能不知道的浏览器实时通信方案"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2019/07/07/sockjs/&name=你可能不知道的浏览器实时通信方案&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2023 Ivan
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-44571525-2', 'auto');
        ga('send', 'pageview');
    </script>


    <!-- Disqus Comments -->
    <script type="text/javascript">
        var disqus_shortname = 'bobi-ink';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


