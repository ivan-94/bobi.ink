<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bobi.ink</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bobi.ink/"/>
  <updated>2023-08-21T10:25:28.746Z</updated>
  <id>https://bobi.ink/</id>
  
  <author>
    <name>Ivan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 Docker 实现前端应用的标准化构建、部署和运行</title>
    <link href="https://bobi.ink/2023/08/21/docker-for-fe/"/>
    <id>https://bobi.ink/2023/08/21/docker-for-fe/</id>
    <published>2023-08-20T16:00:00.000Z</published>
    <updated>2023-08-21T10:25:28.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="why-docker"><a href="#why-docker" class="headerlink" title="Why Docker?"></a>Why Docker?</h1><p>Docker 容器化技术是当今最重要的基础设施之一，或者说它已经成为<code>服务程序</code> 的标准化运行环境。</p><p>先不谈它相比传统的<code>虚拟化</code>技术有多少优势，站在软件工程角度，笔者认为，Docker 有两个重要的意义：</p><p><br><br><br></p><p><img src="/images/docker-for-fe/Untitled.png" alt="Untitled"></p><p>一）<strong>提供一致性的运行环境。让我们的程序在一致性的环境中运行：不管是开发环境、测试环境、还是生产环境；不管是开发时、构建时、还是运行时</strong>。</p><p>比如开发时可以使用 <a href="https://docs.docker.com/desktop/dev-environments/" target="_blank" rel="noopener">Docker Dev Environments</a>, 可以配合 VsCode Remote 开发，从而实现跳槽时或者换设备，可以快速 Setup 自己的开发环境。有兴趣的可以看看掘友写的 <a href="https://juejin.cn/post/7264403008163201081?searchId=2023081817551184D71DDBF183A7BC83DA" target="_blank" rel="noopener">Docker化一个前端基础开发环境：简洁高效的选择</a></p><p>构建时，现在 CI/CD 平台都是基于 Docker 来提供多样化的构建环境需求。</p><p>运行时，‘巨轮’ K8S 已经是云时代的重要基础设施。</p><p><br><br><br></p><p><img src="/images/docker-for-fe/Untitled%201.png" alt="Untitled"></p><p><strong>二）标准化的服务程序封装技术。</strong> </p><p>在没有容器之前，使用不同编程语言或框架编写的程序，部署和运行的方式千差万别。比如 Java 会生成 jar 包或者war 包，运行环境需要预装指定版本的 JDK…</p><p>而现在，容器<code>镜像</code>成为了标准的服务程序封装技术。镜像中包含了<code>程序</code>以及程序对运行环境的<code>依赖</code>。</p><p><img src="/images/docker-for-fe/Untitled%202.png" alt="Untitled"></p><p>不管前后端应用都可以使用镜像的形式进行分发和流通。这应该就是 Docker Logo，那条鲸鱼驮着货运箱的解释吧：就像我们平时下载、传递 Zip 文件一样， 镜像是云时代’通用货币’，可以在研发的不同环节、区域中流通。</p><p>这种标准化的打包格式、轻量化的运行时，不仅给开发者和运维带来便利， 也催生了强大的容器管理工具比如 K8S,  <strong>K8S 现在已经是容器和集群管理的标准。</strong></p><p><br></p><hr><p><br></p><p><strong>那 Docker 之于前端意义是啥？</strong></p><p>Docker 对前端的意义也很重大。 实际上，Docker 的世界里，并不区分什么前端、后端，没有人说只适合后端、不适合前端 … 在运维的眼里更是如此</p><p>为了照顾那些不太懂 Docker 的开发者，本文会循序渐进、由浅入深地讲解。如果你需要 Docker 入门教程，推荐你看看 <a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener">Docker —— 从入门到实践</a></p><p>主要分成三个部分：</p><ul><li>标准化的 CI/CD。讲讲怎么基于 Docker 来构建前端应用，这里提出了一个重要的观点：就是基于 Dockerfile 来实现 ‘跨 CI/CD’ 的任务执行，我们可以在 Dockerfile 中执行各种任务，包括环境初始化、单元测试、构建等等</li><li>标准化部署和运行。怎么部署基于 Docker 的前端应用，包括静态资源、NodeJS 程序、微前端。</li><li>一些高级的话题。讲讲容器化后的前端应用怎么实现 ’<strong>一份基准代码，多份部署</strong>‘、灰度发布、蓝绿发布等高级发布需求。</li></ul><p><br><br><br></p><h1 id="标准化ci-cd"><a href="#标准化ci-cd" class="headerlink" title="标准化CI/CD"></a>标准化CI/CD</h1><p>市面上有很多 CI/CD 产品，比如 GitLab、Github Action、Jenkins、Zadig… 它们的构建配置、脚本语法差异都挺大，基本上是不能共用的。</p><p>比如我们公司前不久引入了 Zadig，原本基于 Jenkinks 的构建配置几乎需要重新适配。</p><p><strong>有没有跨‘平台’的方式？</strong>于是，我开始探索将前端 CI/CD 的流程完全集成到 Docker 镜像构建中去。</p><h2 id="从简单的单元测试开始"><a href="#从简单的单元测试开始" class="headerlink" title="从简单的单元测试开始"></a>从简单的单元测试开始</h2><p>我们先从简单的任务开始。先来写一个简单的单元测试：</p><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">20</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 🔴 pnpm 安装</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> corepack <span class="built_in">enable</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 🔴 拷贝源代码</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 🔴 安装依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pnpm install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 🔴 执行测试</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pnpm <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><blockquote><p>⁉️ <a href="https://nodejs.org/api/corepack.html#corepack" target="_blank" rel="noopener">corepack</a>?  NodeJS 的包管理碎片化越来越验证了，以前我们区分 npm、yarn、pnpm, 现在还要继续分裂版本，pnpm v7、pnpm v8…<br><br><br>NodeJS 官方推出的 Corepack 应该可以救你一命</p></blockquote><p><br></p><p>别忘了 <code>.dockerignore</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node_modules</span><br><span class="line">.git</span><br><span class="line">.gitignore</span><br><span class="line">*.md</span><br><span class="line">dist</span><br></pre></td></tr></table></figure><blockquote><p>⁉️ 为什么不能遗漏 <code>.dockerignore</code> 呢？</p></blockquote><p><br><br><br></p><p>构建运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build . --progress=plain</span><br><span class="line"><span class="comment">#1 [internal] load build definition from Dockerfile.for_test</span></span><br><span class="line"><span class="comment">#1 transferring dockerfile: 40B done</span></span><br><span class="line"><span class="comment">#1 DONE 0.0s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2 [internal] load .dockerignore</span></span><br><span class="line"><span class="comment">#2 transferring context: 34B done</span></span><br><span class="line"><span class="comment">#2 DONE 0.0s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3 [internal] load metadata for docker.io/library/node:20-slim</span></span><br><span class="line"><span class="comment">#3 DONE 1.5s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4 [1/6] FROM docker.io/library/node:20-slim@sha256:6eea4330e89a0c6a8106d0bee575d3d9978b51aac16ffe7f6825e78727815631</span></span><br><span class="line"><span class="comment">#4 CACHED</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5 [internal] load build context</span></span><br><span class="line"><span class="comment">#5 transferring context: 227B done</span></span><br><span class="line"><span class="comment">#5 DONE 0.0s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#6 [2/6] RUN corepack enable</span></span><br><span class="line"><span class="comment">#6 DONE 0.2s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#7 [3/6] COPY . /app</span></span><br><span class="line"><span class="comment">#7 DONE 0.0s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#8 [4/6] WORKDIR /app</span></span><br><span class="line"><span class="comment">#8 DONE 0.0s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#9 [5/6] RUN pnpm install</span></span><br><span class="line"><span class="comment">#9 4.878 Lockfile is up to date, resolution step is skipped</span></span><br><span class="line"><span class="comment">#9 4.880 Progress: resolved 1, reused 0, downloaded 0, added 0</span></span><br><span class="line"><span class="comment">#9 4.881 Packages: +1</span></span><br><span class="line"><span class="comment">#9 4.881 +</span></span><br><span class="line"><span class="comment">#9 6.603 Progress: resolved 1, reused 0, downloaded 1, added 0</span></span><br><span class="line"><span class="comment">#9 6.643 Packages are hard linked from the content-addressable store to the virtual store.</span></span><br><span class="line"><span class="comment">#9 6.643   Content-addressable store is at: /root/.local/share/pnpm/store/v3</span></span><br><span class="line"><span class="comment">#9 6.643   Virtual store is at:             node_modules/.pnpm</span></span><br><span class="line"><span class="comment">#9 6.659 </span></span><br><span class="line"><span class="comment">#9 6.659 dependencies:</span></span><br><span class="line"><span class="comment">#9 6.659 + lodash 4.17.21</span></span><br><span class="line"><span class="comment">#9 6.659 </span></span><br><span class="line"><span class="comment">#9 6.661 Done in 2s</span></span><br><span class="line"><span class="comment">#9 7.608 Progress: resolved 1, reused 0, downloaded 1, added 1, done</span></span><br><span class="line"><span class="comment">#9 DONE 7.7s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#10 [6/6] RUN pnpm test</span></span><br><span class="line"><span class="comment">#10 0.497 测试通过</span></span><br><span class="line"><span class="comment">#10 DONE 0.5s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#11 exporting to image</span></span><br><span class="line"><span class="comment">#11 exporting layers</span></span><br><span class="line"><span class="comment">#11 exporting layers 0.2s done</span></span><br><span class="line"><span class="comment">#11 writing image sha256:9d61ce0fd5d96685aa62fb268db37b3dea4cfa1699df73d8d6a7de259c914a8d done</span></span><br><span class="line"><span class="comment">#11 DONE 0.2s</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><p>二次运行的结果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1 [internal] load build definition from Dockerfile.for_test</span></span><br><span class="line"><span class="comment">#1 transferring dockerfile: 40B done</span></span><br><span class="line"><span class="comment">#1 DONE 0.0s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2 [internal] load .dockerignore</span></span><br><span class="line"><span class="comment">#2 transferring context: 34B done</span></span><br><span class="line"><span class="comment">#2 DONE 0.0s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3 [internal] load metadata for docker.io/library/node:20-slim</span></span><br><span class="line"><span class="comment">#3 DONE 3.2s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4 [1/6] FROM docker.io/library/node:20-slim@sha256:6eea4330e89a0c6a8106d0bee575d3d9978b51aac16ffe7f6825e78727815631</span></span><br><span class="line"><span class="comment">#4 DONE 0.0s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5 [internal] load build context</span></span><br><span class="line"><span class="comment">#5 transferring context: 227B done</span></span><br><span class="line"><span class="comment">#5 DONE 0.0s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#6 [2/6] RUN corepack enable</span></span><br><span class="line"><span class="comment">#6 CACHED  &lt;- 🔴 缓存了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#7 [4/6] WORKDIR /app</span></span><br><span class="line"><span class="comment">#7 CACHED</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#8 [3/6] COPY . /app</span></span><br><span class="line"><span class="comment">#8 CACHED</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#9 [5/6] RUN pnpm install</span></span><br><span class="line"><span class="comment">#9 CACHED</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#10 [6/6] RUN pnpm test</span></span><br><span class="line"><span class="comment">#10 CACHED &lt;- 🔴 缓存了</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><br></p><p>Docker 镜像是<code>多层存储</code>的， 每一层是在前一层的基础上进行的修改。换句话说，  <code>Dockerfile</code> 文件中的每条指令(Instruction)都是在构建新的一层。</p><p><br></p><p>Docker 使用了<code>缓存</code>来加速镜像构建，所以上面执行结果可以看出只要<code>上一层</code>和<code>当前层的输入</code>没有变动，那么执行结果就会被缓存下来。</p><p><br></p><p>现在你可以随便更动 <code>src/*</code> 或者 <code>package.json</code> , 再执行构建，会发现，从 <code>COPY</code> 指令那里重新开始执行了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3 [internal] load metadata for docker.io/library/node:20-slim</span></span><br><span class="line"><span class="comment">#3 DONE 1.3s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4 [1/6] FROM docker.io/library/node:20-slim@sha256:75404fc5825f24222276501c09944a5bee8ed04517dede5a9934f1654ca84caf</span></span><br><span class="line"><span class="comment">#4 DONE 0.0s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5 [internal] load build context</span></span><br><span class="line"><span class="comment">#5 transferring context: 525B done</span></span><br><span class="line"><span class="comment">#5 DONE 0.0s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#6 [2/6] RUN corepack enable</span></span><br><span class="line"><span class="comment">#6 CACHED</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 🔴 变更点</span></span><br><span class="line"><span class="comment">#7 [3/6] COPY . /app</span></span><br><span class="line"><span class="comment">#7 DONE 0.0s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#8 [4/6] WORKDIR /app</span></span><br><span class="line"><span class="comment">#8 DONE 0.0s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#9 [5/6] RUN pnpm install</span></span><br><span class="line"><span class="comment">#....</span></span><br></pre></td></tr></table></figure><p>也就是，又从 0 开始进行 <code>pnpm install</code> …</p><p><br><br><br></p><h2 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h2><p>前端构建会深度依赖缓存来加速，比如 node_modules、Webpack 的模块缓存、vite 的 prebundle、Typescript 的 <a href="https://www.typescriptlang.org/tsconfig/#tsBuildInfoFile" target="_blank" rel="noopener">tsBuildInfoFile</a> …</p><p>上面从零开始 pnpm install 显然是无法接受的。每次都是从头开始，构建的过程会变得很慢。有什么解决办法呢?</p><p><br><br><br></p><p><strong>解决办法 1）利用 Docker 分层缓存</strong></p><p><code>pnpm</code> 依赖的安装，其实只需要 <code>package.json</code>、<code>pnpm-lock.yaml</code> 等文件就够了，那我们是不是可以把 COPY 拆分从两步？采用动静分离策略，分离 package.json 和源代码的变更。毕竟 package.json 的变更频率要低得多：</p><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">20</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> corepack <span class="built_in">enable</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝依赖声明</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json pnpm-lock.yaml /app/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pnpm install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝源代码</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pnpm <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><p><strong>解决办法 2） RUN 挂载缓存</strong></p><p>方案1 还是有很多缺陷，比如 package.json 只要变动一个字节，都会导致 pnpm 重新安装。能不能在运行 build 的时候挂载缓存目录进去？把  <code>node_modules</code> 或者 <code>pnpm store</code> 缓存下来？</p><p>Docker build 确实支持<a href="https://docs.docker.com/build/guide/mounts/" target="_blank" rel="noopener">挂载</a>(<a href="https://yeasy.gitbook.io/docker_practice/buildx/buildkit" target="_blank" rel="noopener">BuildKit</a>, 需要 Docker 18.09+)。以下是缓存 pnpm 的示例(来自官方<a href="https://pnpm.io/zh/docker" target="_blank" rel="noopener">文档</a>)：</p><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">20</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> corepack <span class="built_in">enable</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝依赖声明</span></span><br><span class="line"><span class="keyword">ENV</span> PNPM_HOME=<span class="string">"/pnpm"</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">"$PNPM_HOME:$PATH"</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json pnpm-lock.yaml /app/</span></span><br><span class="line"><span class="comment"># 挂载缓存</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> --mount=<span class="built_in">type</span>=cache,id=pnpm,target=/pnpm/store pnpm install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝源代码</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pnpm <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><blockquote><p>💡你也可以通过设置 <code>DOCKER_BUILDKIT=1</code> 环境变量来启用 <code>BuildKit</code></p></blockquote><p><code>RUN —mount</code> 参数可以指定要挂载的目录，对应的缓存会存储在<code>宿主机器</code>中。这样就解决了 Docker 构建过程的外部缓存问题。</p><p>同理其他的缓存，比如 vite、Webpack，也是通过 <code>—mount</code> 挂载。一个 <code>RUN</code> 支持指定多个 <code>—mount</code> </p><blockquote><p>⚠️ 因为采用挂载形式，这种跨设备会导致 <code>pnpm</code> 回退到拷贝模式(pnpm store → node_modules)，而不是链接模式，所以安装性能会有所损耗。</p></blockquote><blockquote><p>如果是 npm 通常需要缓存 <code>~/.npm</code> 目录</p></blockquote><p><br><br><br><br><br></p><h2 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h2><p>假设我们要在原有单元测试的基础上，加入编译任务。并且要求两个命令支持<strong>独立执行</strong>，比如在代码 commit 到远程仓库时只执行单元测试，发布时才执行单元测试 + 编译。</p><p>第一种解决办法就是创建两个 Dockerfile， 这个方案的缺点就是指令重复(比如 pnpm 安装依赖)。另一个缺点就是如果任务之间有依赖或文件交互，那么整合起来也会比较<a href="https://yeasy.gitbook.io/docker_practice/image/multistage-builds#fen-san-dao-duo-ge-dockerfile" target="_blank" rel="noopener">麻烦</a>。</p><p>更好的办法就是<a href="https://docs.docker.com/build/guide/multi-stage/" target="_blank" rel="noopener">多阶段构建</a>（Multi-Stage）。Docker 允许将多个构建步骤整合在一个 Dockerfile 文件中，这个构建步骤之间可以存在依赖关系，也可以进行文件传递，还可以更好地利用缓存。</p><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 🔴 阶段 1，安装依赖</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">20</span>-slim as base</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> corepack <span class="built_in">enable</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PNPM_HOME=<span class="string">"/pnpm"</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">"$PNPM_HOME:$PATH"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝依赖声明</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json pnpm-lock.yaml /app/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> --mount=<span class="built_in">type</span>=cache,id=pnpm,target=/pnpm/store pnpm install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 🔴 阶段 2，单元测试</span></span><br><span class="line"><span class="keyword">FROM</span> base as test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝源代码</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pnpm <span class="built_in">test</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 🔴 阶段 3，构建</span></span><br><span class="line"><span class="keyword">FROM</span> test as build</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pnpm build</span></span><br></pre></td></tr></table></figure><p>通过 <code>FROM * as NAME</code> 的形式创建一个阶段。FROM 可以指定依赖的其他步骤。</p><p><br><br><br></p><p>现在我们运行:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build .</span><br></pre></td></tr></table></figure><p>默认会执行最后一个阶段。即 build。</p><p>如果我们只想跑 test，可以通过 <code>—target</code> 参数指定:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build --target=build .</span><br></pre></td></tr></table></figure><p><br></p><p>我们再来看一个典型的复杂例子，<code>Nextjs</code> 程序构建：</p><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">19</span>-alpine AS base</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0. 构建依赖, 为什么要分开一步构建依赖呢，这是为了利用 Docker 的构建缓存</span></span><br><span class="line"><span class="keyword">FROM</span> base AS deps</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --no-cache libc6-compat</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json .npmrc pnpm-lock.yaml* ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm i -g pnpm@7 &amp;&amp; pnpm install </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 第一步构建编译</span></span><br><span class="line"><span class="keyword">FROM</span> base AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># COPY 依赖</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=deps /app/node_modules /app/node_modules</span></span><br><span class="line"><span class="comment"># COPY 源代码</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># COPY .env.production.sample .env.production</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> env &amp;&amp; ls -a &amp;&amp; npm run build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 第二步，运行</span></span><br><span class="line"><span class="keyword">FROM</span> base AS runner</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> NODE_ENV production</span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line in case you want to disable telemetry during runtime.</span></span><br><span class="line"><span class="comment"># ENV NEXT_TELEMETRY_DISABLED 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> addgroup --system --gid 1001 nodejs</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> adduser --system --uid 1001 nextjs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder --chown=nextjs:nodejs app/public /app/public</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder --chown=nextjs:nodejs app/.next/standalone /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder --chown=nextjs:nodejs app/.next/static /app/.next/static</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> nextjs</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PORT <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"node"</span>, <span class="string">"server.js"</span>]</span></span><br></pre></td></tr></table></figure><p><br></p><p>多阶段构建的另一个好处是隐藏构建的细节:  比如上游构建的过程中传递的一些敏感信息、隐藏源代码等。</p><p><br></p><p>在上面的 Next.js 例子中， 最终构建的是 runner,  它从 builder 中拷贝编译的结果，对最终的镜像使用者来说，是查看不到 builder 的构建细节和内容的。</p><p><br><br><br><br><br></p><h2 id="构建参数"><a href="#构建参数" class="headerlink" title="构建参数"></a>构建参数</h2><p>程序在构建时可能会有一些微调变量，比如调整 Webpack PublicPath、编译产物的目标平台、调试开关等等。</p><p><br></p><p>在 DockerFile 下可以通过 <code>ARG</code> 指令来声明<code>构建参数</code> ：</p><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 声明构建参数，支持默认值</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以在 DockerFile 中作为 '模板变量' 使用</span></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印 library</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印 包含 DOCKER_USERNAME=library </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> env</span></span><br></pre></td></tr></table></figure><p><br></p><p><code>ARG</code> 和 <code>ENV</code> 的效果一样，都是设置<strong>环境变量</strong>。不同的是，<code>ARG</code> 所设置是<code>构建时</code>的环境变量，在将来容器<code>运行时</code>是不会存在这些环境变量的。</p><blockquote><p>⚠️  注意，尽量不要在 <code>ARG</code> 放置敏感信息，因为 <code>docker history</code>  可以看到构建的过程</p></blockquote><p>通过 <code>docker build --build-arg Key=[Value]</code> 设置构建参数：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build --build-arg BABEL_ENV=<span class="built_in">test</span> .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 🔴 或者只指定 KEY, Value 自动获取</span></span><br><span class="line">$ docker build --build-arg BABEL_ENV .</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="怎么支持更复杂的构建需求？"><a href="#怎么支持更复杂的构建需求？" class="headerlink" title="怎么支持更复杂的构建需求？"></a>怎么支持更复杂的构建需求？</h2><p>Dockerfile 中不建议放置复杂的逻辑，而且它语法支持也很有限。如果有复杂的构建需求，更应该通过  Shell 脚本或者 Node 程序来实现。</p><p><br><br><br></p><h2 id="集成到-ci-cd-平台"><a href="#集成到-ci-cd-平台" class="headerlink" title="集成到 CI/CD 平台"></a>集成到 CI/CD 平台</h2><p>上文，我们探索了使用 Docker 来实现‘跨平台’(CI/CD) 的构建任务。看起来还不错，应该能够满足我们的需求。</p><p>通常这些平台对 Docker 镜像构建的支持都是开箱即用的， 如果使用 Dockerfile 方案，我们可以免去一些额外的声明，比如构建依赖的软件包、缓存配置、构建脚本等等。</p><p>现在只需要关注 <code>Dockerfile</code> 构建， 下图以 <code>Zadig</code> 为例。在 Zadig 中，我们只需要告诉 Dockerfile 在哪，其余的工作(比如镜像 tag、镜像发布)都不需要操心：</p><p><img src="/images/docker-for-fe/Untitled%203.png" alt="Untitled"></p><p>接入其他构建平台也是类似的，<strong>我们只需要学习对应平台如何构建镜像就行</strong>。</p><p><br><br><br><br><br></p><h1 id="标准化部署和运行"><a href="#标准化部署和运行" class="headerlink" title="标准化部署和运行"></a>标准化部署和运行</h1><p>上一节， 讲到将 Docker 作为‘跨平台’的任务执行环境。下一步就是发布、部署、运行。注意接下内容可能需要你对 K8S 有基本的了解。</p><p>镜像发布就不用展开说了，就和 npm 发布一样简单。本节的重点在于讨论，前端‘应用’在容器环境如何对外服务。</p><p>目前比较主流的前端应用可以分为三类：</p><ul><li>纯静态资源。</li><li>NodeJS 程序。包括 NodeJS 的纯后端服务、还有 NextJS、NuxtJS 这里 SSR 服务</li><li>微前端。主要指<strong>以基座为核心的中心化的微前端方案</strong>， 比如 <code>qiankun</code>。这类程序需要基座和子应用相互搭配才能对外服务。</li></ul><p><br><br><br></p><h2 id="纯静态资源"><a href="#纯静态资源" class="headerlink" title="纯静态资源"></a>纯静态资源</h2><p>估计 80% 以上的前端应用都是纯静态的。</p><p>笔者尝试过多种部署的方式。在我们将前端应用容器化的初期， 有过这样一种中间的演进形态：</p><p><img src="/images/docker-for-fe/Untitled%204.png" alt="Untitled"></p><p><br></p><p>在改造之前我们所有的前端静态资源都堆在一个静态资源服务器中(上图左侧)，所有人都有部署权限、所有人都能改 Nginx 配置、目录混乱。部署方式也是各显神通，有 Jenkins 自动部署、有 FTP/rsync 手动上传… 就是一个极其原始的状态。</p><p><br></p><p>在容器化改造的初期，运维把<code>静态资源服务器</code>转换成为了 <code>Nginx 容器</code>，而原本 Nginx 的配置通过<code>配置映射</code>（Config Map）来挂载到容器内部。</p><p><br></p><p>前端应用也做了非常简单的改造， 就是简单把静态资源 COPY 到镜像中：</p><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox:latest</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> dist /data</span></span><br></pre></td></tr></table></figure><p>运行时，前端应用以 <code>Nginx 容器</code>的 <code>Sidecar</code> 形式存在，在启动时向共享的 PVC (数据卷)拷贝静态资源。</p><p><br></p><hr><p><br></p><p>更理想的情况是每个前端应用能够独立对外服务， 对镜像的使用者来说，他应该是开箱即用的、自包含、透明的。</p><p>所以我们对部分比较独立的应用进行了重构：</p><p><img src="/images/docker-for-fe/Untitled%205.png" alt="Untitled"></p><p>如上图， 前端应用基于 nginx 运行，流量会通过 Ingress 来分发到不同的应用，分发的方式通常有域名、请求路径等等。</p><p>这也进一步简化了运维的工作，运维只需要前端后两个镜像就可以将一套系统部署起来。</p><p><br><br><br></p><p>我们稍微改造一下上文的 Dockerfile 来支持 nginx 部署：</p><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 🔴 阶段 1，安装依赖</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">20</span>-slim as base</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> corepack <span class="built_in">enable</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PNPM_HOME=<span class="string">"/pnpm"</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">"$PNPM_HOME:$PATH"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝依赖声明</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json pnpm-lock.yaml /app/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> --mount=<span class="built_in">type</span>=cache,id=pnpm,target=/pnpm/store pnpm install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 🔴 阶段 2，单元测试</span></span><br><span class="line"><span class="keyword">FROM</span> base as test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝源代码</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pnpm <span class="built_in">test</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 🔴 阶段 3，构建</span></span><br><span class="line"><span class="keyword">FROM</span> test as build</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pnpm build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 🔴 阶段 4，运行</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:stable-alpine as deploy</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=build /app/dist/ /usr/nginx/wwwroot</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要自定义 nginx 配置，可以开启这行</span></span><br><span class="line"><span class="comment">#COPY nginx.conf /etc/nginx/nginx.conf</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"nginx"</span>, <span class="string">"-g"</span>, <span class="string">"daemon off;"</span>]</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="nodejs-程序"><a href="#nodejs-程序" class="headerlink" title="NodeJS 程序"></a>NodeJS 程序</h2><p><br></p><p>这个和普通后端服务没什么区别，狭义上不属于前端的范畴，没有太多可以讲的，可以参考上文的 Next.js 示例。</p><p><br></p><h2 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h2><p>我在<a href="https://juejin.cn/post/7254944931386163260#heading-6" target="_blank" rel="noopener">微前端的落地和治理实战</a> 中简单介绍过：</p><p><img src="/images/docker-for-fe/Untitled%206.png" alt="Untitled"></p><p>我们公司目前采用的是上图的 Sidecar 模式。每个子应用都是一个 Sidecar，启动时将自己‘注册’到基座中，由基座统一对外服务。</p><p>好处：基座可以统一管理所有子应用。比如可以实现‘子应用发现’、动态配置替换之类的工作</p><p>坏处：依赖 PVC 共享存储。我们也有遇到部分客户环境不支持共享 PVC 的。</p><p><br><br><br></p><p>对于不支持共享 PVC 的场景，我们也会进行回退：</p><p><img src="/images/docker-for-fe/Untitled%207.png" alt="Untitled"></p><p>让每个子应用独立对外服务，每个子应用都有自己的前缀， Ingress 根据前缀来分发流量。</p><p>好处就是子应用可以自己管理自己，升级和流量控制会更加灵活。缺点就是基座无法感知到这些子应用的存在，需要手动配置这些子应用的信息。</p><p>如果要更进一步，可以将基座定义为类似后端“<code>注册中心</code>”， 子应用主动向基座注册，有点后端微服务的味道了。如果真需要复杂到这一步，也没有必要自己造轮子，复用后端的技术栈不是更香？</p><p>除此之外，还有很多手段，比如基座提供发布服务，子应用调用基座发布服务，将自己的应用信息、静态资源提交给基座。</p><p><br><br><br><br><br></p><h2 id="不是银弹"><a href="#不是银弹" class="headerlink" title="不是银弹"></a>不是银弹</h2><p>上面我们介绍了基于 Docker 容器的前端应用部署的各种方式和场景。但这并不是银弹！前端也不一定非得就要容器化。</p><p>很多大厂都有自己成熟的发布、部署流程和系统平台，他们需要应付各种复杂的情况,  比如大流量、CDN 同步、熔断降级、灰度发布、蓝绿发布，回滚…  那本文讲到的各种‘朴素’的技巧，就是一种雕虫小技</p><p><br></p><p><strong>那它对我们为什么有用？</strong></p><p>我们主要做 ToB 业务，容器化的方案可以应付私有化交付、私有化部署需求。开发和运维会面对各种千奇百怪的运行环境、公有云、私有云。但大部分甲方都会提供基础的 K8S 环境，容器化对我们来说就是一个最简单且高效的方案。</p><p>另外，依托于 K8S 这类强大容器管理平台，大部分问题都有解决方案，何必造轮子呢？</p><p><br><br><br><br><br></p><h1 id="一些高级话题"><a href="#一些高级话题" class="headerlink" title="一些高级话题"></a>一些高级话题</h1><h2 id="一份基准代码，多份部署"><a href="#一份基准代码，多份部署" class="headerlink" title="一份基准代码，多份部署"></a><strong>一份基准代码，多份部署</strong></h2><p><img src="/images/docker-for-fe/Untitled%208.png" alt="Untitled"></p><p><a href="https://12factor.net/zh_cn/" target="_blank" rel="noopener">12-factors</a> 里有一个原则：<em>一份基准代码，多份部署</em>。如果放在容器这个上下文中，就是一个镜像应该能够在不同的环境部署，而不需要任何修改。</p><p><br></p><p>这对我们做 ToB 的也很重要，如果我们为一个客户做一次私有化部署，就要将所有的应用重新构建一遍，这显然无法接受。</p><p>对于后端服务来说，很容易做到，要么通过<code>环境变量</code>，要么就从<code>配置中心</code>动态拉取。</p><p><br></p><p>而对于前端来说，静态资源的各种 URL (比如 CDN 链接) 和配置可能在<code>构建时</code>就固定下来了。而且我们的代码不运行在服务端，因此也不能通过环境变量来动态配置。</p><p>当然，也有解决办法：</p><ul><li>使用 SSR。理论上可以解决，但是现代前端框架不是纯动态的，也会有一个编译的过程</li><li>模板替换。可以参考 <a href="https://juejin.cn/post/7254944931386163260#heading-6" target="_blank" rel="noopener">微前端的落地和治理实战</a> ，<a href="https://wakeadmin.wakedata.com/mapp/advanced/container.html#%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener">运行容器</a>。</li><li>还有古老的 <a href="http://nginx.org/en/docs/http/ngx_http_ssi_module.html" target="_blank" rel="noopener">SSI</a>(ServerSideInclude) 技术。</li></ul><p><br><br><br></p><p>下面以 <code>Nginx</code> SSI + <code>Vite</code>  为例， 演示一下 SSI: </p><p>vite 配置：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">'vite'</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">'@vitejs/plugin-vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  plugins: [vue()],</span><br><span class="line">  experimental: &#123;</span><br><span class="line">    renderBuiltUrl(filename) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"&lt;!--# echo var='public_url' --&gt;"</span> + filename</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p><code>&lt;!--# echo var=&#39;public_url&#39; --&gt;</code> 是 SSI 的指令语法。这里使用 Vite 实验性的 renderBuiltUrl 来配置（因为直接使用 base 会有问题）。</p><p><br></p><p>Dockerfile:</p><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:stable-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> dist /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> nginx.conf /etc/nginx/nginx.conf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里是需要显式告诉 envsubst 要替换的环境变量，如果有多个环境变量，使用 ',' 分割</span></span><br><span class="line"><span class="comment"># 因为 nginx 变量的语法和 环境变量相似，如果不显式设置，envsubst 可能会误替其他 nginx 变量</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> (cat /etc/nginx/nginx.conf | envsubst <span class="string">'$&#123;PUBLIC_URL&#125;'</span> &gt;/etc/nginx/nginx.conf) &amp;&amp; cat /etc/nginx/nginx.conf &amp;&amp; nginx -g <span class="string">'daemon off;'</span></span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>nginx 配置文件中无法愉快地引用环境变量</strong>，所以<a href="https://www.baeldung.com/linux/nginx-config-environment-variables" target="_blank" rel="noopener">曲线救国</a>， 使用 <code>envsubst</code> 来替换 nginx.conf 中的环境变量占位符。</p><p>Nginx 配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ... 省略</span></span><br><span class="line"></span><br><span class="line">        <span class="string">location</span> <span class="string">/</span> <span class="string">&#123;</span></span><br><span class="line">            <span class="comment"># 开启 ssi</span></span><br><span class="line">            <span class="string">ssi</span> <span class="string">on;</span></span><br><span class="line">            <span class="string">ssi_last_modified</span> <span class="string">on;</span></span><br><span class="line">            <span class="comment"># 支持 html、js、css 等文件</span></span><br><span class="line">            <span class="string">ssi_types</span> <span class="string">text/html</span> <span class="string">application/javascript</span> <span class="string">text/css;</span></span><br><span class="line">            <span class="comment"># 设置变量，将由 envsubst 替换，格式为 $&#123;NAME-defaultValue&#125;</span></span><br><span class="line">            <span class="string">set</span> <span class="string">$public_url</span> <span class="string">"$&#123;PUBLIC_URL-/&#125;"</span><span class="string">;</span></span><br><span class="line">            <span class="string">root</span> <span class="string">/usr/share/nginx/html;</span></span><br><span class="line">            <span class="string">index</span> <span class="string">index.html</span> <span class="string">index.htm;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ... 省略</span></span><br></pre></td></tr></table></figure><p><br></p><p>自己试试看吧!</p><p><br><br><br><br><br></p><h2 id="如何做灰度发布、蓝绿发布…？"><a href="#如何做灰度发布、蓝绿发布…？" class="headerlink" title="如何做灰度发布、蓝绿发布…？"></a>如何做灰度发布、蓝绿发布…？</h2><p>在 K8S 环境，有挺多简单的手段可以实现灰度(金丝雀发布)发布、蓝绿发布这些功能，比如：</p><ul><li><p><a href="https://support.huaweicloud.com/intl/zh-cn/bestpractice-cce/cce_bestpractice_10002.html" target="_blank" rel="noopener">通过 Service。</a>一个 Service 实际上可以映射到多个 Deployment。通过调整不同版本Deployment的副本数，即可调整不同版本服务的权重，实现灰度发布。</p><p>  <img src="/images/docker-for-fe/Untitled%209.png" alt="Untitled"></p></li></ul><ul><li><p><a href="https://support.huaweicloud.com/intl/zh-cn/bestpractice-cce/cce_bestpractice_10003.html" target="_blank" rel="noopener">通过Nginx Ingress</a>。Nginx Ingress 则更加强大一些，支持基于Header、Cookie和服务权重三种流量切分的策略</p><p>  <img src="/images/docker-for-fe/Untitled%2010.png" alt="Untitled"></p></li></ul><p>还有很多实现手段，因为不是本文的重点，就不赘述了。如果大家有更好更简单的方式也可以评论区交流。</p><p><br><br><br></p><p><strong>那如果按照上文讲的微前端部署方式，怎么实现子应用灰度呢？</strong></p><p>这里不需要用到复杂的流量分发技术，因为基座自己会收集子应用的信息，那么只需要在子应用注册表上做文章就行了。例如：</p><p><img src="/images/docker-for-fe/Untitled%2011.png" alt="Untitled"></p><ul><li><p>基座会收集到所有的已部署的子应用。一个子应用可能有多个版本。子应用版本之间使用版本号区分目录：</p>  <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">/apps/</span><br><span class="line">  foo/</span><br><span class="line">     v1/</span><br><span class="line">       manifest.json  # 应用描述信息</span><br><span class="line">       index.html</span><br><span class="line">       js/</span><br><span class="line">       ...</span><br><span class="line">     v2/</span><br><span class="line">       manifest.json</span><br><span class="line">       index.html</span><br><span class="line">       js/</span><br><span class="line">       ...</span><br><span class="line">     current.json     # 保存当前对外服务的应用版本信息。实际上也可以保存一些灰度条件匹配之类的配置信息</span><br><span class="line">  bar/</span><br><span class="line">     v1/</span><br><span class="line">       manifest.json</span><br><span class="line">     current.json</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li></ul><ul><li>基座会提供一个管理平台，供运维和开发者 pick 要对外服务的版本，或者配置灰度匹配条件等等。</li><li>当浏览器发起入口文件请求时，基座计算最终要返回的子应用配置列表，不同人群可能拿到的结果不一样，从而实现灰度发布功能。</li></ul><p>这个思路看起来和后端的<code>服务发现</code>平台(比如 Nacos)很像，后端服务实现灰度基本也是依靠这些平台来实现的。</p><p><br><br><br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回顾一下本文。Docker 发布已经十年，大家对它应该已经熟悉不过了，它对现代的软件工程有非常重要的意义。</p><p><br></p><p>我在这篇文章中分了两个维度来讨论它， 一是将它作为一个’跨平台’的任务运行环境，它让我们可以在一致的环境中运行单测、构建、发布等任务；二是讲怎么将前端应用容器化，对齐后端，利用现有的容器管理平台来实现复杂的部署需求。</p><p><br></p><p>复杂的前端应用构建、发布和部署需要考虑很多问题，可以看看知乎：<a href="https://www.zhihu.com/question/20790576" target="_blank" rel="noopener">大公司里怎样开发和部署前端代码？</a> 字节这篇文章 <a href="https://juejin.cn/post/7017710911443959839" target="_blank" rel="noopener">2021 年当我们聊前端部署时，我们在聊什么</a>。</p><p><br><br><br><br><br></p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://docs.docker.com/build/guide/mounts/" target="_blank" rel="noopener">Build With Docker</a><br><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile reference</a><br><a href="https://yeasy.gitbook.io/docker_practice/image/multistage-builds" target="_blank" rel="noopener">Dockerfile 多阶段构建</a><br><a href="https://12factor.net/zh_cn/" target="_blank" rel="noopener">The Twelve-Factor App</a><br><a href="http://nginx.org/en/docs/http/ngx_http_ssi_module.html" target="_blank" rel="noopener">ngx_http_ssi_module</a><br><a href="https://www.baeldung.com/linux/nginx-config-environment-variables" target="_blank" rel="noopener">Using Environment Variables in Nginx Config File</a><br><a href="https://juejin.cn/post/7017710911443959839" target="_blank" rel="noopener">2021 年当我们聊前端部署时，我们在聊什么</a><br><a href="https://yeasy.gitbook.io/docker_practice/buildx/buildkit" target="_blank" rel="noopener">BuildKit 下一代的镜像构建组件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;why-docker&quot;&gt;&lt;a href=&quot;#why-docker&quot; class=&quot;headerlink&quot; title=&quot;Why Docker?&quot;&gt;&lt;/a&gt;Why Docker?&lt;/h1&gt;&lt;p&gt;Docker 容器化技术是当今最重要的基础设施之一，或者说它已经成为&lt;c
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>前端国际化：语言包篇</title>
    <link href="https://bobi.ink/2023/08/08/i18n-locale/"/>
    <id>https://bobi.ink/2023/08/08/i18n-locale/</id>
    <published>2023-08-07T16:00:00.000Z</published>
    <updated>2023-08-08T08:08:21.066Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><p><img src="/images/i18n-locale/Untitled.png" alt="Cover"></p><p>又开了个新坑，来讲讲前端国际化。</p><p><br></p><p>开篇之前，读者需要区分好<code>国际化</code>(i18n - internationalization)和<code>本地化</code>(l10n - localization) ， 它们是相互关联但又不同的概念：</p><ol><li>国际化（i18n）：这是一个设计和开发过程，确保产品（如软件、网站或应用）能够在不做任何修改的情况下适应不同的语言和地区。这涉及到从一开始就预留空间用于文本扩展，确保日期和时间格式可以根据地区变化，以及确保代码可以处理不同的字符集和写作系统等。</li><li>本地化（L10n）：这是将产品或内容适应到特定市场的过程。这可能包括将文本翻译成本地语言，调整图像和色彩以适应本地文化，以及修改日期、电话号码和地址格式等。本地化可能还需要考虑本地法规和商业习惯。</li></ol><p><br></p><p>简单来说，国际化是创建一个可以轻易本地化的产品的过程，而本地化是将产品调整以适应特定地区的过程。两者在实际产品中的边界可能比没有那么清晰，而是相辅相成，通常在大的国际化基座上进一步进行本地化。</p><p><br></p><p>国际化的涉及面非常广，比如语言、文字编码、时区、书写习惯、单复数、标点符号、时间格式、货币格式、计量单位…</p><p>强烈推荐读者读一下 <a href="https://www.zhihu.com/column/txtwork" target="_blank" rel="noopener">基础设计专栏 - From.RED</a> 这个专栏，这里面一系列的国际化/本地化的文章都非常赞：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/29759116" target="_blank" rel="noopener">为全球设计，国际化与本地化探索：快速入门</a></li><li><a href="https://zhuanlan.zhihu.com/p/29780850" target="_blank" rel="noopener">为全球设计，国际化与本地化探索：国际化设计</a></li><li><a href="https://zhuanlan.zhihu.com/p/31025276" target="_blank" rel="noopener">为全球设计，国际化与本地化探索：本地化设计</a></li></ul><p><br></p><p>实际上笔者也不是特别专业，这系列文章仅是我的一些技术实践总结。作为开篇，我们先聊一聊一些比较基础的话题：前端语言包的管理。</p><p><br></p><p>对于语言包的管理，我们大概率会遇到以下问题：</p><ul><li>语言包应该放在哪个目录？</li><li>全局使用一个语言包，还是分模块？</li><li>如果是分模块的话？粒度怎么把握?</li><li>怎么实现按需加载？Web 端？小程序端？</li><li>如果分模块组织，碎片化的语言包会不会导致多个请求？</li><li>如何管理和分析语言包的使用？</li><li>还有哪些建议？</li></ul><p><br></p><p>如果进一步归纳，这些问题又可以分为三大类：</p><ul><li><p>组织语言包</p><ul><li>语言包应该放在哪个目录？</li><li>全局使用一个语言包，还是分模块？</li><li>如果是分模块的话？粒度怎么把握?</li></ul></li><li><p>语言包加载</p><ul><li>怎么实现按需加载？Web 端？小程序端？</li><li>如果分模块组织，碎片化的语言包会不会导致多个请求？</li></ul></li><li><p>语言包管理</p><ul><li>如何管理和分析语言包的使用？</li><li>还有哪些建议？</li></ul></li></ul><p><br><br><br><br><br></p><h1 id="1-组织语言包"><a href="#1-组织语言包" class="headerlink" title="1. 组织语言包"></a>1. 组织语言包</h1><h2 id="1-1-放在哪个目录下？"><a href="#1-1-放在哪个目录下？" class="headerlink" title="1.1 放在哪个目录下？"></a>1.1 放在哪个目录下？</h2><p>通常放在 <code>locales</code> 或者 <code>i18n</code> 目录下。比如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/src</span><br><span class="line">  /locales</span><br><span class="line">    zh.json</span><br><span class="line">    zh-Hant.json</span><br><span class="line">    en.json</span><br><span class="line">    th.json</span><br></pre></td></tr></table></figure><p><br></p><p>我们团队的规范是使用 <code>*.tr</code> 来作为语言包，例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/src</span><br><span class="line">  /locales</span><br><span class="line">    zh.tr</span><br><span class="line">    zh-Hant.tr</span><br><span class="line">    en.tr</span><br><span class="line">    th.tr</span><br></pre></td></tr></table></figure><p><br></p><p><code>tr</code> 即 <code>translate</code> 的缩写， 这么做的目的主要为了和 <code>json</code> 文件区分开，方便后面的构建工具识别。</p><p>当然还有其他手段可以实现，但在本篇文章中我们统一约定使用 <code>.tr</code> 作为语言包文件。</p><blockquote><p>💡 VSCode 中加上以下配置，可以将 tr 文件识别为 <code>JSON</code>:</p> <figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt;  // .vscode/settings.json</span><br><span class="line">&gt;  &#123;</span><br><span class="line">&gt;    "files.associations": &#123;</span><br><span class="line">&gt;      "*.tr": "json"</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><br><br><br><br><br></p><h2 id="1-2-全局使用一个语言包，还是分模块？"><a href="#1-2-全局使用一个语言包，还是分模块？" class="headerlink" title="1.2 全局使用一个语言包，还是分模块？"></a>1.2 全局使用一个语言包，还是分模块？</h2><p>我们推荐<code>按照业务来聚合&#39;实现&#39;</code>，大部分情况不应该将所有的语言包一股脑放在一起，除非你的项目比较简单。换句话说，应该遵循<code>就近原则</code>，Global is Evil。</p><p><br></p><p>比如 MonoRepo 项目：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">packages</span><br><span class="line">  ├── pkgA</span><br><span class="line">  |   └── i18n</span><br><span class="line">  |       ├── en.tr</span><br><span class="line">  |       ├── zh.tr</span><br><span class="line">  |       └── ...</span><br><span class="line">  ├── pkgB</span><br><span class="line">  |   └── i18n</span><br><span class="line">  |       ├── en.tr</span><br><span class="line">  |       ├── zh.tr</span><br><span class="line">  |       └── ...</span><br><span class="line">  └── ...</span><br></pre></td></tr></table></figure><p><br></p><p><strong>分模块的好处是维护起来相对容易，尤其是后期迁移和重构时。另外一个好处是可以根据模块按需加载</strong>。</p><p><br><br><br><br><br></p><h2 id="1-3-如果是分模块的话？粒度怎么把握"><a href="#1-3-如果是分模块的话？粒度怎么把握" class="headerlink" title="1.3 如果是分模块的话？粒度怎么把握?"></a>1.3 如果是分模块的话？粒度怎么把握?</h2><p>为了平衡加载速度、可维护性，翻译文件不能过小、也不能过大。通常按照<code>业务模块</code>的粒度来划分。<strong>业务模块是由一个或多个页面组成的完整的功能</strong>。</p><p><br><br><br></p><p><img src="/images/i18n-locale/Untitled%201.png" alt="子域划分"></p><p>图片来源: <a href="https://time.geekbang.org/column/intro/100037301" target="_blank" rel="noopener">https://time.geekbang.org/column/intro/100037301</a></p><p><br></p><p>如果按照 DDD 的说法，业务模块可以是一个<code>子域</code>、甚至更小粒度的<code>聚合</code>。总之这个业务模块有以下特征：</p><ul><li>自包含。自给自足实现一个完整的功能闭环</li><li>高聚合。对外部依赖较少。</li></ul><p><br></p><p>读者也不用过于纠结，实际在业务开发时，随着对需求了解的深入，你会摸索到它们的边界，或者你也可以从其他地方借鉴，比如后端服务的划分、产品需求结构的划分等等。</p><p><br></p><p>从代码的实现层面来看，你也可以认为<code>业务模块</code>等同于 MonoRepo 的一个<code>子项目</code>。尽管子项目内部可能会继续拆分。</p><p><br></p><hr><p><br></p><h1 id="2-语言包加载"><a href="#2-语言包加载" class="headerlink" title="2. 语言包加载"></a>2. 语言包加载</h1><h2 id="2-1-怎么实现按需加载？web-端？小程序端？"><a href="#2-1-怎么实现按需加载？web-端？小程序端？" class="headerlink" title="2.1 怎么实现按需加载？Web 端？小程序端？"></a>2.1 怎么实现按需加载？Web 端？小程序端？</h2><p><strong>在 Web 端</strong>，通常通过<code>动态导入</code>(Dynamic Import) 实现， 例如：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">registerBundles(&#123;</span><br><span class="line">  zh: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./zh.tr'</span>),</span><br><span class="line">  en: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./en.tr'</span>),</span><br><span class="line">  <span class="string">'zh-Hant'</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./zh-Hant.tr'</span>),</span><br><span class="line">  th: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./th.tr'</span>),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 Webpack 中无法识别 tr 扩展名，我们扩展一下：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack chain</span></span><br><span class="line">chain.module.rule(<span class="string">'translate'</span>).test(<span class="regexp">/\.tr$/</span>).use(<span class="string">'json'</span>).loader(<span class="string">'json-loader'</span>).end()</span><br></pre></td></tr></table></figure><p>使用 <code>json-loader</code> 来处理 tr 文件。</p><p><br><br><br><br><br></p><p><strong>小程序端呢？</strong></p><p>小程序端不支持<code>动态执行代码</code>, 所以无法使用<code>动态导入</code>， 解决办法就是作为静态资源提取出去，托管到<code>静态资源服务器</code> 或 <code>CDN</code>中，远程加载:</p><p><img src="/images/i18n-locale/Untitled%202.png" alt="小程序"></p><p><br></p><p>以 <code>Taro</code> 配置为例</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Webpack 5</span></span><br><span class="line"><span class="keyword">const</span> generator = &#123;</span><br><span class="line">  filename: fileLoaderOptions.name,</span><br><span class="line">  publicPath: fileLoaderOptions.publicPath,</span><br><span class="line">  outputPath: fileLoaderOptions.outputPath,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx.modifyWebpackChain(<span class="function">(<span class="params">&#123; chain &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 翻译文件提取</span></span><br><span class="line">  <span class="keyword">const</span> translation = chain.module.rule(<span class="string">'translation'</span>).test(<span class="regexp">/\.tr$/</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'development'</span>) &#123;</span><br><span class="line">    <span class="comment">// 🔴 开发环境使用 JSON 引用</span></span><br><span class="line">    translation.type(<span class="string">'json'</span>).end()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 🔴 生产环境 使用 ’file-loader‘ 提取到 CDN 服务器</span></span><br><span class="line">    translation.type(<span class="string">'asset/resource'</span>).set(<span class="string">'generator'</span>, generator).end()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持 import xx from './test.json?extra' 模式, 强制提取</span></span><br><span class="line">    chain.module</span><br><span class="line">      .rule(<span class="string">'extra'</span>)</span><br><span class="line">      .resourceQuery(<span class="regexp">/extra/</span>)</span><br><span class="line">      .type(<span class="string">'asset/resource'</span>)</span><br><span class="line">      .set(<span class="string">'generator'</span>, generator)</span><br><span class="line">      .end()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>对于开发环境，沿用 json-loader 的方式处理，生产环境则进行<a href="https://webpack.js.org/guides/asset-modules/" target="_blank" rel="noopener">资源提取</a>(等价 Webpack 4 的 url-loader、file-loader)。</p><p><br></p><p>小程序语言包声明：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">registerBundles(&#123;</span><br><span class="line">  zh: <span class="built_in">require</span>(<span class="string">'@wakeapp/login-sdk/i18n/zh.tr'</span>),</span><br><span class="line">  <span class="string">'zh-Hant'</span>: <span class="built_in">require</span>(<span class="string">'@wakeapp/login-sdk/i18n/zh-Hant.tr'</span>),</span><br><span class="line">  en: <span class="built_in">require</span>(<span class="string">'@wakeapp/login-sdk/i18n/en.tr'</span>),</span><br><span class="line">  th: <span class="built_in">require</span>(<span class="string">'@wakeapp/login-sdk/i18n/th.tr'</span>),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>同样的思路也可以用于小程序的其他静态资源、比如图片、视频、字体等。</p><p><br><br><br><br><br></p><h2 id="2-2-如果分模块组织，碎片化的语言包会不会导致多个请求？"><a href="#2-2-如果分模块组织，碎片化的语言包会不会导致多个请求？" class="headerlink" title="2.2 如果分模块组织，碎片化的语言包会不会导致多个请求？"></a>2.2 如果分模块组织，碎片化的语言包会不会导致多个请求？</h2><p><img src="/images/i18n-locale/Untitled%203.png" alt="碎片化"></p><p><br><br><br></p><p>一个屎山项目可能会有很多语言包。如果不干预，就会有很多碎片化的请求, 在不支持 HTTP 2.0 的环境，这些请求会对页面性能造成较大的影响，怎么优化加载呢？</p><p><br></p><p>在 Web 端，可以利用 <a href="https://webpack.js.org/plugins/split-chunks-plugin/#root" target="_blank" rel="noopener"><code>splitChunks</code></a> 对语言包进行合并：</p><p><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const TRANSLATE_FILE_REG = /([^./]*)\.tr$/</span><br><span class="line"></span><br><span class="line">function getLocale(request: string) &#123;</span><br><span class="line">  return request.match(TRANSLATE_FILE_REG)?.[1]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ... 省略部分代码</span><br><span class="line"></span><br><span class="line">// 翻译文件资源合并, 避免碎片化, 导致并发请求数量过多</span><br><span class="line">if (process.env.NODE_ENV === &apos;production&apos;) &#123;</span><br><span class="line">  const splitChunks = chain.optimization.get(&apos;splitChunks&apos;)</span><br><span class="line">  if (splitChunks == null) &#123;</span><br><span class="line">    // 已禁用</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const translateMerge = &#123;</span><br><span class="line">    // 只针对异步模块</span><br><span class="line">    chunks: &apos;async&apos;,</span><br><span class="line">    test: /\.tr$/,</span><br><span class="line">    // 🔴 最大尺寸</span><br><span class="line">    maxSize: 200 * 1024,</span><br><span class="line">    name: (module: &#123; rawRequest: string &#125;) =&gt; &#123;</span><br><span class="line">      const request = module.rawRequest</span><br><span class="line">      if (request == null) &#123;</span><br><span class="line">        throw new Error(`[vue-cli-plugin-i18n]: failed to get locale from $&#123;request&#125;`)</span><br><span class="line">      &#125;</span><br><span class="line">      // 🔴 按 locale 作为 key 进行合并</span><br><span class="line">      return `$&#123;getLocale(request)&#125;-tr`</span><br><span class="line">    &#125;,</span><br><span class="line">    // 强制执行</span><br><span class="line">    enforce: true,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  chain.optimization.splitChunks(&#123;</span><br><span class="line">    ...splitChunks,</span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">      ...splitChunks.cacheGroups,</span><br><span class="line">      translateMerge,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>上面的代码就是使用 splitChunks 对相同 Locale 的语言包进行合并，最大体积不超过 200kb。</p><p><br></p><p>小程序端暂时不支持这种方式。可以通过其他手段来弥补，比如人工避免碎片化、缓存到本地存储等等。</p><p><br><br><br></p><h2 id="2-3-registerbundles-怎么实现？"><a href="#2-3-registerbundles-怎么实现？" class="headerlink" title="2.3 registerBundles 怎么实现？"></a>2.3 registerBundles 怎么实现？</h2><p><code>registerBundles</code> 负责对语言包进行注册、加载、合并、激活等操作：</p><p><img src="/images/i18n-locale/Untitled%204.png" alt="注册"></p><p><br></p><ul><li>调用 <code>registerBundles</code> 会将相关语言包注册到<code>资源表</code>（Resouces）中。它可以接收对象、HTTP 链接、Promise 等</li><li>具体要加载哪个语言包由 i18n 库通知。i18n 库传入一个 <code>Locale chain</code>, 这是一个字符串数组。表示的是 i18n 库的<code>语言回退链条</code>， 或者说 i18n 库就是按照这个顺序到语言包中查找 key，比如当前 locale 是 ‘<code>zh-Hant-HK</code>’， 那么 Locale chain 就是 <code>[&#39;zh-Hant-HK&#39;, &#39;zh-Hant&#39;, &#39;zh&#39;]</code></li><li>接着根据 <code>Locale chain</code> 计算出需要加载的语言包。</li><li>根据资源的类型选择不同的<code>Loader</code>(加载器)进行处理。比如 <code>HTTP Loader</code>、<code>Promise Loader</code></li><li>当所有语言包加载就绪后，将所有结果合并成一棵树，返回给 i18n。合并时可以有优先级，比如某些语言包从后端服务中获取，我们希望它能覆盖其他语言包，优先展示。</li></ul><p><br><br><br></p><p>来看一下具体代码：</p><p><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export class BundleRegister &#123;</span><br><span class="line">  private executing = false</span><br><span class="line"></span><br><span class="line">  private resources: &#123; [locale: string]: Set&lt;I18nBundle&gt; &#125; = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  private layerLinks: &#123; [locale: string]: LayerLink &#125; = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 缓存资源的层级</span><br><span class="line">   */</span><br><span class="line">  private resourceLayer: Map&lt;I18nBundle, number&gt; = new Map()</span><br><span class="line"></span><br><span class="line">  private pendingQueue = new PromiseQueue&lt;void&gt;()</span><br><span class="line"></span><br><span class="line">  constructor(</span><br><span class="line">    private registerBundle: (locale: string, bundle: Record&lt;string, any&gt;) =&gt; void,</span><br><span class="line">    private getLocaleChain: () =&gt; string[],</span><br><span class="line">    private onBundleChange: () =&gt; void</span><br><span class="line">  ) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 判断是否存在正在加载中的语言包</span><br><span class="line">   */</span><br><span class="line">  hasPendingBundle() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 调度语言包加载和合并</span><br><span class="line">   */</span><br><span class="line">  async schedulerMerge(): Promise&lt;void&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 注册语言包</span><br><span class="line">   */</span><br><span class="line">  registerBundles = async (</span><br><span class="line">    bundles: &#123; [locale: string]: I18nBundle &#125;,</span><br><span class="line">    layer: number = 10</span><br><span class="line">  ): Promise&lt;void&gt; =&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>整个类的结构如上，构造函数需要传入三个钩子：</p><ul><li>registerBundle。 BundleRegister 通过它向 i18n 库提交语言包(message)</li><li>getLocaleChain。向 i18n 获取 local chain</li><li>onBundleChange。语言包变动事件通知</li></ul><p><br></p><p>看下在 vue-i18n(9+) 下怎么对接：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 🔴 初始化</span><br><span class="line">const bundleRegister = new BundleRegister(</span><br><span class="line">  (loc, bundle) =&gt; &#123;</span><br><span class="line">    // 🔴 提交语言包</span><br><span class="line">    const initialMessages = messages?.[loc]</span><br><span class="line">    let cloneBundle = bundle</span><br><span class="line"></span><br><span class="line">    // 拷贝</span><br><span class="line">    if (initialMessages) &#123;</span><br><span class="line">      cloneBundle = merge(&#123;&#125;, initialMessages, cloneBundle)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vueI18nInstance.setLocaleMessage(loc, cloneBundle)</span><br><span class="line">  &#125;,</span><br><span class="line">  // 🔴 获取 Local chain</span><br><span class="line">  getFallbackLocaleChain,</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    eventBus.emit(EVENT_MESSAGE_CHANGE)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 🔴 监听语言变动并触发 BundlerRegister 加载</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; unref(vueI18nInstance.locale),</span><br><span class="line">  (loc) =&gt; &#123;</span><br><span class="line">    // 检查是否通过 setLocale 调用</span><br><span class="line">    if (!SET_LOCALE_CONTEXT) &#123;</span><br><span class="line">      console.error(`[i18n] 禁止直接设置 .locale 来设置当前语言， 必须使用 setLocale()`)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eventBus.emit(EVENT_LOCALE_CHANGE, loc)</span><br><span class="line">    bundleRegister.schedulerMerge()</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; flush: &apos;sync&apos; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br></p><p>返回来看注册细节。<code>registerBundles</code> 就是注册语言包，过程很简单：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 注册语言包</span><br><span class="line"> */</span><br><span class="line">registerBundles = async (</span><br><span class="line">  bundles: &#123; [locale: string]: I18nBundle &#125;,</span><br><span class="line">  layer: number = 10</span><br><span class="line">): Promise&lt;void&gt; =&gt; &#123;</span><br><span class="line">  let dirty = false</span><br><span class="line">  Object.keys(bundles).forEach((k) =&gt; &#123;</span><br><span class="line">    const normalizedKey = k.toLowerCase()</span><br><span class="line">    // 登记到资源表</span><br><span class="line">    const list = (this.resources[normalizedKey] ??= new Set())</span><br><span class="line">    const bundle = bundles[k]</span><br><span class="line"></span><br><span class="line">    const add = (b: I18nBundle) =&gt; &#123;</span><br><span class="line">      if (!list.has(b)) &#123;</span><br><span class="line">        list.add(b)</span><br><span class="line">        this.resourceLayer.set(b, layer)</span><br><span class="line">        dirty = true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (Array.isArray(bundle)) &#123;</span><br><span class="line">      for (const child of bundle) &#123;</span><br><span class="line">        add(child)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      add(bundle)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  if (dirty) &#123;</span><br><span class="line">    // 🔴 立即调度加载</span><br><span class="line">    return await this.schedulerMerge()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>相对比较复杂的是 <code>scheduleMerge</code>，但也不难理解：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async schedulerMerge(): Promise&lt;void&gt; &#123;</span><br><span class="line">  // 🔴 执行中，不需要重新发起</span><br><span class="line">  if (this.executing) &#123;</span><br><span class="line">    return await this.pendingQueue.push();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let queue = this.pendingQueue;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    this.executing = true;</span><br><span class="line"></span><br><span class="line">    // 🔴 等待更多 bundle 插入，批量执行</span><br><span class="line">    await Promise.resolve();</span><br><span class="line"></span><br><span class="line">    // 🔴 下一批执行</span><br><span class="line">    this.pendingQueue = new PromiseQueue();</span><br><span class="line"></span><br><span class="line">    // 🔴 加载当前语言</span><br><span class="line">    const localeChain = this.getLocaleChain();</span><br><span class="line"></span><br><span class="line">    // 🔴 已经加载的语言</span><br><span class="line">    let messages: &#123; [locale: string]: Record&lt;string, any&gt;[] &#125; = &#123;&#125;;</span><br><span class="line">    let task: Promise&lt;void&gt;[] = [];</span><br><span class="line"></span><br><span class="line">    // 🔴 遍历 localeChain</span><br><span class="line">    for (const locale of localeChain) &#123;</span><br><span class="line">      const resource = this.resources[locale.toLowerCase()];</span><br><span class="line"></span><br><span class="line">      if (resource == null) &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      for (const bundle of resource.values()) &#123;</span><br><span class="line">        // 🔴 跳过已经加载</span><br><span class="line">        if (isLoaded(bundle)) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 🔴 layer 表示语言包的分层，或者说合并的优先级， 层数越低优先级越高</span><br><span class="line">        const layer = this.resourceLayer.get(bundle) ?? DEFAULT_LAYER;</span><br><span class="line"></span><br><span class="line">        if (typeof bundle === &apos;function&apos;) &#123;</span><br><span class="line">          // 🔴 异步加载函数</span><br><span class="line">          task.push(</span><br><span class="line">            (async () =&gt; &#123;</span><br><span class="line">              const loadedBundle = await asyncModuleLoader(bundle as I18nAsyncBundle);</span><br><span class="line">              if (loadedBundle) &#123;</span><br><span class="line">                this.setLayer(loadedBundle, layer);</span><br><span class="line">                console.debug(`[i18n] bundle loaded: `, bundle);</span><br><span class="line">                (messages[locale] ??= []).push(loadedBundle);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)()</span><br><span class="line">          );</span><br><span class="line">        &#125; else if (typeof bundle === &apos;string&apos;) &#123;</span><br><span class="line">          // 🔴 http 链接</span><br><span class="line">          task.push(</span><br><span class="line">            (async () =&gt; &#123;</span><br><span class="line">              const loadedBundle = await httpLoader(bundle);</span><br><span class="line"></span><br><span class="line">              if (loadedBundle) &#123;</span><br><span class="line">                this.setLayer(loadedBundle, layer);</span><br><span class="line">                console.debug(`[i18n] bundle loaded: `, bundle);</span><br><span class="line">                (messages[locale] ??= []).push(loadedBundle);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)()</span><br><span class="line">          );</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // 🔴 直接就是语言包对象</span><br><span class="line">          this.setLayer(bundle, layer);</span><br><span class="line">          (messages[locale] ??= []).push(bundle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setLoaded(bundle);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 🔴 并发加载</span><br><span class="line">    if (task.length) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        await Promise.all(task);</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        console.warn(`[i18n] 加载语言包失败:`, err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const messageKeys = Object.keys(messages);</span><br><span class="line"></span><br><span class="line">    // 🔴 接下来就是将 messages 合并成一棵树</span><br><span class="line">    if (messageKeys.length) &#123;</span><br><span class="line">      const messageToUpdate: &#123; [locale: string]: LayerLink &#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">      for (const locale of messageKeys) &#123;</span><br><span class="line">        // 🔴 LayerLink 存储了所有已经加载的语言包和他的分层信息</span><br><span class="line">        const layerLink = (this.layerLinks[locale] ??= new LayerLink());</span><br><span class="line"></span><br><span class="line">        for (const bundle of messages[locale]) &#123;</span><br><span class="line">          const layer = this.getLayer(bundle);</span><br><span class="line"></span><br><span class="line">          layerLink.assignLayer(layer, bundle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        messageToUpdate[locale] = layerLink;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 🔴 触发更新</span><br><span class="line">      for (const locale in messageToUpdate) &#123;</span><br><span class="line">        this.registerBundle(locale, messageToUpdate[locale].flattenLayer());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      this.onBundleChange();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.error(`[i18n] 语言包加载失败`, err);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    this.executing = false;</span><br><span class="line">    queue.flushResolve();</span><br><span class="line"></span><br><span class="line">    // 🔴 判断是否有新的 bundle 加进来，需要继续调度加载</span><br><span class="line">    if (this.hasUnloadedBundle()) &#123;</span><br><span class="line">      // 继续调度</span><br><span class="line">      this.schedulerMerge();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 没有了，清空队列不需要继续等待了</span><br><span class="line">      this.pendingQueue.flushResolve();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>这就是一个典型的异步任务执行的调度过程。相关的<a href="https://github.com/wakeadmin/tools/tree/main/packages/i18n-shared" target="_blank" rel="noopener">源码可以看这里</a></p><p><br><br><br><br><br></p><h1 id="3-语言包管理"><a href="#3-语言包管理" class="headerlink" title="3. 语言包管理"></a>3. 语言包管理</h1><h2 id="3-1-如何管理和分析语言包的使用？"><a href="#3-1-如何管理和分析语言包的使用？" class="headerlink" title="3.1 如何管理和分析语言包的使用？"></a>3.1 如何管理和分析语言包的使用？</h2><p>那么如何提高前端国际化的开发体验呢？比如：</p><ul><li>能够在编辑器回显 key 对应的中文</li><li>能够点击跳转到 key 定义的语言包</li><li>能够分析语言包是否被引用、有没有重复、缺译的情况</li><li>支持 key 重命名(重构)</li><li>能自动发现文本硬编码，并支持提取</li><li>支持机器翻译</li><li>提供协同翻译….</li></ul><p><img src="/images/i18n-locale/Untitled%205.png" alt="i18n-ally"></p><p>🎉 还真有这么一个神器可以满足上面所有需求，那就是 VSCode 的 <a href="https://marketplace.visualstudio.com/items?itemName=lokalise.i18n-ally" target="_blank" rel="noopener">i18n Ally</a> 插件(还是 <a href="http://antfu.me" target="_blank" rel="noopener">antfu</a> 大神开发的, 顶礼膜拜)！</p><p><img src="/images/i18n-locale/Untitled%206.png" alt="i18n-ally"></p><p><br></p><p>安装了 <a href="https://marketplace.visualstudio.com/items?itemName=lokalise.i18n-ally" target="_blank" rel="noopener">i18n Ally</a> 后，大多数情况下是能开箱即用。以下是一些你可能需要调整的常见配置项：</p><p><br></p><ol><li><p>使用的框架。默认情况下，i18n ally 会分析项目根目录下的 package.json, 确定你使用的 i18n 框架，它支持了很多常见的 i18n 库，比如 <code>vue-i18n</code>, <code>react-i18next</code>。</p><p><em>💡  如果无法你发现 i18n ally 插件没有启用，那大概率就是它检测失败了, 可以在 <code>OUTPUT</code> Panel 下看的日志：</em></p><p><img src="/images/i18n-locale/Untitled%207.png" alt="OUTPUT"></p><p>解决办法就是显式告诉它：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">// .vscode/setting.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"i18n-ally.enabledFrameworks"</span>: [<span class="string">"react-i18next"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义语言包检查目录。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">// .vscode/setting.json</span><br><span class="line">&#123;</span><br><span class="line">  // 支持在所有嵌套的 locales、i18n 目录下发现语言包</span><br><span class="line">  "i18n-ally.localesPaths": ["**/locales", "**/i18n"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>语言包配置</p><p>我们上文使用的是 <code>.tr</code> 扩展名， i18n ally 并不能识别它，我们通过下面的配置来告诉它如何处理 tr 文件：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">// .vscode/setting.json</span><br><span class="line">&#123;</span><br><span class="line">  // 语言包的命名规则</span><br><span class="line">  "i18n-ally.pathMatcher": "&#123;locale&#125;.tr",</span><br><span class="line">  // 语言包的 parser</span><br><span class="line">  "i18n-ally.parsers.extendFileExtensions": &#123;</span><br><span class="line">    "tr": "json"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其他常见配置</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 源语言。主要会影响翻译，即以哪个语言为源语言翻译到其他语种。中文开发者通常设置为中文</span><br><span class="line">  "i18n-ally.sourceLanguage": "zh",</span><br><span class="line">  // 在编辑器内联提示的语种</span><br><span class="line">  "i18n-ally.displayLanguage": "zh",</span><br><span class="line">  // 语言包的组织形式，nested 表示嵌套对象模式</span><br><span class="line">  "i18n-ally.keystyle": "nested"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>更多的配置可以看它的<a href="https://github.com/lokalise/i18n-ally/wiki" target="_blank" rel="noopener">文档</a>。</p><p><br><br><br><br><br></p><h2 id="3-2-还有哪些建议？"><a href="#3-2-还有哪些建议？" class="headerlink" title="3.2 还有哪些建议？"></a>3.2 还有哪些建议？</h2><p><br></p><h3 id="3-2-1-统一语言标签"><a href="#3-2-1-统一语言标签" class="headerlink" title="3.2.1 统一语言标签"></a>3.2.1 统一语言标签</h3><p>多语言的语言标签通常遵循 <a href="https://en.wikipedia.org/wiki/IETF_language_tag" target="_blank" rel="noopener">BCP 47</a>， 这是由互联网工程任务组（IETF）发布的一种语言标签规范，用于唯一标识各种语言。格式为 <code>lng-(script)-(Region 区域)-(Variant 变体)</code>，例如 zh-Hans-CN、en-US、zh-Hant 等等。</p><p>因为语言标签形式多种多样，而且不同的环境给出的结果可能都不太一样，所以建议开发者在维护语言包时统一使用语言标签，并且前后端保持统一。</p><p>以我们团队为例：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">en 默认英文</span><br><span class="line">zh 默认简体中文</span><br><span class="line">zh-Hant 默认繁体</span><br><span class="line">th 默认泰文</span><br></pre></td></tr></table></figure><p>同时维护一些语言标签的映射规则：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"zh-TW"</span>: <span class="string">"zh-Hant-TW"</span>,</span><br><span class="line">  <span class="attr">"zh-HK"</span>: <span class="string">"zh-Hant-HK"</span>,</span><br><span class="line">  <span class="attr">"zh-MO"</span>: <span class="string">"zh-Hant-MO"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>你会发现我们使用的 en、zh、zh-Hant、th 这些语言标签都是 <code>lng-(script)</code> 形式，这样兜底/命中效果会好点。</p><p>举个例子 <code>zh-Hant-TW</code> 的 <code>Locale chain</code> 是 <code>[&#39;zh-Hant-TW&#39;, &#39;zh-Hant&#39;, &#39;zh&#39;]</code> , 会回退加载 <code>zh-Hant</code> 和 <code>zh</code> 语言包。 如果有朝一日，需要对 TW 地区做特殊的适配，我们再创建一个更具体 <code>zh-Hant-TW</code> 语言包就行了。</p><p><br><br><br></p><h3 id="3-2-2-使用嵌套命名空间来组织语言包"><a href="#3-2-2-使用嵌套命名空间来组织语言包" class="headerlink" title="3.2.2 使用嵌套命名空间来组织语言包"></a>3.2.2 使用嵌套命名空间来组织语言包</h3><p>建议以<code>业务模块</code>或者<code>团队名</code>称来作为<code>命名空间</code>, 避免直接将 key 暴露到全局。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"rule"</span>: &#123;</span><br><span class="line">    <span class="attr">"deleteRuleTips"</span>: <span class="string">"删除规则后无法恢复，确定删除？"</span>,</span><br><span class="line">    <span class="attr">"newRule"</span>: <span class="string">"新建规则"</span>,</span><br><span class="line">    <span class="attr">"pointRule"</span>: <span class="string">"积分规则"</span>,</span><br><span class="line">    <span class="attr">"tiedRule"</span>: <span class="string">"等级规则"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>下一篇，我们介绍多语言的翻译问题，敬请期待！！</strong></p><p><br><br><br><br><br></p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://www.zhihu.com/question/51158638/answer/2378431663" target="_blank" rel="noopener">如何论述设计的全球化与本土化的关系？</a></li><li><a href="https://zhuanlan.zhihu.com/p/29759116" target="_blank" rel="noopener">为全球设计，国际化与本地化探索：快速入门</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/i18n-locale/Untitled.png&quot; alt=&quot;Cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;又开了个新坑，来讲讲前端国际化。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;开篇之前，读者需要区分好&lt;code&gt;国际化&lt;/co
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>来一瓶  Web Component 魔法胶水</title>
    <link href="https://bobi.ink/2023/08/03/web-component/"/>
    <id>https://bobi.ink/2023/08/03/web-component/</id>
    <published>2023-08-02T16:00:00.000Z</published>
    <updated>2023-08-08T08:08:21.031Z</updated>
    
    <content type="html"><![CDATA[<p>Web Component 已经被浏览器广泛支持，不再是新鲜玩意了，它有很多使用场景，比如编写跨框架的组件库、微前端，完全用它开发复杂的应用也没问题。</p><p>而今天我要介绍的是 Web component 如何扮演框架/微应用之间的胶水层这个角色。</p><h1 id="web-component-是前端通用协议"><a href="#web-component-是前端通用协议" class="headerlink" title="Web Component 是前端通用协议"></a>Web Component 是前端通用协议</h1><p>在软件系统中 ，前端通常作为各种后端服务的聚合层，一个页面中可能承载来自多个业务域的内容：</p><p><img src="/images/web-component/Untitled.png" alt="服务聚合"></p><p>因此前端的业务边界并那么清晰，很难做到和后端微服务一一映射:</p><p><img src="/images/web-component/Untitled%201.png" alt="微应用映射"></p><p>就像微服务一样，微应用之间也会互相依赖。比如在微前端中，我们可能会依赖其他子应用的<code>业务组件</code>，并且这些子应用有可能是异构的，比如 React 引用 Vue 的组件、或者 Vue 3 引用老旧 Vue 2 组件。</p><p>尽管在大部分情况下，我们并不建议子应用之间产生耦合，但是考虑迁移的成本等现实因素，我们只能妥协。下面是一些常见的解决办法有：</p><ul><li>将这些组件剥离出来，放置到通用的业务组件库。</li><li>子应用暴露服务方法，传入 DOM 挂载点，让目标子应用将元素渲染到这个 DOM 元素上</li><li>子应用通过 Web Component 暴露服务。</li></ul><p>第一种方式。很多情况，这些组件很难剥离出来，就算剥离出来为了应付异构消费，我们可能还是得通过 Web component 重构。</p><p>而第二种方式，还不如直接使用 Web Component , 这是一种标准组件 API，主流的视图框架都支持。</p><p><img src="/images/web-component/Untitled%202.png" alt="通用协议"></p><p>就如异构的微服务使用通用的 HTTP、RPC 协议来通信一样，Web Component 就是异构前端应用之间的「通用协议」。</p><p>所以本文的话题就是围绕着：<code>怎么把现有的组件包装成 Web Component</code> 展开。</p><p><br><br><br><br><br></p><h1 id="web-component-概览"><a href="#web-component-概览" class="headerlink" title="Web component 概览"></a>Web component 概览</h1><p>Web Component ，或者说<code>自定义元素</code>(Custom Element) 更加贴切，它就是支持我们<strong><code>创建自定义 HTML 元素</code></strong>的相关’<strong>技术集合’</strong>。</p><p><img src="/images/web-component/Untitled%203.png" alt="思维导图"></p><p>上面的思维导图，基本覆盖了你需要掌握的内容了。如果读者熟悉主流视图框架(比如 Vue)，只要花一两个小时就可以掌握啦。这块资料也比较多， 我就展开细节了，推荐 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_components" target="_blank" rel="noopener">MDN 的相关教程</a>。</p><p><br><br><br></p><p>先简单写几个 <code>Hello world</code> 吧：</p><p><br></p><p>创建一个自定义元素：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        hello-world &#123; color: red; &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        class HelloWorld extends HTMLElement &#123;</span><br><span class="line">            connectedCallback() &#123;</span><br><span class="line">                this.innerHTML = `&lt;p&gt;Hello, World!&lt;/p&gt;`;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        customElements.define(&apos;hello-world&apos;, HelloWorld);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;hello-world&gt;&lt;/hello-world&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><br></p><p>Shadow DOM 版本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        class HelloWorld extends HTMLElement &#123;</span><br><span class="line">            constructor() &#123;</span><br><span class="line">                super();</span><br><span class="line">                this.attachShadow(&#123; mode: &apos;open&apos; &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            connectedCallback() &#123;</span><br><span class="line">                this.shadowRoot.innerHTML = `</span><br><span class="line">                    &lt;style&gt;:host &#123; color: red; &#125;&lt;/style&gt;</span><br><span class="line">                    &lt;p&gt;Hello, World!&lt;/p&gt;</span><br><span class="line">                `;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        customElements.define(&apos;hello-world&apos;, HelloWorld);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;hello-world&gt;&lt;/hello-world&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><br></p><p>包装 <a href="https://vuejs.org/guide/extras/web-components.html" target="_blank" rel="noopener">Vue 3 组件</a>, 官方支持:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; defineCustomElement &#125; from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">const MyVueElement = defineCustomElement(&#123;</span><br><span class="line">  // normal Vue component options here</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  emits: &#123;&#125;,</span><br><span class="line">  template: `...`,</span><br><span class="line"></span><br><span class="line">  // defineCustomElement only: CSS to be injected into shadow root</span><br><span class="line">  styles: [`/* inlined css */`]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// Register the custom element.</span><br><span class="line">// After registration, all `&lt;my-vue-element&gt;` tags</span><br><span class="line">// on the page will be upgraded.</span><br><span class="line">customElements.define(&apos;my-vue-element&apos;, MyVueElement)</span><br></pre></td></tr></table></figure><p><br></p><p>包装 React 组件:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class XSearch extends HTMLElement &#123;</span><br><span class="line">  connectedCallback() &#123;</span><br><span class="line">    const mountPoint = document.createElement(&apos;span&apos;);</span><br><span class="line">    this.attachShadow(&#123; mode: &apos;open&apos; &#125;).appendChild(mountPoint);</span><br><span class="line"></span><br><span class="line">    const name = this.getAttribute(&apos;name&apos;);</span><br><span class="line">    const url = &apos;https://www.google.com/search?q=&apos; + encodeURIComponent(name);</span><br><span class="line">    const root = ReactDOM.createRoot(mountPoint);</span><br><span class="line">    root.render(&lt;a href=&#123;url&#125;&gt;&#123;name&#125;&lt;/a&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">customElements.define(&apos;x-search&apos;, XSearch);</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>将原有的组件包装成 Web Component,  我们需要做以下工作：</p><ul><li>怎么把<code>自定义元素</code>的 Attribute 或者 Property 映射到组件的 Props?</li><li>怎么将组件的事件定义映射成 <code>自定义元素</code> 的事件？</li><li>组件的插槽又怎么处理？</li><li>Shadow DOM 要不要用？</li></ul><p>下面开始详细介绍这些细节。</p><p><br><br><br></p><h1 id="映射-props"><a href="#映射-props" class="headerlink" title="映射 Props"></a>映射 Props</h1><p>HTML <code>自定义元素</code>有两种输入参数形式：<code>HTML Attribute</code> 和 <code>Property</code>。这两个的区别就无须过多介绍了。Property 就是普通的类实例属性。而 HTML Attribute 相对特殊：</p><ul><li>HTML Attribute 可以在 HTML 中携带，或者通过 <code>Element.setAttribute</code> 设置</li><li>并且它的值只能是字符串形式，因此它只适合传递一些简单的原始类型。我们可能需要进行转换</li><li>Attribute key 不区分大小写。通常习惯使用 <code>kebab-case</code> 形式。</li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>关于怎么设计 Attribute 和 Property，社区已经积累了很多经验，常见的最佳实践有：</p><ul><li>尽量同时提供 HTML Attribute 和 Property 两种形式。并在命名和行为上保持统一</li><li>不要通过 Attribute 传递复杂数据(非原始类型数据)</li><li>单数据源（Source of truth）。即不管是 Attribute 还是 Property 都是来源于单一的数据源。</li></ul><blockquote><p>💡 关于 Web Component 的更多最佳实践，可以参考下面文章：</p><ul><li><a href="https://web.dev/custom-elements-best-practices/" target="_blank" rel="noopener"> web.dev Custom Element Best Practices</a></li><li><a href="https://webcomponents.today/best-practices/" target="_blank" rel="noopener">Best Practices</a></li></ul></blockquote><p>比如简单的场景可以将 Attribute 作为单一数据源：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> observedAttributes() &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'foo'</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  attributeChangedCallback(name, oldValue, newValue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">'foo'</span>) &#123;</span><br><span class="line">      <span class="comment">// 在这里触发动作</span></span><br><span class="line">      dosomething()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> foo() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getAttribute(<span class="string">'foo'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> foo(val) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setAttribute(<span class="string">'foo'</span>, val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>或者使用一个「对象」作为单一数据源：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.props = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> observedAttributes() &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'foo'</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  attributeChangedCallback(name, oldValue, newValue) &#123;</span><br><span class="line">    <span class="keyword">this</span>.updateProps(name, newValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> foo() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.foo; <span class="comment">// 从 props 对象中获取值</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> foo(val) &#123;</span><br><span class="line">    <span class="keyword">this</span>.updateProps(<span class="string">'foo'</span>, val, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  updateProps(key, value, updateAttribute = <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props[key] = value;</span><br><span class="line">    <span class="keyword">if</span> (updateAttribute) <span class="keyword">this</span>.setAttribute(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  connectedCallback() &#123;</span><br><span class="line">    <span class="comment">// 初始化操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.customElements.define(<span class="string">'my-component'</span>, MyComponent);</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>手动维护 Attribute/Property 太麻烦了。</p><p>比如我们已经在 Vue 组件声明中定义了 props，可以直接搬过来用,  基于这些信息来批量添加 Attribute 和 Property，另外也方便我们对 Attribute 进行类型转换，以 <a href="https://github.com/vuejs/vue-web-component-wrapper/blob/master/src/index.js" target="_blank" rel="noopener">Vue 2</a> 为例：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> options = <span class="keyword">typeof</span> Component === <span class="string">'function'</span></span><br><span class="line">      ? Component.options</span><br><span class="line">      : Component</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取 Props 信息</span></span><br><span class="line">    <span class="keyword">const</span> propsList = <span class="built_in">Array</span>.isArray(options.props)</span><br><span class="line">      ? options.props</span><br><span class="line">      : <span class="built_in">Object</span>.keys(options.props || &#123;&#125;)</span><br><span class="line">    hyphenatedPropsList = propsList.map(hyphenate)</span><br><span class="line">    camelizedPropsList = propsList.map(camelize)</span><br><span class="line">    <span class="keyword">const</span> originalPropsAsObject = <span class="built_in">Array</span>.isArray(options.props) ? &#123;&#125; : options.props || &#123;&#125;</span><br><span class="line">    camelizedPropsMap = camelizedPropsList.reduce(<span class="function">(<span class="params">map, key, i</span>) =&gt;</span> &#123;</span><br><span class="line">      map[key] = originalPropsAsObject[propsList[i]]</span><br><span class="line">      <span class="keyword">return</span> map</span><br><span class="line">    &#125;, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 🔴 定义 Properties</span></span><br><span class="line">    camelizedPropsList.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(CustomElement.prototype, key, &#123;</span><br><span class="line">        <span class="keyword">get</span> () &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>._wrapper.props[key]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span> (newVal) &#123;</span><br><span class="line">          <span class="keyword">this</span>._wrapper.props[key] = newVal</span><br><span class="line">          <span class="comment">// 更新到 attribute </span></span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 🔴 Attribute 同步和转换到 props</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">syncAttribute</span> (<span class="params">el, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> camelized = camelize(key)</span><br><span class="line">    <span class="keyword">const</span> value = el.hasAttribute(key) ? el.getAttribute(key) : <span class="literal">undefined</span></span><br><span class="line">    el._wrapper.props[camelized] = convertAttributeValue(</span><br><span class="line">      value,</span><br><span class="line">      key,</span><br><span class="line">      camelizedPropsMap[camelized]</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CustomElement</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">      <span class="keyword">const</span> self = <span class="keyword">super</span>()</span><br><span class="line">      self.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">'open'</span> &#125;)</span><br><span class="line">      <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 🔴 使用 MutationObserver 监听 Attribute 变化，这是另一种监听 Attribute 变化的方式</span></span><br><span class="line">      <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">mutations</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> hasChildrenChange = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; mutations.length; i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> m = mutations[i]</span><br><span class="line">          <span class="keyword">if</span> (isInitialized &amp;&amp; m.type === <span class="string">'attributes'</span> &amp;&amp; m.target === self) &#123;</span><br><span class="line">            syncAttribute(self, m.attributeName)</span><br><span class="line">          &#125; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      observer.observe(self, &#123;</span><br><span class="line">        attributes: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><p>React 同理，我们需要按照一定的协议来声明 props，然后批量添加即可。</p><p><br><br><br></p><h2 id="框架怎么决定用-html-attribute-还是-property-的呢？"><a href="#框架怎么决定用-html-attribute-还是-property-的呢？" class="headerlink" title="框架怎么决定用 HTML Attribute 还是 Property 的呢？"></a>框架怎么决定用 HTML Attribute 还是 Property 的呢？</h2><p>那么在常见的视图框架中，在对接<code>自定义元素</code>时，<strong>是怎么决定用 HTML Attribute 还是 Property 的呢？</strong></p><ul><li>Vue 2。除了某些特殊的内置字段会使用 Property，默认都使用 Attribute，这个在模板编译阶段就确定下来了。不过开发者可以显式使用 <code>v-bind.prop</code> 强制 Property。</li><li>Vue 3 和 React 会判断元素实例中存不存在 Property（通常用 in 操作符），如果存在就使用 Property，否则使用 Attribute。</li></ul><p>因此，<strong>我们最好是遵循上述的最佳实践，可以让自定义元素更加普适， 减少使用者的心智负担</strong>。</p><p><br><br><br><br><br></p><h1 id="代理事件"><a href="#代理事件" class="headerlink" title="代理事件"></a>代理事件</h1><p>Web Component 使用 Custom Event 对外抛出事件。</p><p>在 Vue 下可以通过拦截 emit 方法来实现代理：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 🔴 intercept emit</span><br><span class="line">instance.emit = (event: string, ...args: any[]) =&gt; &#123;</span><br><span class="line">  // dispatch both the raw and hyphenated versions of an event</span><br><span class="line">  // to match Vue behavior</span><br><span class="line">  dispatch(event, args)</span><br><span class="line"></span><br><span class="line">  if (hyphenate(event) !== event) &#123;</span><br><span class="line">    dispatch(hyphenate(event), args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 则需要预先声明好需要代理哪些事件，预生成对应的 Props。</p><p><br><br><br></p><h2 id="视图框架支持自定义元素的事件订阅吗？"><a href="#视图框架支持自定义元素的事件订阅吗？" class="headerlink" title="视图框架支持自定义元素的事件订阅吗？"></a>视图框架支持自定义元素的事件订阅吗？</h2><ul><li>Vue 支持通过 <code>v-on</code> 来监听自定义元素的事件。</li><li><strong>React 不支持！</strong>因为 React 使用了自己的<code>合成事件</code>(SyntheticEvent)系统，没有提供手段来监听节点的原生事件。因此自定义元素的事件只能通过 addEventListener 来监听。 这篇<a href="https://css-tricks.com/3-approaches-to-integrate-react-with-custom-elements/" target="_blank" rel="noopener">文章</a>也介绍了 React 监听原生事件的几种方式。</li></ul><p><br><br><br></p><h1 id="不使用-shadow-dom-？"><a href="#不使用-shadow-dom-？" class="headerlink" title="不使用  Shadow DOM ？"></a>不使用  Shadow DOM ？</h1><p>Shadow DOM 就是一个超强的<code>结界</code>,  相互隔离了 DOM 和样式。 <code>宿主</code>无法访问它的内部细节，宿主的样式影响不了 Shadow DOM,  Shadow DOM 内部的样式也不会影响宿主。</p><p>Shadow DOM 基本上就是 Web Component 的代名词。但<strong>实际上 Shadow DOM 对于<code>自定义元素</code>来说是可选的，而 Shadow DOM 也可以用在<code>自定义元素</code>之外。</strong></p><p>所以用不用 Shadow DOM 也需要我们来权衡。</p><p><br></p><p>很多视图框架官方提供的 Web Component 包装方案，但都是强制使用 Shadow DOM的，比如：</p><ul><li>Vue 3.x 官方内置支持，使用 <a href="https://cn.vuejs.org/guide/extras/web-components.html" target="_blank" rel="noopener">defineCustomElement</a> 进行定义</li><li>Vue 2.x 则可以通过 Vue CLI 来构建生成，底层由  <a href="https://github.com/karol-f/vue-custom-element" target="_blank" rel="noopener">vue-custom-element</a> 支持</li><li>…</li></ul><p><br><br><br></p><h2 id="那什么时候不使用-shadow-dom-呢？"><a href="#那什么时候不使用-shadow-dom-呢？" class="headerlink" title="那什么时候不使用 Shadow DOM 呢？"></a>那什么时候不使用 Shadow DOM 呢？</h2><p>如果我不使用 Shadow DOM, 理由估计只有一个 —— <strong>样式难以管理</strong>！</p><p>如果没有任何历史包袱的、原子粒度组件库，管理起来要容易很多。我也不需要写一篇文章来讲它了，市面上有很多框架可以帮我们创建 Web Component 组件库，比如 <a href="https://stenciljs.com/docs/react" target="_blank" rel="noopener">Stencil</a>、<a href="https://lit.dev/" target="_blank" rel="noopener">Lit</a>、还有哈啰团队最近开源的 <a href="https://quarkc.hellobike.com/#/" target="_blank" rel="noopener">Quarkc</a>…</p><p>而老旧项目对外暴露的业务组件，首先粒度会比较大，还可能会依赖所在子应用的全局样式、第三方组件库样式等等。这些样式的提取、大量样式应用的性能都是比较大的问题。</p><blockquote><p>较新的浏览器支持 <a href="http://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot/adoptedStyleSheets" target="_blank" rel="noopener">adoptedStyleSheets</a> ，可以让<code>构造样式表</code>(Constructed stylesheet) 应用到多个 Shadow Root 中，实现共享。 但也需要开发者来管理样式。</p></blockquote><p><br><br><br></p><h2 id="如果不使用-shadow-dom-会有什么后果？"><a href="#如果不使用-shadow-dom-会有什么后果？" class="headerlink" title="如果不使用 Shadow DOM 会有什么后果？"></a>如果不使用 Shadow DOM 会有什么后果？</h2><ul><li>我们需要自行处理全局样式污染问题。</li><li>无法使用 Slot。</li><li>DOM 干扰</li><li>…</li></ul><p><br><br><br><br><br></p><h1 id="slot-插槽"><a href="#slot-插槽" class="headerlink" title="Slot 插槽"></a>Slot 插槽</h1><p>不使用 Shadow DOM，比较大影响就是无法使用原生 Slot。</p><p>先来简单看看它的用法，和早期的 Vue 非常相似。或者说 Vue 在竭力对齐 Web 标准</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template id=&quot;my-component&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;slot name=&quot;header&quot;&gt;Default header&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;body&quot;&gt;Default body&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  class MyComponent extends HTMLElement &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">      super();</span><br><span class="line"></span><br><span class="line">      const template = document.getElementById(&apos;my-component&apos;);</span><br><span class="line">      const node = document.importNode(template.content, true);</span><br><span class="line">      this.attachShadow(&#123; mode: &apos;open&apos; &#125;).appendChild(node);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  customElements.define(&apos;my-component&apos;, MyComponent);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line">&lt;my-component&gt;</span><br><span class="line">  &lt;span slot=&quot;header&quot;&gt;Custom Header&lt;/span&gt;</span><br><span class="line">  &lt;span slot=&quot;body&quot;&gt;Custom Body&lt;/span&gt;</span><br><span class="line">&lt;/my-component&gt;</span><br></pre></td></tr></table></figure><p><br></p><p>浏览器在 DOM 渲染时，会将自定义元素下的宿主 DOM 节点分配(Assign) 给 Shadow Root 的 Slot 元素：</p><p><img src="/images/web-component/Untitled%204.png" alt="Assignment"></p><p>不过 slot 相比 Vue 的插槽就要弱化很多了。比如不支持作用域插槽(Scoped Slot)。因此它只能简单满足一些 DOM 节点的替换。</p><p><br><br><br><br><br></p><h2 id="先来看看主流的视图框架支不支持原生-slot？"><a href="#先来看看主流的视图框架支不支持原生-slot？" class="headerlink" title="先来看看主流的视图框架支不支持原生 Slot？"></a>先来看看主流的视图框架支不支持原生 Slot？</h2><ul><li><p>Vue 2。因为 slot 和 Vue 本身的插槽机制是冲突的， 如果你通过<a href="https://github.com/vuejs/vue-web-component-wrapper" target="_blank" rel="noopener">https://github.com/vuejs/vue-web-component-wrapper</a> 来创建自定义元素，它的方案比较 Hack, 它会监听宿主 Light DOM 节点的变化，然后将这些 DOM 节点的 <code>innerHTML</code> 提取出来，再搬运到 Shadow DOM 下：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  // 监听 Light DOM</span><br><span class="line">  const observer = new MutationObserver(mutations =&gt; &#123;</span><br><span class="line">     // ... 省略</span><br><span class="line">     if (hasChildrenChange) &#123;</span><br><span class="line">       // 🔴 toVnodes 使用 转换 childNodes 为 innerHTML，再转成 VNode</span><br><span class="line">       wrapper.slotChildren = Object.freeze(toVNodes(</span><br><span class="line">         wrapper.$createElement,</span><br><span class="line">         self.childNodes</span><br><span class="line">       ))</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">    </span><br><span class="line">const wrapper = self._wrapper = new Vue(&#123;</span><br><span class="line">     name: &apos;shadow-root&apos;,</span><br><span class="line">     customElement: self,</span><br><span class="line">     shadowRoot: self.shadowRoot,</span><br><span class="line">     data () &#123;</span><br><span class="line">       return &#123;</span><br><span class="line">         props: &#123;&#125;,</span><br><span class="line">         slotChildren: []</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     render (h) &#123;</span><br><span class="line">       return h(Component, &#123;</span><br><span class="line">         ref: &apos;inner&apos;,</span><br><span class="line">         props: this.props</span><br><span class="line">       // 🔴 VNode 渲染</span><br><span class="line">       &#125;, this.slotChildren)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure></li></ul><ul><li>Vue 3。而 Vue 3 的 <code>&lt;slot&gt;</code> 在<code>自定义元素（isCE）模式</code>（defineCustomElement）下, 会渲染成真正 Slot HTML 元素</li><li>React。React 本身没有 slot 的概念，不存在冲突，所以 slot 也是渲染成 Slot HTML 元素。</li></ul><p><br><br><br><br><br></p><h2 id="如果不使用-slot-还有哪些回退方案？"><a href="#如果不使用-slot-还有哪些回退方案？" class="headerlink" title="如果不使用 slot 还有哪些回退方案？"></a>如果不使用 slot 还有哪些回退方案？</h2><p>可以理解  Web Component 的 slot 可以理解为 DOM 节点的「搬运工」。将 Light DOM 搬进 Shadow DOM,  尽管这种说法可能不严谨。</p><blockquote><p>💡从将 Light DOM 「搬进」 Shadow DOM 的过程称为“<code>分配</code>”（<code>Assignment</code>） 或者’赋值‘。这并不是简单的将 DOM 节点移动到 Shadow DOM，整个过程有点像变量’引用‘， 插槽的内容和作用域还在宿主 DOM,  而插入 Shadow DOM 内部只是一个’分身‘。</p></blockquote><p><br></p><p>如果不是用 Shadow DOM,  还有一些手段来实现类似插槽的效果：</p><p>方法一，<strong>传入 HTML 字符串。这是最简单、最普适的方案了</strong>。至于事件，可以通过冒泡委托。</p><p><br></p><hr><p><br></p><p>方法二是定义一些<code>元素锚点</code>(Anchor)，供外部来修改这个 DOM 节点。</p><p>我们可以使用  Vue 3 的 <code>Teleport</code> 或者 React <code>Portal</code> 之类的技术来挂载。下面是 Vue 示例:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Demo = defineComponent(&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 定义插槽</span></span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">"div"</span>, [h(<span class="string">"div"</span>, &#123; <span class="string">"data-slot"</span>: <span class="string">"header"</span> &#125;)]);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoElement</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  connectedCallback() &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = createApp(Demo);</span><br><span class="line">    <span class="keyword">this</span>.vm.mount(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.dispatchEvent(<span class="keyword">new</span> CustomEvent(<span class="string">"ready"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  disconnectedCallback() &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm.unmount();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!customElements.get(<span class="string">"wk-demo"</span>)) &#123;</span><br><span class="line">  customElements.define(<span class="string">"wk-demo"</span>, DemoElement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">wk-demo</span> @<span class="attr">ready</span>=<span class="string">"handleReady"</span>&gt;</span><span class="tag">&lt;/<span class="name">wk-demo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Teleport</span> <span class="attr">v-if</span>=<span class="string">"demoRef"</span> <span class="attr">:to</span>=<span class="string">"demoRef.querySelector('[data-slot=header]')"</span>&gt;</span></span><br><span class="line">    hello header</span><br><span class="line">  <span class="tag">&lt;/<span class="name">Teleport</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> handleReady = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="undefined">  demoRef.value = event.target;</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然可以工作，但是不是特别优雅。</p><p><br></p><hr><p><br></p><p><a href="https://stenciljs.com/" target="_blank" rel="noopener">Stenciljs</a> 提供另一种思路 —— <code>Slot Relocation</code> (插槽重定位)。</p><p>Stencil 是一个 Web Component 编译器，因为早期浏览器对 Shadow DOM 支持比较差，基于兼容性的考虑， Stencil 并不强制所有功能都和 Shadow DOM 绑定。slot 就是一个例子。</p><p><br></p><p>那它是怎么模拟 slot 的呢？我们通过一个示例来展开看看：</p><p>组件定义：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// my-component.tsx</span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">  return [</span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"item-start"</span>&gt;</span>fallback content<span class="tag">&lt;/<span class="name">slot</span>&gt;</span>,</span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here is my main content<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>,</span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"item-end"</span> /&gt;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件使用：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  return(</span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"item-start"</span>&gt;</span>I'll be placed before the h1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"item-end"</span>&gt;</span>I'll be placed after the h1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染结果：</p><p><img src="/images/web-component/Untitled%205.png" alt="Stencil 渲染结果"></p><p>我们来图解一下它的渲染流程：</p><p><img src="/images/web-component/Untitled%206.png" alt="Stencil 渲染流程"></p><p>Stencil 实际上也是一个基于 Virtual DOM 的框架</p><ul><li>挂载前： 插槽的 DOM 节点实际上在 <code>connectedCallback</code> （即挂载）调用之前，就已经存在。</li><li>渲染后： Stencil 在渲染时不会完全清空宿主元素(host)，渲染的内容以 append 的形式追加到宿主元素</li><li>重新定位： 渲染完成后，就会开始插槽重定位。stencil 会遍历宿主元素下的子节点，找出所有非 Virtual DOM 渲染出来的节点(举个例子，Virtual DOM 渲染出来的节点会有特殊的标记， 可以排除掉)。接着对这些节点, 根据 <code>slot=*</code> 声明进行重定位，插入到对应的 <code>&lt;slot-fb&gt;</code> 之后</li><li>隐藏插槽 Fallback:  接着将已经被占用的 <code>&lt;slot-fb&gt;</code>  设置为  hidden，隐藏掉</li></ul><p><br><br><br></p><p>这种思路有一些借鉴意义。不过它目前也有很多缺陷：Stencil 只是在首次挂载时才会进行‘重定位’， 不会动态监听元素新增和移除。比如：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.querySelector(<span class="string">'my-component'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态操作不会被重新定位</span></span><br><span class="line">el.appendChild(...)</span><br><span class="line">el.innerHTML = ...</span><br></pre></td></tr></table></figure><p><br></p><p>这也导致了，它和其他视图框架配合使用时，未必能正常工作。</p><p><br></p><p>比如下面使用 JSX 条件渲染 <code>footer</code>，底层的操作就是在 <code>app-foo</code> 节点上执行 <code>remove</code> 和 <code>insert</code> 操作，这将导致 Stencil 的插槽重定位失效：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;app-foo&gt;</span><br><span class="line">        &lt;div onClick=&#123;() =&gt; &#123; this.count++; &#125;&#125;&gt;world&lt;/div&gt;</span><br><span class="line">        &#123;this.count % 2 === 0 &amp;&amp; &lt;footer slot=&quot;footer&quot;&gt;footer: &#123;this.count&#125;&lt;/footer&gt;&#125;</span><br><span class="line">      &lt;/app-foo&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><p>毕竟本质上<code>插槽重定位</code>和 Shadow DOM slot 还是不一样。Shadow DOM 方案会隔离出 Light DOM 和 Shadow DOM 两个不同的空间，DOM 的操作互不干扰。</p><p><strong>如果没有使用 Shadow DOM , 这些操作都是不安全的，会破坏 Stencil 渲染的结果。</strong></p><p>综上，目前最为普适和灵活的方案还是字符串 HTML。</p><p><br><br><br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文将 Web Component 定义为跨框架的<code>微应用</code>之间的通用协议。介绍了将已有组件以 Web Component 形式对外暴露的各种技术细节， 以及主流视图框架对 Web Component 的支持程度。</p><p>当我们需要封装一个 Web Component 时需要处理以下事情：</p><ul><li>如何将自定义元素的 Attribute 和 Property 映射到组件 Props。本文列举了一些最佳实践</li><li>如何将组件的事件代理出去。</li><li>权衡要不要使用 Shadow DOM。</li><li>插槽的使用等等。</li></ul><p>总得来说，Web Component 作为一个标准的、底层的技术，在目前看来是不能覆盖现在主流视图框架的所有能力的，哪些能力需要进行取舍，需要开发者自行权衡。</p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_components" target="_blank" rel="noopener">MDN 的相关教程</a></li><li>Web Component 最佳实践<ul><li><a href="https://web.dev/custom-elements-best-practices/" target="_blank" rel="noopener">web.dev Custom Element Best Practices</a></li><li><a href="https://webcomponents.today/best-practices/" target="_blank" rel="noopener">Best Practices</a></li></ul></li><li>图书推荐<ul><li>Developing Web Components with TypeScript Native Web Development Using Thin Libraries</li><li>Web Components in Action</li></ul></li><li>组件包装<ul><li><a href="https://github.com/vuejs/vue-web-component-wrapper" target="_blank" rel="noopener">vue-web-component-wrapper</a></li><li><a href="https://github.com/bitovi/react-to-web-component/tree/main/packages/react-to-web-component" target="_blank" rel="noopener">react-to-web-component</a></li></ul></li><li>Web Component 框架<ul><li><strong>StencilJS</strong></li><li><strong>LitElement</strong></li><li>Quarkc</li></ul></li><li><a href="https://www.notion.so/Vue-2-3-ca2b6bf71c564dfa90fb09ae92fff599?pvs=21" target="_blank" rel="noopener">Vue 2/3 的互操作性</a></li><li><strong><a href="https://dev.to/steveblue/the-state-of-web-components-in-2022-1ip3" target="_blank" rel="noopener">The State Of Web Components in 2022</a></strong></li><li><strong><strong><a href="https://cn.vuejs.org/guide/extras/web-components.html" target="_blank" rel="noopener">Vue 与 Web Components</a></strong></strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Web Component 已经被浏览器广泛支持，不再是新鲜玩意了，它有很多使用场景，比如编写跨框架的组件库、微前端，完全用它开发复杂的应用也没问题。&lt;/p&gt;
&lt;p&gt;而今天我要介绍的是 Web component 如何扮演框架/微应用之间的胶水层这个角色。&lt;/p&gt;
&lt;h1 
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>2023年了，我还是选择 MobX</title>
    <link href="https://bobi.ink/2023/07/28/mobx/"/>
    <id>https://bobi.ink/2023/07/28/mobx/</id>
    <published>2023-07-27T16:00:00.000Z</published>
    <updated>2023-07-28T01:18:47.138Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/mobx/Untitled.jpeg" alt="Untitled"></p><p>时至今日，前端的各种状态管理方案仍层出不穷，花式百样，争议不断，尤其是 React 社区。那我为什么要“背道而驰”，选择基本没什么声音的 MobX 呢？</p><p>这篇文章会深入探讨 MobX 背后的面向对象范式之争，以及可变数据与不可变数据之争。篇幅有点长，读者耐心读读会有收获。在阅读时，建议多留意一下目录，把握整篇文章叙述结构。</p><p><br><br><br></p><h2 id="面向对象与函数式之争"><a href="#面向对象与函数式之争" class="headerlink" title="面向对象与函数式之争"></a>面向对象与函数式之争</h2><p>首当其冲的是面向对象和函数式编程之争。MobX 背后代表的是面向对象思想 。</p><p><br></p><p>我问 <code>ChatGPT</code>, <strong>面向对象的优势是什么</strong>：</p><blockquote><p>**🤖 ChatGPT 曰:</p></blockquote><p>面向对象编程可以将复杂的现实世界中的问题抽象成易于理解和管理的对象，通过对象之间的交互来解决问题。这种对象抽象的方法可以使得程序设计更加直观、简单，可以更好地描述复杂系统中的各个组成部分和它们之间的关系。**</p><blockquote><p>面向对象编程（Object-oriented programming）具有以下优势：</p><ol><li>抽象化：<strong>通过面向对象编程，可以将复杂的现实世界中的问题抽象成易于理解和管理的对象，并通过对象之间的交互来解决问题。这种抽象化的方法使得程序设计更加直观、简单，使得开发人员更容易理解和维护代码</strong>。</li><li>封装性：面向对象编程提供了封装的机制，将对象的属性和方法封装在一起，只暴露必要的接口给外部使用，避免了对内部实现细节的直接暴露，从而提高了代码的安全性和可维护性。</li><li>继承性：面向对象编程提供了继承的机制，通过继承，子类可以继承父类的属性和方法，并在此基础上进行扩展和修改。这种继承的机制可以避免代码重复，提高代码的可重用性和可维护性。</li><li>多态性：面向对象编程提供了多态的机制，通过多态，同一种方法可以在不同的对象上产生不同的行为。多态性可以提高程序的灵活性和可扩展性，使得程序更加适应复杂多变的需求。</li><li>代码复用：面向对象编程提供了模块化的机制，可以将代码分解成多个模块，实现代码的复用和重构。这种模块化的机制可以使得代码更加易于管理和维护，提高了代码的可重用性和可维护性</li></ol></blockquote><p><br></p><p>这是一个教科书式的回答。</p><p><br><br><br></p><h3 id="抽象能力"><a href="#抽象能力" class="headerlink" title="抽象能力"></a>抽象能力</h3><p>我又问 ChatGPT, 在抽象能力上面向对象相比函数式有什么优势?</p><blockquote><p>🤖 ChatGPT 曰:</p><p>在抽象能力上，面向对象和函数式编程都有其独特的优势。</p><p>面向对象编程的优势在于其能够将复杂的问题抽象成对象，并通过对象之间的交互来解决问题。面向对象编程提供了封装、继承、多态等机制，可以将代码分解成多个独立的模块，使得代码更加易于维护和修改，减少了代码的耦合，提高了代码的灵活性和可维护性。<strong>在面向对象编程中，对象是程序的基本组成单元，对象之间通过消息传递来实现交互，从而实现了高度的抽象能力</strong>。面向对象编程还提供了丰富的设计模式，可以帮助开发人员更好地组织和管理代码，提高代码的可读性、可维护性和可扩展性。</p><p>函数式编程的优势在于其强调函数的纯度和不可变性，可以将函数看作是数学中的函数，而不是过程式编程中的函数。函数式编程提供了高阶函数、闭包、柯里化等机制，可以将函数看作是一等公民，可以进行组合、抽象和重用，从而实现了高度的抽象能力。在函数式编程中，函数是程序的基本组成单元，函数之间通过函数调用来实现交互，从而实现了高度的模块化和组合能力。函数式编程还提供了丰富的函数组合和递归等技术，可以帮助开发人员更好地组织和管理代码，提高代码的可读性、可维护性和可扩展性。</p><p>总的来说，在抽象能力上，面向对象和函数式编程都具有其独特的优势，可以根据具体的应用场景选择适合的编程范式。</p></blockquote><p><br></p><p>又一个教科书式的回答，谁都不得罪，请收下我的膝盖！</p><p><br></p><p>ChatGPT 回答总是那么八面玲珑，它也知道应该规避二元论，世界上并没有绝对的非黑即白。因此，我们脱离场景去讨论孰好孰坏，都是在耍流氓。</p><p><br></p><p>我们将上面 ChatGPT 的回答再归纳一下：</p><table><thead><tr><th></th><th>面向对象</th><th>函数式</th></tr></thead><tbody><tr><td>抽象单位</td><td>对象</td><td>函数</td></tr><tr><td>行为和数据的关系</td><td>数据和行为合并。强调现实世界问题的抽象还原。</td><td>数据和行为分离。强调数据不可变性、行为无副作用</td></tr><tr><td>机制</td><td>封装、继承、多态等</td><td>高阶函数、闭包、柯里化、递归等</td></tr><tr><td>抽象能力实现</td><td>对象之间的交互、引用</td><td>函数组合</td></tr></tbody></table><p><br></p><p>OK，我觉得文章都让 ChatGPT 来写好了，继续问：<strong>分别举一些面向对象和函数式擅长的场景</strong></p><p><br><br><br></p><blockquote><p>🤖 ChatGPT 曰:</p><p>面向对象编程和函数式编程各有擅长的场景，具体如下：</p><p>面向对象编程：</p><ol><li>GUI 编程：面向对象编程可以很好地用于 GUI 编程，因为 GUI 程序通常涉及到许多对象之间的交互，面向对象编程可以将这些对象和它们之间的关系进行抽象和封装，从而使得程序更加易于理解和管理。</li><li>游戏开发：面向对象编程可以很好地用于游戏开发，因为游戏通常涉及到许多对象之间的交互，面向对象编程可以将这些对象和它们之间的关系进行抽象和封装，从而使得游戏逻辑更加易于理解和管理。</li><li>企业级应用：面向对象编程可以很好地用于开发大型的企业级应用，因为企业级应用通常需要涉及到多个模块之间的交互，面向对象编程可以将这些模块和它们之间的关系进行抽象和封装，从而使得程序更加易于理解和管理。</li></ol><p>函数式编程：</p><ol><li>并发编程：函数式编程可以很好地用于并发编程，因为函数式编程强调不可变性和无副作用，可以避免并发问题，使得并发编程更加安全和可靠。</li><li>数据分析：函数式编程可以很好地用于数据分析，因为函数式编程提供了丰富的高阶函数和数据处理函数，可以方便地处理和分析大量的数据。</li><li>数学计算：函数式编程可以很好地用于数学计算，因为函数式编程强调函数抽象和高阶函数，可以方便地实现数学函数和算法，使得数学计算更加简单和高效。</li></ol><p>总之，面向对象编程和函数式编程各有擅长的场景，需要根据具体的应用需求来选择合适的编程范式</p></blockquote><p><br><br><br></p><p>有人说：面向对象就是计算机软件对现实世界的阐述，当我们能直观的描述业务场景，就能很好的编写代码。</p><p><br></p><p><strong>面向对象的优势在于可以将复杂的现实世界中的问题抽象成易于理解和管理的对象。换句话说它可以比较直接/自然地表达业务对象和业务关系。这个比较契合人类对这个世界的朴素理解。</strong></p><p><br></p><p>比如 DDD（一个用来应对复杂业务的研发方法论） 方法论中，基本都以面向对象作为它的建模范式，因为面向对象编程能够直观地表达 DDD 中的模型概念。</p><blockquote><p>💡 也有使用函数式来实现 DDD 的，非常少见</p></blockquote><blockquote><p>💡 即使是面向对象编程中，通常也会面临“贫血模型” 和 “充血模型” 之争。采用充血模式大概率是某些技术上的妥协。<br>按照「正统」的面向对象思想，对象是充血的，有血(数据)有肉(行为)的对象。DDD 中也是鼓励使用充血模型。</p></blockquote><p><br></p><p>在前端领域, 面向对象范式在很多场景也有很大的优势：</p><ul><li>游戏开发。这是面向对象的传统强项，游戏通常包含许多不同类型的对象，如角色、道具、地图等等。利用面向对象编程的优势，可以更加方便地对这些对象进行管理和操作，从而实现更加复杂和精细的游戏系统</li><li>复杂的交互客户端。比如图像处理软件、低代码编辑器，这类「重」前端软件。</li><li>复杂的业务系统。比如 ERP、电子商务。比较少见，因为前端业务通常比较薄。</li></ul><p>这些场景共有的特征是：<strong>它们有复杂的数据结构和对象关系，这些对象之间需要紧密合作才能完成业务。</strong></p><p><br></p><p>比如面向对象可以直观地表示树、图这种复杂的关系：</p><p><img src="/images/mobx/Untitled.png" alt="Untitled"></p><p><br></p><p>面向对象语言提供了成熟的抽象机制(类、接口、继承、属性、方法、访问控制、多态)、社区上也沉淀了丰富的设计方法论(设计模式、UML、DDD)。</p><p>更神奇的是，面向对象曾经被认为是 <code>GUI</code> 开发的不二法门，当然这个已经被 React 等框架打破了，在前端领域，类函数式/数据驱动引领的 UI 开发已经是主流，甚至影响了平台(比如 Flutter, SwiftUI)。</p><p><br></p><p>再来看看，目前比较主流的状态管理方案, 比如 <a href="https://redux.js.org/" target="_blank" rel="noopener">Redux</a>/Redux Toolkit、<a href="https://docs.pmnd.rs/zustand/getting-started/comparison#state-model" target="_blank" rel="noopener">Zustand</a>、Recoil、<a href="https://pinia.vuejs.org/zh/introduction.html" target="_blank" rel="noopener">Pinia</a>等等。</p><p><img src="/images/mobx/Untitled%201.png" alt="Untitled"></p><p><br></p><p>这类以状态（State）为中心的状态管理器中，任何对象都只是一个序列化<code>文档</code>的一个<code>片段</code>(slice)。</p><blockquote><p>💡 就是一个对象文档，从后端的角度看来，这些就是 <code>DTO</code> 这类的结构化对象，没有业务含义，只是数据。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 伪代码</span><br><span class="line"></span><br><span class="line">// 状态</span><br><span class="line">const state = &#123;</span><br><span class="line">  tree: &#123;</span><br><span class="line">    root: &#123;</span><br><span class="line">      id: ID,</span><br><span class="line">      name: NAME,</span><br><span class="line">      active: true,</span><br><span class="line">      hidden: false,</span><br><span class="line">      properties: &#123;&#125;,</span><br><span class="line">      parent: undefined,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: ID,</span><br><span class="line">          name: NAME,</span><br><span class="line">          active: true,</span><br><span class="line">          hidden: false,</span><br><span class="line">          properties: &#123;&#125;,</span><br><span class="line">          parent: undefined,</span><br><span class="line">          children: [],</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 方法</span><br><span class="line">const methods = &#123;</span><br><span class="line">  walk(fn: (node: Node) =&gt; void) &#123;&#125;,</span><br><span class="line">  // ...</span><br><span class="line">  addChild(parentId: string, node: Node): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 衍生数据</span><br><span class="line">const selectors = &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这类状态管理方案，在面临复杂的对象关系时，有以下缺陷：</p><ol><li><p><strong>没有更细的粒度(模块)。</strong></p><p>这类方案通常只支持 <a href="https://docs.pmnd.rs/zustand/guides/slices-pattern" target="_blank" rel="noopener">Store 水平分割</a>(slice，本质上最终都会合入一个全局的树，对象之间没有清晰的边界)。<br>面向对象方案则以对象为抽象粒度，可以随意组合，来表示复杂的事物关系。</p><p>而函数式编程语言的一等公民——函数，尽管它有灵活的复合能力，它非常擅长处理数据，但无法在对象关系上发挥太多作用。</p></li><li><p>无法表达引用关系。</p><p>这些状态都是 <code>Plain Data</code>，通常还是不可变数据，无法维持稳定的内存引用 , 难以传递引用。</p></li><li><p>行为和数据结构不是亲密绑定。</p><p>这也是面向对象和函数式的主要区别，函数式主导数据和行为分离。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// zustand</span><br><span class="line">export const createBearSlice = (set) =&gt; (&#123;</span><br><span class="line">  bears: 0,</span><br><span class="line">  addBear: () =&gt; set((state) =&gt; (&#123; bears: state.bears + 1 &#125;)),</span><br><span class="line">  eatFish: () =&gt; set((state) =&gt; (&#123; fishes: state.fishes - 1 &#125;)),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>尽管这类<code>状态管理库</code>看上去将数据和行为组织在一起，但是和类还是有本质的区别：</p><ul><li><strong>体现在了调用方式上</strong>。类体系下，我们可以用 object.method() 形式，而 store 体系下，我们通常需要自行传递上下文: store.method(object)。</li><li><strong>在传递上</strong>。比如将数据传递给视图或者某个组件：面向对象通常直接传递对象或者模型，我们可以在这个对象上直接访问相关的数据和行为，对象本身是<strong><code>自包含</code></strong>的；而函数式，传递的是数据，就只有数据。</li></ul></li><li><p>裸露的数据。数据结构通常应该作为一种内部的实现细节封装起来，目前大部分 类 Redux 库都无法实施访问控制，更别说是抽象了(比如接口)。</p><p>毕竟现在是数据驱动视图的时代，我们通常不认为「数据」就是内部实现。</p></li><li><p>不支持复杂的数据结构</p></li></ol><p><br><br><br></p><p>不过面向对象也可能走向另外一种极端，就是过度设计、过度抽象，导致抽象的层级过深，最终也丧失的透明性。典型的症状是：什么都要套用一下设计模式、大量的类、类层级深、过渡的分层。</p><p><br></p><p><strong>笔者看来，应该将面向对象当做一个朴素的业务对象/关系映射器</strong>，所谓的过度设计/抽象，不过是提前设想了多余的场景，杀鸡用了牛刀。这其实是每个技术人都会犯的毛病。</p><p><br><br><br><br><br></p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p><img src="/images/mobx/Untitled%202.png" alt="Untitled"></p><p>这些类 Redux 状态管理库，通常都有类似的规约，如上图。单向数据流、数据和行为分离、数据只能通过 actions/dispatch 修改、使用 selector 计算状态等等。</p><p>为了履行这些规约，这些库通常会创造一套自己的 DSL 。</p><p>在这些规约下，一方面，代码可以保持一致性。另一方面，可以最大程度，确保用户按照库的理念执行，并保证用户可以安全地享受库提供的便利(比如调试、时间旅行、镜像)，实现双赢：</p><p>Pinia 示例</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// pinia 示例</span><br><span class="line">import &#123; defineStore &#125; from &apos;pinia&apos;</span><br><span class="line"></span><br><span class="line">export const useTodos = defineStore(&apos;todos&apos;, &#123;</span><br><span class="line">  state: () =&gt; (&#123;</span><br><span class="line">    /** @type &#123;&#123; text: string, id: number, isFinished: boolean &#125;[]&#125; */</span><br><span class="line">    todos: [],</span><br><span class="line">    /** @type &#123;&apos;all&apos; | &apos;finished&apos; | &apos;unfinished&apos;&#125; */</span><br><span class="line">    filter: &apos;all&apos;,</span><br><span class="line">    // 类型将自动推断为 number</span><br><span class="line">    nextId: 0,</span><br><span class="line">  &#125;),</span><br><span class="line">  getters: &#123;</span><br><span class="line">    finishedTodos(state) &#123;</span><br><span class="line">      // 自动补全！ ✨</span><br><span class="line">      return state.todos.filter((todo) =&gt; todo.isFinished)</span><br><span class="line">    &#125;,</span><br><span class="line">    unfinishedTodos(state) &#123;</span><br><span class="line">      return state.todos.filter((todo) =&gt; !todo.isFinished)</span><br><span class="line">    &#125;,</span><br><span class="line">    /**</span><br><span class="line">     * @returns &#123;&#123; text: string, id: number, isFinished: boolean &#125;[]&#125;</span><br><span class="line">     */</span><br><span class="line">    filteredTodos(state) &#123;</span><br><span class="line">      if (this.filter === &apos;finished&apos;) &#123;</span><br><span class="line">        // 调用其他带有自动补全的 getters ✨</span><br><span class="line">        return this.finishedTodos</span><br><span class="line">      &#125; else if (this.filter === &apos;unfinished&apos;) &#123;</span><br><span class="line">        return this.unfinishedTodos</span><br><span class="line">      &#125;</span><br><span class="line">      return this.todos</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    // 接受任何数量的参数，返回一个 Promise 或不返回</span><br><span class="line">    addTodo(text) &#123;</span><br><span class="line">      // 你可以直接变更该状态</span><br><span class="line">      this.todos.push(&#123; text, id: this.nextId++, isFinished: false &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>在 MobX 这类面向对象的方案上， 并没有统一约束和指导。 MobX 文档上唯一相关的指导就是 <a href="https://www.mobxjs.com/defining-data-stores" target="_blank" rel="noopener"><strong>定义数据存储</strong></a>。</p><p><img src="/images/mobx/Untitled%203.png" alt="Untitled"></p><p><br></p><p>好事！我们站起来了，没有镣铐，我们自由了。我们可以随意组织自己的代码，应用各种牛逼的设计模式。</p><p><br></p><p>但是怎么把钱了挣？我们只知道面向「对象」，我们有太多选择。没有任何约束，组织松散，每个人的代码可能都不一样，可能项目就会很快失控，越来越糟糕…</p><blockquote><p>💡 其实 MobX 社区也有其他选项，那就是 <a href="https://github.com/mobxjs/mobx-state-tree" target="_blank" rel="noopener">https://github.com/mobxjs/mobx-state-tree</a> 和 <a href="https://mobx-keystone.js.org/" target="_blank" rel="noopener">mobx-keystone</a>，只不过还是得跪着。</p></blockquote><p>所以站着挣钱很难。文章的进度条还很长，后面我还会继续讲这些约束。</p><p><br></p><p>说一句宽慰自己的话：关键还看人，设计完全看开发者经验和组织，Redux 有严格的数据变更和订阅约束，照样可以写出面条、巨石代码。</p><p><br><br><br><br><br></p><h3 id="返璞归真"><a href="#返璞归真" class="headerlink" title="返璞归真"></a>返璞归真</h3><p>时尚的潮流总是那么飘忽不定：</p><ul><li>有人叫嚣着<a href="https://www.notion.so/2023-MobX-67374c0c4ded4f409770b93b3717bf64?pvs=21" target="_blank" rel="noopener">去 Typescript</a></li><li>Alpine.js 说它能免构建运行，就跟“以前”一样</li><li>别用 tailwindcss，用 unocss</li><li>React 换名字叫 PHP</li><li>…</li></ul><p><br></p><p>2023 要返璞归真，放弃追求时尚，Less is more，回归朴素编程。</p><p>第一个示范就是用好编程语言提供的原生能力。</p><p>在 JavaScript/Typescript 或者其他主流编程语言，面向对象都是原生公民，功能成熟而强大，我们可能真的不需要其他的轮子。</p><p><br></p><p>我们可以举一些返璞归真例子：</p><ul><li>RESTful。这是一个大家都知道，也是最容易被误用规范。可以 RESTful 实际上并没有发明新的技术，它就是 HTTP 原本样子，比如 URL 表示服务器的资源，HTTP METHOD 表示对资源的操作方式，用 HTTP STATUS 表示操作的状态… 目前多少声称自己是 REST API, 然后自己重新发明了野生协议？</li><li>React vs Vue。另一个例子是 React 和 Vue，在 React 中组件就是一个纯粹的函数，所有输入都在一个 props 中，不需要区分属性，事件还是插槽，组件树就是函数的“复合”，不需要学习 JavaScript 语言之外的概念。这也使得他的 API 非常的简洁和稳定，Typescript 支持也是基本开箱即用。<br>Vue 引入了较多概念，当然在 Vue 3 下有所改善，如果读者站着库作者的角度上看，Vue 真是复杂不是一丁半点。<br>Vue，Angular，小程序，越来越多的框架引入了自己的 DSL。好处就是给开发者提供一个受控的开发体验和使用范围，稳定的接口也给了框架实现者也有了更多的优化空间和实现的替换能力。<br>坏处也比较明显，开发者要学习新的概念和语法；框架实现也会变得复杂，实现者需要保证 DX，需要给 DSL 配套类型检查，编译和测试套件，开发者工具… 这是一个很大的工程</li></ul><blockquote><p>💡 以上说法可能存在争议，两者理念存在差异，Vue 的设计更多是 Port from HTML，而 React 是 Keep in JavaScript</p></blockquote><p>讲这么多，无非那个道理，<strong>时尚一直在变，我们除了向外求，也可以向里求</strong>。</p><p>面向对象就是摆在眼前的，现成的「状态管理」方案。而且复杂的应用不仅仅是状态管理问题，面向对象方案有广泛的适应性。</p><p><br><br><br><br><br></p><h2 id="可变数据与不可变数据之争"><a href="#可变数据与不可变数据之争" class="headerlink" title="可变数据与不可变数据之争"></a>可变数据与不可变数据之争</h2><h3 id="两大门派"><a href="#两大门派" class="headerlink" title="两大门派"></a>两大门派</h3><p>不可变数据和可变数据是另一处两极分化。</p><p>Vue 和 MobX 为代表的可变响应式数据结构，还有 Redux 为代表的不可变数据。</p><p>可变数据的好处对是数据的操作符合习惯，毕竟 JavaScript 并不是一门函数式编程语言。这也使得它在变更不可变数据的时候会比较繁琐，且效率也不高的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; create &#125; from &apos;zustand&apos;</span><br><span class="line"></span><br><span class="line">const useCountStore = create((set) =&gt; (&#123;</span><br><span class="line">  nested: &#123; count: 0 &#125;,</span><br><span class="line">  inc: () =&gt;</span><br><span class="line">    set((state) =&gt; (&#123;</span><br><span class="line">      nested: &#123; ...state.nested, count: state.nested.count + 1 &#125;,</span><br><span class="line">    &#125;)),</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p><br></p><p>有趣的是，为了像操作可变数据一样“自然”，也有 <a href="https://immerjs.github.io/immer/" target="_blank" rel="noopener">immer</a> 这些库:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; produce &#125; from &apos;immer&apos;</span><br><span class="line"></span><br><span class="line">const nextState = produce(baseState, (draft) =&gt; &#123;</span><br><span class="line">  draft[1].done = true</span><br><span class="line">  draft.push(&#123; title: &apos;Tweet about it&apos; &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>那何不直接使用可变数据呢？</p><p>你问 ChatGPT，它会告诉你不可变数据有很多好处，比如：</p><ul><li><strong><code>安全性</code></strong>：不可变数据类型的值不能被修改，因此在多线程或并发编程中更加安全。避免了数据竞争和数据不一致的问题。<br>—— JavaScript 是单线程的，基本上不需要考虑这个问题。</li><li><strong><code>可预测性</code></strong>：不可变数据类型的值不会被修改，因此程序的行为更加可预测。在调试和测试时更加方便。<br>—— 数据如果可以被随意修改，导致的 Bug 通常很隐晦，而且很难排查。</li><li><strong><code>可缓存性</code></strong>：不可变数据类型的值不会被修改，因此可以进行缓存优化，提高程序的效率。<br>—— 不可变数据可以被安全地缓存，相对应的基于它的计算结果也可以被缓存。React memo 函数就是基于这种假设。<br>—— 可以提高比对的效率。可不变数据通常只需要全等比较(===) 就可以判断是否变更。而可变数据引用可能是固定的。<br>—— 可镜像。比如实现「时间旅行」，可以高效地序列化</li></ul><p><br><br><br><br><br></p><h3 id="可预测性"><a href="#可预测性" class="headerlink" title="可预测性"></a>可预测性</h3><p>类 Redux 的状态管理器实际上就是 <code>CQRS</code>(Command and Query Responsibility Segregation) 架构，就是把将应用程序中的读和写操作分离。这种架构在后端 DDD 实现中，也被广泛推荐。</p><p><img src="/images/mobx/Untitled%204.png" alt="服务端 CQRS 架构"></p><p>服务端 CQRS 架构</p><p><br><br><br></p><p>在本文的场景中，CQRS 的主要好处还是实现数据变更的「可预测性」。</p><p>我们大可不必像后端程序那样，定义一堆 Query 类、Command 类、QueryHandler 类、CommandHandler 类。</p><p><br></p><p>MobX 也提供了 Action 的概念，对于大型项目，我们都推荐只在 action 方法下去变更状态：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; configure &#125; from &apos;mobx&apos;</span><br><span class="line"></span><br><span class="line">configure(&#123;</span><br><span class="line">  // 强制开启 action</span><br><span class="line">  enforceActions: &apos;always&apos;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>只允许在 action 中变更状态：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Todo &#123;</span><br><span class="line">  id = Math.random()</span><br><span class="line">  @observable title = &apos;&apos;</span><br><span class="line">  @observable finished = false</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    makeObservable(this)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @action</span><br><span class="line">  toggle() &#123;</span><br><span class="line">    this.finished = !this.finished</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当状态在 action 之外被修改时，控制台会输出警告。另外配合 MobX 开发工具，我们也可以对这些 Action 和状态进行跟踪。</p><p><br><br><br><br><br></p><h3 id="时间旅行"><a href="#时间旅行" class="headerlink" title="时间旅行"></a>时间旅行</h3><p>「时间旅行」是类 Redux 的状态管理器的另一个杀手器。时间旅行可以有两种理解：一个是开发调试上，另一个是应用本身需要具备历史回溯能力(即撤销/重做, 甚至多人协作)。</p><p><br></p><blockquote><p>💡 换句话说，一种是满足开发需求，一种是满足业务需求。</p></blockquote><p><br></p><p>先来看开发调试。时间旅行并不是不可变数据的专属，比如 Vuex、Pinia、MobX-state-tree 这些状态管理库都能做到。它们的实现的条件和过程如下：</p><ul><li>Single Store。Store 是全局的，方便被跟踪</li><li>配套开发者工具(比如 Redux DevTool, Vue DevTool)。举例 Pinia ，它会在 Action 执行前后触发订阅事件，开发者工具可以在这些事件触发时，对 Store 进行一次镜像拷贝。有了这些镜像历史之后，就可以实现回滚操作啦。</li><li>另外状态管理库还需要在 HMR、Store Patch 上提供支持。</li></ul><p>这种「时间旅行」可以给我们的开发和调试带来极致的体验，很甜。</p><p>我们使用野生的面向对象方案，比较难实现这种效果，而且需要开发者工具的支持。 实际上，「时间旅行」的开发体验通常也不是我们选择这类方案的主要原因。</p><blockquote><p>如果想要在 MobX 上实现时间旅行，建议使用 MobX-state-tree</p></blockquote><p><br><br><br></p><hr><p><br><br><br></p><p>另一种时间旅行是满足业务上的需求，比如实现撤销/重做，甚至多人协作。</p><p>针对这种需求，笔者有以下建议：</p><ol><li>Single Store。建议将需要进行’时间旅行‘核心数据聚合到一个类中，而不是分散在不同的 Store，方便对状态进行统一管理(镜像和 patch)，实现起来也会简单很多。</li><li>单向数据流/CQRS 分离。即我们上一节介绍的内容，限制读写分离，避免意外的修改，另外可以将 action 作为一个进行镜像化的时机。</li><li>如果想要实现多人协作的需求，建议配合更专业 <code>yjs</code> 等 CDRT 方案去实现。</li></ol><p><br></p><p>对于树状结构的 Store，我们这里就简单介绍一个「镜像化」的思路。假设我们的 Store 是一颗树状结构：</p><p><img src="/images/mobx/Untitled%205.png" alt="Untitled"></p><p><br></p><p>我们可以设计一个 Serializable 接口：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实现序列化，时间旅行功能。</span><br><span class="line"> */</span><br><span class="line">export interface Serializable&lt;T = any&gt; &#123;</span><br><span class="line">  applySnapshot(snapshot: T): void</span><br><span class="line">  toSnapshot(): T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>让需要实现镜像化的 Model 和 Store 都实现这个接口, 我们只需自顶向下调用 toSnapshot 就可以构造一个镜像:</p><p><img src="/images/mobx/Untitled%206.png" alt="Untitled"></p><p><br></p><p>但这种效率并不高，一个小的变动就需要序列化一棵树。我们可以在这个基础上再加上一些脏标记或者版本号之类的，来避免不必要的序列化：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface Serializable&lt;T = any&gt; &#123;</span><br><span class="line">  applySnapshot(snapshot: T): void</span><br><span class="line">  toSnapshot(): T</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 脏标记, 返回一个 boolean 表示是否成功标记</span><br><span class="line">   * reason 表示变更的原因</span><br><span class="line">   * source 表示变更触发的源头, 默认是 this</span><br><span class="line">   */</span><br><span class="line">  markDirty(reason: string, source?: any): boolean</span><br><span class="line"></span><br><span class="line">  isDirty(): boolean</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 父级</span><br><span class="line">   */</span><br><span class="line">  administrator: Serializable&lt;any&gt; | null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>镜像化的过程，类似于 DOM 的事件冒泡机制的形式:</p><p><img src="/images/mobx/Untitled%207.png" alt="Untitled"></p><p>假设我们在 Model Foo 中执行了 Action，我们就将 Model Foo 标记为 dirty，接着<code>冒泡调用</code>父级的 markDirty， 直到根节点终止。接下来，从根节点开始向下递归调用 <code>toSnapshot</code>, 如果节点没有被标记为 Dirty ，那么返回之前缓存的结果就行了。</p><p>对于复杂的场景，笔者还是建议配合 yjs 这类库区实现。后续会有专门的文章来介绍这块，敬请期待。</p><p><br><br><br><br><br><br><br></p><h3 id="精细渲染"><a href="#精细渲染" class="headerlink" title="精细渲染"></a>精细渲染</h3><p>精细渲染是视图框架实现高性能渲染的一<a href="https://juejin.cn/post/7251763342954512440" target="_blank" rel="noopener">个重要方向之一</a>。可变数据和不可变数据的两者各有千秋.</p><p><br></p><p>可变数据，我们通常使用响应式数据(事件/订阅模式)的方案，在渲染过程中收集数据订阅，当这些数据变更时，触发对应组件的渲染。</p><p><img src="/images/mobx/Untitled%208.png" alt="Untitled"></p><p>举个例子，View 2.1 订阅了 bar，那么 bar 变更时，仅需重新渲染 View 2.1。</p><p><br></p><hr><p><br></p><p>而不可变数据的精细化渲染则是基于<code>不可变数据</code>的<code>可缓存性</code>，那对应的组件就是<code>缓存函数</code>（记忆函数，memoize）。也就是说，如果视图依赖的数据没有变更，那么可以假设不需要重新渲染视图：</p><p><img src="/images/mobx/Untitled%209.png" alt="Untitled"></p><p>假设 bazz 修改了:</p><p><img src="/images/mobx/Untitled%2010.png" alt="Untitled"></p><p>视图层自上而下比对，如果输入(props or state) 不变，就可以跳过渲染。</p><p><br></p><p>实际应用中，<strong>不可变数据的精细化的实施成本相对较高</strong>。如果严格按照这套逻辑，我们通常需要分离状态，将衍生数据、 组件都标记为 <code>memoize</code> (组件使用 React.memo 或 PureComponent，衍生数据使用 useMemo)。</p><blockquote><p>💡  为了解决繁琐的 memo 逻辑，React 在 React Conf 2021 上曾提出过 <a href="https://www.youtube.com/watch?v=lGEMwh32soc" target="_blank" rel="noopener">React Forget</a> 的计划。</p></blockquote><blockquote><p>Svelte 则是另外一种思路，通过静态编译阶段分析数据变更的影响范围，并生成变更拦截代码。更加精细和高效</p></blockquote><p>结论就是，在精细化渲染方面，响应式数据则更容易实施，没有那么多心智负担，<strong>对于初级开发者也不太容易写出性能差的应用</strong>。</p><p><br><br><br><br><br></p><h2 id="应用到视图"><a href="#应用到视图" class="headerlink" title="应用到视图"></a>应用到视图</h2><p>接下来我们讨论如何将我们的 Store 注入到视图，以及这些 Store 对象生命周期的管理。</p><p><br></p><h3 id="注入视图层"><a href="#注入视图层" class="headerlink" title="注入视图层"></a>注入视图层</h3><p>视图注入有两种方式。一种是利用视图框架提供的 Context/provide-inject 功能：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// in vue</span><br><span class="line">// 提供</span><br><span class="line">const store = new Store()</span><br><span class="line">provide(key, store)</span><br><span class="line">onUnmounted(() =&gt; dispose(store))</span><br><span class="line"></span><br><span class="line">// 页面消费</span><br><span class="line">const store = inject(key)</span><br></pre></td></tr></table></figure><p>稍微封装一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Disposable &#123;</span><br><span class="line">  dispose?: () =&gt; void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createStore&lt;T extends new () =&gt; T&gt;(Store: T) &#123;</span><br><span class="line">  const key: InjectionKey&lt;T&gt; = Symbol(Store.name)</span><br><span class="line"></span><br><span class="line">  const _provide = () =&gt; &#123;</span><br><span class="line">    const store = new Store()</span><br><span class="line">    provide(key, store)</span><br><span class="line"></span><br><span class="line">    onUnmounted(() =&gt; &#123;</span><br><span class="line">      // 销毁</span><br><span class="line">      ;(store as Disposable).dispose?.()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const _inject = () =&gt; &#123;</span><br><span class="line">    return inject(key)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return [_provide, _inject]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">const [provideMyStore, useMyStore] = createStore(MyStore)</span><br><span class="line"></span><br><span class="line">// provide in parent view</span><br><span class="line">provideMyStore()</span><br><span class="line"></span><br><span class="line">// consume in children view</span><br><span class="line">useMyStore()</span><br></pre></td></tr></table></figure><p>大部分简单的场景，这已经足够了。</p><p><br></p><hr><p><br></p><p>更复杂的场景，比如 Store 对象之间有复杂的依赖关系，这些对象的作用域和生命周期规则也比较复杂。这时候就可以考虑引入<code>依赖注入</code>方案了, 比如<a href="https://github.com/mgechev/injection-js" target="_blank" rel="noopener">injection-js</a>、<a href="https://github.com/inversify/InversifyJS" target="_blank" rel="noopener">inversify</a>、<a href="https://github.com/Microsoft/tsyringe" target="_blank" rel="noopener">tsyringe</a>。</p><p><br></p><p>依赖注入的优势，笔者就不在这里展开说了。下面是笔者公司<a href="https://www.notion.so/wakeapp-framework-b08cb3cb5f8e49f597aa90bbb89a1641?pvs=21" target="_blank" rel="noopener">内部框架</a>的代码示例：</p><ol><li><p>创建模型： CounterModel.ts</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;injectable, page&#125; <span class="keyword">from</span> <span class="string">'@wakeapp/framework'</span></span><br><span class="line"><span class="keyword">import</span> &#123; makeObservable, observable &#125; <span class="keyword">from</span> <span class="string">'mobx'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明需求映射</span></span><br><span class="line">declare global &#123;</span><br><span class="line">  interface DIMapper &#123;</span><br><span class="line">    <span class="string">'DI.CounterModel'</span>: CounterModel</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line">@injectable()</span><br><span class="line">@page()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterModel</span> </span>&#123;</span><br><span class="line">  @observable</span><br><span class="line">  count: number = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  constrcutor() &#123;</span><br><span class="line">    makeObservable(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  increment = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.count++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  decrement = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.count--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费 CounterPage.tsx</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useInject &#125; <span class="keyword">from</span> <span class="string">'@wakeapp/framework'</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">'mobx-react'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 observer 包裹，让组件可以监听 mobx 响应式数据的变动</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CounterPage = observer(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> counter = useInject(<span class="string">'DI.CounterModel'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">onClick</span>=<span class="string">&#123;counter.increment&#125;</span>&gt;</span>&#123;counter.count&#125;<span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>更多介绍，可以见<a href="https://www.notion.so/wakeapp-framework-b08cb3cb5f8e49f597aa90bbb89a1641?pvs=21" target="_blank" rel="noopener">这里</a></p><p><br><br><br><br><br></p><h3 id="对象生命周期"><a href="#对象生命周期" class="headerlink" title="对象生命周期"></a>对象生命周期</h3><p>模型对象的生命周期如何管理呢?</p><p>大部分情况下，我们都不需要复杂的对象生命管理，让它随页面而生，随页面销毁而死就行了，比如上一节提到的第一种视图注入方案。我们只需要在视图根节点或者页面节点创建 Store，在节点销毁时 dispose 掉。</p><p><br><br><br></p><p>如果使用<code>依赖注入</code>的方式就可以对对象进行更精细的生命周期管理。比如：</p><table><thead><tr><th>类型</th><th>描述</th><th>挂靠对象</th><th>场景</th></tr></thead><tbody><tr><td>singleton</td><td>单例。在整个应用生命周期内存在，有且只有一个实例</td><td>应用</td><td>全局数据，跨页面共享数据</td></tr><tr><td>container</td><td>子容器单例。 singleton 实际上就是在全局容器的单例</td><td>子容器</td><td>数据隔离</td></tr><tr><td>page</td><td>页面。和页面的生命周期挂靠，在当前页面中，有且只有一个实例。 <br> 可以认为就是为每个页面创建 container</td><td>页面</td><td>需要在同一个页面组件层级下共享的数据。</td></tr><tr><td>request</td><td>请求。在一次请求中有且只有一个实例。</td><td>请求</td><td></td></tr><tr><td>transient 默认</td><td>临时。每次请求都会创建一个实例</td><td></td><td>临时数据</td></tr></tbody></table><p>更详细的介绍可以看看 <a href="https://github.com/inversify/InversifyJS" target="_blank" rel="noopener">InversifyJS</a>、<a href="https://github.com/Microsoft/tsyringe" target="_blank" rel="noopener">tsyringe</a> 等库的文档。注意，大部分情况我们都不需要用到这么复杂的方案。</p><blockquote><p>💡 关于 SSR 的支持，由于篇幅有限，这里就不展开了</p></blockquote><p><br><br><br><br><br></p><h2 id="mobx-in-vue"><a href="#mobx-in-vue" class="headerlink" title="MobX in Vue"></a>MobX in Vue</h2><p>尽管 MobX 也提供了 <a href="https://www.npmjs.com/package/mobx-vue-lite" target="_blank" rel="noopener">Vue 绑定</a>，但是总觉得奇奇怪怪的，实际上也很少人这么用。</p><p><br><br><br></p><p>那为什么不直接基于 Vue 的 reactive API 封装类 MobX API, 支持使用 class 来编写呢？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export class CounterModel &#123;</span><br><span class="line">  @observable</span><br><span class="line">  count: number = 0</span><br><span class="line"></span><br><span class="line">  constrcutor() &#123;</span><br><span class="line">    makeObservable(this)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  increment = () =&gt; &#123;</span><br><span class="line">    this.count++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  decrement = () =&gt; &#123;</span><br><span class="line">    this.count--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说干就干，相关实现源码请见<a href="https://github.com/wakeadmin/tools/tree/main/packages/framework/src/reactive" target="_blank" rel="noopener">这里</a>， 我在 《<a href="https://juejin.cn/post/7248801590113763386" target="_blank" rel="noopener">全新 Javascript 装饰器实战上篇：用 MobX 的方式打开 Vue</a>》中也介绍过，这里懒得展开说了。</p><p><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要探讨笔者为什么选择 MobX 放在自己的武器库中：</p><ul><li>面向对象 VS 函数式，探讨面向对象范式的优势和适用场景</li><li>回归朴素编程，利用编程语言原生的能力把事情做好，放弃不必要的约束和时尚</li><li>现代状态管理库需要处理的各种问题，比如可预测性，时间旅行，精细化渲染</li><li>最后介绍如何和视图结合，以及管理复杂的对象生命周期</li></ul><p><br><br><br></p><p>2023 年了，如果视图框架趋于稳定(往服务端方向卷了)， 而状态管理器还是一个火山爆发期（可以看看 <a href="https://juejin.cn/post/7195513281228898363#heading-50" target="_blank" rel="noopener">2023 再看 React 状态管理库</a>）。</p><p><br></p><p>我还是坚持还是<a href="https://juejin.cn/post/6844903848255946766#heading-1" target="_blank" rel="noopener">三年前那句话</a>；大部分情况你不需要状态管理，其次你不需要复杂的状态管理：</p><ul><li>如果组件或者页面可以做到自包含，那么完全没必要使用状态管理，更没必要为了某些状态管理器的「最佳实践」将状态外部化。</li><li>你不需要复杂的状态管理。简单的状态管理，可以使用视图框架内置的一些能力，比如 Vue 的 provide/inject， React 的 Context。再复杂的，可以使用与视图框架心智模型相近的方案，比如 Vue + Pinia，React + Hox？</li></ul><p><br></p><p>本文的标题是我选择 MobX 的原因，并不代表我推荐你无脑地使用它。</p><p>笔者是 MobX 的重度使用者，过去几年在若干复杂的项目中应用过，这些项目不乏有 IM 应用、低代码编辑器、图形编辑器。</p><p>如果你的场景再复杂一点，特别是需要能够直观地表达对业务的抽象，对象之间有复杂的交互，那这便是面向对象的强项。当然复杂的应用不仅仅需要状态管理，面向对象方案都有较强的普适性。</p><p>不过因为它过于灵活，缺乏约束，不是所有团队都能适应，也很容易写出难以维护的代码。</p><p>时至今日，不是 MobX 「热度」不再，而是 MobX 所代表的面向对象范式光芒被暂时屏蔽了。但历史总有峰回路转的时候。</p><p><br><br><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://www.zhihu.com/question/546185320/answer/2608425396" target="_blank" rel="noopener">如何看待新开源的前端 DDD 框架 Remesh?</a></li><li><a href="https://www.zhihu.com/question/401914770/answer/2065218097" target="_blank" rel="noopener">前端是否有必要引入领域驱动设计(DDD)？</a></li><li><a href="https://github.com/jherr/which-react-state-manager" target="_blank" rel="noopener">which-react-state-manager</a></li><li><a href="https://zhuanlan.zhihu.com/p/32107541" target="_blank" rel="noopener">从时间旅行的乌托邦，看状态管理的设计误区</a></li><li><a href="https://juejin.cn/post/7195513281228898363#heading-50" target="_blank" rel="noopener">2023 再看 React 状态管理库</a></li><li><a href="https://juejin.cn/post/7153071955405439012" target="_blank" rel="noopener">React 状态管理器，我是这样选的</a></li><li><a href="https://zhuanlan.zhihu.com/p/408512128" target="_blank" rel="noopener">使用函数式语言实践DDD</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/mobx/Untitled.jpeg&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;时至今日，前端的各种状态管理方案仍层出不穷，花式百样，争议不断，尤其是 React 社区。那我为什么要“背道而驰”，选择基本没什么声音的 MobX 呢？
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>AI 调教师：绘制 ER 图</title>
    <link href="https://bobi.ink/2023/07/26/ai-build-er/"/>
    <id>https://bobi.ink/2023/07/26/ai-build-er/</id>
    <published>2023-07-25T16:00:00.000Z</published>
    <updated>2023-07-26T01:57:28.331Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ai-build-er/Untitled.png" alt="Untitled"></p><p><br></p><p><img src="/images/ai-build-er/Untitled.gif" alt="Untitled"></p><p>在上一篇文章中，我们<a href="https://juejin.cn/post/7258150367120310332" target="_blank" rel="noopener">让 ChatGPT 来帮我们写 SQL 语句</a>, 现在我们再挑战一下，让 ChatGPT 来帮我们数据建模。</p><p><br></p><p>如上图，我们希望能做到比如：</p><ul><li>创建数据模型，让 ChatGPT 帮我们推断表应该包含的字段、字段类型、主键、索引、表之间的关联关系等等</li><li>优化数据模型。对现有的数据模型进行扩展和优化</li><li>对数据模型及其字段进行增删改。</li><li>…</li></ul><p><br></p><p>要 ChatGPT 处理这么「复杂」的需求，其实有点难度。我们从最简单的需求开始，先让 ChatGPT 将用户的需求转换为数据模型，并返回 JSON 格式：</p><p><br></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">你是一个数据库建模专家, 你会根据用户的提示进行数据库概念建模, 假设实体(表)有多个字段(属性), 这些字段支持以下类型:</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Boolean</span><br><span class="line"><span class="bullet">- </span>Date</span><br><span class="line"><span class="bullet">- </span>DateTime</span><br><span class="line"><span class="bullet">- </span>Timestamp</span><br><span class="line"><span class="bullet">- </span>Integer</span><br><span class="line"><span class="bullet">- </span>Decimal</span><br><span class="line"><span class="bullet">- </span>Long</span><br><span class="line"><span class="bullet">- </span>Double</span><br><span class="line"><span class="bullet">- </span>Float</span><br><span class="line"><span class="bullet">- </span>String</span><br><span class="line"><span class="bullet">- </span>Text</span><br><span class="line"><span class="bullet">- </span>LongText</span><br><span class="line"><span class="bullet">- </span>JSON</span><br><span class="line"><span class="bullet">- </span>Reference</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">引用关系的描述：</span><br><span class="line"></span><br><span class="line">其中 Reference 类型表示对其他实体的引用，比如 引用了 B 实体的 b 字段，会这样表示: &#123;"type": "Reference", "target": "B", "property": "b", "cardinality": "OneToMany" &#125;</span><br><span class="line"></span><br><span class="line">cardinality 可选值有: OneToOne, OneToMany, ManyToOne, ManyToMany</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">如果是主键，需要将字段的 primaryKey 设置为 true</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">举个例子，用户输入: """创建一个用户, 这个用户有多个地址"""", 你应该返回：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line"><span class="code">    "name": "User",</span></span><br><span class="line"><span class="code">    "title": "用户",</span></span><br><span class="line"><span class="code">    "properties": [</span></span><br><span class="line"><span class="code">      &#123;</span></span><br><span class="line"><span class="code">        "name": "id",</span></span><br><span class="line"><span class="code">        "title": "用户唯一 id",</span></span><br><span class="line"><span class="code">        "primaryKey": true,</span></span><br><span class="line"><span class="code">        "type": &#123; "type": "Long" &#125;</span></span><br><span class="line"><span class="code">      &#125;,</span></span><br><span class="line"><span class="code">      &#123;</span></span><br><span class="line"><span class="code">        "name": "name",</span></span><br><span class="line"><span class="code">        "title": "用户名",</span></span><br><span class="line"><span class="code">        "type": &#123; "type": "String" &#125;</span></span><br><span class="line"><span class="code">      &#125;</span></span><br><span class="line"><span class="code">    ]</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line"><span class="code">    "name": "Address",</span></span><br><span class="line"><span class="code">    "title": "地址",</span></span><br><span class="line"><span class="code">    "properties": [</span></span><br><span class="line"><span class="code">      &#123;</span></span><br><span class="line"><span class="code">        "name": "id",</span></span><br><span class="line"><span class="code">        "title": "唯一 id",</span></span><br><span class="line"><span class="code">        "primaryKey": true,</span></span><br><span class="line"><span class="code">        "type": &#123; "type": "Long" &#125;</span></span><br><span class="line"><span class="code">      &#125;,</span></span><br><span class="line"><span class="code">      &#123;</span></span><br><span class="line"><span class="code">        "name": "value",</span></span><br><span class="line"><span class="code">        "title": "详细地址",</span></span><br><span class="line"><span class="code">        "type": &#123; "type": "String" &#125;</span></span><br><span class="line"><span class="code">      &#125;,</span></span><br><span class="line"><span class="code">      &#123;</span></span><br><span class="line"><span class="code">        "name": "userId",</span></span><br><span class="line"><span class="code">        "title": "用户引用",</span></span><br><span class="line"><span class="code">        "type": &#123; "type": "Reference", "target": "User", "property": "id", "cardinality": "ManyToOne" &#125;</span></span><br><span class="line"><span class="code">      &#125;</span></span><br><span class="line"><span class="code">    ]</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">你可以根据问题创建多个对象，以数组的形式返回。上面的例子只是一个格式示范, 不要照搬，你需要根据用户的提示, 以及你的数据库建模的丰富经验和行业的最佳实践来回答。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">以 JSON 数组的格式回答，不要解释</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">当你无法理解请求时， 请回答直接返回：</span><br><span class="line"></span><br><span class="line">[SORRY]</span><br><span class="line"></span><br><span class="line">不要解释</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p><br></p><p>这个 Prompt 结构算是比较典型：</p><ul><li>角色定义。数据库建模专家</li><li>任务。将用户需求转换为概念模型</li><li>规则。字段的类型，引用关系的描述，主键</li><li>输出规则。输出 JSON，如果失败就返回 <code>[SORRY]</code></li><li>示例。</li></ul><p><br></p><p>这个 Prompt 大部分情况运行还好，调试的过程中发现的一些坑，也体现在 Prompt 里面了，比如</p><p><br></p><ul><li>我们想让它返回 JSON 格式，但是它可能会夹带一些解释，导致没办法直接 JSON.parse</li><li>它可能会直接照搬我们给它的示例</li></ul><p><br></p><p>这是我们最初的 Prompt 版本，仅支持创建新数据模型，而且没有结合已有的数据模型上下文来输出结果。我们还需要继续优化。</p><p><br><br><br><br><br></p><h1 id="设计原子操作"><a href="#设计原子操作" class="headerlink" title="设计原子操作"></a>设计原子操作</h1><p>在需求明确之后，我们首先需要设计接入 AI 的原子操作，在上面的需求中，我们无非是希望通过 AI 对我们的数据模型进行<code>增删改</code>。当然这不是简单的转换，我们还希望 ChatGPT 能在这里发挥<code>推导</code>和<code>演绎</code>的能力。</p><p><br></p><p>基于此，我们设计了以下原子操作</p><ul><li>表操作<ul><li>新增表</li><li>修改表</li><li>重命名表</li><li>删除表</li></ul></li><li>字段操作<ul><li>创建字段</li><li>修改字段</li><li>重命名字段</li><li>删除字段</li></ul></li></ul><p>另外我们还要考虑安全性的约束，比如不能删除和引用不存在的表和字段。</p><p><br></p><p>于是，我们重新整理了 Prompt 需求：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">You are an expert in conceptual modeling for relational databases. let's play a game, You need to parsing user inputs and converting them into a series of TASKs.</span><br><span class="line"></span><br><span class="line">Here are some rules:</span><br><span class="line"></span><br><span class="line">Rule 1: The following descriptions are equivalent:</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>table, entity, model, 实体,表,数据对象, 模型</span><br><span class="line"><span class="bullet">- </span>field, property, 字段, 属性, 表字段, 表属性,实体属性</span><br><span class="line"><span class="bullet">- </span>name,名称,名,标识符</span><br><span class="line"><span class="bullet">- </span>title,标题,中文名</span><br><span class="line"><span class="bullet">- </span>rename, 重命名,修改标识符, 修改名称</span><br><span class="line"><span class="bullet">- </span>retitle, 重命名标题,修改标题</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">Rule 2: The types of TASK:</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>createTable:</span><br><span class="line">  - name: table name in upper camel case</span><br><span class="line">  - title: table title in chinese</span><br><span class="line"><span class="bullet">- </span>updateTable:</span><br><span class="line">  - name</span><br><span class="line">  - title</span><br><span class="line"><span class="bullet">- </span>renameTable</span><br><span class="line">  - name</span><br><span class="line">  - newName: the new table new in upper camel case</span><br><span class="line"><span class="bullet">- </span>removeTable:</span><br><span class="line">  - name</span><br><span class="line"><span class="bullet">- </span>addField:</span><br><span class="line">  - table: table name</span><br><span class="line">  - name: field name in lower camel case</span><br><span class="line">  - title: field title in chinese</span><br><span class="line">  - type: field type</span><br><span class="line"><span class="code">    - Boolean</span></span><br><span class="line"><span class="code">    - Date</span></span><br><span class="line"><span class="code">    - DateTime</span></span><br><span class="line"><span class="code">    - Timestamp</span></span><br><span class="line"><span class="code">    - Integer</span></span><br><span class="line"><span class="code">    - Decimal</span></span><br><span class="line"><span class="code">    - Long</span></span><br><span class="line"><span class="code">    - Double</span></span><br><span class="line"><span class="code">    - Float</span></span><br><span class="line"><span class="code">    - String</span></span><br><span class="line"><span class="code">    - Text</span></span><br><span class="line"><span class="code">    - LongText</span></span><br><span class="line"><span class="code">    - JSON</span></span><br><span class="line"><span class="code">    - Reference: reference to other table</span></span><br><span class="line">  - reference: reference to other table field, for example: Table.field</span><br><span class="line">  - referenceCardinality: OneToOne, OneToMany, ManyToOne, ManyToMany</span><br><span class="line">  - primaryKey: optional, true or false</span><br><span class="line">  - notNull: optional, true or false</span><br><span class="line"><span class="bullet">- </span>removeField: remove the table field</span><br><span class="line">  - table</span><br><span class="line">  - name</span><br><span class="line"><span class="bullet">- </span>updateField: update the table field</span><br><span class="line">  - table</span><br><span class="line">  - name</span><br><span class="line">  - title</span><br><span class="line">  - type</span><br><span class="line">  - reference</span><br><span class="line">  - referenceCardinality</span><br><span class="line">  - primaryKey</span><br><span class="line">  - notNull</span><br><span class="line"><span class="bullet">- </span>renameField: rename the table field</span><br><span class="line">  - table</span><br><span class="line">  - name: old field name</span><br><span class="line">  - newName: new field name in lower camel case</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">Rule 3: CANNOT reference non-existent tables.</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">Rule 4: please response in chinese</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>在这里我们要求 ChatGPT 将用户的输入转换为一系列的 <code>Task</code>。以及这些 Task 的 <code>Schema</code>。</p><blockquote><p>💡  这里为什么使用英文？有两个原因, ChatGPT 大部分的训练集是英文；还有中文在表述相同的事情占用的 Token 通常要高于英语。</p></blockquote><p><br><br><br><br><br><br><br></p><h1 id="few-shot-prompting"><a href="#few-shot-prompting" class="headerlink" title="Few-shot Prompting"></a>Few-shot Prompting</h1><p>我们描述好需求了，但是还没有告诉 ChatGPT 应该返回怎样的数据，ChatGPT 只能自己 YY 了：</p><p><img src="/images/ai-build-er/Untitled%201.png" alt="Untitled"></p><p><br><br><br></p><p>解决办法是给 ChatGPT 更多示例，这种技巧称之为 “<a href="https://learningprompt.wiki/docs/chatGPT/tutorial-extras/Few-Shot%20Prompting" target="_blank" rel="noopener"><code>Few-Shot Prompting</code></a>”，像 ChatGPT 这种统计模型，实际上是读不懂我们上面的需求的，它是基于“概率预测”来输出内容。</p><p>我们在上面 Prompt 的基础上加上一些示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Here is same demo:</span><br><span class="line"></span><br><span class="line"><span class="section">#### START OF DEMO 1</span></span><br><span class="line"></span><br><span class="line">Given Tables:</span><br><span class="line"></span><br><span class="line">"""</span><br><span class="line">[not table here]</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">USER: """删除订单表"""</span><br><span class="line">ASSISTANT: """订单表不存在，无法删除"""</span><br><span class="line">explain: If the manipulated table is not in 'Given tables', you should stop the game</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """给所有表都加上更新时间和创建时间"""</span><br><span class="line">ASSISTANT: """不存在表，无法添加字段"""</span><br><span class="line">explain: table not exist</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER:"""创建一个用户, 这个用户有多个地址"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">%%createTable name="User" title="用户"%%</span><br><span class="line">%%createTable name="Address" title="地址"%%</span><br><span class="line"></span><br><span class="line">%%addField table="User" name="id" title="用户 id" type="Long" primaryKey="true" notNull="true"%%</span><br><span class="line">%%addField table="User" name="name" title="用户名" type="String" notNull="true"%%</span><br><span class="line">%%addField table="User" name="avatar" title="头像" type="String" %%</span><br><span class="line">%%addField table="User" name="home" title="主页" type="String" %%</span><br><span class="line"></span><br><span class="line">%%addField table="Address" name="id" title="地址 id" type="Long" primaryKey="true" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="userId" title="用户引用" type="Reference" reference="User.id" referenceCardinality="ManyToOne" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="street" title="街道" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="city" title="城市" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="state" title="州" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="country" title="国家" type="String" notNull="true"%%</span><br><span class="line">"""</span><br><span class="line">explain: create User and Address Table, User has many Address, Address belongs to User, so Address to User is ManyToOne.</span><br><span class="line"></span><br><span class="line"><span class="section">#### END of DEMO 1</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="section">#### START OF DEMO 2</span></span><br><span class="line"></span><br><span class="line">Given tables:</span><br><span class="line"></span><br><span class="line">"""</span><br><span class="line">Table A (</span><br><span class="line">  foo: Long;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Table B (</span><br><span class="line">  bar: Long;</span><br><span class="line">)</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """修改 A 的 foo 标题为用户唯一标识"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">%%updateField table="A" name="foo" title="用户唯一标识" %%</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """将 B 重命名为账号"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">%%updateTable name="B" title="账号"%%</span><br><span class="line">%%renameTable name="B" newName="Account"%%</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """将所有表下的所有属性名称都加上 o 前缀"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">%%renameField table="A" name="foo" newName="oFoo" %%</span><br><span class="line">%%renameField table="B" name="bar" newName="oBar" %%</span><br><span class="line">"""</span><br><span class="line">explain: rename all fields in given tables</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """删除 C"""</span><br><span class="line">ASSISTANT: """C 不存在，无法删除"""</span><br><span class="line">explain: If the manipulated table is not in 'Given tables'</span><br><span class="line"></span><br><span class="line"><span class="section">#### END of DEMO 2</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### START OF DEMO 3</span></span><br><span class="line"></span><br><span class="line">Given tables:</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line"><span class="section"># 用户</span></span><br><span class="line"></span><br><span class="line">Table User (</span><br><span class="line">id: Long, PrimaryKey;</span><br><span class="line">name: String;</span><br><span class="line">age: String;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """完善和优化用户"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">%%addField table="User" name="avatar" title="头像" type="String" %%</span><br><span class="line">%%addField table="User" name="home" title="主页" type="String" %%</span><br><span class="line">%%addField table="User" name="password" title="密码" type="String" notNull="true" %%</span><br><span class="line">"""</span><br><span class="line">explain: improve User Table</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """创建地址表"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">%%createTable name="Address" title="地址"%%</span><br><span class="line">%%addField table="Address" name="id" title="地址 id" type="Long" primaryKey="true" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="street" title="街道" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="city" title="城市" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="state" title="州" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="country" title="国家" type="String" notNull="true"%%</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="section">#### END of DEMO 3</span></span><br><span class="line"></span><br><span class="line">Ok, FORGET the DEMO given tables above, let's start the new game</span><br><span class="line"></span><br><span class="line"><span class="section">#### START GAME</span></span><br><span class="line"></span><br><span class="line">Given Tables:</span><br><span class="line"></span><br><span class="line">$&#123;tables ?? '[not table here]'&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """$&#123;input&#125;"""</span><br><span class="line">ASSISTANT: """</span><br></pre></td></tr></table></figure><p><br></p><p>这些示例覆盖了很多场景：</p><ul><li>数据模型为空时。各种安全性的检查</li><li>表结构、关联关系的推导</li><li>表结构的增删改</li><li>输出的格式</li><li>…</li></ul><p><br><br><br></p><p>你可能有这些疑问：</p><p><strong>为什么需要这么多示例？</strong></p><p>这些示例只是覆盖了各种已知的交互场景，如果没有给 ChatGPT 提供相关的示例，它并不知道怎么处理或者处理效果不好。未来随着更多场景被扩展， 示例会越来越多。</p><p><br><br><br></p><p>为什么使用 <code>%%&lt;&gt;%%</code> 这种格式，而不是 JSON？</p><p>ChatGPT 很‘任性’， 它不一定听你话，只返回 JSON。而且我们可能需要等待所有消息接收完毕之后才能开始处理，%%&lt;&gt;%% 则能以流的形式一边接收一边处理。最后就是它的结构更容易描述</p><p><br><br><br></p><p><img src="/images/ai-build-er/Untitled%202.png" alt="Untitled"></p><p><strong>Prompt 这么长？Token 够吗？</strong></p><p>这个版本的 Prompt 在没有算上数据模型上下文的情况下，已经达到 2000+ token 了。好在现在 GPT 3.5 有 16k 版本，GPT 4 最少也有 8k, 是够用的。当然 GPT4 有点小贵</p><p><br><br><br><br><br></p><p>执行效果：</p><p><img src="/images/ai-build-er/Untitled%203.png" alt="Untitled"></p><p>这里发现了一个有趣的想象，ChatGPT 模仿我们的示例套路(USER、ASSISTANT)，继续重复输出了很多内容。<strong>这实锤 ChatGPT 就是复读机了</strong>。</p><p>通过反复的调试，你会发现，我们在一开始定义的”需求规则” 对 ChatGPT 的影响微乎其微，甚至会直接忽略它们。<strong>它更多是从示例中学习规律</strong>。</p><p>那怎么避免这种重复呢？可以通过 ChatGPT API 的 <code>stop</code> 参数来告诉它什么时候终止。这里我们设置为 <code>&quot;&quot;&quot;</code> 即可。</p><p><br><br><br><br><br></p><h1 id="思维链"><a href="#思维链" class="headerlink" title="思维链"></a>思维链</h1><p>上面的 Prompt 还有一些缺陷。我们发现 ChatGPT 就是一个复读机，基本上只会照搬我们的示例。主要的原因是 ChatGPT 只知道结果，而不知道过程，所以推理能力就比较有限。</p><p>因此我们就需要引入 Few-shot Prompt 的进阶技巧 —— <strong><a href="https://learningprompt.wiki/docs/chatGPT/tutorial-tips/%E6%8A%80%E5%B7%A78%EF%BC%9AFew-Shot%20Chain%20of%20Thought" target="_blank" rel="noopener">Few-Shot Chain of Thought</a>：</strong></p><p><br></p><blockquote><p>通过向大语言模型展示一些少量的样例，并在样例中解释推理过程，大语言模型在回答提示时也会显示推理过程。这种推理的解释往往会引导出更准确的结果。</p></blockquote><p><br><br><br></p><p>继续重构和改进：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">You are an expert in the conceptual design of relational databases, and you need to parse the user's input according to the following steps, and then convert it into a series of operation tasks.</span><br><span class="line"></span><br><span class="line">Step 1: Analyze which tables need to be created. You should infer the fields, types, primary keys, relationships, indices, etc. of the table.</span><br><span class="line">Step 2: Analyze which tables need to be deleted.</span><br><span class="line">Step 3: Analyze which tables need to be updated, including adding fields, deleting fields, modifying field types, modifying field names, etc.</span><br><span class="line">Step 4: Analyze unsafe operations, such as repeated creation, deletion of non-existent tables, modification of non-existent tables, modification of non-existent fields, deletion of non-existent fields, etc. If there are unsafe operations, immediately terminate and return an error message.</span><br><span class="line">Step 5: Convert the analysis results into the form of %%&lt;action&gt; &lt;key&gt;="&lt;value&gt;"%% to return, and the action structure must conform to the defined Action type:</span><br><span class="line"></span><br><span class="line">\<span class="code">`\`</span>\`typescript</span><br><span class="line">type Action = CreateTable | UpdateTable | RemoveTable | AddField | RemoveField | updateField | RenameField;</span><br><span class="line"></span><br><span class="line">type CreateTable = &#123;</span><br><span class="line">  action: 'createTable';</span><br><span class="line">  name: string; // table name in upper camel case</span><br><span class="line">  title: string; // table name in chinese</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type UpdateTable = &#123;</span><br><span class="line">  action: 'updateTable';</span><br><span class="line">  name: string; // table name in upper camel case</span><br><span class="line">  title: string; // table name in chinese</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type RemoveTable = &#123;</span><br><span class="line">  action: 'removeTable';</span><br><span class="line">  name: string;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type FieldType =</span><br><span class="line">  | 'Boolean'</span><br><span class="line">  | 'Data'</span><br><span class="line">  | 'DateTime'</span><br><span class="line">  | 'Timestamp'</span><br><span class="line">  | 'Integer'</span><br><span class="line">  | 'Decimal'</span><br><span class="line">  | 'Long'</span><br><span class="line">  | 'Double'</span><br><span class="line">  | 'Float'</span><br><span class="line">  | 'String'</span><br><span class="line">  | 'Text'</span><br><span class="line">  | 'LongText'</span><br><span class="line">  | 'JSON'</span><br><span class="line">  | 'Reference';</span><br><span class="line"></span><br><span class="line">type ReferenceCardinality = 'OneToOne' | 'OneToMany' | 'ManyToOne' | 'ManyToMany';</span><br><span class="line"></span><br><span class="line">type AddField = &#123;</span><br><span class="line">  action: 'addField';</span><br><span class="line">  table: string; // table name</span><br><span class="line">  name: string; // field name in lower camel case</span><br><span class="line">  title: string; // field name in chinese</span><br><span class="line">  type: FieldType;</span><br><span class="line">  reference?: string; // reference to other table field, for example: Table.field</span><br><span class="line">  referenceCardinality?: ReferenceCardinality;</span><br><span class="line">  primaryKey?: boolean;</span><br><span class="line">  notNull?: boolean;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type RemoveField = &#123;</span><br><span class="line">  action: 'removeField';</span><br><span class="line">  table: string; // table name</span><br><span class="line">  name: string; // field name</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type updateField = &#123;</span><br><span class="line">  action: 'updateField';</span><br><span class="line">  table: string; // table name</span><br><span class="line">  name: string; // field name in lower camel case</span><br><span class="line">  title?: string; // field name in chinese</span><br><span class="line">  type?: FieldType;</span><br><span class="line">  reference?: string; // reference to other table field, for example: Table.field</span><br><span class="line">  referenceCardinality?: ReferenceCardinality;</span><br><span class="line">  primaryKey?: boolean;</span><br><span class="line">  notNull?: boolean;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type RenameField = &#123;</span><br><span class="line">  action: 'renameField';</span><br><span class="line">  table: string; // table name</span><br><span class="line">  name: string; // field name in lower camel case</span><br><span class="line">  newName: string; // new field name in lower camel case</span><br><span class="line">&#125;;</span><br><span class="line">\<span class="code">`\`</span>\`</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>上面的 Prompt 做了以下几点改进：</p><p><br></p><ul><li>我们拆解了整个推导的过程：<ul><li>第一步：识别需要创建的表格，以及对应的字段、字段类型、主键、关联关系等等</li><li>第二步：识别需要删除的表格</li><li>第三步：识别需要更新的字段</li><li>第四步：识别不安全的操作，如果存在不安全的操作就终止生成</li><li>第五步：将上面的结果转换为 DSL。</li></ul></li><li>我们使用 Typescript 来描述 DSL 的 Schema。我在上一篇文章*<strong>*<a href="https://juejin.cn/post/7259188522308550716" target="_blank" rel="noopener">AI 调教师：聊聊 TypeChat 以及 ChatGPT 形式化输出</a></strong> 大概介绍过 ChatGPT 的形式化输出能力。ChatGPT 可能很好地识别 Typescript</li></ul><p><br><br><br></p><p>接着我们再优化示例，加上上述的推导步骤：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Here is same demo:</span><br><span class="line"></span><br><span class="line"><span class="section">#### START OF DEMO 1</span></span><br><span class="line"></span><br><span class="line">Given Tables:</span><br><span class="line"></span><br><span class="line">"""</span><br><span class="line">[not table here]</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">USER: """删除订单表"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">step 1: 不需要创建表</span><br><span class="line">step 2: 删除订单表</span><br><span class="line">step 3: 不需要更新表</span><br><span class="line">step 4: 未定义任何表，订单表不存在, 终止</span><br><span class="line"></span><br><span class="line">结果: 不能删除订单表, 订单表不存在</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """给所有表都加上更新时间和创建时间"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">step 1: 不需要创建表</span><br><span class="line">step 2: 不需要删除表</span><br><span class="line">step 3: 不存在表，不需要更新操作</span><br><span class="line">step 4: 未定义任何表, 没有可以更新的表，终止</span><br><span class="line"></span><br><span class="line">结果：不存在表，无法添加字段</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER:"""创建一个用户, 这个用户有多个地址"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">step 1: 需要创建用户表和地址表, 用户和地址是一对多关系，所以地址表需要有一个用户引用字段。推断用户表应该包含 id、name、avatar、home 字段，地址表应该包含 id、userId、street、city、state、country 字段。</span><br><span class="line">step 2: 不需要删除表</span><br><span class="line">step 3: 不需要更新表</span><br><span class="line">step 4: 操作安全</span><br><span class="line">step 5: 输出结果</span><br><span class="line"></span><br><span class="line">%%createTable name="User" title="用户"%%</span><br><span class="line">%%createTable name="Address" title="地址"%%</span><br><span class="line"></span><br><span class="line">%%addField table="User" name="id" title="用户 id" type="Long" primaryKey="true" notNull="true"%%</span><br><span class="line">%%addField table="User" name="name" title="用户名" type="String" notNull="true"%%</span><br><span class="line">%%addField table="User" name="avatar" title="头像" type="String" %%</span><br><span class="line">%%addField table="User" name="home" title="主页" type="String" %%</span><br><span class="line"></span><br><span class="line">%%addField table="Address" name="id" title="地址 id" type="Long" primaryKey="true" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="userId" title="用户引用" type="Reference" reference="User.id" referenceCardinality="ManyToOne" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="street" title="街道" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="city" title="城市" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="state" title="州" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="country" title="国家" type="String" notNull="true"%%</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line"><span class="section">#### END of DEMO 1</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="section">#### START OF DEMO 2</span></span><br><span class="line"></span><br><span class="line">Given tables:</span><br><span class="line"></span><br><span class="line">"""</span><br><span class="line">Table A (</span><br><span class="line">  foo: Long;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Table B (</span><br><span class="line">  bar: Long;</span><br><span class="line">)</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """修改 A 的 foo 标题为用户唯一标识"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">step 1: 不需要创建表</span><br><span class="line">step 2: 不需要删除表</span><br><span class="line">step 3: 更新 A 表的 foo 字段的 title 为 '用户唯一标识'</span><br><span class="line">step 4: 操作安全</span><br><span class="line">step 5: 输出结果</span><br><span class="line"></span><br><span class="line">%%updateField table="A" name="foo" title="用户唯一标识" %%</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """将 B 重命名为账号"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">step 1: 不需要创建表</span><br><span class="line">step 2: 不需要删除表</span><br><span class="line">step 3: 更新 B 表的 name 为 'Account', title 为 '账号'</span><br><span class="line">step 4: 操作安全</span><br><span class="line">step 5: 输出结果</span><br><span class="line"></span><br><span class="line">%%updateTable name="B" title="账号"%%</span><br><span class="line">%%renameTable name="B" newName="Account"%%</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """将所有表下的所有属性名称都加上 o 前缀"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">step 1: 不需要创建表</span><br><span class="line">step 2: 不需要删除表</span><br><span class="line">step 3: 更新 A 表的 foo 字段的 name 为 'oFoo', B 表的 bar 字段的 name 为 'oBar'</span><br><span class="line">step 4: 操作安全</span><br><span class="line">step 5: 输出结果</span><br><span class="line"></span><br><span class="line">%%renameField table="A" name="foo" newName="oFoo" %%</span><br><span class="line">%%renameField table="B" name="bar" newName="oBar" %%</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """删除 A 的 bar 字段"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">step 1: 不需要创建表</span><br><span class="line">step 2: 不需要删除表</span><br><span class="line">step 3: 删除 A 表的 bar 字段</span><br><span class="line">step 4: A 表不存在 bar 字段，终止</span><br><span class="line"></span><br><span class="line">结果： A 表不存在 bar 字段，无法删除</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """删除 C"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">step 1: 不需要创建表</span><br><span class="line">step 2: 删除 C 表</span><br><span class="line">step 3: 不需要更新表</span><br><span class="line">step 4: C 不存在，终止</span><br><span class="line"></span><br><span class="line">结果： C 不存在，无法删除</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line"><span class="section">#### END of DEMO 2</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### START OF DEMO 3</span></span><br><span class="line"></span><br><span class="line">Given tables:</span><br><span class="line"></span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line"><span class="section"># 用户</span></span><br><span class="line"></span><br><span class="line">Table User (</span><br><span class="line">  id: Long, PrimaryKey;</span><br><span class="line">  name: String;</span><br><span class="line">  age: String;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """完善和优化用户"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">step 1: User 已存在，不需要创建表, 扩展 User 表，增加 avatar、home、password 字段</span><br><span class="line">step 2: 不需要删除表</span><br><span class="line">step 3: 不需要更新表</span><br><span class="line">step 4: 操作安全</span><br><span class="line">step 5: 输出结果</span><br><span class="line"></span><br><span class="line">%%addField table="User" name="avatar" title="头像" type="String" %%</span><br><span class="line">%%addField table="User" name="home" title="主页" type="String" %%</span><br><span class="line">%%addField table="User" name="password" title="密码" type="String" notNull="true" %%</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """创建地址表"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">step 1: 创建地址表，推断增加 id、street、city、state、country 字段</span><br><span class="line">step 2: 不需要删除表</span><br><span class="line">step 3: 不需要更新表</span><br><span class="line">step 4: 操作安全</span><br><span class="line">step 5: 输出结果</span><br><span class="line"></span><br><span class="line">%%createTable name="Address" title="地址"%%</span><br><span class="line">%%addField table="Address" name="id" title="地址 id" type="Long" primaryKey="true" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="street" title="街道" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="city" title="城市" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="state" title="州" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="country" title="国家" type="String" notNull="true"%%</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="section">#### END of DEMO 3</span></span><br><span class="line"></span><br><span class="line">Ok, FORGET the DEMO given tables above, let's start the new game</span><br><span class="line"></span><br><span class="line"><span class="section">#### START GAME</span></span><br><span class="line"></span><br><span class="line">Given Tables:</span><br><span class="line"></span><br><span class="line">$&#123;tables ?? '[not table here]'&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """$&#123;input&#125;"""</span><br><span class="line">ASSISTANT: """</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>运行结果：</p><p><img src="/images/ai-build-er/Untitled%204.png" alt=" GPT 3.5"></p><p>GPT 3.5</p><p><br><br><br></p><p><img src="/images/ai-build-er/Untitled%205.png" alt="GPT 4"></p><p>GPT 4</p><p><br><br><br><br><br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>加入了思维链(Chain of Thought) 之后，结果相对更可控了。但是还是不够完美，现在还有以下问题：</p><ul><li>Token 占用过大。尽管我们可以选择支持更大 Token 的模型，然而我们还要考虑未来为更多场景的加入示例、对话历史需要预留的空间，还有就是成本问题。</li><li>不支持多轮对话或者用户纠正机制。这个需要从交互上进行优化，比如提供执行确定，重新生成等等</li><li>回答效果还有待优化。并没有发挥出 ChatGPT 强大的联想能力，其实这是一件挺矛盾的事情，示例不够，GPT 输出的结果可能不符合要求，多了有可能抑制它的「创造性」？</li></ul><p><br><br><br></p><p>我觉得后面还有这些优化的方向：</p><ol><li><p>转换为多步骤 Prompt(<code>multi-step Prompt</code>)。典型的例子可以看 OpenAI 官方的 <a href="https://github.com/openai/openai-cookbook/blob/main/examples/Unit_test_writing_using_a_multi-step_prompt.ipynb" target="_blank" rel="noopener">Unit test writing using a multi-step prompt</a> 。我们上文的例子就是大锅炖，其实还可以继续拆解和引导 ChatGPT 展开细节。比如单元测试就拆解了三个步骤：</p><ol><li><strong>Explain(解释)</strong>: 给一个 Python 函数，让 GPT 解释它做了什么，为什么这么做.</li><li><strong>Plan(计划)</strong>: 让 GPT 列举针对这个函数单元测试的计划。如果这个计划太短，我们就请 GPT 进一步阐述更多单元测试的思路</li><li><strong>Execute(执行)</strong>: 最后，让 GPT 将上述计划的用例转换为单元测试</li></ol><p>同理，这些思路也可以用在我们的「数据建模」的场景</p></li><li><p>模型微调(Fine-tune)。上面的 Prompt 已经列举了较多的示例，已经占据了很多 Token 空间，如果要达到生产可用的级别，我们还需要积累更多的样本，微调出专用的模型是更好的选择。</p></li><li>使用更高级的模型。比如 GPT 4 的效果会比 3.5 好上很多</li></ol><p><br><br><br></p><p>虽然还达不到「生产可用」的级别，但在这期间我们也总结了对接 AI 到已有系统的一些<code>工作流</code>：</p><ul><li>确定需求。</li><li>系统原子操作的拆解。我们的主要工作就是让 AI 将用户的自然语言需求转换为这些原子操作。</li><li>设计 DSL。设计 AI 输出的 DSL 形式，需要兼顾 AI 和已有系统的处理能力</li><li>推理过程步骤设计。让 AI 模型知道结果是如何得到的，可以提升输出结果的准确性。</li><li>提供案例。案例越多，输出的结果就越可控</li><li>调优。这个调试的过程很难一步到位，就是测试、重建、测试、重建的过程。而且我们很难对它进行单元测试诸如此类的。</li></ul><p><br><br><br></p><p>后面我们还会继续优化，如果读者有更好的建议请和我交流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/ai-build-er/Untitled.png&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/ai-build-er/Untitled.gif&quot; alt=&quot;Untitled&quot;
      
    
    </summary>
    
      <category term="AI" scheme="https://bobi.ink/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>AI 调教师：聊聊 TypeChat 以及ChatGPT 形式化输出</title>
    <link href="https://bobi.ink/2023/07/24/typechat/"/>
    <id>https://bobi.ink/2023/07/24/typechat/</id>
    <published>2023-07-23T16:00:00.000Z</published>
    <updated>2023-07-24T03:27:27.183Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/typechat/Untitled%201.png" alt="Untitled"></p><p>Typescript 之父(微软)在 7月 21 号发布了一个有趣的项目—— <code>[Typechat](https://github.com/microsoft/TypeChat)</code>。<strong>旨在使用 AI 来连接自然语言和应用的 Schema / API</strong>。说白话就是使用 Typescript 类型信息来约束 ChatGPT 输出内容的结构。</p><p>我们早已见证过 ChatGPT 的强大，如果想要对接到我们已有的软件系统，通常会要求它输出 JSON 这类形式化、结构化的数据。如果你调教过 ChatGPT 就会发现， 它的输出结果往往没那么靠谱。为了让它输出符合要求的内容，我们需要给出足够的上下文信息和示例，并且这个调教过程也比较玄学。</p><p>本文就来看看 Typechat 是如何让 ChatGPT 输出符合需求的内容</p><p><br></p><h1 id="chatgpt-的能力和缺陷"><a href="#chatgpt-的能力和缺陷" class="headerlink" title="ChatGPT 的能力和缺陷"></a>ChatGPT 的能力和缺陷</h1><h3 id="chatgpt-看起来很擅长处理代码"><a href="#chatgpt-看起来很擅长处理代码" class="headerlink" title="ChatGPT 看起来很擅长处理代码"></a>ChatGPT 看起来很擅长处理代码</h3><p><img src="/images/typechat/Untitled%202.png" alt="扮演一个 linux 终端"></p><p>扮演一个 linux 终端</p><p><br></p><p><img src="/images/typechat/Untitled%203.png" alt="扮演一个 Javascript 执行器"></p><p>扮演一个 Javascript 执行器</p><p><br></p><p><img src="/images/typechat/Untitled%204.png" alt="扮演 Typescript"></p><p>扮演 Typescript</p><p><br></p><p>这能说明 ChatGPT 的预训练集中包含了丰富的编程语言相关的内容。</p><p><br><br><br><br><br></p><h2 id="连续对话和纠错机制"><a href="#连续对话和纠错机制" class="headerlink" title="连续对话和纠错机制"></a>连续对话和纠错机制</h2><p><img src="/images/typechat/Untitled%205.png" alt="Untitled"></p><p>众所周知， ChatGPT 生成的内容存在一定的随机性和不稳定性，很难一步到位。读者们作为开发者我们经常使用它来生成代码，应该能够体会到。</p><p>这个问题怎么解决呢？大概有以下几个方向</p><ul><li>可以和 ChatGPT 连续对话，引导它，反问它、纠正它</li><li>给 ChatGPT 提供更详细的上下文信息</li><li>使用一些对话的技巧：Chain of thought, 让 ChatGPT 学习推理的过程</li><li>模型微调。</li></ul><p>最后是平常心，开放地对待， AI 不是无所不能的，我们可能用尽的所有技巧， 也可能无法令人满意的答案。</p><p><br><br><br></p><h2 id="dsl-输出"><a href="#dsl-输出" class="headerlink" title="DSL 输出"></a>DSL 输出</h2><p>如果我们想要让 AI 连接到其他生态，比如连接到软件系统、控制硬件设备、实现各种自动化流程，在现在这个阶段，我们需要让 ChatGPT 输出结构化的数据，比如 JSON、XML、或者其他常见的 DSL。</p><p><img src="/images/typechat/Untitled%206.png" alt="Untitled"></p><p>就像我们开头说的 “ <em>Typechat 旨在使用 AI 来连接自然语言和应用的 Schema / API</em>”,  结合上面的流程图理解，你应该就能体会到这句话的意思。<strong><code>AI</code> 在这里就是一个<code>连接者</code>，让用户可以使用<code>自然语言</code>和我们的<code>应用系统</code>进行交互，AI 在这里的责任就是将<code>自然语言</code>翻译为我们应用系统能够处理的 <code>DSL</code></strong>。</p><p><br></p><p>ChatGPT 已经具备这样的能力：</p><p><img src="/images/typechat/Untitled%207.png" alt="绘制 mermaid 流程图"></p><p>绘制 mermaid 流程图</p><p><br></p><p><img src="/images/typechat/Untitled%208.png" alt="输出 JSON"></p><p>输出 JSON</p><p><br></p><p>如果你要求输出更复杂的数据结构，则需要使用 <a href="https://learningprompt.wiki/docs/chatGPT/tutorial-extras/Few-Shot%20Prompting" target="_blank" rel="noopener">Few-shot</a> Prompt 等手段，<strong>在受限的 Token 范围内，给 ChatGPT足够的案例和上下文信息</strong>。</p><p>除此之外，OpenAI 官方在 613 版本的 GPT 3.5 和 4 带来了<code>函数调用</code>的能力(<a href="https://platform.openai.com/docs/guides/gpt/function-calling" target="_blank" rel="noopener">Function Calling</a>), 可以帮助开发者通过 API 方式实现类似于 ChatGPT 插件的数据交互能力。让开发者可以使用  JSON Schema 来描述你的函数接口，GPT 会根据用户的输入，决定调用哪个函数，并组装符合 Schema 要求的 JSON 数据。</p><p>以下是 OpenAI 的官方示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 🔴 函数接口定义</span></span><br><span class="line">functions = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"get_current_weather"</span>,</span><br><span class="line">        <span class="string">"description"</span>: <span class="string">"Get the current weather in a given location"</span>,</span><br><span class="line">        <span class="string">"parameters"</span>: &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"object"</span>,</span><br><span class="line">            <span class="string">"properties"</span>: &#123;</span><br><span class="line">                <span class="string">"location"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">                    <span class="string">"description"</span>: <span class="string">"The city and state, e.g. San Francisco, CA"</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"unit"</span>: &#123;<span class="string">"type"</span>: <span class="string">"string"</span>, <span class="string">"enum"</span>: [<span class="string">"celsius"</span>, <span class="string">"fahrenheit"</span>]&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"required"</span>: [<span class="string">"location"</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 🔴 用户输入</span></span><br><span class="line">messages = [&#123;<span class="string">"role"</span>: <span class="string">"user"</span>, <span class="string">"content"</span>: <span class="string">"What's the weather like in Boston?"</span>&#125;]</span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">response = openai.ChatCompletion.create(</span><br><span class="line">    model=<span class="string">"gpt-3.5-turbo-0613"</span>,</span><br><span class="line">    messages=messages,</span><br><span class="line">    functions=functions,</span><br><span class="line">    function_call=<span class="string">"auto"</span>,  <span class="comment"># auto is default, but we'll be explicit</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">response_message = response[<span class="string">"choices"</span>][<span class="number">0</span>][<span class="string">"message"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 🔴 GPT 会告诉你最终需要调用哪个函数以及它的参数，也可能不会调用任何东西</span></span><br><span class="line"><span class="keyword">if</span> response_message.get(<span class="string">"function_call"</span>):</span><br></pre></td></tr></table></figure><p>gpt-3.5-turbo-0613、gpt-4-0613 针对 Function calling 这种场景做了微调，实际上这些 ‘函数’ 也是注入到 <code>system</code> prompt 里面，同样会占用请求的 Token。在旧的版本理论上也可以实现类似的效果。我会在后续的文章中专门介绍 Function calling。</p><p><br></p><p>实际上，Function Calling 还是不完美，比如无法保证严格按照我们给定的 JSON  Schema 输出，不支持复杂的 JSON Schema，缺乏灵活性等等。现在我们开始介绍本文的主角 —— typechat</p><p><br><br><br><br><br></p><h1 id="typechat"><a href="#typechat" class="headerlink" title="TypeChat"></a>TypeChat</h1><p>TypeChat 是微软刚发布一个有趣的项目，不同于 Function calling， 它使用 Typescript 类型来作为 「Schema」，要求 ChatGPT 返回符合这个类型定义的数据。</p><p>在 <code>Typechat</code> 中，先定义好 ChatGPT 的响应类型，即 <code>Schema</code>, 例如:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">type Response = &#123;</span><br><span class="line">    items: Item[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type Item = &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    quantity: number;</span><br><span class="line">    size?: string;</span><br><span class="line">    notes?: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求 ChatGPT 返回 JSON 格式，并符合上述的 Response 类型。接着输入用户需求：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Could I get a blueberry muffin and a grande latte?</span><br></pre></td></tr></table></figure><p>最后 ChatGPT 返回结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"items"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"blueberry muffin"</span>,</span><br><span class="line">      <span class="string">"quantity"</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"latte"</span>,</span><br><span class="line">      <span class="string">"quantity"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">"size"</span>: <span class="string">"grande"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><p>那么它是怎么工作的？我们在上一节对 ChatGPT 的能力做了大概的分析，你可以将它们结合起来想想：</p><ul><li>ChatGPT 擅长扮演“代码”执行器,  这其中也包括 Typescript</li><li>ChatGPT 的缺点就是不稳定、随机性。解决办法就给出更多的信息、推理步骤，通过连续对话、反复纠正它。</li><li>ChatGPT 通过给出足够的指示，可以输出‘符合’需求的结构化数据。</li></ul><p><br><br><br><br><br></p><p>Typechat 就是运用了上述思路：</p><p><img src="/images/typechat/Untitled%209.png" alt="Untitled"></p><ul><li>将类型定义和用户需求一起投喂给 ChatGPT，要求它返回指定类型的 JSON数据</li><li>将返回的数据喂给 Typescript 进行检查</li><li>如果类型错误，将错误结果丢回 ChatGPT，重新纠正</li></ul><p><br><br><br></p><p>它的 Prompt 非常简单。 请求的 Prompt：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createRequestPrompt(request: string) &#123;</span><br><span class="line">      return `You are a service that translates user requests into JSON objects of type &quot;$&#123;validator.typeName&#125;&quot; according to the following TypeScript definitions:\n` +</span><br><span class="line">          `\`\`\`\n$&#123;validator.schema&#125;\`\`\`\n` +</span><br><span class="line">          `The following is a user request:\n` +</span><br><span class="line">          `&quot;&quot;&quot;\n$&#123;request&#125;\n&quot;&quot;&quot;\n` +</span><br><span class="line">          `The following is the user request translated into a JSON object with 2 spaces of indentation and no properties with the value undefined:\n`;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><br></p><p>纠错 Prompt：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createRepairPrompt(validationError: string) &#123;</span><br><span class="line">        return `The JSON object is invalid for the following reason:\n` +</span><br><span class="line">            `&quot;&quot;&quot;\n$&#123;validationError&#125;\n&quot;&quot;&quot;\n` +</span><br><span class="line">            `The following is a revised JSON object:\n`;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><p>翻译流程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function translate(request: string) &#123;</span><br><span class="line">        let prompt = typeChat.createRequestPrompt(request);</span><br><span class="line">        let attemptRepair = typeChat.attemptRepair;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            const response = await model.complete(prompt);</span><br><span class="line">            if (!response.success) &#123;</span><br><span class="line">                return response;</span><br><span class="line">            &#125;</span><br><span class="line">            const responseText = response.data;</span><br><span class="line">            const startIndex = responseText.indexOf(&quot;&#123;&quot;);</span><br><span class="line">            const endIndex = responseText.lastIndexOf(&quot;&#125;&quot;);</span><br><span class="line">            if (!(startIndex &gt;= 0 &amp;&amp; endIndex &gt; startIndex)) &#123;</span><br><span class="line">                return error(`Response is not JSON:\n$&#123;responseText&#125;`);</span><br><span class="line">            &#125;</span><br><span class="line">            const jsonText = responseText.slice(startIndex, endIndex + 1);</span><br><span class="line">            // 🔴 类型检查</span><br><span class="line">            const validation = validator.validate(jsonText);</span><br><span class="line">            if (validation.success) &#123;</span><br><span class="line">                return validation;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!attemptRepair) &#123;</span><br><span class="line">                return error(`JSON validation failed: $&#123;validation.message&#125;\n$&#123;jsonText&#125;`);</span><br><span class="line">            &#125;</span><br><span class="line">            // 🔴 修复</span><br><span class="line">            prompt += `$&#123;responseText&#125;\n$&#123;typeChat.createRepairPrompt(validation.message)&#125;`;</span><br><span class="line">            attemptRepair = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><p>Typechat 与 Function calling 对比：</p><ul><li>Typescript 可以更简洁、灵活地定义复杂的数据类型；</li><li>Typechat 也加入了简单的纠错机制，进一步保证结果的可靠性。</li></ul><p><br></p><p>它们都改变不了 ChatGPT 的特性，结果依然不一定是可靠的。目前 Typechat  只有一轮纠正，其实际的效果、Token 消耗量等还有待验证。</p><p><br><br><br><br><br><br><br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面我们简单介绍了 ChatGPT 的一些特性和缺陷。接着引入了 Typechat，它给我们提供了一个较新的思路：使用 Typescript 类型来定义 ChatGPT 的输出结构，然后通过 Typescript 来验证输出结果，循环纠正 ChatGPT。</p><p>本文的要点：</p><ul><li>ChatGPT 看起来很擅长处理编程语言。比如 Typescript，这就给 Typechat 的实现奠定了基础。</li><li>使用 Typescript 类型作为 Schema，这本身就可以给 ChatGPT 提供较为严谨的上下文信息。</li><li>ChatGPT 的回答是随机的、不稳定，很难做到一步到位。在实际使用中，需要通过多次对话和纠正才能得到较为完善的结果。所以 Typechat 就引入了自动纠错机制，让 ChatGPT 输出更加稳定。</li><li>编程语言是严苛的，具备可‘纠错性’。我们可以将代码错误信息反馈给 ChatGPT 来完善答案。Typechat 就是利用了这点，其他编程语言也可以轻松实现类似的效果，很快其他语言应该也会有类似的库出来</li></ul><p><br></p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://github.com/microsoft/TypeChat" target="_blank" rel="noopener">https://github.com/microsoft/TypeChat</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/typechat/Untitled%201.png&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;Typescript 之父(微软)在 7月 21 号发布了一个有趣的项目—— &lt;code&gt;[Typechat](https://githu
      
    
    </summary>
    
      <category term="AI" scheme="https://bobi.ink/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>AI 调教师系列开篇： MySQL 专家</title>
    <link href="https://bobi.ink/2023/07/21/ai-sql-master/"/>
    <id>https://bobi.ink/2023/07/21/ai-sql-master/</id>
    <published>2023-07-20T16:00:00.000Z</published>
    <updated>2023-07-21T09:17:38.044Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ai-sql-master/Untitled.jpeg" alt="cover"></p><p>ChatGPT 在年初爆火，成为街头巷尾热议的话题。现在的 AI 应该算是目前最卷的赛道了，从卖账号、套壳客户端、 割韭菜教程、大厂争先发布自己的大模型…</p><p>作为普通开发者，搞底层大模型不是人人都能企及，下场割韭菜实在卷不过别人，追新也需要付出很多精力。眼前貌似就只有一条路，着眼于 AI 的应用层，看能不能给自己的垂直赛道赋赋能？ 或者针对个人而言，能不能利用 AI 提高工作效率？</p><p><br></p><p>所以我开一个新坑, 以前端开发者视角， 记录一下作为一个 「AI 调教师」在 <code>AI 应用层</code>的一些实践记录, 没有高谈阔论，就一些碎碎念。</p><p><br><br><br></p><h1 id="一种全新的人机交互模式"><a href="#一种全新的人机交互模式" class="headerlink" title="一种全新的人机交互模式"></a>一种全新的人机交互模式</h1><p>今年二月份，我们就开始尝试将 ChatGPT 接入到我们的工具中，如下图：</p><p><img src="/images/ai-sql-master/Untitled.png" alt="AI对话框"></p><p><br></p><p>就是这样的一个<code>对话框</code>，现在大家可能司空见惯了。那时候并不常见，毕竟 Microsoft Office Copilot、<code>ChatGPT 插件</code>什么的都还没发布。在当时想出这个点子的时候，我一整夜睡不着觉，第二天四五点就决定起床，肝了一天搞出这样的效果。</p><blockquote><p>😂 不知道有没有人跟我一样，一兴奋就会睡不着觉</p></blockquote><p><br></p><p>这是一种全新的系统交互方式，即用<code>自然语言</code>来操控整个系统。怎么操控法呢？</p><p><img src="/images/ai-sql-master/Untitled%201.png" alt="指令"></p><p><br></p><ul><li>这个对话框是全局的<code>常驻</code>的，用户可以随时通过快捷键或者悬浮按钮唤起</li><li>每个页面都可以扩展自己的指令，比如进入数据建模页面，就注册 <code>SQL 专家</code>、<code>数据建模</code>等指令，离开后就销毁：<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React 代码</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (model.readonly) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册扩展</span></span><br><span class="line">  <span class="keyword">return</span> registerExtension(&#123;</span><br><span class="line">    key: <span class="string">'数据建模(测试)'</span>,</span><br><span class="line">    match: <span class="string">'数据建模(测试)'</span>,</span><br><span class="line">    type: ExtensionType.Command,</span><br><span class="line">    description: <span class="string">'数据模型创建和修改'</span>,</span><br><span class="line">    onSend(context) &#123;</span><br><span class="line">      <span class="comment">// ... 实现</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure></li></ul><p><br></p><p><img src="/images/ai-sql-master/Untitled%202.png" alt="指令系统"><br>指令系统</p><p><br></p><p><code>指令</code>类似于现在的 <code>ChatGPT 插件</code>，用于扩展 ChatGPT 的能力边界。</p><p>对话框只是提供了 AI 对话的能力(机制)，而具体的业务、上下文信息只有页面自己最清楚，因此就让页面自己提供与 AI 对接的接口。</p><p>目前的实现方式是通过 <code>#</code> 来唤起选择具体指令，未来我们会利用 ChatGPT 最新的 <a href="https://platform.openai.com/docs/guides/gpt/function-calling" target="_blank" rel="noopener">Function Calling</a> 实现类似 <code>ChatGPT 插件</code> 一样的自然语言调用能力。</p><p><br><br><br><br><br></p><h1 id="mysql-专家"><a href="#mysql-专家" class="headerlink" title="MySQL 专家"></a>MySQL 专家</h1><p>我们第一个接入的 <code>AI 的大腿</code>，就是给我们的<code>数据建模工具</code>接入 <code>AI  生成 SQL 语句</code>的功能：</p><p><img src="/images/ai-sql-master/Untitled.png" alt="对话框"></p><p>如上图所示，我们可以使用自然语言的形式，基于我们已创建的数据模型来做以下事情：</p><ul><li>生成 MySQL 建表、 增删改查语句</li><li>给出优化的建议</li><li>检查是否符合关系型数据的范式等等…</li></ul><p><br></p><p>建表语句：</p><p><img src="/images/ai-sql-master/Untitled%203.png" alt="建表语句"></p><p><br></p><p>优化建议：</p><p><img src="/images/ai-sql-master/Untitled%204.png" alt="优化建议"></p><p>还有很多场景…</p><p><br><br><br><br><br></p><h1 id="prompt-实现"><a href="#prompt-实现" class="headerlink" title="Prompt 实现"></a>Prompt 实现</h1><p>几乎零成本就可以拥有一个 「MySQL 专家」。它的 Prompt 其实很简单！</p><p><br></p><p>首先需要将已创建的数据模型序列化，作为上下文喂给 ChatGPT, 例如：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#会员主档</span></span><br><span class="line">Table m_member (</span><br><span class="line">  <span class="symbol">id:</span> Long, PrimaryKey;</span><br><span class="line">  <span class="symbol">tenant_id:</span> Long; <span class="comment">#租户id</span></span><br><span class="line">  <span class="symbol">unique_account_id:</span> String; <span class="comment">#会员一账通id</span></span><br><span class="line">  <span class="symbol">status:</span> Integer; <span class="comment">#会员状态</span></span><br><span class="line">  <span class="symbol">unique_identifier_key:</span> String; <span class="comment">#会员唯一标识键</span></span><br><span class="line">  <span class="symbol">unique_identifier:</span> String; <span class="comment">#会员唯一标识的值</span></span><br><span class="line">  <span class="symbol">ext_json:</span> String; <span class="comment">#自定义扩展字段</span></span><br><span class="line">  <span class="symbol">clubs:</span> String; <span class="comment">#会员所属的俱乐部</span></span><br><span class="line">  <span class="symbol">channel:</span> String; <span class="comment">#渠道</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#俱乐部会员</span></span><br><span class="line">Table club_member_do (</span><br><span class="line">  <span class="symbol">id:</span> Long, PrimaryKey; <span class="comment">#实体唯一标识符</span></span><br><span class="line">  <span class="symbol">tenant_id:</span> Long; <span class="comment">#租户id</span></span><br><span class="line">  <span class="symbol">club_id:</span> Long; <span class="comment">#俱乐部id</span></span><br><span class="line">  <span class="symbol">unique_account_id:</span> String; <span class="comment">#会员一账通id</span></span><br><span class="line">  <span class="symbol">member_no:</span> String; <span class="comment">#会员卡号</span></span><br><span class="line">  <span class="symbol">level_num:</span> Integer; <span class="comment">#会员等级编号</span></span><br><span class="line">  <span class="symbol">level_expired_time:</span> DateTime; <span class="comment">#等级过期时间</span></span><br><span class="line">  <span class="symbol">nickname:</span> String; <span class="comment">#昵称</span></span><br><span class="line">  <span class="symbol">channel:</span> String; <span class="comment">#渠道</span></span><br><span class="line">  <span class="symbol">certificate_type:</span> String; <span class="comment">#证件类型</span></span><br><span class="line">  <span class="symbol">certificate_no:</span> String; <span class="comment">#证件号码</span></span><br><span class="line">  <span class="symbol">email:</span> String; <span class="comment">#邮箱</span></span><br><span class="line">  <span class="symbol">country_code:</span> String; <span class="comment">#国家编码</span></span><br><span class="line">  <span class="symbol">address:</span> String; <span class="comment">#详细地址信息</span></span><br><span class="line">  <span class="symbol">ext_json:</span> String; <span class="comment">#扩展字段</span></span><br><span class="line">  <span class="symbol">status:</span> Integer; <span class="comment">#俱乐部会员状态</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#会员变动日志</span></span><br><span class="line">Table m_member_operation_log (</span><br><span class="line">  <span class="symbol">id:</span> Long; <span class="comment">#实体唯一标识符</span></span><br><span class="line">  <span class="symbol">tenant_id:</span> Long; <span class="comment">#租户ID</span></span><br><span class="line">  <span class="symbol">club_id:</span> Long; <span class="comment">#俱乐部Id</span></span><br><span class="line">  <span class="symbol">unique_account_id:</span> String; <span class="comment">#一账通ID</span></span><br><span class="line">  <span class="symbol">operation_type:</span> String; <span class="comment">#操作类型</span></span><br><span class="line">  <span class="symbol">remark:</span> String; <span class="comment">#操作备注</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>这个 DSL 的格式无所谓，ChatGPT 自然语言的处理能力非常强，只要你给出的信息符合一定的规律，格式并不重要。</p><p><br></p><p>完整的 Prompt(<code>system</code>) 模板如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你是一个 MySQL 专家，你会根据用户给出的概念模型，创建专业、高性能 SQL 语句， 以及回答用户关于数据库的任何问题，提出建设性意见。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">假设实体(或者表)有多个字段(或者属性), 这些字段支持以下类型:</span><br><span class="line"></span><br><span class="line">- Boolean</span><br><span class="line">- Date</span><br><span class="line">- DateTime</span><br><span class="line">- Timestamp</span><br><span class="line">- Integer</span><br><span class="line">- Decimal</span><br><span class="line">- Long</span><br><span class="line">- Double</span><br><span class="line">- Float</span><br><span class="line">- String</span><br><span class="line">- Text</span><br><span class="line">- LongText</span><br><span class="line">- JSON</span><br><span class="line">- Reference : 表示对其他表的引用</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">这是概念模型：</span><br><span class="line"></span><br><span class="line">$&#123;conception&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">用户输入： &quot;&quot;&quot;$&#123;input&#125;&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>这是一个很简单的 Prompt，但也揭示了我们写 Prompt 的<a href="https://learningprompt.wiki/docs/chatGPT/tutorial-extras/ChatGPT%20Prompt%20Framework" target="_blank" rel="noopener">主要框架</a>：</p><ul><li><strong>能力与角色</strong>（Capacity and Role）：一上来就给它带个帽子，定义好它的角色和能力</li><li><strong>洞察力</strong>（Insight）：背景信息和上下文。即我们携带了数据模型工具中提取出来的 <code>模型 DSL</code>， 以及 DSL 的基础规则</li><li><strong>指令</strong>（Statement）：要求 ChatGPT 做什么。这个由后续的用户给出</li></ul><p><br></p><p>这里我们也使用了一些<a href="https://learningprompt.wiki/docs/chatGPT/tutorial-tips/%E6%8A%80%E5%B7%A75%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E6%8C%87%E4%BB%A4%E5%92%8C%E9%9C%80%E8%A6%81%E5%A4%84%E7%90%86%E7%9A%84%E6%96%87%E6%9C%AC%E5%88%86%E5%BC%80" target="_blank" rel="noopener">特殊符号</a>, 比如 <code>---</code> <code>&quot;&quot;&quot;</code> , 对文本进行分段，可以提升 AI 反馈的准确性</p><p><br></p><p>因为 ChatGPT 语言模型已经预训练了很多数据库相关的语料，所以回答的效果还不错，不需要太多的指示(即 <code>[Zero-Shot Prompting](https://learningprompt.wiki/docs/chatGPT/tutorial-extras/Zero-Shot%20Prompts)</code>)。</p><blockquote><p>💡  你可以通过这个<a href="https://sdk.vercel.ai/r/25O12Mq" target="_blank" rel="noopener">链接试一试效果</a></p></blockquote><p><br><br><br><br><br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>「AI 调教师」系列的第一篇文章以一个最简单的示例开始， 这是我为数不多比较短的文章了。如果你想给已有的工具接入 AI 能力，兴许这种方式就是最好的开始，从已有的工具中提取出相关上下文信息，投喂给 AI 来实现智能问答。</p><p>下一篇文章，我们将进一步深化，讲讲如何利用 AI 来实现<code>数据建模</code>(画 ER 图)，敬请期待。同时求赞求关注求收藏，你也可以直接订阅这个专栏。</p><p><br><br><br></p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p>本文用到的技巧</p><ul><li><a href="https://learningprompt.wiki/docs/chatGPT/tutorial-extras/Zero-Shot%20Prompts" target="_blank" rel="noopener">Zero-Shot Prompts</a></li><li><a href="https://learningprompt.wiki/docs/chatGPT/tutorial-tips/%E6%8A%80%E5%B7%A75%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E6%8C%87%E4%BB%A4%E5%92%8C%E9%9C%80%E8%A6%81%E5%A4%84%E7%90%86%E7%9A%84%E6%96%87%E6%9C%AC%E5%88%86%E5%BC%80" target="_blank" rel="noopener">技巧 5：使用特殊符号指令和需要处理的文本分开</a></li><li><a href="https://learningprompt.wiki/docs/chatGPT/tutorial-extras/ChatGPT%20Prompt%20Framework" target="_blank" rel="noopener">CRISPE Prompt Framework</a></li></ul><p>学习 Prompt</p><ul><li><a href="https://learningprompt.wiki/docs/chatGPT/tutorial-basics/%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%20&amp;%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/scenario-1-ask-questions" target="_blank" rel="noopener">Learning Prompt</a></li><li><a href="https://www.deeplearning.ai/short-courses/chatgpt-prompt-engineering-for-developers/" target="_blank" rel="noopener">ChatGPT Prompt Engineering for Developers</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/ai-sql-master/Untitled.jpeg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;ChatGPT 在年初爆火，成为街头巷尾热议的话题。现在的 AI 应该算是目前最卷的赛道了，从卖账号、套壳客户端、 割韭菜教程、大厂争先发布
      
    
    </summary>
    
      <category term="AI" scheme="https://bobi.ink/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>2B or not 2B: 前端大泥球</title>
    <link href="https://bobi.ink/2023/07/20/to-be-shit/"/>
    <id>https://bobi.ink/2023/07/20/to-be-shit/</id>
    <published>2023-07-19T16:00:00.000Z</published>
    <updated>2023-07-20T03:05:33.711Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/to-be-shit/Untitled.jpeg" alt="cover"></p><p>今天给大家带来的是 2B 领域的一个架构难题，我们最终也没有找到一个较好「解决」方案， 或者说它本来就是一个伪命题。</p><p>让我慢慢跟你道来…</p><p><br><br><br></p><h1 id="软件的划分模式"><a href="#软件的划分模式" class="headerlink" title="软件的划分模式"></a>软件的划分模式</h1><p>首先从软件系统的划分模式讲起。<strong>软件系统的划分有很多种方式，拆分的目的无非都是：分治、复用、隔离、扩展性、抽象等等。</strong></p><p><br></p><hr><p><br></p><p><strong>最为常见的便是<code>分层架构</code></strong></p><p>分层架构将软件系统划分为若干层次，每个层次都是相互独立的，各自负责不同的功能和职责，通过明确的接口和协议进行通信，从而实现系统的可扩展性、可维护性、可测试性、可重用性等特点。</p><p>比如一个典型的 Web 系统的“三层架构”：</p><ul><li><code>表示层（Presentation Layer）</code>：负责用户界面、用户交互和用户输入输出等功能，通过 Web 页面或者客户端应用来展示和控制数据的呈现方式。</li><li><code>业务逻辑层（Business Logic Layer</code>）：负责系统的业务逻辑处理、数据处理和其他业务规则的实现，为表示层提供数据和业务逻辑的支持。</li><li><code>数据访问层（Data Access Layer）</code>：负责数据的存储和访问，为业务逻辑层提供数据访问的接口和实现。</li></ul><p><img src="/images/to-be-shit/Untitled.png" alt="分层"></p><p><br></p><hr><p><br></p><p><strong>微服务架构</strong></p><p>随着系统的复杂化，我们需要将系统拆分为更小的子系统，来解决性能、维护性、扩展性等诸多问题。比如引入了微服务、微前端等解决方案，这个本质上是一种<code>垂直方向的拆分</code>：</p><p><img src="/images/to-be-shit/Untitled%201.png" alt="垂直拆分"></p><p>甚至我们在应用内部还会进一步拆分, 按照业务聚合度拆分成不同的模块：</p><p><img src="/images/to-be-shit/Untitled%202.png" alt="领域拆分"></p><p>这就是分治的魅力吧。</p><p><br><br><br><br><br></p><h1 id="多业态"><a href="#多业态" class="headerlink" title="多业态"></a>多业态</h1><p>在 2B 领域，让我们更棘手的是，还要面临<code>多业态问题</code>。</p><p><br></p><p><strong>什么是多业态？</strong></p><p>让 <code>ChatGPT</code> 来解释一下：<em>多业态是指一个企业或者品牌在不同的业务领域或行业中拥有不同的业态，例如同一个品牌既可以开设餐厅，也可以开设酒店、咖啡店、快餐店、影院等不同的业态。多业态的企业或品牌通过在不同的业态中提供不同的产品和服务，以满足不同消费者的需求和偏好，增加企业的收入和市场份额</em>。</p><p><strong>多业态并不是一种结果，而是一种手段</strong>。比如在垂直领域耕耘多年的企业，想要扩大创收，就会将触角伸到其他行业，即所谓的跨界。还有就是一些初创企业，就像无头苍蝇一样，将网撒向不同的行业，来摸索出路。</p><p>我们就是属于后者。不过也有可能前期策略是在模仿<code>有赞</code> 的嫌疑(<em>毕竟有赞在 18、19 年是当红的 SaaS 炸子鸡</em>)，铺设了很多行业：医药、教育、文旅、零售、地产、汽车…</p><p>也就是说在这种「广撒网」的商业策略下, 我们需要在「一套代码」中适配“多业态”：</p><p><img src="/images/to-be-shit/Untitled%203.png" alt="多业态"></p><p>然而多业态并不是简单的<code>垂直方向</code>的进一步细分，而是多了一个<code>维度</code>。如果说分层是 1D、 垂直划分是 2D、再加上多业态，就是 3D 了！</p><p><strong>这些<code>行业多态</code>会横向击穿垂直拆分后的模块壁垒，行业的多样性会渗透到程序的各个角落，开闭原则形同虚设。不管是前端还是后端，这是都是一个非常大的挑战。</strong></p><p>现状就是本文标题中讲的，多了一个维度之后，对开发而言是灾难性性，整个项目就是一个大泥球。</p><p>所有行业的代码都堆砌在一起，充斥着各种区分行业的 if/else 语句、耦合牵扯、渗透在项目的各个角落… 总之这可能是程序生涯难得一见的代码屎山！</p><p><img src="/images/to-be-shit/Untitled%204.png" alt="给大家一个直观的体验"><br>给大家一个直观的体验</p><p><br><br><br></p><p>垂直的软件拆分有很多方法论，比如微服务、 DDD。而多业态，在软件行业并找不到太多这样的最佳实践。</p><p>且不论这是否是战略上的错误。作为技术开发我们只能服从它， 并需求在战术上进行弥补。<strong>企业对软件开发的要求并不会因此降低，它还是会要求你的代码要区别「复用性」，要能快速应变各种需求、支持快速迭代…</strong></p><p><img src="/images/to-be-shit/Untitled%205.png" alt="产品架构"><br>产品架构</p><p><br></p><p>上图是我们团队基本结构，也是<code>产品结构</code>(康威定律)、更体现了我们的<code>项目交付模式</code>。很多非 SasS 化的 2B 公司的应该都是这类模式。</p><p>对我们来说更大的挑战在于：<strong>下游的项目能尽量复用上游的功能，避免重复工作，并且要求上游的更新能向下传递，甚至不排除下游合并到上游的可能性。</strong></p><p>能感受到它的难度了吗？</p><p><br><br><br></p><h1 id="怎么解决？"><a href="#怎么解决？" class="headerlink" title="怎么解决？"></a>怎么解决？</h1><h2 id="战略上的调整"><a href="#战略上的调整" class="headerlink" title="战略上的调整"></a>战略上的调整</h2><p>从近几年组织架构上面的调整，可以反映软件架构的战略调整，它定下整个研发体系的基调。另外这些变化，也反映了我们对 2B 行业探索和认知上面的变化：</p><p><img src="/images/to-be-shit/Untitled%206.png" alt="单体团队"></p><p>初创团队就是一个单体团队(左图所示)，接着开始多行业撒网，原本的项目上慢慢堆砌出各种行业的形态(右图所示)。</p><p><br></p><hr><p><br></p><p><img src="/images/to-be-shit/Untitled%207.png" alt="拆分事业部"></p><p>随着业务发展起来，一些发展较好的行业成立了事业部，专门负责项目的交付。</p><p><br></p><hr><p><br></p><p><img src="/images/to-be-shit/Untitled%208.png" alt="行业标品"></p><p>随着行业的深入，事业部慢慢积累起来了更多行业 <code>Known How</code>，通用的标品已经无法满足需求，事业部开始成立<code>行业标品团队</code>，在行业标准化产品上做更多深入的定制开发；另外事业部内部继续细分专门的交付团队。</p><blockquote><p>💡 行业 Known How 指的是某个行业内部特定的、非公开的知识和技术，通常只有在该行业内部的从业人员才能够掌握和理解。这些知识和技术可能包括行业内部的标准、工艺、流程、技术、经验等方面的内容，是行业内部的核心竞争力和商业机密。</p></blockquote><p>到这个阶段「产品研发」开发的「标品」就处于一种比较尴尬的位置。一来它毕竟不是为特定行业打造的，已经不能满足行业的定制化需求，无法实现开箱即用；二来产品研发部门离真实的客户也比较远，很容易闭门造车，产品没有经过市场打磨，质量较差。</p><p>人们开始对「产品研发部」的价值产生了怀疑。</p><p><br></p><hr><p><br></p><p><img src="/images/to-be-shit/Untitled%209.png" alt="平台化"></p><p>于是「产品研发」的出路是继续做下沉，不再做所谓的大而全标品，而是做好核心的<code>平台化能力</code>，比如会员体系、CDP、SCRM、MA(Marketing Automation)…</p><p>这些平台化能力，剥离了具体的行业属性，并向未来的 SaaS 化靠拢。</p><p><br></p><hr><p><br><br><br></p><p><strong>多业态的架构难题，从笔者的角度来看，在战术上是基本是无解的</strong>。通过上面的战略调整可以看出，我们慢慢规避了这些问题。</p><p>也就说，我们没有解决它，而是绕过了它，甚至说我们放弃了这条路线也不为过。</p><p>通过上面的调整我们可以看到：</p><ul><li>覆盖的行业在慢慢收敛，不赚钱的、走不通的行业干脆就放弃了。</li><li>另一方面，在具体行业和平台上更加专注，不再追求打造一个大而全的、可以覆盖多行业的单一产品。</li></ul><p><br><br><br><br><br></p><h2 id="战术上的适配"><a href="#战术上的适配" class="headerlink" title="战术上的适配"></a>战术上的适配</h2><p>虽然，我们最终通过战略上的调整规避了多业态架构难题，但这毕竟是「<code>果</code>」。推动战略上调整的「<code>因</code>」，并不是因为战术上的实施难度，而是企业的市场适应。</p><p>虽然战略的调整可以从根上解决了问题，但这是一个漫长的演进过程(大概五年)。 一开始我们也预料不到现在的结局。因此在过去相当长的时间内，我们一直都在尝试<code>战术层面</code>去解决多业态问题。</p><p>下面讲一讲，前端是怎么应对这些问题。</p><p><br><br><br></p><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>首先确立一些行事的原则，作为后面具体实施的指导方向， 比如：</p><ul><li><strong>统一规范</strong>。完整的项目版图设计到很多团队、上下游的参与，我们必须统一规范。</li><li><strong>保持沟通</strong>。因为我们需要拉通上下游，进行一些知识和代码的传递，沟通是很重要的。</li><li><strong>更新/联动，隔离/复用机制</strong>。我们需要在框架层面提供代码上下游更新、联动，复用、隔离等机制。</li><li><strong>生态共建</strong>。规定上下游团队需要一起共建生态，沉淀知识和行业 Known How.</li><li><strong>互不影响、独立开发、独立部署</strong>。</li><li><strong>开闭原则</strong>。对下游扩展开放，对修改关闭。</li><li><strong>分离关注点</strong>。</li></ul><p><br><br><br></p><h3 id="确立共建的范围和上下游的协作关系"><a href="#确立共建的范围和上下游的协作关系" class="headerlink" title="确立共建的范围和上下游的协作关系"></a>确立共建的范围和上下游的协作关系</h3><p><img src="/images/to-be-shit/Untitled%2010.png" alt="协同"></p><p>即定义了一些团队之间的协作规范，比如：</p><ul><li>上下游团队之间责任划分、共建的范围</li><li>沟通机制</li><li>发布更新的频率和形式</li><li>分支规范等等</li></ul><p><br><br><br></p><h3 id="宏观上：行业隔离-业务聚合"><a href="#宏观上：行业隔离-业务聚合" class="headerlink" title="宏观上：行业隔离/业务聚合"></a>宏观上：行业隔离/业务聚合</h3><p>在宏观的层面上，定义了两大措施或建议：</p><ol><li><strong>行业隔离</strong>。为了隔离不同业态，我们提出了两个措施<ul><li>分支隔离。不同业态有不同的分支前缀(比如<code>团队名/dev</code>、<code>团队名/master</code>)，从而做到开发上互不干扰。可以从上游标品团队的分支中<code>单向合并</code>，来实现下游同步</li><li>模块/文件的隔离。在这里我们主要使用<code>业态扩展名</code>， 比如 <code>index.js</code>、<code>index.ky.js</code>、<code>index.home.js</code>, 有点类似于 <code>React Native</code>（<code>*.android.js</code>, <code>*.ios.js</code>） 或者 <code>Taro</code> 的特定平台文件。在编译时，根据当前业态进行条件编译。</li></ul></li><li><p><strong>按照业务聚合</strong>。模块按照业务进行聚合，而不是根据菜单/职能：</p><ul><li>❌  菜单。这个问题主要出在 B 端，很多前端理所当然会按照导航菜单来拆分应用，问题就是菜单并不一定能准确地表达业务的边界，而且菜单是多变的，受运营的影响比较大。<br>这个我在 <a href="https://www.notion.so/b590284a71934f97a1db71ef967fbc5a?pvs=21" target="_blank" rel="noopener">微前端的落地和治理实战</a> 中也有讨论</li><li><p>❌  职能聚合。例如, 全局按照职能划分目录，所有业务模块都堆在一起</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">  /components</span><br><span class="line">  A.js</span><br><span class="line">    B.js</span><br><span class="line">  /pages</span><br><span class="line">  /api</span><br><span class="line">  /...</span><br></pre></td></tr></table></figure></li><li><p>✅ 业务聚合。<strong>按照业务领域的边界进行垂直的拆分：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">A 领域</span><br><span class="line">  /components</span><br><span class="line">  /pages</span><br><span class="line">  /api</span><br><span class="line"></span><br><span class="line">B 领域</span><br><span class="line">  /components</span><br><span class="line">  /pages</span><br><span class="line">  /api</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><br><br><br><br><br></p><h3 id="微观上：复用和扩展模式"><a href="#微观上：复用和扩展模式" class="headerlink" title="微观上：复用和扩展模式"></a>微观上：复用和扩展模式</h3><p>宏观的分支、业态扩展名可以实现<code>行业隔离</code>，让多个团队在同一个仓库下互不干扰，又可以融合开发。</p><p>而微观上层面，主要关注代码的复用和扩展机制，目的则是让行业能够最大限度地「复用」<code>标品</code>的功能和代码。</p><p><br><br><br></p><p>笔者在实践过程中，总结了很多「设计模式」， 比如：</p><table><thead><tr><th>模式</th><th>灵感来源</th><th>概要说明</th><th>适用场景</th></tr></thead><tbody><tr><td>原子能力组合模式</td><td>低代码平台，前端组件化搭建，流程编排</td><td>先对应用程序进行分层，再组成拆分原子能力。实现自上而下的可组合。</td><td>应用的整体架构</td></tr><tr><td>插件模式</td><td>VSCode、各种支持插件的工具</td><td>分离关注点，提取核心能力和外壳。通过插件接口扩展核心能力。</td><td>固定、稳定的业务</td></tr><tr><td>钩子模式</td><td>很多 Web 框架都提供了钩子函数、或者生命周期方法，对框架进行扩展</td><td>预留插槽，按需填充。</td><td>+ 适合比较固化的业务流程，比如登录、下单<br> + 适合比较固化的界面布局，通过插槽扩展某个区块的显示</td></tr><tr><td>覆盖模式</td><td>依赖注入</td><td>通过依赖注入覆盖原有的实现</td><td></td></tr><tr><td>继承模式</td><td>类继承</td><td>在覆盖模式基础深入定制</td><td>实现文件级别的覆盖，完全重新实现功能。和 index 导出兼容。业态隔离</td></tr><tr><td>重复/隔离模式</td><td>React Native、Taro 条件编译</td><td>无可退路的退路。拷贝代码，深度定制，互不干扰</td><td>差异性较大，没有合理扩展方案的情况</td></tr></tbody></table><p>由于文章篇幅原因，<strong>关于这些设计模式的细节，请<a href="https://www.notion.so/358c4bafc42b42acacab2c74f3f21593?pvs=21" target="_blank" rel="noopener">移步到这里</a></strong></p><p><br><br><br><br><br></p><h1 id="没有银弹"><a href="#没有银弹" class="headerlink" title="没有银弹"></a>没有银弹</h1><p>在多业态的架构难题上，笔者并没有想到行之有效的办法。反而随着战略的调整，这个问题变得不再重要。</p><p>上文介绍的战术适配，也仅仅能够实现「隔离」问题。而「复用」问题，我只是给出了一些设计模式，实际执行起来比较困难：一则是需求的变化和多样性足以打破各种美好的假设； 二来这会提升复杂度，不是所有开发者都具备良好的架构设计素养。</p><p>最后，随着市场的变化，驱动企业战略上的调整，企业家逐渐放弃了在产品上做大做全的幻想。 我们的各种挣扎，最终不过是炮灰，并没有太多实际的意义。</p><p><br><br><br></p><p>当然，对我来说也不是一无所获，<strong>历史经验教训</strong>:</p><ul><li>不要过度追求复用。它是一把双刃剑，重复不见得就是坏事，我们需要在复用性和隔离性之间权衡利弊。</li><li>不要追求大而全。更要做深做精。</li><li>用奥卡姆剃刀做减法。放弃那些不切实际的幻想。</li><li>战略和战术配合。不要只在战术层面钻牛角尖。</li><li>Keep it simple and stupid。 简单即是美，在设计和开发过程中，尽量追求简单和易于理解的方案，避免过度设计和复杂性。关注用户最核心的需求。</li></ul><p><br></p><p>本文完，求赞求收藏求转发。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/to-be-shit/Untitled.jpeg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天给大家带来的是 2B 领域的一个架构难题，我们最终也没有找到一个较好「解决」方案， 或者说它本来就是一个伪命题。&lt;/p&gt;
&lt;p&gt;让我慢慢跟你道
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>TypeScript 接口合并， 你不知道的妙用</title>
    <link href="https://bobi.ink/2023/07/17/ts-interface-merge/"/>
    <id>https://bobi.ink/2023/07/17/ts-interface-merge/</id>
    <published>2023-07-16T16:00:00.000Z</published>
    <updated>2023-07-17T06:34:55.473Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ts-interface-merge/Untitled.jpeg" alt="Untitled"></p><p><br></p><h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><p><a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces" target="_blank" rel="noopener">声明合并(Declaration Merging)</a> 是 <code>Typescript</code> 的一个高级特性，顾名思义，<code>声明合并</code>就是将相同名称的一个或多个声明合并为单个定义。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Box &#123;</span><br><span class="line">  height: number;</span><br><span class="line">  width: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Box &#123;</span><br><span class="line">  scale: number;</span><br><span class="line">&#125;</span><br><span class="line">let box: Box = &#123; height: 5, width: 6, scale: 10 &#125;;</span><br><span class="line"></span><br><span class="line">interface Cloner &#123;</span><br><span class="line">  clone(animal: Animal): Animal;</span><br><span class="line">&#125;</span><br><span class="line">interface Cloner &#123;</span><br><span class="line">  clone(animal: Sheep): Sheep;</span><br><span class="line">&#125;</span><br><span class="line">interface Cloner &#123;</span><br><span class="line">  clone(animal: Dog): Dog;</span><br><span class="line">  clone(animal: Cat): Cat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Cloner 将合并为</span><br><span class="line">//interface Cloner &#123;</span><br><span class="line">//  clone(animal: Dog): Dog;</span><br><span class="line">//  clone(animal: Cat): Cat;</span><br><span class="line">//  clone(animal: Sheep): Sheep;</span><br><span class="line">//  clone(animal: Animal): Animal;</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>声明合并最初的设计目的是为了解决早期 <code>JavaScript</code> 模块化开发中的类型定义问题。</p><ul><li>早期的 JavaScript 库基本都使用全局的<code>命名空间</code>，比如  <code>jQuery</code>  使用 <code>$</code>, <code>lodash</code> 使用 <code>_</code>。这些库通常还允许对命名空间进行扩展，比如 jQuery 很多插件就是扩展 $ 的原型方法</li><li>早期很多 Javascript 库也会去扩展或覆盖 JavaScript 内置对象的原型。比如古早的 RxJS 就会去 「Monkey Patching」 JavaScript 的 Array、Function 等内置原型对象。</li></ul><p><br><br><br></p><p>尽管这些方案在当今已经属于「反模式」了，但是在 Typescript 2012 年发布那个年代， jQuery 还是王者。</p><p><br></p><p>Typescript 通过类型合并这种机制，支持将分散到不同的文件中的命名空间的类型定义合并起来，避免编译错误。</p><p>现在是 ES Module 当道， 命名空间的模式已经不再流行。但是不妨碍 <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces" target="_blank" rel="noopener">声明合并</a> 继续发光发热，本文就讲讲它几个有趣的使用场景。</p><p><br><br><br><br><br></p><h1 id="jsx-内置组件声明"><a href="#jsx-内置组件声明" class="headerlink" title="JSX 内置组件声明"></a>JSX 内置组件声明</h1><p>Typescript 下，内置的组件(<code>Host Components</code>) 都挂载在 <code>JSX</code> 命名空间下的 <code>IntrinsicElements</code> 接口中。例如 Vue 的 JSX 声明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// somehow we have to copy=pase the jsx-runtime types here to make TypeScript happy</span><br><span class="line">import type &#123;</span><br><span class="line">  VNode,</span><br><span class="line">  IntrinsicElementAttributes,</span><br><span class="line">  ReservedProps,</span><br><span class="line">  NativeElements</span><br><span class="line">&#125; from &apos;@vue/runtime-dom&apos;</span><br><span class="line"></span><br><span class="line">// 🔴 全局作用域</span><br><span class="line">declare global &#123;</span><br><span class="line">  namespace JSX &#123;</span><br><span class="line">    export interface Element extends VNode &#123;&#125;</span><br><span class="line">    export interface ElementClass &#123;</span><br><span class="line">      $props: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    export interface ElementAttributesProperty &#123;</span><br><span class="line">      $props: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 🔴 内置组件定义</span><br><span class="line">    export interface IntrinsicElements extends NativeElements &#123;</span><br><span class="line">      // allow arbitrary elements</span><br><span class="line">      // @ts-ignore suppress ts:2374 = Duplicate string index signature.</span><br><span class="line">      [name: string]: any</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    export interface IntrinsicAttributes extends ReservedProps &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>我们也可以随意地扩展 IntrinsicElements，举个例子，我们开发了一些 <code>Web Component</code> 组件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare global &#123;</span><br><span class="line">  namespace JSX &#123;</span><br><span class="line">    export interface IntrinsicElements &#123;</span><br><span class="line">      &apos;wkc-header&apos;: &#123;</span><br><span class="line">        // props 定义</span><br><span class="line">        title?: string;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>💡 上面例子中 JSX 是放在 <code>global</code> 空间下的，某些极端的场景下，比如有多个库都扩展了它，或者你即用了 Vue 又用了 React， 那么就会互相污染。<br> 现在 Typescript 也支持 JSX 定义的局部化，配合 <a href="https://www.typescriptlang.org/tsconfig#jsxImportSource" target="_blank" rel="noopener">jsxImportSource</a> 选项来开启， 参考 <a href="https://github.com/vuejs/core/blob/main/packages/vue/jsx-runtime/index.d.ts" target="_blank" rel="noopener">Vue 的实现</a></p></blockquote><p><br><br><br><br><br></p><h1 id="vue-全局组件声明"><a href="#vue-全局组件声明" class="headerlink" title="Vue 全局组件声明"></a>Vue 全局组件声明</h1><p>和 JSX 类似， Vue 全局组件、全局属性等声明也通过接口合并来实现。下面是 vue-router 的代码示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare module &apos;@vue/runtime-core&apos; &#123;</span><br><span class="line">  // Optional API 扩展</span><br><span class="line">  export interface ComponentCustomOptions &#123;</span><br><span class="line">    beforeRouteEnter?: TypesConfig extends Record&lt;&apos;beforeRouteEnter&apos;, infer T&gt;</span><br><span class="line">      ? T</span><br><span class="line">      : NavigationGuardWithThis&lt;undefined&gt;</span><br><span class="line">    beforeRouteUpdate?: TypesConfig extends Record&lt;&apos;beforeRouteUpdate&apos;, infer T&gt;</span><br><span class="line">      ? T</span><br><span class="line">      : NavigationGuard</span><br><span class="line">    beforeRouteLeave?: TypesConfig extends Record&lt;&apos;beforeRouteLeave&apos;, infer T&gt;</span><br><span class="line">      ? T</span><br><span class="line">      : NavigationGuard</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 组件实例属性</span><br><span class="line">  export interface ComponentCustomProperties &#123;</span><br><span class="line">    $route: TypesConfig extends Record&lt;&apos;$route&apos;, infer T&gt;</span><br><span class="line">      ? T</span><br><span class="line">      : RouteLocationNormalizedLoaded</span><br><span class="line">    $router: TypesConfig extends Record&lt;&apos;$router&apos;, infer T&gt; ? T : Router</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 🔴 全局组件</span><br><span class="line">  export interface GlobalComponents &#123;</span><br><span class="line">    RouterView: TypesConfig extends Record&lt;&apos;RouterView&apos;, infer T&gt;</span><br><span class="line">      ? T</span><br><span class="line">      : typeof RouterView</span><br><span class="line">    RouterLink: TypesConfig extends Record&lt;&apos;RouterLink&apos;, infer T&gt;</span><br><span class="line">      ? T</span><br><span class="line">      : typeof RouterLink</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>上面我们见识了 JSX 使用 <code>declare global</code>  来挂载<code>全局作用域</code>，而 <code>declare module *</code> 则可以挂载到<code>具体模块的作用域</code>中。</p><p><br></p><p>另外，我们在定义 Vue Route 时，通常会使用 meta 来定义一些路由元数据，比如标题、权限信息等,  也可以通过上面的方式来实现：</p><p><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare module &apos;vue-router&apos; &#123;</span><br><span class="line">  interface RouteMeta &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 是否显示面包屑, 默认 false</span><br><span class="line">     */</span><br><span class="line">    breadcrumb?: boolean</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 标题</span><br><span class="line">     */</span><br><span class="line">    title?: string</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 所需权限</span><br><span class="line">     */</span><br><span class="line">    permissions?: string[]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const routes: RouteRecordRaw[] = [ </span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/club/plugins&apos;,</span><br><span class="line">    name: &apos;custom-club-plugins&apos;,</span><br><span class="line">    component: () =&gt; import(&apos;./plugins&apos;),</span><br><span class="line">    // 现在 meta 就支持类型检查了</span><br><span class="line">    meta: &#123;</span><br><span class="line">      breadcrumb: true,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h1 id="依赖注入：实现标识符和类型信息绑定"><a href="#依赖注入：实现标识符和类型信息绑定" class="headerlink" title="依赖注入：实现标识符和类型信息绑定"></a>依赖注入：实现标识符和类型信息绑定</h1><p>还有一个比较有趣的使用场景，即依赖注入。我们在使用 <code>[InversifyJS](https://github.com/inversify/InversifyJS)</code> 这里依赖注入库时，通常都会使用字符串或者 Symbol 来作为依赖注入的<code>标识符</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// inversify 示例</span><br><span class="line">// 定义标识符</span><br><span class="line">const TYPES = &#123;</span><br><span class="line">    Warrior: Symbol.for(&quot;Warrior&quot;),</span><br><span class="line">    Weapon: Symbol.for(&quot;Weapon&quot;),</span><br><span class="line">    ThrowableWeapon: Symbol.for(&quot;ThrowableWeapon&quot;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@injectable()</span><br><span class="line">class Ninja implements Warrior &#123;</span><br><span class="line">    @inject(TYPES.Weapon) private _katana: Weapon;</span><br><span class="line">    @inject(TYPES.ThrowableWeapon) private _shuriken: ThrowableWeapon;</span><br><span class="line">    public fight() &#123; return this._katana.hit(); &#125;</span><br><span class="line">    public sneak() &#123; return this._shuriken.throw(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>但是这种标识符没有关联任何类型信息，无法进行类型检查和推断。</p><p><br></p><p>于是，笔者就想到了<code>接口合并</code>。能不能利用它来实现标识符和类型之间的绑定？答案是可以的：</p><p>我们可以声明一个全局的 <code>DIMapper</code> 接口。这个接口的 key 为依赖注入的标识符，value 为依赖注入绑定的类型信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare global &#123;</span><br><span class="line">  interface DIMapper &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>接下来，依赖注入的『供应商』，就可以用来声明标识符和注入类型的绑定关系：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface IPhone &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 打电话</span><br><span class="line">   */</span><br><span class="line">  call(num: string): void</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 发短信</span><br><span class="line">   */</span><br><span class="line">  sendMessage(num: string, message: string): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 表示 DI.IPhone 这个标识符关联的就是 IPhone 接口类型</span><br><span class="line">declare global &#123;</span><br><span class="line">  interface DIMapper &#123;</span><br><span class="line">    &apos;DI.IPhone&apos;: IPhone</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>我们稍微改造一下依赖注入相关方法的实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取所有依赖注入标识符</span><br><span class="line"> */</span><br><span class="line">export type DIIdentifier = keyof DIMapper;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 计算依赖注入值类型</span><br><span class="line"> */</span><br><span class="line">export type DIValue&lt;T extends DIIdentifier&gt; = DIMapper[T];</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 注册依赖</span><br><span class="line"> */</span><br><span class="line">export function registerClass&lt;I extends DIIdentifier, T extends DIValue&lt;I&gt;&gt;(</span><br><span class="line">  identifier: I,</span><br><span class="line">  target: new (...args: never[]) =&gt; T,</span><br><span class="line">): void</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取依赖</span><br><span class="line"> */</span><br><span class="line">export function useInject&lt;I extends DIIdentifier, T extends DIValue&lt;I&gt;&gt;(</span><br><span class="line">  identifier: I,</span><br><span class="line">  defaultValue?: T,</span><br><span class="line">): T</span><br></pre></td></tr></table></figure><p><br></p><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo &#123;&#125;</span><br><span class="line">class MI &#123;</span><br><span class="line">  call(num: string) &#123;&#125;</span><br><span class="line">  sendMessage(num: string, message: string) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">registerClass(&apos;DI.IPhone&apos;, Foo) // ❌ 这个会报错，Foo 不符合 IPhone 接口</span><br><span class="line">registerClass(&apos;DI.IPhone&apos;, MI) // ✅ OK!</span><br><span class="line"></span><br><span class="line">const phone = useInject(&apos;DI.IPhone&apos;) // phone 自动推断为 IPhone 类型</span><br></pre></td></tr></table></figure><blockquote><p>💡 对于依赖注入，我在 <a href="https://juejin.cn/post/7250356064989397053" target="_blank" rel="noopener">全新 JavaScript 装饰器实战下篇：实现依赖注入</a>， 介绍了另外一种更加严格和友好的方式。</p></blockquote><p><br><br><br><br><br></p><h1 id="事件订阅"><a href="#事件订阅" class="headerlink" title="事件订阅"></a>事件订阅</h1><p>同样的办法也可以用于<code>事件订阅</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare global &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 声明 事件 标识符和类型的映射关系</span><br><span class="line">   * @example 扩展定义</span><br><span class="line">   * declare global &#123;</span><br><span class="line">   *   interface EventMapper &#123;</span><br><span class="line">   *     &apos;Event.foo.success&apos;: ISuccessMessage</span><br><span class="line">   *   &#125;</span><br><span class="line">   * &#125;</span><br><span class="line">   */</span><br><span class="line">  interface EventMapper &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 事件名称</span><br><span class="line"> */</span><br><span class="line">export type EventName = keyof EventMapper;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 事件参数</span><br><span class="line"> */</span><br><span class="line">export type EventArgument&lt;T extends EventName&gt; = EventMapper[T];</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>EventBus 实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export class EventBus &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 监听事件</span><br><span class="line">   */</span><br><span class="line">  on&lt;N extends EventName, A extends EventArgument&lt;N&gt;&gt;(event: N, callback: (arg: A) =&gt; void) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 触发事件</span><br><span class="line"></span><br><span class="line">   */</span><br><span class="line">  emit&lt;N extends EventName, A extends EventArgument&lt;N&gt;&gt;(event: N, arg: A) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h1 id="动态类型插槽"><a href="#动态类型插槽" class="headerlink" title="动态类型插槽"></a>动态类型插槽</h1><p>还有一个比较脑洞的例子，我之前封装过一个 Vue i18n 库，因为  Vue 2/3 差异有点大，所以我就拆了两个库来实现，如下图。<code>i18n</code> 用于  <code>Vue 3</code> + <code>vue-i18n@&gt;=9</code>, <code>i18n-legacy</code> 用于 <code>Vue 2</code> + <code>vue-i18n@8</code>。</p><p>但是两个库大部分的实现是一致的，这些共性部分就提取到 <code>i18n-shared</code> ：</p><p><img src="/images/ts-interface-merge/Untitled.png" alt="Untitled"></p><p>然而 <code>i18n-shared</code> 并不耦合 <code>Vue</code> 和 <code>vue-i18n</code> 的版本，也不可能将它们声明为依赖项， 那么它相关 API 的类型怎么办呢？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// i18n-shared 代码片段</span><br><span class="line">export interface I18nInstance &#123;</span><br><span class="line">  /**</span><br><span class="line">   * vue 插件安装</span><br><span class="line">   * 🔴 VueApp 是 Vue App 的实例</span><br><span class="line">   */</span><br><span class="line">  install(app: VueApp): void;</span><br><span class="line"></span><br><span class="line">  // 🔴 vue-i18n 的实例</span><br><span class="line">  i18n: VueI18nInstance;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取全局实例</span><br><span class="line"> * @returns</span><br><span class="line"> */</span><br><span class="line">export function getGlobalInstance(): I18nInstance &#123;</span><br><span class="line">  if (globalInstance == null) &#123;</span><br><span class="line">    throw new Error(`请先使用 createI18n 创建实例`);</span><br><span class="line">  &#125;</span><br><span class="line">  return globalInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取全局 vue i18n 实例</span><br><span class="line"> */</span><br><span class="line">export function getGlobalI18n(): I18nInstance[&apos;i18n&apos;] &#123;</span><br><span class="line">  return getGlobalInstance().i18n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>这里用<code>泛型</code>也解决不了问题。</p><p>一些奇巧淫技还得是类型合并。我在这里就巧妙地使用了类型合并来创建<code>类型插槽。</code></p><p>首先在 <code>i18n-shared</code> 下预定义一个接口：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 🔴 供子模块详细定义类型参数</span><br><span class="line"> */</span><br><span class="line">export interface I18nSharedTypeParams &#123;</span><br><span class="line">  // VueI18nInstance: vue i18n 实例类型</span><br><span class="line">  // FallbackLocale</span><br><span class="line">  // VueApp 应用类型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 提取参数</span><br><span class="line">// @ts-expect-error</span><br><span class="line">type ExtraParams&lt;T, V = I18nSharedTypeParams[T]&gt; = V;</span><br><span class="line"></span><br><span class="line">export type VueApp = ExtraParams&lt;&apos;VueApp&apos;&gt;;</span><br><span class="line">export type VueI18nInstance = ExtraParams&lt;&apos;VueI18nInstance&apos;&gt;;</span><br></pre></td></tr></table></figure><p><br></p><p>定义了一个接口 <code>I18nSharedTypeParams</code>，<strong>它具体的类型由下级的库来注入</strong>，我尚且把它命名为 “<code>动态类型插槽</code>” 吧。</p><p>现在 <code>i18n</code> 和 <code>i18n-legacy</code> 就可以根据自己的依赖环境来配置它了：</p><p><br><br><br></p><p>i18n-legacy:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import VueI18n from &apos;vue-i18n&apos;; // vue-i18n@8</span><br><span class="line">import Vue from &apos;vue&apos;; // vue@2</span><br><span class="line"></span><br><span class="line">declare module &apos;i18n-shared&apos; &#123;</span><br><span class="line">  export interface I18nSharedTypeParams &#123;</span><br><span class="line">    VueI18nInstance: VueI18n;</span><br><span class="line">    VueApp: typeof Vue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>i18n:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; VueI18n, Composer &#125; from &apos;vue-i18n&apos;; // vue-i18n@9+</span><br><span class="line">import &#123; App &#125; from &apos;vue&apos;; // vue@3</span><br><span class="line"></span><br><span class="line">declare module &apos;i18n-shared&apos; &#123;</span><br><span class="line">  interface I18nSharedTypeParams &#123;</span><br><span class="line">    VueI18nInstance: VueI18n&lt;any, any, any&gt; | Composer&lt;any, any, any&gt;;</span><br><span class="line">    VueApp: App;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>💡 源码可以<a href="https://github.com/wakeadmin/tools/blob/db3809305e5698ac31a130319f430377a0e9c1be/packages/i18n-shared/src/types.ts#L45" target="_blank" rel="noopener">看这里</a></p></blockquote><p><br><br><br><br><br></p><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>当你深入了解了类型合并之后，你可能会在越来越多的地方发现它的身影。这毕竟是 TypeScript 为数不多，支持动态去扩展类型的特性。</p><p>更多的场景，读者可以开开脑洞，比如：</p><ul><li><code>unplugin-vue-components</code>  Vue 组件自动导入是如何支持类型检查的？</li><li><a href="https://github.com/posva/unplugin-vue-router" target="_blank" rel="noopener">unplugin-vue-router</a> 如何实现支持类型检查的 vue-router?</li><li>给插件系统加上类型检查</li><li>…</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/ts-interface-merge/Untitled.jpeg&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;初识&quot;&gt;&lt;a href=&quot;#初识&quot; class=&quot;headerlink&quot; title=&quot;初
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>微前端的落地和治理实战</title>
    <link href="https://bobi.ink/2023/07/13/microfrontend/"/>
    <id>https://bobi.ink/2023/07/13/microfrontend/</id>
    <published>2023-07-12T16:00:00.000Z</published>
    <updated>2023-07-13T02:11:54.631Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/microfrontend/Untitled.png" alt="Untitled"></p><p>微前端实现原理、框架选型之类的文章比较泛滥，我不打算讲这些玩意，本文主要来源于笔者过去一年落地微前端的一手经验，尽量不讲技术细节，而是讲一个体系化的方案是怎么搭建起来。</p><p>文章较长，耐心看完保证会有收获。</p><h1 id="背景与痛点"><a href="#背景与痛点" class="headerlink" title="背景与痛点"></a>背景与痛点</h1><p>首先来看下业务背景，方便读者了解我们为什么选择微前端，以及其他相关技术选型的原因。</p><p>前端在架构上面的变化远落后于后端，后端的架构已经经历了微服务、中台化、DDD 改造的腥风血雨…</p><p>在改造成微前端之前, 我们也是一个巨型的<code>单体应用</code>，后面随着业务的复杂化，业务和团队进一步进行拆分， 我们的前端项目也根据<a href="https://zh.wikipedia.org/zh-hans/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener"><code>康威定律</code></a>，进化成为了‘<code>多页应用</code>’， 如下图所示：</p><p><img src="/images/microfrontend/Untitled%201.png" alt="多页"></p><p><br></p><p>我们主要做的是 2B 业务，做 <a href="https://zh.wikipedia.org/zh-hans/%E6%A6%82%E5%BF%B5%E9%AA%8C%E8%AF%81" target="_blank" rel="noopener">POC</a>(概念验证) 和<code>私有化部署</code>是家常便饭，在已有的架构下，我们需要应用某些配置可能会牵扯多个项目，比如主题、文案、接口配置等信息的修改，需要针对多个项目进行创建分支、修改代码、构建、发布、部署… 一系列繁琐的流程</p><p>主要原因是我们的业务系统经过长期、多团队、多业态的迭代，积累了大量的技术债。</p><ul><li>技术栈老旧，开发效率低，我们想要应用新的技术和规范，但碍于项目体量大、质量差，重构举步维艰。</li><li>子应用的拆分没有固定的范式。有些模块按照团队拆分出独立的仓库，有些仓库则采用 MonoRepo。前者仓库之间存在大量重复代码、缺乏管理；而后者 MonoRepo 则越来越臃肿, 职责不清晰，编译缓慢, 逐渐也演变成了<code>巨石应用</code>。</li><li>基于多页的子应用缺乏管理，规范/标准不统一。无法统一控制视觉呈现、共享的功能和依赖。造成重复工作</li><li>新旧项目、第三方应用集成都很复杂。</li><li>多行业、多团队的项目特性，导致工程管理复杂，扩展性差。</li><li>部署方式原始。</li><li>应用按照菜单聚合，而不是按照业务聚合</li><li>…</li></ul><p><br></p><blockquote><p>💡  怎么理解 “应用按照菜单聚合，而不是按照业务聚合” 呢？</p><p><img src="/images/microfrontend/Untitled%202.png" alt="菜单聚合"></p><p><strong>朴素的多页应用通常按照“菜单”来拆分应用，比如按照上图的顶级 Tab。</strong></p><p>后面来这一个这样的需求，a 应用的某些功能菜单需要在 b Tab 下展示，这时候就傻眼了：</p><ul><li>把 a 的相关代码搬运到 b？如果后面菜单又改了怎么办？再说，你能搬得动吗？</li><li>用 iframe 将 a 套在 b 应用下？</li></ul></blockquote><p><br><br><br></p><p>因此我们亟需一套新的架构，<strong>能统一管理不同团队业务线、同时能够保持原本的独立性和灵活性</strong>。这时候微前端架构就进入了我们的考察范围：</p><p><img src="/images/microfrontend/Untitled%203.png" alt="星状"></p><p>我们需要一个「底座」将不同的应用聚合起来，将原本<code>离散</code>的应用通过一个<code>基座</code>串联起来：</p><ul><li><strong>离散的应用结构，转换为星状结构。</strong>基座可以统一管理子应用。</li><li><strong>开发者可以更专注于业务的开发</strong>。基座会提供配套的登录会话管理、权限管理、菜单管理、路由管理、主题管理等方案，子应用只需关心业务功能本身的开发。</li><li><strong>更容易地集成应用</strong>。不管是自己的业务应用、老旧系统、还是外部第三方应用，都可以在极少改动的情况下集成进来。</li><li><strong>视觉统一</strong>。</li><li><strong>拆分巨石应用，让子应用可以按照“业务聚合”</strong>。<strong>不再耦合菜单</strong>， 让应用更轻量、内聚、更可维护</li></ul><blockquote><p>💡  使用微前端之后，子应用不再耦合菜单，菜单由基座来管理和组合，菜单可以被放在任意位置。</p></blockquote><p><br></p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><strong>由于我们原本就是<code>多页应用</code>的架构，所以基于<code>路由分发</code> + <code>基座形式</code>的微前端方案是一种比较自然的选择</strong>。整体项目架构如下：</p><p><img src="/images/microfrontend/Untitled%204.png" alt="Untitled"></p><p>我们构造了一整套体系化的方案： 从<code>规范</code>到<code>开发基础库</code>、从<code>权限管理系统</code>到<code>微前端基座</code>、从<code>开发调试</code>到<code>部署运维</code>。</p><ol><li><strong>基础库：</strong>我们将每个应用都重复的工作提取出来，重新设计，并严格管理起来。使之能真正有效地服务业务开发，避免重复造轮子。</li><li><strong>开发规范</strong>：同时，我们期望提供更丰富的开发规范、指导、最佳实践作为支撑。让开发者走更少的弯路。</li><li><strong>权限管理平台</strong>：基座的<strong>菜单</strong>、<strong>权限信息</strong>来源于<code>权限管理平台</code>, 通过权限管理平台可以灵活地给不同业态、不同角色配置不同的菜单和权限。这是我们微前端方案的重要基础。</li><li><strong>基座:</strong> 基座是微前端应用集成的一个重要平台。同时也肩负着管理公共资源、依赖、规范的责任。主要有以下职责：<ul><li>子应用集成。给子应用提供渲染容器</li><li>路由/菜单管理</li><li>权限管理</li><li>主题管理</li><li>会话管理</li><li>多语言管理</li><li>共享依赖等</li></ul></li><li><p><strong>运行容器：<a href="https://wakeadmin.wakedata.com/mapp/deploy.html" target="_blank" rel="noopener">运行容器</a></strong>  是我们提供的一套微前端的运行和部署方案。相比传统纯粹的前端资源静态部署，我们希望在部署阶段可以做更多的事情：</p><ul><li>动态配置。比如域名配置、SEO 信息配置</li><li>主题管理。一键换肤能否实现？</li><li>子应用管理。自动发现子应用，而不是在微前端基座中硬编码？</li><li>语言包。能否实时配置语言包，而不需要重新编译代码、审核、发布…</li><li>开发环境、测试环境部署能否简化？</li></ul><p>得益于<code>运行容器</code>，我们可以实现<strong>前端部署的标准化</strong>，支持「<strong>一键部署」</strong>等能力。</p></li></ol><p><br><br><br><br><br><br><br></p><h1 id="基座"><a href="#基座" class="headerlink" title="基座"></a>基座</h1><p><img src="/images/microfrontend/Untitled%205.png" alt="基座主界面"></p><p>基座主界面</p><p>如上所示，基座为子应用提供了基础的运行环境， 蓝色区域为子应用的运行范围。</p><p><br></p><p><img src="/images/microfrontend/Untitled%206.png" alt="基座结构"></p><p>基座的大概结构如上。</p><p>首先是<code>会话管理</code>，基座会<code>拦截</code>应用的所有请求，如果监听到 401 状态码，则跳转到登录页面进行授权。登录/注册页面也是由子应用提供，我们尽量不让基座耦合具体的业务。</p><p><br></p><p>基座启动后，就会从<code>权限管理平台</code>拉取菜单、权限配置信息，渲染页面的菜单导航框架。同时也会对页面路由进行授权拦截，而细粒度的权限控制(比如按钮)，基座也会暴露 API 供子应用适配。</p><p><br></p><p>至于子应用信息，则是<strong>由<code>运行容器</code>自动发现并注入</strong>，避免在基座中硬编码了这些信息。基座底层基于 <a href="https://github.com/umijs/qiankun" target="_blank" rel="noopener">qiankun</a>，根据路由匹配渲染指定的子应用。</p><blockquote><p>💡 <code>运行容器</code>是啥? 这个我们会在下文介绍，简单来说，它就是一个 <code>NodeJS</code> 服务，会<strong>自动发现</strong>已经部署在服务器中的子应用，然后将这些信息注入到基座的启动代码中。</p></blockquote><p><br></p><p>基座还统一管理了<code>主题包</code>、<code>多语言</code>。从而保证子应用可以有较为统一的呈现。主题包也可以在部署时动态切换，这对于 POC 或者私有化部署比较方便。</p><blockquote><p>💡  主题包主要包含 CSS 变量、组件库样式、语言包、静态资源、甚至一些部署配置信息。</p></blockquote><p><br></p><p><img src="/images/microfrontend/Untitled%207.png" alt="API"></p><p>为了方便子应用使用基座的「<code>服务</code>」， 基座也向子应用暴露了一系列的组件库和 API。</p><p>组件库基于使用 <code>Web Component</code> 的形式，实现框架无关， 基于 Vue 3 创建。Vue 3 <a href="https://cn.vuejs.org/guide/extras/web-components.html" target="_blank" rel="noopener">构建自定义元素</a> 也很方便，所以就没必要引入其他框架专门来编写这块了</p><p>这些 API 可以直接挂载在全局 window 对象上，子应用可以直接访问。</p><blockquote><p>💡  实际上我们封装了一个套壳 npm 库，避免子应用直接访问 window 对象上的服务, 隐藏细节，另外可以提供类型提示。</p></blockquote><p><br><br><br><br><br><br><br></p><h1 id="子应用接入"><a href="#子应用接入" class="headerlink" title="子应用接入"></a>子应用接入</h1><p>简单、免侵入地改造子应用使我们要达成的主要目标。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>为此，我们也提供了相应的 <code>vue-cli</code> 插件, 支持快速集成，避免开发者关心 Webpack 底层的各种配置细节</p><blockquote><p>我们的微前端主要基于 <a href="https://github.com/umijs/qiankun" target="_blank" rel="noopener">qiankun</a>，官方目前并不支持 Vite，并且我们大量项目主要以 Vue CLI 为主。</p></blockquote><p>示例：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">'@vue/cli-service'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; defineMappChild &#125; = <span class="built_in">require</span>(<span class="string">'@wakeadmin/vue-cli-plugin-mapp-child'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  transpileDependencies: <span class="literal">false</span>,</span><br><span class="line">  pluginOptions: &#123;</span><br><span class="line">    <span class="comment">// 只需要简单的配置</span></span><br><span class="line">    ...defineMappChild(&#123;</span><br><span class="line">      mapp: &#123;</span><br><span class="line">        activeRule: <span class="string">'/dsp.html'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">  lintOnSave: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>多入口配置：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">'@vue/cli-service'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; defineMappChild &#125; = <span class="built_in">require</span>(<span class="string">'@wakeadmin/vue-cli-plugin-mapp-child'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  <span class="comment">// 多页应用</span></span><br><span class="line">  pages: &#123;</span><br><span class="line">    index: <span class="string">'src/main.ts'</span>,</span><br><span class="line">    another: <span class="string">'src/another.ts'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  pluginOptions: &#123;</span><br><span class="line">    <span class="comment">// 微前端集成配置</span></span><br><span class="line">    ...defineMappChild(&#123;</span><br><span class="line">      mapp: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// entry 必须为上面 pages 中定义的 key</span></span><br><span class="line">          entry: <span class="string">'index'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// entry 必须为上面 pages 中定义的 key</span></span><br><span class="line">          entry: <span class="string">'another'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>接着调整应用挂载程序：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp, App <span class="keyword">as</span> TApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHashHistory &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> Bay <span class="keyword">from</span> <span class="string">'@wakeadmin/bay'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; routes &#125; <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app: TApp</span><br><span class="line"></span><br><span class="line">Bay.createMicroApp(&#123;</span><br><span class="line">  <span class="keyword">async</span> bootstrap() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bootstrap vue3'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> mount(container, props) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'mount vue3'</span>, props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">      history: createWebHashHistory(),</span><br><span class="line">      routes,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    app = createApp(App).use(store).use(router).use(Bay)</span><br><span class="line"></span><br><span class="line">    app.mount(container?.querySelector(<span class="string">'#app'</span>) ?? <span class="string">'#app'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> unmount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'unmount vue3'</span>)</span><br><span class="line"></span><br><span class="line">    app.unmount()</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> update() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'update vue3'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="本地开发和调试"><a href="#本地开发和调试" class="headerlink" title="本地开发和调试"></a>本地开发和调试</h2><p>运行起来后， 我们会在终端打印出子应用的相关信息，如下图：</p><p><img src="/images/microfrontend/Untitled%208.png" alt="terminal"></p><p>接下来，只需要在<code>基座的调试页面</code>，注册这个子应用就可以运行起来的：</p><p><img src="/images/microfrontend/Untitled%209.png" alt="debug"></p><blockquote><p>💡  有了微前端之后，子应用的开发和调试也简化了很多，可以随时挂载到任意环境，不需要配置任何服务端代理。</p></blockquote><p><br><br><br><br><br></p><h1 id="部署和治理"><a href="#部署和治理" class="headerlink" title="部署和治理"></a>部署和治理</h1><p>网上很少关于微前端应用的部署和治理的介绍，下面介绍我们自己摸索出来一套方案， 这也是本文的重点。</p><p><br></p><h2 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h2><p>在此之前，我们的前端项目都是扔到一台静态资源服务器，很多开发者会手动操作，项目之前通过目录隔离，手动维护 Nginx 进行分流，手段原始且容易出错，场面十分混乱。</p><p>在 2021 年，我们就开始推行前端项目的容器化，来解决这种混乱的状态。</p><p>为了<code>标准化</code>、<code>自动化</code>每个项目的构建操作、部署流程，我们和后端对齐， 使用容器和 K8S 来实现发布产物的封装和部署。这样的好处是：</p><ul><li>实现测试环境和生产环境的统一。</li><li>简化部署流程， 采用统一的配置，无需更改 Nginx 配置</li><li>真正做到不同团队项目的隔离。</li><li>支持回滚</li><li>简化和标准化构建流程。同时也简化了运维的工作，前后端都是容器部署。</li><li>运行的环境更加灵活。我们可以使用最新的 nginx 版本，可以使用 HTTP2 等新的技术，前端自己就可以部署一套 NodeJS 环境，做一些更酷的事情。对运维的依赖性会更低。</li></ul><p><br></p><p>这对我们来说是一个比较重要的升级。我们的工作不再局限于静态资源的伺服，我们可以使用 NodeJS 开发 API、自动化工作流、可以进行服务端渲染等等，拓展了能力的边界。</p><p><br><br><br></p><p>然而，很多配置信息在构建时就固定下来了，比如 CDN 域名，接口请求路径等等。而不同环境通常会使用不同的配置信息。<strong>这样就无法实现构建一次镜像，在不同环境运行。</strong></p><p>后端程序的解决办法是将配置信息外置，比如通过<code>环境变量</code>配置或者从<code>配置中心</code>(比如 Nacos)获取。</p><p>这在前端行不通，所以我们引入了<code>运行容器</code>的概念。</p><p><br><br><br></p><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p><code>运行容器</code>，顾名思义就是整套<code>微前端</code> 的<code>运行时</code>，以 「<code>Docker 容器</code>」的形式部署。我们尽量复用 K8S 提供的基础设施(比如 PVC、配置映射、Sidecar 等) 来实现。</p><p>运行容器的主要结构：</p><p><img src="/images/microfrontend/Untitled%2010.png" alt="container"></p><p><code>运行容器</code>主要包含两大部分：</p><ul><li><code>Nginx</code> ：毫无疑问，Nginx 是<code>静态资源伺服</code>的最佳能手，同时它作为内部服务<code>反向代理</code>。</li><li><code>transpiler</code> (我们称为<code>转换器</code>): 这是一个「搬运工」，主要负责配置的收集、代码转换。并将转换后的静态资源交给  <code>nginx</code>  伺服。</li></ul><p>下面会详细介绍它的能力。</p><p><br><br><br></p><h2 id="如果实现子应用的自动发现？"><a href="#如果实现子应用的自动发现？" class="headerlink" title="如果实现子应用的自动发现？"></a>如果实现子应用的自动发现？</h2><p>答案是<strong>”约定“</strong>。</p><p>运行容器约定了以下目录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/data/</span><br><span class="line">  /<span class="built_in">source</span>/                   <span class="comment"># 源目录</span></span><br><span class="line">    /__public__/             <span class="comment"># 公共资源, 外部可以直接访问，不需要 __public__ 前缀</span></span><br><span class="line">    /__config__/             <span class="comment"># 配置目录</span></span><br><span class="line">      config.yml</span><br><span class="line">      any-sub-dir/</span><br><span class="line">        my-config.yml</span><br><span class="line"></span><br><span class="line">    /__entry__/              <span class="comment"># 基座目录</span></span><br><span class="line">      js/</span><br><span class="line">      index.html</span><br><span class="line"></span><br><span class="line">    /__apps__/               <span class="comment"># 子应用目录</span></span><br><span class="line">      wkb/</span><br><span class="line">      dsp/</span><br><span class="line">      dmp/</span><br><span class="line">        js/</span><br><span class="line">        mapp.json</span><br><span class="line">        index.html</span><br><span class="line"></span><br><span class="line">    /__i18n__/               <span class="comment"># 语言包目录</span></span><br><span class="line">      zh.tr</span><br><span class="line">      en.tr</span><br><span class="line">      any-sub-dir/</span><br><span class="line">        zh.tr</span><br><span class="line">        en.tr</span><br><span class="line"></span><br><span class="line">    /__theme__/              <span class="comment"># 主题目录</span></span><br><span class="line">      config.yml</span><br><span class="line">      element-ui.css</span><br><span class="line">      element-plus.css</span><br><span class="line">      fonts/</span><br><span class="line">      i18n/</span><br><span class="line">        zh.tr</span><br><span class="line">        en.tr</span><br><span class="line"></span><br><span class="line">  /public/                    <span class="comment"># nginx 伺服目录</span></span><br></pre></td></tr></table></figure><p>目录结构解析：</p><ul><li><code>/data/source</code>。没错，<code>transpiler</code>  就是<code>转译</code>和搬运这里的静态资源。</li><li><code>/data/public</code>。 <code>transpiler</code>  就是将资源转译后搬运到这里，<code>nginx</code>  对外伺服这个目录。</li></ul><p><br></p><blockquote><p>转译？<code>transpiler</code> 可以认为就是一个模板引擎，它会替换代码里面的动态变量。</p></blockquote><p><br></p><p>再来看  <code>/data/source</code>：</p><ul><li><code>__entry__</code>: 基座编译之后的代码就部署这里。</li><li><code>__apps__</code>: 子应用编译之后的代码就部署这里，子应用之间， 按照唯一的  <code>name</code>  区分目录。</li><li><code>__i18n__</code>: 扩展语言包，文件按照  <code>&lt;language&gt;.tr</code>  命名， 子目录的 .tr 文件也会被扫描到。</li><li><code>__config__</code>: 配置目录。配置文件使用  <code>.yml</code>  或  <code>.yaml</code>  命名，也可以放在子目录下。</li><li><code>__theme__</code>: 主题包目录。可以手动维护，也可以使用  <code>npmTheme</code>  配置项, 让  <code>transpiler</code>  从 npm 拉取。</li><li><code>__public__</code>: 公共资源目录。这些资源可以直接访问，而不需要  <code>__public__</code>  前缀。举个例子:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">__theme__/</span><br><span class="line">  index.css  *<span class="comment"># -&gt; 访问链接 example.com/__theme__/index.css*</span></span><br><span class="line">__public__/</span><br><span class="line">  hello.html *<span class="comment"># -&gt; 访问链接 example.com/hello.html*</span></span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><p>那  <code>transpiler</code>  的工作过程应该比较清晰了：</p><ul><li>扫描  <code>__apps__</code>  下的<code>子应用</code>。开发者也可以在<em>子应用目录下</em>使用  <code>mapp.json</code>  显式定义子应用描述信息。扫描后的子应用信息将放在  <code>microApps</code>  变量下。</li><li>扫描  <code>__config__</code>  下的配置文件。解析出配置信息。</li><li>扫描  <code>__i18n__</code>  下的  <code>.tr</code>, 解析结果放在  <code>i18n</code>  变量下。</li><li>扫描  <code>__theme__</code>  目录。<code>__theme__</code>  主题包也支持携带配置文件、语言包，所以这些信息也会合并到配置信息中。另外 CSS 文件、JavaScript 文件将被收集到  <code>theme</code>  变量中。</li></ul><p><br></p><p>扫描完毕之后，<code>transpiler</code>  拿着配置信息进行<code>模板转译</code>，将  <code>/data/source</code>  下的静态资源转换被拷贝到  <code>/data/public</code>  目录下。</p><p>来看个实际的模板例子:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"[%= description %]"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"[%= keywords %]"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"[%= assets.IMG_BAY_FAVICON || entryPath + '/favicon.png' %]"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"version"</span> <span class="attr">content</span>=<span class="string">"[%= version %]"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"update-time"</span> <span class="attr">content</span>=<span class="string">"[%= `$&#123;year&#125;-$&#123;month&#125;-$&#123;date&#125;` %]"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>[%= title %]<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--! [%- theme.stylesheets.map(i =&gt; `&lt;link rel="stylesheet" href="$&#123;i + '?' + hash &#125;" /&gt;`).join('\n') %] --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--! [%- theme.scripts.map(i =&gt; `&lt;script async="true" src="$&#123;i + '?' + hash&#125;"&gt;&lt;/script&gt;`).join('\n') %] --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--! [% if (microApps.length) &#123; %] --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--! [%- </span></span><br><span class="line"><span class="comment">      `&lt;script&gt;</span></span><br><span class="line"><span class="comment">        // 微应用注入</span></span><br><span class="line"><span class="comment">        (window.__MAPPS__ = (window.__MAPPS__ || [])).push($&#123;microApps.map(i =&gt; JSON.stringify(i)).join(', ')&#125;);</span></span><br><span class="line"><span class="comment">      &lt;/script&gt;`</span></span><br><span class="line"><span class="comment">    %] --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--! [% &#125; %]--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--! [%- `&lt;script&gt;</span></span><br><span class="line"><span class="comment">      // 静态资源注入</span></span><br><span class="line"><span class="comment">      (window.__MAPP_ASSETS__ = (window.__MAPP_ASSETS__ || [])).push($&#123;JSON.stringify(assets)&#125;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      // 全局共享的语言包</span></span><br><span class="line"><span class="comment">      window.__I18N_BUNDLES__ = $&#123;JSON.stringify(i18n)&#125;;</span></span><br><span class="line"><span class="comment">    &lt;/script&gt;` %] --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">      <span class="attr">defer</span>=<span class="string">"defer"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">"[%= cdnDomain ? '//' + cdnDomain : '' %][%= removeTrailingSlash(base) %]/__entry__/js/chunk-vendors.582ba02c.js?[%= hash %]"</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">      <span class="attr">defer</span>=<span class="string">"defer"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">"[%= cdnDomain ? '//' + cdnDomain : '' %][%= removeTrailingSlash(base) %]/__entry__/js/app.01bd68bb.js?[%= hash %]"</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">      <span class="attr">href</span>=<span class="string">"[%= cdnDomain ? '//' + cdnDomain : '' %][%= removeTrailingSlash(base) %]/__entry__/css/app.d835cada.css?[%= hash %]"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">rel</span>=<span class="string">"stylesheet"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span></span></span><br><span class="line"><span class="tag">      &gt;</span><span class="tag">&lt;<span class="name">strong</span></span></span><br><span class="line"><span class="tag">        &gt;</span>We're sorry but [%= title %] doesn't work properly without JavaScript enabled. Please</span><br><span class="line">        enable it to continue.</span><br><span class="line">      <span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">noscript</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><p>上面是基座的  <code>index.html</code>  模板。<code>transpiler</code>  基于  <strong><a href="https://ejs.bootcss.com/" target="_blank" rel="noopener">ejs</a></strong>  模板引擎，会解析替换文本文件中  <code>[% 模板 %]</code>  语法。</p><p><br></p><p>还有很多用法值得去挖掘。 比如:</p><ul><li>全局埋点脚本注入</li><li>全局监控脚本注入</li><li>…</li></ul><p>原理就是这么简单，只要子应用部署到 <code>__apps__</code> 目录下，我们就可以监听到，收集到必要的信息后，对 <code>source</code> 目录下的静态文件进行转译，输出到 <code>public</code> 目录下，最终由 Nginx 负责将文件传递给浏览器。</p><p><br><br><br><br><br></p><h2 id="部署和运维"><a href="#部署和运维" class="headerlink" title="部署和运维"></a>部署和运维</h2><p>那么子应用具体如何部署和运维呢？</p><p>子应用构建、生成和发布容器的过程这里就不展开说了，可以自行搜索 Docker 的相关教程，我们这里主要简单介绍一下在 K8S 平台如何部署和运维。</p><p>将基座和子应用聚合在一起，我们需要用到 <code>PVC</code> (PersistentVolumeClaim, 即持久化卷), 你可以认为 PVC 就是一个「网络硬盘」，而每个子应用、基座都是独立运行的「主机」(<code>Pod</code> 或 容器 , <em>Kubernetes</em>  中可部署的最小、最基本对象), 这个 PVC 可以被每个子应用共享访问，只要按照约定将子应用的静态文件拷贝到 PVC 对应位置就行了。如下图所示：</p><p><img src="/images/microfrontend/Untitled%2011.png" alt="PVC"></p><p><br><br><br><br><br></p><p>至于子应用和运行容器在 K8S 下如何组织，可以非常灵活，取决于需求和环境。笔者实践过以下几种方式：</p><ol><li><p>全部部署在一个 Pod 下。子应用作为 <code>Init Sidecar</code>（初始化边车）。这种部署方式比较简单，缺点就是任意一个应用需要更新，整个 Pod 都要重启，包括运行容器。</p><p><img src="/images/microfrontend/Untitled%2012.png" alt="方法1"></p><p>示例图：</p><p><img src="/images/microfrontend/Untitled%2013.png" alt="Sidecar"></p></li><li><p>分离运行容器和子应用。为了避免子应用更新导致整个 Pod 重启（包括运行容器），我们可以将子应用单独拎出去，子应用更新只会重启所在的 Pod，从而避免运行容器停机。</p><p><img src="/images/microfrontend/Untitled%2014.png" alt="方法2"></p></li><li><p>每个子应用都是独立的 Pod。好处就是每个子应用可以真正做到独立部署、启动，坏处就是管理起来稍显麻烦。</p><p><img src="/images/microfrontend/Untitled%2015.png" alt="方法3"></p></li></ol><p>开发者可以根据自己的运行环境选择不同的组织方式。</p><p><br><br><br><br><br></p><h2 id="那么配置呢？"><a href="#那么配置呢？" class="headerlink" title="那么配置呢？"></a>那么配置呢？</h2><p>首先简单的配置可以通过<code>环境变量</code>来实现，因为在 K8S 中，配置环境变量相对简单很多:</p><p><img src="/images/microfrontend/Untitled%2016.png" alt="环境变量配置"></p><p>对于稍微复杂的配置，可以使用<code>配置映射</code>(Config-Maps), 配置映射的每个键值对就相当于一个文件，我们可以挂载到容器的任何位置上：</p><p>定义配置映射：</p><p><img src="/images/microfrontend/Untitled%2017.png" alt="定义配置映射"></p><p>挂载配置映射：</p><p><img src="/images/microfrontend/Untitled%2018.png" alt="挂载配置映射"></p><p>配置映射可以挂载到任意的路径或文件上，它还有一个更赞的能力<strong>是：我们可以直接修改配置映射，这些变动会同步到容器内，从而实现实时变更</strong>。</p><p>小结。我们尽量复用了 K8S 本身的能力，这些能力足以实现较为复杂功能，避免重复造轮子。</p><p><br><br><br><br><br></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>限于篇幅很多细节无法展开，这里点到为止：</p><ul><li><strong>如何实现一键部署？</strong>因为使用的是容器化部署，可以将所有部署声明在 <a href="https://www.notion.so/b590284a71934f97a1db71ef967fbc5a?pvs=21" target="_blank" rel="noopener">yaml 文件</a>中维护, 新环境部署时直接导入就行。我们也开发过一个<a href="https://wakeadmin.wakedata.com/k8s-deploy/index.html#/micro" target="_blank" rel="noopener">可视化生成 yaml 的简易应用</a></li><li><strong>自动化部署？</strong>实现自动化部署有很多手段，如果你的公司有 DevOps 平台(比如我们使用 Zadig) , 这些平台本身就提供了自动化部署的能力，你可以查看相关文档。另外在 Jenkins 中也有相关的插件来实现部署推送。再不济，<a href="https://www.notion.so/a2b1fb632eb44b68b161a38f256756db?pvs=21" target="_blank" rel="noopener">可以使用 rancher 的 CLI 等等</a>。</li><li><strong>子应用如何共享依赖？</strong>可以使用 <a href="https://webpack.js.org/configuration/externals/#externals" target="_blank" rel="noopener">externals</a>, 或者 Webpack 5 的 *<strong>*<a href="https://webpack.js.org/concepts/module-federation/#motivation" target="_blank" rel="noopener">Module Federation</a>,</strong> 我们也探索过类似 <a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">jsDelivr</a> 的方案， 详见<a href="https://wakeadmin.wakedata.com/mapp/advanced/vendors.html#%E9%85%8D%E7%BD%AE%E9%A1%B9" target="_blank" rel="noopener">这里</a></li><li><strong>接口服务</strong>。运行容器除了上文讲到的各种功能，还可以提供一些造福前端的<a href="https://wakeadmin.wakedata.com/mapp/advanced/services.html" target="_blank" rel="noopener">接口服务</a>，比如接口代理、polyfill 服务、vendor 依赖。</li><li><strong><em>安全配置</em></strong>。在运行容器中统一配置 CSP、跨域等安全配置</li><li>…</li></ul><p><br><br><br><br><br></p><h2 id="有哪些最佳实践"><a href="#有哪些最佳实践" class="headerlink" title="有哪些最佳实践?"></a>有哪些最佳实践?</h2><ul><li><strong>保持基座业务无关性</strong>。我们尽量保证基座不耦合业务，为了避免子应用的业务侵入到基座，我们严格管控基座仓库的开发权限，以及向下暴露接口的截面。</li><li><strong>保持子应用之间的独立性</strong>。基座除了 <code>EventBus</code> ，没有提供其他应用通信的手段。对我们来说，微前端只不过是多页应用的延续。 设计良好的应用，不应该耦合其他应用。就算是一些共享状态，也可以从后端读取。</li><li><strong>避免硬编码配置信息</strong>。因为<code>运行容器</code>有动态替换变量的能力，因此应该避免在代码中硬编码配置信息，比如域名信息、企业文案、服务器链接。而是预留模板, 在部署时通过<strong><a href="https://wakeadmin.wakedata.com/mapp/deploy.html" target="_blank" rel="noopener">运行容器</a></strong>来配置。</li><li><strong>按照业务聚合子应用</strong>。即按照业务边界来拆分子应用，而不是按照‘菜单’， 具体来说子应用应该对应后端的微服务，尽管很多时候做不到。</li></ul><p><br><br><br><br><br></p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>我们整套方案并没有‘自造’复杂的技术，而是基于已有的工具整合起来的能力。这也是笔者一直坚持的观念，简单至上。</p><p>这个方案未来会如何迭代呢？</p><ul><li>可视化方式，简化部署的流程。毕竟不是所有开发者都熟悉 K8S 这套概念</li><li>发布流程审核。生产环境部署审核。</li><li>基座插件。支持扩展一些除子应用之外的场景，比如一些全局通用的业务 SDK、组件库。常规的子应用只会在路由匹配到时激活，而插件会在基座启动后加载并持久存在。</li><li>支持子应用扩展服务端的能力。当前的子应用都是 CSR，后续运行容器可以支持子应用扩展服务端接口。</li><li>灰度发布。</li><li>支持 Vite</li><li>…</li></ul><p><br><br><br><br><br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文大概介绍了我们落地和治理微前端应用的大概思路。这套体系中主要包含了三个主要部件：</p><p><img src="/images/microfrontend/Untitled%2019.png" alt="微前端"></p><ul><li>基座：<code>集中式</code>的微前端方案，基座是整个微前端的核心，负责管理子应用，并为子应用的开发提供必要的支撑</li><li>子应用：负责具体业务实现，按照业务聚合和拆分。</li><li>运行容器：为微前端应用架构提供了部署和治理方案</li></ul><p>因为文章篇幅原因，这里面很多细节无法展开。感兴趣的可以移步我们<a href="https://wakeadmin.wakedata.com/mapp/index.html" target="_blank" rel="noopener">公开的文档</a>（暂未开源）。</p><p><br><br><br></p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://wakeadmin.wakedata.com/mapp/index.html" target="_blank" rel="noopener">Wakeadmin</a></li><li><a href="https://github.com/umijs/qiankun" target="_blank" rel="noopener">qiankun</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/microfrontend/Untitled.png&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;微前端实现原理、框架选型之类的文章比较泛滥，我不打算讲这些玩意，本文主要来源于笔者过去一年落地微前端的一手经验，尽量不讲技术细节，而是讲
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue 开发的正确姿势：响应式编程思维</title>
    <link href="https://bobi.ink/2023/07/09/vue-with-rx/"/>
    <id>https://bobi.ink/2023/07/09/vue-with-rx/</id>
    <published>2023-07-08T16:00:00.000Z</published>
    <updated>2023-07-13T02:01:44.044Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vue-with-rx/Untitled.png" alt="Untitled"></p><p>写这篇文章的动机可以追溯到 3 年前， 我发现很多身边开发者并没有正确地使用 React Hooks, 所以我觉得应该把我的开发经验和思维整理下来。</p><p>尽管本文主要从 Vue 的角度出发，但是很多思维也可以用在 React Hooks 上。</p><p>从广义的的“<a href="https://en.wikipedia.org/wiki/Reactive_programming" target="_blank" rel="noopener">响应式编程(Reactive Programing)</a>” 上看，Vue、React、Rxjs 等框架都属于这个范畴。而狭义的响应式编程通常指的是 rxjs 这类 “面向数据<a href="https://zh.wikipedia.org/wiki/%E4%B8%B2%E6%B5%81" target="_blank" rel="noopener">串流</a>和变化传播的<a href="https://zh.wikipedia.org/wiki/%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">声明式</a><a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F" target="_blank" rel="noopener">编程范式</a>”</p><p>虽然 Vue 也是‘响应式编程’， 但是和 RxJS 是完全不一样的概念，至少RxJS 是有范式约束的，不管是编码上还是思维上面，我们都可以感受到它的强力约束，这和我们惯用的命令式编程差别很大。这也导致了它的学习门槛比较高。</p><p>为什么要牵扯到 RxJS 呢？因为它的思维对我们写好 Vue 代码很有帮助！</p><p><br><br><br></p><h1 id="简述-rxjs"><a href="#简述-rxjs" class="headerlink" title="简述 RxJS"></a>简述 RxJS</h1><p>先祭上<a href="https://zhuanlan.zhihu.com/p/25383159" target="_blank" rel="noopener">徐飞的买房的例子</a>，感受一下 RxJS 的魅力：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//           工资周期  ———&gt;  工资</span></span><br><span class="line"><span class="comment">//                            ↓</span></span><br><span class="line"><span class="comment">// 房租周期  ———&gt;  租金  ———&gt;  收入  ———&gt;  现金 </span></span><br><span class="line"><span class="comment">//                ↑           ↓ </span></span><br><span class="line"><span class="comment">//             房子数量 &lt;——— 新购房</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 挣钱是为了买房，买房是为了赚钱</span></span><br><span class="line"><span class="keyword">const</span> house$ = <span class="keyword">new</span> Subject()</span><br><span class="line"><span class="keyword">const</span> houseCount$ = house$.scan(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> acc + num, <span class="number">0</span>).startWith(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工资始终不涨</span></span><br><span class="line"><span class="keyword">const</span> salary$ = Observable.interval(<span class="number">100</span>).mapTo(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> rent$ = Observable.interval(<span class="number">3000</span>)</span><br><span class="line">  .withLatestFrom(houseCount$)</span><br><span class="line">  .map(<span class="function"><span class="params">arr</span> =&gt;</span> arr[<span class="number">1</span>] * <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一买了房，就没现金了……</span></span><br><span class="line"><span class="keyword">const</span> income$ = Observable.merge(salary$, rent$)</span><br><span class="line"><span class="keyword">const</span> cash$ = income$</span><br><span class="line">  .scan(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newSum = acc + num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newHouse = <span class="built_in">Math</span>.floor(newSum / <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">if</span> (newHouse &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      house$.next(newHouse)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newSum % <span class="number">100</span></span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// houseCount$.subscribe(num =&gt; console.log(`houseCount: $&#123;num&#125;`))</span></span><br></pre></td></tr></table></figure><p><br></p><p>如果用几个关键字来描述 RxJS 的话，我想应该是：</p><ul><li>事件：观察者模式</li><li>序列：迭代器模式</li><li>流：管道模式</li></ul><p>这几个模式我们分开去理解都没啥特别，比如 Vue 的 reactivity 数据就是观察者模式；JavaScript 的 for…of/generator 就是迭代器模式；数组的map/filter/reduce, shell 命令都符合管道模式。</p><p>RxJS  的牛逼之处就是把这三个模式优雅地组合起来了。它把事件抽象成为类似’数组’一样的序列，然后提供了丰富的操作符来变换这个序列，就像操作数组一样自然，最后通过管道将这些操作符组合起来实现复杂的功能变换。</p><p><br><br><br></p><h1 id="为什么建议你去学习-rxjs？"><a href="#为什么建议你去学习-rxjs？" class="headerlink" title="为什么建议你去学习 rxjs？"></a>为什么建议你去学习 rxjs？</h1><p>至少它可以帮助你写好 Vue 代码。它可以帮你写出更简洁、结构更清晰、低耦合、更容易测试的代码，这些代码更能体现原本的交互逻辑或业务流程。</p><p>相信我，尝试换个思路，可能原本复杂的实现，会变得更加简单。</p><p><br></p><h1 id="rxjs-和-vue-reactivity-data-有什么关联？"><a href="#rxjs-和-vue-reactivity-data-有什么关联？" class="headerlink" title="RxJS 和 Vue Reactivity Data 有什么关联？"></a>RxJS 和 Vue Reactivity Data 有什么关联？</h1><p>一些和 RxJS 相似的概念</p><ul><li><p>响应式数据。我们用 ref 或reactive 创建的数据，可以等似于 RxJS 的 Observable。只不过响应式数据并不像 rxjs 有显式的事件发布和订阅过程，也不存在事件流(序列)。</p><p>  <strong>我们可以认为Vue 数据的每次变更就相当于 RxJS 发出每次事件</strong>。</p></li><li><p>衍生数据。我们会使用 computed 来衍生新的数据，等似于 RxJS 用操作符衍生出新的 Observable。<strong>即 Vue 数据衍生数据，RxJS 事件衍生事件</strong></p></li><li>副作用。在 Vue 中， watch/watcheffects/render 相当于 RxJS 的 subscribe，RxJS 的数据流的终点通常也是副作用处理，比如将数据渲染到页面上。</li></ul><p><br></p><p>RxJS 的很多东西并不能直接套用过来，但思想和原则是可以复用的。</p><p>其中一个重要的思想就是：管道变换。这是一种思维方式的转变，在以往的编程设计中，我们更多操心的是类、模块、数据结构和算法。而管道变换我们会把程序视作从输入到输出的一个变换去构思:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># “列出目录树中最长的五个文”</span></span><br><span class="line">find . -<span class="built_in">type</span> f | xargs wc -l | sort -n | tail -5</span><br></pre></td></tr></table></figure><p>不要把数据看作是遍布整个系统的小数据池，而要把数据看作是一条浩浩荡荡的河流。</p><p>另一方面，编写 RxJS 代码一些原则，对我们编写 Vue 代码也大有裨益：</p><ul><li>避免副作用。RxJS 的操作符应该是没有副作用的函数，只关注输入的数据，然后对数据进行变换，传递给下一个。</li><li><p>避免外部状态/缓存状态。外部状态也是副作用的一种，单独拎出来讲，是因为我们在 Vue 中创建外部状态太容易了，而 RxJS 则相对来说麻烦一些，毕竟外部状态和事件流显得格格不入。</p><p>  在 RxJS 中管道是自包含的， 所有的状态从一个操作器流向下一个操作器，而不需要外部变量：</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Observable.from([1, 2, 3, 4, 5, 6, 7, 8])</span><br><span class="line">  .filter(val =&gt; val % 2)</span><br><span class="line">  .map(val =&gt; val * 10);</span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><h1 id="看看你代码中的坏味道"><a href="#看看你代码中的坏味道" class="headerlink" title="看看你代码中的坏味道"></a>看看你代码中的坏味道</h1><p>看看你的 Vue 代码有没有这些现象，如果存在这些坏味道，说明你并没有正确使用 Vue 的 Reactivity API。</p><ul><li>创建了大量的缓存状态。比如 sum，avg，temp…</li><li>使用了很多 <code>watch</code> / <code>watchEffect</code>…</li><li>冗长的 <code>setup</code> 方法或者组件代码</li><li>状态被随意修改，修改不属于管辖范围内的状态</li><li>…</li></ul><p><br><br><br></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>先从简单的场景开始: 分页请求。</p><p>❌ 常规的做法：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = reactive(&#123;&#125;) <span class="comment">// 查询参数</span></span><br><span class="line"><span class="keyword">const</span> pagination = reactive(&#123;<span class="attr">pageNo</span>: <span class="number">1</span>, <span class="attr">pageSize</span>: <span class="number">10</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> total = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> list = ref([])</span><br><span class="line"><span class="keyword">const</span> loading = ref(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">const</span> error = ref()</span><br><span class="line"></span><br><span class="line">watch([query, pagination], <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    error.value = <span class="literal">undefined</span></span><br><span class="line">    loading.value = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> request(<span class="string">`/something?<span class="subst">$&#123;qs(&#123;...query, ...pagination&#125;</span>)&#125;`</span>)</span><br><span class="line">    total.value = data.total</span><br><span class="line">    list.value = data.list</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err)&#123;</span><br><span class="line">    error.value = err</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    loading.value = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;<span class="attr">immediate</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p>✅ 推荐做法：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = reactive(&#123;&#125;) <span class="comment">// 查询参数</span></span><br><span class="line"><span class="keyword">const</span> pagination = reactive(&#123;<span class="attr">pageNo</span>: <span class="number">1</span>, <span class="attr">pageSize</span>: <span class="number">10</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// data 包含了 list、loading、error、total 等信息</span></span><br><span class="line"><span class="keyword">const</span> data = useRequest(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`/something?<span class="subst">$&#123;qs(&#123;...query, ...pagination&#125;</span>)&#125;`</span>)</span><br></pre></td></tr></table></figure><ul><li><p>自然地表达 query/pagination → data 的数据流。useRequest 更像 computed 的语义，从一个数据衍生出新的数据，不管它是同步的还是异步的。</p><p>  而使用 watch 会中断数据的流动，并且我们需要创建冗余缓存状态，代码看起来会比较混乱。想象一下复杂的页面，我们可能会有很多复杂、联动的异步请求，情况就会慢慢失控。</p></li><li><p><code>useRequest</code> 是啥？它封装了网络请求， useRequest 可以基于 <a href="https://docs-swrv.netlify.app/guide.html" target="_blank" rel="noopener">swrv</a>(swr 在 Vue 下的实现, 非官方)、或者VueUse 里面的 <a href="https://vueuse.org/core/computedAsync/" target="_blank" rel="noopener">computedAsync</a>、<a href="https://vueuse.org/core/useFetch/" target="_blank" rel="noopener">useFetch</a> 来封装。</p><p>  useRequest 类似于 RxJS 的 switchMap，当新的发起新的请求时，应该将旧的请求抛弃。</p><p>  笔者推荐使用 swr 这类库去处理网络请求，相比直接用 watch, 这类库支持数据缓存、Stale-while-revalidate 更新、还有并发竞态的处理等等。</p></li></ul><p><br><br><br></p><h2 id="实时搜索"><a href="#实时搜索" class="headerlink" title="实时搜索"></a>实时搜索</h2><p>第二个例子也比较简单，用户输入文本，我们debounce 发起数据请求</p><p>⚠️ 常规的实现：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = ref(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法一：在事件处理器加 debounce</span></span><br><span class="line"><span class="comment">// 如果这么实现，双向绑定到表单可能有卡顿问题</span></span><br><span class="line"><span class="keyword">const</span> handleQueryChange = debounce(<span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">  query.value = evt.target.value</span><br><span class="line">&#125;, <span class="number">800</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = ref()</span><br><span class="line"></span><br><span class="line">watch(query, <span class="keyword">async</span> (q) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetchData(q)</span><br><span class="line">  <span class="comment">// <span class="doctag">FIXME:</span> 需要处理竞态问题</span></span><br><span class="line">  data.value = res</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 法二，在 watch 回调或者 fetchData 加上 debounce</span></span><br><span class="line"><span class="keyword">const</span> handleQueryChange = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">  query.value = evt.target.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">watch(query, debounce(<span class="keyword">async</span> (q) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetchData(q)</span><br><span class="line">  data.value = res</span><br><span class="line">&#125;, <span class="number">800</span>))</span><br></pre></td></tr></table></figure><p>RxJS  实现:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> searchInput$ = fromEvent(searchInput, <span class="string">'input'</span>).pipe(</span><br><span class="line">  <span class="comment">// 使用 debounceTime 进行防抖处理</span></span><br><span class="line">  debounceTime(<span class="number">800</span>),</span><br><span class="line">  <span class="comment">// 使用 map 将事件转换为输入框的值</span></span><br><span class="line">  map(<span class="function"><span class="params">event</span> =&gt;</span> event.target.value),</span><br><span class="line">  <span class="comment">// 使用 distinctUntilChanged 进行去重处理</span></span><br><span class="line">  distinctUntilChanged(),</span><br><span class="line">  <span class="comment">// 使用 switchMap 进行请求并转换为列表数据</span></span><br><span class="line">  switchMap(<span class="function"><span class="params">keyword</span> =&gt;</span> <span class="keyword">from</span>(searchList(keyword)))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们使用 Vue 也可以表达类似的流程：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = ref(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">const</span> debouncedQuery = refDebounced(input, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = useRequest(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`/something?<span class="subst">$&#123;qs(&#123;query: query.value&#125;</span>)&#125;`</span>)</span><br></pre></td></tr></table></figure><p>refDebounce 来源于 VueUse，可以 “Debounce” 指定输入 ref 值的变动。</p><p><br><br><br></p><h2 id="定时刷新"><a href="#定时刷新" class="headerlink" title="定时刷新"></a>定时刷新</h2><p>假设我们要在上面的分页基础上实现定时轮询的功能：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = reactive(&#123;&#125;) <span class="comment">// 查询参数</span></span><br><span class="line"><span class="keyword">const</span> tick = useInterval(<span class="number">5000</span>)</span><br><span class="line"><span class="keyword">const</span> pagination = reactive(&#123;<span class="attr">pageNo</span>: <span class="number">1</span>, <span class="attr">pageSize</span>: <span class="number">10</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// data 包含了 list、loading、error、total 等信息</span></span><br><span class="line"><span class="keyword">const</span> data = useRequest(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`/something?<span class="subst">$&#123;qs(&#123;...query, ...pagination, _t: tick.value&#125;</span>)&#125;`</span>)</span><br></pre></td></tr></table></figure><p>我们看到上面的流程很自然。</p><p>现在加大难度，如果要在特定条件下终止呢？</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = reactive(&#123;&#125;) <span class="comment">// 查询参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认关闭</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">counter</span>: tick, pause, resume&#125; = useInterval(<span class="number">5000</span>, &#123;<span class="attr">controls</span>: <span class="literal">true</span>, <span class="attr">immediate</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> pagination = reactive(&#123;<span class="attr">pageNo</span>: <span class="number">1</span>, <span class="attr">pageSize</span>: <span class="number">10</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// data 包含了 list、loading、error、total 等信息</span></span><br><span class="line"><span class="keyword">const</span> data = useRequest(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`/something?<span class="subst">$&#123;qs(&#123;...query, ...pagination, _t: tick.value&#125;</span>)&#125;`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否轮询</span></span><br><span class="line"><span class="keyword">const</span> shouldPoll = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> data.data?.some(<span class="function"><span class="params">i</span> =&gt;</span> i.expired &gt; <span class="built_in">Date</span>.now())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按条件开启轮训</span></span><br><span class="line">watch(shoudPoll, (p) =&gt; p ? resume() : pause())</span><br></pre></td></tr></table></figure><p>如果用 RxJS 来实现的话，代码大概如下：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> interval$ = interval(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> poll$ = interval$.pipe(</span><br><span class="line">  <span class="comment">// 查询</span></span><br><span class="line">  switchMap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">from</span>(fetchData())),</span><br><span class="line">  share()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stop$ = poll$.pipe(</span><br><span class="line">  <span class="comment">// 终止轮询条件</span></span><br><span class="line">  filter(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i.every(<span class="function"><span class="params">i</span> =&gt;</span> i.expired &lt;= <span class="built_in">Date</span>.now())</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 poll$ 和 stop$ 组合在一起</span></span><br><span class="line">poll$</span><br><span class="line">  .pipe(</span><br><span class="line">    <span class="comment">// 使用 takeUntil 在 stop$ 发送事件后停止轮询</span></span><br><span class="line">    takeUntil(stop$)</span><br><span class="line">  )</span><br><span class="line">  .subscribe(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>因为 RxJS 的 Observable 是惰性的，只有被 subscribe 时才会开始执行，同理停止订阅就会中断执行。</p><p>中断执行后，如果要重新发起请求，重新订阅就好了。有点异曲同工之妙吧</p><p><br><br><br></p><h2 id="省市区选择器"><a href="#省市区选择器" class="headerlink" title="省市区选择器"></a>省市区选择器</h2><p>再来看一个稍微复杂一点的例子，常见的省市区选择器，这是一个典型的数据联动的场景。</p><p>我们先来看一个反例吧，我们的选择器需要先选择国家或地区，然后根据它来确定行政区域的划分，接着渲染各级行政区域选择器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default defineComponent(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    modelValue: &#123;</span><br><span class="line">      type: Array as () =&gt; number[],</span><br><span class="line">      default: () =&gt; [],</span><br><span class="line">    &#125;,</span><br><span class="line">    onChange: &#123;</span><br><span class="line">      type: Function,</span><br><span class="line">      default: () =&gt; &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    const isEchoingData = ref(false);</span><br><span class="line">    const regionList = ref&lt;RegionInfoDTO[][]&gt;([]);</span><br><span class="line">    const regionUrl = ref(&apos;&apos;);</span><br><span class="line">    const queryParams = ref(&#123;&#125; as IQueryParams);</span><br><span class="line"></span><br><span class="line">    const selectedRegion = computed&lt;number[]&gt;(&#123;</span><br><span class="line">      get: () =&gt; props.modelValue,</span><br><span class="line">      set: value =&gt; emit(&apos;update:modelValue&apos;, [...value]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const &#123; data: countryList &#125; = useRequest&lt;CountryInfoDTO&gt;(</span><br><span class="line">      () =&gt; `请求国家列表`</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 请求区域列表</span><br><span class="line">    const &#123; data: regionItems &#125; = useRequest&lt;RegionInfoDTO&gt;(() =&gt; regionUrl.value);</span><br><span class="line"></span><br><span class="line">    watch(regionItems, () =&gt; &#123;</span><br><span class="line">      regionList.value[queryParams.value.level] = regionItems.value?.data!;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const countryOptions = computed(() =&gt; &#123;</span><br><span class="line">      return countryList.value?.data.map(i =&gt; &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          label: i.name,</span><br><span class="line">          value: i.id,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    watch(queryParams, async newValue =&gt; &#123;</span><br><span class="line">      if (!Object.keys(newValue).length) return;</span><br><span class="line"></span><br><span class="line">      const query = `&amp;countryId=$&#123;newValue.level ? &apos;&apos; : newValue.value&#125;&amp;parentId=$&#123;</span><br><span class="line">        newValue.level ? newValue.value : &apos;&apos;</span><br><span class="line">      &#125;&amp;level=$&#123;newValue.level + 1&#125;`;</span><br><span class="line">      regionUrl.value = `区域请求路径$&#123;query&#125;`;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    watch(</span><br><span class="line">      props.modelValue,</span><br><span class="line">      async (newValue, oldValue) =&gt; &#123;</span><br><span class="line">        const newLen = newValue.length;</span><br><span class="line">        const oldLen = oldValue?.length ?? 0;</span><br><span class="line"></span><br><span class="line">        if (newLen &amp;&amp; newLen !== oldLen) &#123;</span><br><span class="line">          const index = 0;</span><br><span class="line"></span><br><span class="line">          queryParams.value = &#123; value: newValue[index], level: index &#125;;</span><br><span class="line">          isEchoingData.value = true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; immediate: true &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    watch(</span><br><span class="line">      regionList,</span><br><span class="line">      newVal =&gt; &#123;</span><br><span class="line">        const len = newVal.length;</span><br><span class="line">        const selectedLen = selectedRegion.value.length;</span><br><span class="line"></span><br><span class="line">        if (isEchoingData.value &amp;&amp; selectedLen &gt; len) &#123;</span><br><span class="line">          if (len === selectedLen - 1) return (isEchoingData.value = false);</span><br><span class="line"></span><br><span class="line">          queryParams.value = &#123; value: selectedRegion.value[len], level: len &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; deep: true &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    const onRegionChange = (value: number, level: number) =&gt; &#123;</span><br><span class="line">      selectedRegion.value.splice(level);</span><br><span class="line">      regionList.value.splice(level);</span><br><span class="line">      selectedRegion.value.push(value);</span><br><span class="line"></span><br><span class="line">      const currentRegion = regionList.value[level - 1]?.find(region =&gt; region.id === value);</span><br><span class="line"></span><br><span class="line">      if (!currentRegion?.isLeaf) &#123;</span><br><span class="line">        queryParams.value = &#123; value, level &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      props.onChange?.([...selectedRegion.value], [...selectedRegionNames.value]);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const currentRegionPlaceholder = (index: number) =&gt; &#123;</span><br><span class="line">      return `$&#123;selectedCountry.value?.regionLevelInfos[index]?.name ?? &apos;区域&apos;&#125;`;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const selectedCountry = computed(() =&gt; &#123;</span><br><span class="line">      const selectedCountryId = selectedRegion.value[0];</span><br><span class="line">      const selectedCountry = countryList.value?.data.find(country =&gt; country.id === selectedCountryId);</span><br><span class="line"></span><br><span class="line">      return selectedCountry;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const selectedRegionNames = computed(() =&gt; &#123;</span><br><span class="line">      const names = [];</span><br><span class="line"></span><br><span class="line">      if (selectedCountry.value) &#123;</span><br><span class="line">        names.push(selectedCountry.value.name);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      selectedRegion.value.slice(1).forEach((id, index) =&gt; &#123;</span><br><span class="line">        const region = regionList.value[index]?.find(region =&gt; region.id === id);</span><br><span class="line">        if (region) &#123;</span><br><span class="line">          names.push(region.name);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      return names;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return () =&gt; (</span><br><span class="line">      &lt;FatSpace&gt;</span><br><span class="line">        &lt;ElSelect</span><br><span class="line">          modelValue=&#123;selectedRegion.value[0]&#125;</span><br><span class="line">          placeholder=&quot;请选择国家&quot;</span><br><span class="line">          onChange=&#123;val =&gt; onRegionChange(val, 0)&#125;</span><br><span class="line">          filterable</span><br><span class="line">        &gt;</span><br><span class="line">          &#123;countryOptions.value?.map(country =&gt; (</span><br><span class="line">            &lt;ElOption key=&#123;country.value&#125; label=&#123;country.label&#125; value=&#123;country.value&#125; /&gt;</span><br><span class="line">          ))&#125;</span><br><span class="line">        &lt;/ElSelect&gt;</span><br><span class="line"></span><br><span class="line">        &#123;regionList.value.map((regions, index) =&gt; (</span><br><span class="line">          &lt;ElSelect</span><br><span class="line">            key=&#123;index&#125;</span><br><span class="line">            modelValue=&#123;selectedRegion.value[index + 1]&#125;</span><br><span class="line">            placeholder=&#123;`请选择$&#123;currentRegionPlaceholder(index)&#125;`&#125;</span><br><span class="line">            onChange=&#123;val =&gt; onRegionChange(val, index + 1)&#125;</span><br><span class="line">            filterable</span><br><span class="line">          &gt;</span><br><span class="line">            &#123;regions.map(region =&gt; (</span><br><span class="line">              &lt;ElOption key=&#123;region.id&#125; label=&#123;region.name&#125; value=&#123;region.id&#125; /&gt;</span><br><span class="line">            ))&#125;</span><br><span class="line">          &lt;/ElSelect&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/FatSpace&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>也就 150 行左右的代码，实现的是 <code>国家-国家各种区域</code> 的选择器，比如选择了中国就会有 <code>中国-省-市-区</code> 这样的分级。</p><p>读者也没必要读懂这些代码，我看到也头大，你只需要记住，这个充斥着我们上文提到的各种坏味道：过渡依赖 watch、数据流混乱…</p><p><img src="/images/vue-with-rx/Untitled%201.png" alt="Untitled"></p><p>让我们回归到业务本身，我们为什么需要不恪守这样的联动关系去组织代码呢？</p><p>可以的，一个比较重要的技巧就是自顶而下地去分析流程/数据流变换的过程。</p><p>首先从国家开始，只有用户选择了指定国家之后，我们才能获取到区域的结构信息(是省/市/区, 还是州/城市，anyway):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const AreaSelect2 = defineComponent(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    // 表单值是数组格式，每一项保存的是区域的 id</span><br><span class="line">    modelValue: Array as PropType&lt;number[]&gt;,</span><br><span class="line">  &#125;,</span><br><span class="line">  emits: [&apos;update:modelValue&apos;],</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    // 🔴 获取国家列表</span><br><span class="line">    const country = useCountryList();</span><br><span class="line"></span><br><span class="line">    // 🔴 计算当前选中的国家，我们从这里拿到行政区域结构</span><br><span class="line">    const currentCountry = computed(() =&gt; &#123;</span><br><span class="line">      return country.data.value?.data?.find(i =&gt; i.id === props.modelValue?.[0]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const handleCountryChange = (value: number) =&gt; &#123;</span><br><span class="line">      if (value !== props.modelValue?.[0]) &#123;</span><br><span class="line">        // 🛑 国家变动后，重置掉后续的数据</span><br><span class="line">        emit(&apos;update:modelValue&apos;, [value]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;ElSelect</span><br><span class="line">            modelValue=&#123;props.modelValue?.[0]&#125;</span><br><span class="line">            placeholder=&quot;请选择国家&quot;</span><br><span class="line">            onUpdate:modelValue=&#123;handleCountryChange&#125;</span><br><span class="line">            filterable</span><br><span class="line">            fitInputWidth</span><br><span class="line">            loading=&#123;country.isValidating.value&#125;</span><br><span class="line">          &gt;</span><br><span class="line">            &#123;country.data.value?.data?.map(i =&gt; &#123;</span><br><span class="line">              return &lt;ElOption key=&#123;i.id&#125; label=&#123;i.name&#125; value=&#123;i.id&#125;&gt;&lt;/ElOption&gt;;</span><br><span class="line">            &#125;)&#125;</span><br><span class="line">          &lt;/ElSelect&gt;</span><br><span class="line">          &#123;/* 此处暂时忽略 */&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>Composition API 的好处是，它让组合和封装变得非常便利。如上面的代码，我们将获取国家的相关逻辑封装成 useCountryList，代码变得更加简洁易读。</li><li>避免中间变量。恪守 v-model 单向数据流</li></ul><p><br></p><hr><p><br></p><p>接着我们根据选中的国家来渲染后续的区域联动。</p><p>这里提醒一下读者：“不要吝啬创建组件”</p><p>我在  <a href="https://juejin.cn/post/6844903844711759880#heading-2" target="_blank" rel="noopener">React组件设计实践总结04 - 组件的思维</a> 中讲过：</p><blockquote><p>大部分情况下, 组件表示是一个 UI 对象. 其实组件不单单可以表示 UI, 也可以用来抽象业务对象, 有时候抽象为组件可以巧妙地解决一些问题</p></blockquote><p>组件这个设计实在太好用了，笔者觉得它体现的更重要的思想是分治，而不是复用。组件一些比较重要的特性是：</p><ul><li>和函数一样，它是一个封闭的、自包含的单元。父组件不应该操心它，而应该让他自我组织。</li><li>组件有状态。这个是和函数不一样的地方</li><li><p>组件有生命周期。这就意味着组件可以自己管理和销毁自己的资源，不会泄露出去。</p><p>  这是组件和 Hooks 是有本质区别的！我们使用 Hooks 也可以实现一个自我组织的、封闭的、自包含的单元，但是它的生命周期不是它决定的，而是由使用它的宿主组件决定的</p></li></ul><blockquote><p>关于这块的详细阐述可以看笔者的<a href="https://juejin.cn/post/6844903844711759880#heading-2" target="_blank" rel="noopener">旧文章</a>。</p></blockquote><p>所以说，我们可以创建组件来封装区域选择的逻辑，将复杂度分流出去。或者说通过 props 将数据流往下传递给子组件… </p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">export const AreaSelect2 = defineComponent(&#123;</span><br><span class="line">  // 省略</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    // 省略</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;ElSelect</span><br><span class="line">           // 省略</span><br><span class="line">          &gt;</span><br><span class="line">            &#123;country.data.value?.data?.map(i =&gt; &#123;</span><br><span class="line">              return &lt;ElOption key=&#123;i.id&#125; label=&#123;i.name&#125; value=&#123;i.id&#125;&gt;&lt;/ElOption&gt;;</span><br><span class="line">            &#125;)&#125;</span><br><span class="line">          &lt;/ElSelect&gt;</span><br><span class="line">     </span><br><span class="line"><span class="addition">+          &#123;!!currentCountry.value &amp;&amp;</span></span><br><span class="line"><span class="addition">+            currentCountry.value?.regionLevelInfos?.map((i, index) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+              // 父区域 id</span></span><br><span class="line"><span class="addition">+              const parentValue = props.modelValue?.[index];</span></span><br><span class="line"><span class="addition">+              // 当前区域</span></span><br><span class="line"><span class="addition">+              const value = props.modelValue?.[index + 1];</span></span><br><span class="line"><span class="addition">+              // 父区域信息</span></span><br><span class="line"><span class="addition">+              const parentRegion: RegionLevelDTO =</span></span><br><span class="line"><span class="addition">+                index === 0</span></span><br><span class="line"><span class="addition">+                  ? &#123; code: currentCountry.value?.code!, name: currentCountry.value?.name! &#125;</span></span><br><span class="line"><span class="addition">+                  : currentCountry.value?.regionLevelInfos?.[index - 1]!;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+              const handleChange = (nextValue: number) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+                if (value === nextValue) &#123;</span></span><br><span class="line"><span class="addition">+                  return;</span></span><br><span class="line"><span class="addition">+                &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+                assert(Array.isArray(props.modelValue), 'modelValue is required');</span></span><br><span class="line"><span class="addition">+                // 裁剪掉当前区域后面的区域数据</span></span><br><span class="line"><span class="addition">+                const clone = [...props.modelValue].slice(0, index + 2);</span></span><br><span class="line"><span class="addition">+                clone[index + 1] = nextValue;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+                emit('update:modelValue', clone);</span></span><br><span class="line"><span class="addition">+              &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+              return (</span></span><br><span class="line"><span class="addition">+                &lt;Section</span></span><br><span class="line"><span class="addition">+                  index=&#123;index&#125;</span></span><br><span class="line"><span class="addition">+                  parentValue=&#123;parentValue&#125;</span></span><br><span class="line"><span class="addition">+                  modelValue=&#123;value&#125;</span></span><br><span class="line"><span class="addition">+                  region=&#123;i&#125;</span></span><br><span class="line"><span class="addition">+                  parentRegion=&#123;parentRegion&#125;</span></span><br><span class="line"><span class="addition">+                  country=&#123;currentCountry.value!&#125;</span></span><br><span class="line"><span class="addition">+                  onUpdate:modelValue=&#123;handleChange&#125;</span></span><br><span class="line"><span class="addition">+                /&gt;</span></span><br><span class="line"><span class="addition">+              );</span></span><br><span class="line"><span class="addition">+            &#125;)&#125;</span></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p>继续分流, 看看 Section 组件的实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Section = defineComponent(&#123;</span><br><span class="line">  name: &apos;AreaSelectSection&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 当前索引</span><br><span class="line">     */</span><br><span class="line">    index: &#123; type: Number, required: true &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 区域信息</span><br><span class="line">     */</span><br><span class="line">    region: &#123; type: Object as PropType&lt;RegionLevelDTO&gt;, required: true &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当前国家</span><br><span class="line">     */</span><br><span class="line">    country: &#123; type: Object as PropType&lt;CountryInfoDTO&gt;, required: true &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 父级</span><br><span class="line">     */</span><br><span class="line">    parentRegion: &#123; type: Object as PropType&lt;RegionLevelDTO&gt;, required: true &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 父级的值</span><br><span class="line">     */</span><br><span class="line">    parentValue: Number,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当前值</span><br><span class="line">     */</span><br><span class="line">    modelValue: Number,</span><br><span class="line">  &#125;,</span><br><span class="line">  emits: [&apos;update:modelValue&apos;],</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    // 获取区域列表</span><br><span class="line">    const region = useRegion(</span><br><span class="line">      computed(() =&gt; &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          countryId: props.country.id,</span><br><span class="line">          level: props.index + 1,</span><br><span class="line">          parentId: props.parentValue,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    const handleChange = (value: number) =&gt; &#123;</span><br><span class="line">      emit(&apos;update:modelValue&apos;, value);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;ElSelect</span><br><span class="line">          modelValue=&#123;props.modelValue&#125;</span><br><span class="line">          placeholder=&#123;`请选择$&#123;props.region.name&#125;`&#125;</span><br><span class="line">          filterable</span><br><span class="line">          fitInputWidth</span><br><span class="line">          disabled=&#123;!props.parentValue&#125;</span><br><span class="line">          onUpdate:modelValue=&#123;handleChange&#125;</span><br><span class="line">          loading=&#123;region.isValidating.value&#125;</span><br><span class="line">          class=&#123;s.select&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          &#123;region.data.value?.data?.map(i =&gt; &#123;</span><br><span class="line">            return &lt;ElOption key=&#123;i.id&#125; label=&#123;i.name&#125; value=&#123;i.id&#125;&gt;&lt;/ElOption&gt;;</span><br><span class="line">          &#125;)&#125;</span><br><span class="line">        &lt;/ElSelect&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可见，Section 的实现也再简单不过了。到这里，我相信很多读者已经感受到“响应式”编程的魅力了吧</p><p><br><br><br><br><br></p><h1 id="原则和建议"><a href="#原则和建议" class="headerlink" title="原则和建议"></a>原则和建议</h1><ol><li>优先使用 <code>computed</code>，警惕 <code>watch</code>/<code>watchEffect</code> 等 API 的使用。转换思维先从克制使用 watch 开始。</li><li>适当使用 <code>readonly</code>, 禁止状态被坏人修改</li><li>最小化状态。避免创建‘缓存’状态，让数据自然流动，不要阻断。</li><li>自顶而下，将细节/副作用分流到 hooks 或子组件中，起一个好一点的名字， 让流程看起来更清晰</li><li>将 watch 转换为 computed 的语义。外观上的差别是 watch 有 callback， 而 computed 是「管道」，会衍生新的数据。比如上面 useRequest 的例子</li><li>推荐使用 VueUse</li><li>封装 hooks， 让各种外部的状态或副作用优雅地集成进来</li><li>单向数据流，对这个有两层理解<ul><li>表示是一种数据流动的方向，通常和 CQRS 模式配合，比如 Redux、Vuex，只能单向的修改和查询</li><li>表示一种数据管辖的范围。 通常应用只有数据的拥有者才有权限变更。进一步地讲，我们应该以组件为边界，来限定数据的管辖范围。需要变更时，通过‘事件’ 来通知拥有者。比如 严格遵循 v-model 协议。</li></ul></li><li><p>使用响应式开发思维，构造单向的数据流</p><ul><li>尽量管道化的方式去设计你的程序</li><li>声明式，不要命令式</li><li>拆分组件或hooks来分治数据流</li><li>组件之间 props 传递也属于数据流。</li></ul><ol start="10"><li>使用 ref/reactive → computed → watch → handler → render 这样的顺序组织代码</li></ol></li></ol><p>🌹本文完，你的点赞是我写作的最大动力，欢迎留言转发（备注原文作者和链接）。</p><p><br><br><br></p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://juejin.cn/post/6844903844711759880#heading-4" target="_blank" rel="noopener">React组件设计实践总结04 - 组件的思维</a></li><li><a href="https://rxjs.dev/" target="_blank" rel="noopener">RxJS</a></li><li><a href="https://dev.to/lloyds-digital/comparing-reactivity-models-react-vs-vue-vs-svelte-vs-mobx-vs-solid-29m8" target="_blank" rel="noopener">Comparing reactivity models - React vs Vue vs Svelte vs MobX vs Solid vs Redux</a></li><li><a href="https://zhuanlan.zhihu.com/p/25383159" target="_blank" rel="noopener">RxJS 入门指引和初步应用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vue-with-rx/Untitled.png&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;写这篇文章的动机可以追溯到 3 年前， 我发现很多身边开发者并没有正确地使用 React Hooks, 所以我觉得应该把我的开发经验和思维整
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>次世代前端视图框架都在卷啥？</title>
    <link href="https://bobi.ink/2023/07/02/fe-view-future/"/>
    <id>https://bobi.ink/2023/07/02/fe-view-future/</id>
    <published>2023-07-01T16:00:00.000Z</published>
    <updated>2023-07-04T01:19:01.665Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/fe-view-future/Untitled.png" alt="state of JavaScript 2022 满意度排名"></p><p>state of JavaScript 2022 满意度排名</p><p>上图是 <a href="https://2022.stateofjs.com/zh-Hans/libraries/front-end-frameworks/" target="_blank" rel="noopener">State of JavaScript</a> 2022 前端框架满意度排名。前三名分别是 <code>Solid</code>、<code>Svelte</code>、<code>Qwik</code>。我们可以称他们为次世代前端框架的三大代表，前辈是 <code>React</code>/<code>Angular</code>/<code>Vue</code>。<br>目前 React/Augular/Vue 还占据的主流的市场地位， 现在我们还不知道下一个五年、十年谁会成为主流，有可能前辈会被后浪拍死在沙滩上， 也有可能你大爷还是你大爷。</p><p>就像编程语言一样，尽管每年都有新的语言诞生，但是撼动主流编程语言的地位谈何容易。在企业级项目中，我们的态度会趋于保守，选型会偏向稳定、可靠、生态完善的技术，因此留给新技术的生存空间并不多。除非是革命性的技术，或者有大厂支撑，否则这些技术或框架只会停留小众圈子内。</p><blockquote><p>比如有一点革命性、又有大厂支撑的 Flutter。</p></blockquote><p><br></p><p>那么从更高的角度看，这些次时代的前端视图框架在卷哪些方向呢？有哪些是革命性的呢?</p><p>先说一下本文的结论：</p><ul><li>整体上视图编程范式已经固化</li><li>局部上体验上内卷</li></ul><p><br><br><br></p><h1 id="视图编程范式固化"><a href="#视图编程范式固化" class="headerlink" title="视图编程范式固化"></a>视图编程范式固化</h1><p>从 JQuery 退出历史舞台，再到 React 等占据主流市场。视图的编程范式基本已经稳定下来，不管你在学习什么视图框架，我们接触的概念模型是趋同的，无非是实现的手段、开发体验上各有特色：</p><ul><li><strong>数据驱动视图</strong>。数据是现代前端框架的核心，视图是数据的映射， <code>View=f(State)</code> 这个公式基本成立。</li><li><strong>声明式视图</strong>。相较于上一代的 jQuery，现代前端框架使用声明式描述视图的结构，即描述结果而不是描述过程。</li><li><strong>组件化视图</strong>。组件是现代前端框架的第一公民。组件涉及的概念无非是 props、slots、events、ref、Context…</li></ul><p><br><br><br></p><h1 id="局部体验内卷"><a href="#局部体验内卷" class="headerlink" title="局部体验内卷"></a>局部体验内卷</h1><p>回顾一下 4 年前写的 <strong><a href="https://juejin.cn/post/6844903865926549511" target="_blank" rel="noopener">浅谈 React 性能优化的方向</a></strong>，现在看来依旧不过时，各大框架无非也是围绕着这些「方向」来改善。</p><p>当然，在「框架内卷」、「既要又要还要」时代，新的框架要脱颖而出并不容易，它既要服务好开发者(<code>开发体验</code>)，又要服务好客户(<code>用户体验</code>) ， 性能不再是我们选择框架的首要因素。</p><p><br></p><p>以下是笔者总结的，次世代视图框架的内卷方向:</p><ul><li><strong>用户体验</strong><ul><li>性能优化<ul><li>精细化渲染：这是次世代框架内卷的主要战场，它们的首要目的基本是实现低成本的精细化渲染<ul><li>预编译方案：代表有 Svelte、Solid</li><li>响应式数据：代表有 Svelte、Solid、Vue、Signal(不是框架)</li><li>动静分离</li></ul></li></ul></li><li>并发(Concurrent)：React 在这个方向独枳一树。</li><li>去 JavaScript：为了获得更好的首屏体验，各大框架开始「抛弃」JavaScript，都在比拼谁能更快到达用户的眼前，并且是完整可交互的形态。</li></ul></li><li><strong>开发体验</strong><ul><li>Typescript 友好：不支持 Typescript 基本就是 ca</li><li>开发工具链/构建体验: Vite、Turbopack… 开发的工具链直接决定了开发体验</li><li>开发者工具：框架少不了开发者工具，从 Vue Devtools 再到 <a href="https://devtools.nuxtjs.org/" target="_blank" rel="noopener">Nuxt Devtools</a>，酷炫的开发者工具未来可能都是标配</li><li>元框架: 毛坯房不再流行，从前到后、大而全的元框架称为新欢，内卷时代我们只应该关注业务本身。代表有 Nextjs、Nuxtjs</li></ul></li></ul><p><br><br><br><br><br></p><h2 id="精细化渲染"><a href="#精细化渲染" class="headerlink" title="精细化渲染"></a>精细化渲染</h2><p><br><br><br></p><h3 id="预编译方案"><a href="#预编译方案" class="headerlink" title="预编译方案"></a>预编译方案</h3><p>React、Vue 这些以 Virtual DOM 为主的渲染方式，通常只能做到组件级别的精细化渲染。<strong>而次世代的 Svelte、Solidjs 不约而同地抛弃了 Virtual DOM，采用静态编译的手段，将「声明式」的视图定义，转译为「命令式」的 DOM 操作</strong>。</p><p>Svelte</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> count = <span class="number">0</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    count += 1</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">on:click</span>=<span class="string">"&#123;handleClick&#125;"</span>&gt;</span>Clicked &#123;count&#125; &#123;count === 1 ? 'time' : 'times'&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编译结果：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ....</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_fragment</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> button</span><br><span class="line">  <span class="keyword">let</span> t0</span><br><span class="line">  <span class="keyword">let</span> t1</span><br><span class="line">  <span class="keyword">let</span> t2</span><br><span class="line">  <span class="keyword">let</span> t3_value = <span class="comment">/*count*/</span> (ctx[<span class="number">0</span>] === <span class="number">1</span> ? <span class="string">'time'</span> : <span class="string">'times'</span>) + <span class="string">''</span></span><br><span class="line">  <span class="keyword">let</span> t3</span><br><span class="line">  <span class="keyword">let</span> mounted</span><br><span class="line">  <span class="keyword">let</span> dispose</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    c() &#123;</span><br><span class="line">      button = element(<span class="string">'button'</span>)</span><br><span class="line">      t0 = text(<span class="string">'Clicked '</span>)</span><br><span class="line">      t1 = text(<span class="comment">/*count*/</span> ctx[<span class="number">0</span>])</span><br><span class="line">      t2 = space()</span><br><span class="line">      t3 = text(t3_value)</span><br><span class="line">    &#125;,</span><br><span class="line">    m(target, anchor) &#123;</span><br><span class="line">      insert(target, button, anchor)</span><br><span class="line">      append(button, t0)</span><br><span class="line">      append(button, t1)</span><br><span class="line">      append(button, t2)</span><br><span class="line">      append(button, t3)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!mounted) &#123;</span><br><span class="line">        dispose = listen(button, <span class="string">'click'</span>, <span class="comment">/*handleClick*/</span> ctx[<span class="number">1</span>])</span><br><span class="line">        mounted = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    p(ctx, [dirty]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dirty &amp; <span class="comment">/*count*/</span> <span class="number">1</span>) set_data(t1, <span class="comment">/*count*/</span> ctx[<span class="number">0</span>])</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        dirty &amp; <span class="comment">/*count*/</span> <span class="number">1</span> &amp;&amp;</span><br><span class="line">        t3_value !== (t3_value = <span class="comment">/*count*/</span> (ctx[<span class="number">0</span>] === <span class="number">1</span> ? <span class="string">'time'</span> : <span class="string">'times'</span>) + <span class="string">''</span>)</span><br><span class="line">      )</span><br><span class="line">        set_data(t3, t3_value)</span><br><span class="line">    &#125;,</span><br><span class="line">    i: noop,</span><br><span class="line">    o: noop,</span><br><span class="line">    d(detaching) &#123;</span><br><span class="line">      <span class="keyword">if</span> (detaching) &#123;</span><br><span class="line">        detach(button)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mounted = <span class="literal">false</span></span><br><span class="line">      dispose()</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance</span>(<span class="params">$$self, $$props, $$invalidate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $$invalidate(<span class="number">0</span>, (count += <span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [count, handleClick]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">SvelteComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    init(<span class="keyword">this</span>, options, instance, create_fragment, safe_not_equal, &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><p>我们看到，简洁的模板最终被转移成了底层 DOM 操作的命令序列。</p><p>我写文章比较喜欢比喻，这种场景让我想到，编程语言对内存的操作，DOM 就是浏览器里面的「内存」：</p><ul><li>Virtual DOM 就是那些那些带 GC 的语言，使用运行时的方案来屏蔽 DOM 的操作细节，这个抽象是有代价的</li><li>预编译方案则更像 Rust，没有引入运行时 GC, 使用了一套严格的所有权和对象生命周期管理机制，让编译器帮你转换出安全的内存操作代码。</li><li>手动操作 DOM, 就像 C、C++ 这类底层语言，需要开发者手动管理内存</li></ul><p>使用 Svelte/SolidJS 这些方案，可以做到修改某个数据，精细定位并修改 DOM 节点，犹如我们当年手动操作 DOM 这么精细。而 Virtual DOM 方案，只能到组件这一层级，除非你的组件粒度非常细。</p><p><br><br><br><br><br></p><h3 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h3><p>和精细化渲染脱不开身的还有<code>响应式数据</code>。</p><p>React 一直被诟病的一点是当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树，如果要避免不必要的子组件的重渲染，需要开发者手动进行优化(比如 <code>shouldComponentUpdate</code>、<code>PureComponent</code>、<code>memo</code>、<code>useMemo</code>/<code>useCallback</code>)  。同时你可能会需要使用不可变的数据结构来使得你的组件更容易被优化。</p><p>在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。</p><p>近期比较火热的 signal (信号，Angular、Preact、Qwik、Solid 等框架都引入了该概念)，如果读者是 Vue 或者 MobX 之类的用户， Signal 并不是新的概念。</p><p>按 Vue 官方文档的话说：<em>从根本上说，信号是与 Vue 中的 ref 相同的响应性基础类型。它是一个在访问时跟踪依赖、在变更时触发副作用的值容器。</em></p><p>不管怎样，响应式数据不过是<code>观察者模式</code>的一种实现。相比 React 主导的通过不可变数据的比对来标记重新渲染的范围，响应式数据可以实现更细粒度的绑定；而且响应式的另一项优势是它的可传递性(有些地方称为 <code>Props 下钻</code>(Props Drilling))。</p><p><br><br><br></p><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>Vue 3 就是动静结合的典型代表。在我看来 Vue 深谙中庸之道，在它身上我们很难找出短板。</p><p>Vue 的模板是需要静态编译的，这使得它可以像 Svelte 等框架一样，有较大的优化空间；同时保留了 Virtual DOM 和运行时 Reactivity，让它兼顾了灵活和普适性。</p><p>基于静态的模板，Vue 3 做了很多优化，笔者将它总结为<code>动静分离</code>吧。比如静态提升、更新类型标记、树结构打平，无非都是将模板中的静态部分和动态部分作一些分离，避免一些无意义的更新操作。</p><p>更长远的看，受 SolidJS 的启发， Vue 未来可能也会退出 Vapor 模式，不依赖 Virtual DOM 来实现更加精细的渲染。</p><p><br><br><br><br><br></p><h2 id="再谈编译时和运行时"><a href="#再谈编译时和运行时" class="headerlink" title="再谈编译时和运行时"></a>再谈编译时和运行时</h2><p>编译时和运行时没有优劣之分， 也不能说纯编译的方案就必定是未来的趋势。</p><p>这几年除了新的编译时的方案冒出来，宣传自己是未来；也有从编译时的焦油坑里爬出来， 转到运行时方案的，这里面的典型代表就是 Taro。</p><p>Taro 2.0 之前采用的是静态编译的方案，即将 ’React‘ 组件转译为小程序原生的代码:</p><p><img src="/images/fe-view-future/Untitled%201.png" alt="Untitled"></p><p>但是这个转译工作量非常庞大，JSX 的写法千变万化，非常灵活。Taro 只能采用 <code>穷举</code> 的方式对 JSX 可能的写法进行了一 一适配，这一部分工作量很大，实际上 Taro 有大量的 Commit 都是为了更完善的支持 JSX 的各种写法。这也是 Taro 官方放弃这种架构的原因。</p><p>也就是说 <strong>Taro 也只能覆盖我们常见的 JSX 用法，而且我们必须严格遵循 Taro 规范才能正常通过。</strong></p><p>有非常多的局限：</p><ul><li>静态的 JSX</li><li>不支持高阶组件</li><li>不支持动态组件</li><li>不支持操作 JSX 的结果</li><li>不支持 render function</li><li>不能重新导出组件</li><li>需要遵循 on<em>、render</em> 约束</li><li>不支持 Context、Fragment、props 展开、forwardRef</li><li>….</li></ul><p><a href="https://www.notion.so/Taro-React-65161e2a09f648c0ad1c69f314ff3cea?pvs=21" target="_blank" rel="noopener">有太多太多的约束</a>，这已经不是带着镣铐跳舞了，是被五花大绑了。</p><p><br></p><p>使用编译的方案不可避免的和实际运行的代码有较大的 <code>Gap</code>，源码和实际运行的代码存在较大的差别会导致什么？</p><ul><li>比较差的 Debug 体验。</li><li>比较黑盒。</li></ul><p>我们在歌颂编译式的方案，能给我们带来多大的性能提升、带来多么简洁的语法的同时。另一方面，一旦我们进行调试/优化，我们不得不跨越这层 Gap，去了解它转换的逻辑和底层实现。</p><p>这是一件挺矛盾的事情，当我们「精通」这些框架的时候，估计我们已经是一个<code>人肉编译器</code>了。</p><p>Taro 2.x 配合小程序， 这对卧龙凤雏, 可以将整个开发体验拉到地平线以下。</p><p><br></p><p>回到这些『次世代』框架。React/Vue/Angular 这些框架先入为主， 在它们的教育下，我们对前端视图开发的概念和编程范式的认知已经固化。</p><p><img src="/images/fe-view-future/Untitled%202.png" alt="Untitled"></p><p>比如在笔者看来 Svelte 是违法直觉的。因为 JavaScript 本身并不支持这种语义。Svelte 要支持这种语义需要一个编译器，而作为一个 JavaScript 开发者，我也需要进行心智上的转换。</p><p>而 SolidJS 则好很多，目之所及都是我们熟知的东西。尽管编译后可能是一个完全不一样的东西。</p><blockquote><p>💡 Vue 曾经也过一个名为<strong><a href="https://cn.vuejs.org/guide/extras/reactivity-transform.html" target="_blank" rel="noopener">响应性语法糖</a></strong>的实验性功能来探索这个方向，但最后由于<strong><a href="https://github.com/vuejs/rfcs/discussions/369#discussioncomment-5059028" target="_blank" rel="noopener">这个原因</a></strong>，废弃了。这是一次明智的决定</p></blockquote><p>当然，年轻的次世代的前端开发者可能不这么认为，他们毕竟没有经过旧世代框架的先入为主和洗礼，他们更能接受新的开发范式，然后扛起这些旗帜，让它们成为未来主流。</p><p>总结。纯编译的方能可以带来更简洁的语法、更多性能优化的空间，甚至也可以隐藏一些跨平台/兼容性的细节。另一方面，源码和实际编译结果之间的 Gap，可能会逼迫开发者成为人肉编译器，尤其在复杂的场景，对开发者的心智负担可能是翻倍的。</p><p>对于框架开发者来说，纯编译的方案实现复杂度会更高，这也意味着，会有较高贡献门槛，间接也会影响生态。</p><p><br><br><br><br><br></p><h2 id="去-javascript"><a href="#去-javascript" class="headerlink" title="去 JavaScript"></a>去 JavaScript</h2><p>除了精细化渲染，Web 应用的首屏体验也是框架内卷的重要方向，这个主要的发展脉络，笔者在 <a href="https://juejin.cn/post/7241027834490437669" target="_blank" rel="noopener">现代前端框架的渲染模式</a> 一文已经详细介绍，推荐大家读一下：</p><p><img src="/images/fe-view-future/Untitled%203.png" alt="Untitled"></p><p>这个方向的强有力的代表主要有 Astro(Island Architecture 岛屿架构)、Next.js(React Server Component)、Qwik(Resumable 去 Hydration)。</p><p>这些框架基本都是秉承 SSR 优先，在首屏的场景，JavaScript 是「有害」的，为了尽量更少地向浏览器传递 JavaScript，他们绞尽脑汁 ：</p><ul><li>Astro：’静态 HTML‘优先，如果想要 SPA 一样实现复杂的交互，可以申请开启一个岛屿，这个岛屿支持在客户端进行水合和渲染。你可以把岛屿想象成一个 iframe 一样的玩意。</li><li>React Server Component: 划分服务端组件和客户端组件，服务端组件仅在服务端运行，客户端只会看到它的渲染结果，JavaScript 执行代码自然也仅存于服务端。</li><li>Qwik：我要直接革了水合(Hydration)的命，我不需要水合，需要交互的时候，我惰性从服务端拉取事件处理器不就可以了…</li></ul><p>不得不说，「去 JavaScript」的各种脑洞要有意思多了。</p><p><br><br><br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要讲了次世代前端框架的内卷方向，目前来看还处于量变的阶段，并没有脱离现在主流框架的心智模型，因此我们上手起来基本不会有障碍。</p><p>作为普通开发者，我们可以站在更高的角度去审视这些框架的发展，避免随波逐流和无意义的内卷。</p><p><br><br><br></p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/597473358" target="_blank" rel="noopener">新时代的 SSR 框架破局者：<em>qwik</em></a></li><li><a href="https://cn.vuejs.org/guide/extras/rendering-mechanism.html" target="_blank" rel="noopener">Vue 渲染机制</a></li><li><a href="https://cn.vuejs.org/guide/extras/reactivity-in-depth.html" target="_blank" rel="noopener">Vue 深入响应式系统</a></li><li><a href="https://2022.stateofjs.com/zh-Hans/libraries/front-end-frameworks/" target="_blank" rel="noopener">State of JavaScript</a></li><li><a href="https://juejin.cn/post/6844903865926549511" target="_blank" rel="noopener">浅谈 React 性能优化的方向</a></li><li><a href="https://zhuanlan.zhihu.com/p/350507037" target="_blank" rel="noopener">新兴前端框架 Svelte 从入门到原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/fe-view-future/Untitled.png&quot; alt=&quot;state of JavaScript 2022 满意度排名&quot;&gt;&lt;/p&gt;
&lt;p&gt;state of JavaScript 2022 满意度排名&lt;/p&gt;
&lt;p&gt;上图是 &lt;a 
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>全新 JavaScript 装饰器实战下篇：实现依赖注入</title>
    <link href="https://bobi.ink/2023/06/30/decorator-2/"/>
    <id>https://bobi.ink/2023/06/30/decorator-2/</id>
    <published>2023-06-29T16:00:00.000Z</published>
    <updated>2023-06-30T08:43:56.329Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/decorator-2/Untitled.jpeg" alt="cover"></p><p><br></p><p>系列文章：</p><ul><li><a href="https://www.notion.so/Javascript-MobX-Vue-5e1c633167094d9784e602d66a5877f8?pvs=21" target="_blank" rel="noopener">全新 Javascript 装饰器实战上篇：用 MobX 的方式打开 Vue </a></li><li><a href="https://www.notion.so/JavaScript-0729df8081ec44b48f6f2e6ec7835120?pvs=21" target="_blank" rel="noopener">全新 JavaScript 装饰器实战下篇：实现依赖注入</a></li></ul><p>上一篇<a href="https://www.notion.so/Javascript-MobX-Vue-5e1c633167094d9784e602d66a5877f8?pvs=21" target="_blank" rel="noopener">文章</a>我们介绍了 JavaScript 最新的装饰器提案，以及它和旧版的区别。这篇文章我们将继续深入装饰器，尝试实现一个简易的依赖注入库。</p><p><br></p><p>谈到装饰器我们总会听到 <code>reflect-metadata</code>, 尤其是社区上的依赖注入库，比如 <a href="https://github.com/inversify/InversifyJS" target="_blank" rel="noopener">inversify.js</a></p><p><br></p><p><img src="/images/decorator-2/Untitled.png" alt="inversify.js"></p><p><br></p><p><strong>我们在上一篇文章的装饰器实现中，会直接去转换或者修改类的结构，大部分场景这并不是最佳实践。</strong></p><p><strong>大部分情况下我们应该利用装饰器来收集一些标注信息</strong>，比如 MobX 用装饰器来标注哪些是 observable、哪些是 computed；Inversify.js 用 inject 标注哪些属性需要进行注入；Angular.js 使用 Input/Output 标记属性….</p><p>如果我们要通过装饰器来标记类的原信息，那就得来认识一下：装饰器的好搭子 <code>reflect-metadata</code> 。</p><p><br><br><br><br><br></p><h2 id="di-库经常提及的-reflect-metadata-到底是什么？"><a href="#di-库经常提及的-reflect-metadata-到底是什么？" class="headerlink" title="DI 库经常提及的 reflect-metadata 到底是什么？"></a>DI 库经常提及的 reflect-metadata 到底是什么？</h2><p>这是一个 JavaScript 提案，但是作者并没有<a href="https://github.com/rbuckton/reflect-metadata/issues/96" target="_blank" rel="noopener">将其提交到 TC39</a>。它的继任者现在是 <a href="https://github.com/tc39/proposal-decorator-metadata" target="_blank" rel="noopener">Decorator Metadata</a>，现在已经进入了 Stage 3 阶段，Typescript 也将在 5.2 中实现这个提案。</p><p>Decorator Metadata 会在下文详细介绍，我们先来看看 reflect-metadata。</p><p>先来看看使用它能用来干啥：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test(&apos;reflect-metadata&apos;, () =&gt; &#123;</span><br><span class="line">  const key = &apos;myKey&apos;</span><br><span class="line"></span><br><span class="line">  // 🔴 装饰器语法</span><br><span class="line">  @Reflect.metadata(key, &apos;inClass&apos;)</span><br><span class="line">  class Foo &#123;</span><br><span class="line">    @Reflect.metadata(key, &apos;inStaticMember&apos;)</span><br><span class="line">    static staticMember = 1</span><br><span class="line"></span><br><span class="line">    @Reflect.metadata(key, &apos;inMember&apos;)</span><br><span class="line">    member = 2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 🔴 上述装饰器等价于</span><br><span class="line">  Reflect.defineMetadata(key, &apos;inClass&apos;, Foo)</span><br><span class="line">  Reflect.defineMetadata(key, &apos;inStaticMember&apos;, Foo, &apos;staticMember&apos;)</span><br><span class="line">  Reflect.defineMetadata(key, &apos;inMember&apos;, Foo.prototype, &apos;member&apos;)</span><br><span class="line"></span><br><span class="line">  // 🔴 静态成员</span><br><span class="line">  expect(Reflect.getMetadata(key, Foo)).toBe(&apos;inClass&apos;)</span><br><span class="line">  expect(Reflect.getMetadata(key, Foo, &apos;staticMember&apos;)).toBe(&apos;inStaticMember&apos;)</span><br><span class="line"></span><br><span class="line">  // 🔴 实例成员，**需要通过实例获取**</span><br><span class="line">  expect(Reflect.getMetadata(key, Foo, &apos;member&apos;)).toBeUndefined()</span><br><span class="line">  const foo = new Foo()</span><br><span class="line">  expect(Reflect.getMetadata(key, foo, &apos;member&apos;)).toBe(&apos;inMember&apos;)</span><br><span class="line">  // 或者通过原型对象获取</span><br><span class="line">  expect(Reflect.getMetadata(key, Foo.prototype, &apos;member&apos;)).toBe(&apos;inMember&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>通过上面的 「hello world」 我们可以发现：</p><ol><li>可以作为<code>装饰器</code>使用。这个表示这个提案和装饰器有不解的渊源，所以当我们谈及装饰器的时候，总会看到它的身影。</li><li>元数据? 没那么高大上，就是一些 key/value 存储</li><li>扩展了 Reflect API？为什么是 Reflect API?</li><li>关于存储位置，类和静态成员存储在类上，实例成员存储在类的原型上(prototype)</li></ol><p><br></p><p>通过上面的皮毛，我们 GET 不到它要解决痛点是啥。不就是存储一些元数据嘛，我们不需要这个 API 也可以做到，比如 MobX 的装饰器就是放在原型上的一个隐藏自定义属性上：</p><p><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function storeAnnotation(prototype: any, key: PropertyKey, annotation: Annotation) &#123;</span><br><span class="line">  if (!hasProp(prototype, storedAnnotationsSymbol)) &#123;</span><br><span class="line">    addHiddenProp(prototype, storedAnnotationsSymbol, &#123;</span><br><span class="line">      // Inherit annotations</span><br><span class="line">      ...prototype[storedAnnotationsSymbol],</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><p>实际上这个概念是从其他语言借鉴的，比如下面 Java Spring 依赖注入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 中，可以通过它的 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html" target="_blank" rel="noopener">Reflect API</a> 可以获取到类的<code>类型信息</code>，比如方法、方法的参数、返回值等类型信息。</p><p>然而，JavaScript 是一门弱类型语言，没有这类信息。所以我们在实现<code>依赖注入</code>时，并不能做到像 Java 那么强大：</p><p><br></p><p>Java:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> Engine engine;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      engine.turnOn();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vs Typescript</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Engine &#123;&#125;</span><br><span class="line"></span><br><span class="line">@injectable()</span><br><span class="line">class Car &#123;</span><br><span class="line">  @inject(&apos;EngineKey&apos;)</span><br><span class="line">  private engine: Engine</span><br><span class="line">  start() &#123;</span><br><span class="line">    this.engine.turnOn()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Java Spring 可以自动推断类型来进行注入</strong>，这个类型可以是接口、具体的类、抽象类等等。而现在 JavaScript 下的 DI 库，我们通常需要显式指定一个标识符，或者只能是一个具体的类(不支持接口)， 一点也不够优雅。</p><p>既然现在有了 <code>Typescript</code> ，能不能做到呢？Typescript 最终也是转换为 JavaScript ，默认情况下<code>类型信息</code>都会被裁减掉。</p><p>而 reflect-metadata 的初衷还是想将 Java/C# 这类语言的 Reflect 能力带到 JavaScript。<strong>因此就拟定了这样一个协议， 让 Typescript 或者其他转译到 JavaScript 强类型语言，可以通过它将类型信息保留下来。</strong></p><p><br></p><p>所以我们看到 Typescript 是它的主要推动者。我们在 Typescript 中可以通过开启 <code>emitDecoratorMetadata</code> 实现装饰器类型信息的保留:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Bar &#123;&#125;</span><br><span class="line"></span><br><span class="line">@d</span><br><span class="line">class Foo &#123;</span><br><span class="line">  @d</span><br><span class="line">  static staticMember = 1</span><br><span class="line"></span><br><span class="line">  @d</span><br><span class="line">  member = 2</span><br><span class="line"></span><br><span class="line">  @d</span><br><span class="line">  method(foo: number, bar: Bar, baz: Foo): string &#123;&#125;</span><br><span class="line"></span><br><span class="line">  constructor(a: Bar) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var __metadata =</span><br><span class="line">  (this &amp;&amp; this.__metadata) ||</span><br><span class="line">  function (k, v) &#123;</span><br><span class="line">    if (typeof Reflect === &apos;object&apos; &amp;&amp; typeof Reflect.metadata === &apos;function&apos;)</span><br><span class="line">      return Reflect.metadata(k, v)</span><br><span class="line">  &#125;</span><br><span class="line">// 省略部分代码</span><br><span class="line">__decorate([d, __metadata(&apos;design:type&apos;, Object)], Foo.prototype, &apos;member&apos;, void 0)</span><br><span class="line">__decorate(</span><br><span class="line">  [</span><br><span class="line">    d,</span><br><span class="line">    __metadata(&apos;design:type&apos;, Function),</span><br><span class="line">    __metadata(&apos;design:paramtypes&apos;, [Number, Object, Foo]),</span><br><span class="line">    __metadata(&apos;design:returntype&apos;, String),</span><br><span class="line">  ],</span><br><span class="line">  Foo.prototype,</span><br><span class="line">  &apos;method&apos;,</span><br><span class="line">  null</span><br><span class="line">)</span><br><span class="line">__decorate([d, __metadata(&apos;design:type&apos;, Object)], Foo, &apos;staticMember&apos;, void 0)</span><br><span class="line">Foo = __decorate([d, __metadata(&apos;design:paramtypes&apos;, [Object])], Foo)</span><br></pre></td></tr></table></figure><p>我们看到大部分的类型信息都保留下来了，比如成员类型、方法的参数/返回值类型。</p><p>但是它也有局限性，比如接口等自定义类型依旧无法保留，毕竟 JavaScript 并没有这些概念。这也直接决定了依旧无法和 Java 这种「原生」强类型语言比肩。</p><p><br></p><blockquote><p>reflect-metadata 可能代表的是 JavaScript 作为一个新汇编语言的觉悟，但是目前的事实也证明了这条路比较难。就拿 Typescript 来说，保留的信息比较有限，而且这会让开发者的技术栈严重依赖 Typescript，另外像 esbuild、swc、babel 这些转译器也很难跟进这种特性。<br><br><br>实际上，现在流行的 DI 库，如 <code>inversify</code>、<code>tsyringe</code> 对 Typescript <code>emitDecoratorMetadata</code> 的依赖也很小，去掉基本上不影响其有效运行。</p></blockquote><blockquote></blockquote><p><br></p><p>总结, reflect-metadata 视图提供一个类(class)元信息的存储标准。在笔者开来，主要的愿景是为上层更高级的语言(比如 Typescript)保留静态类型信息提供一种方式。其次，普通开发者也能使用这个标准化的 API 来给类标注信息。</p><p><br><br><br><br><br></p><h2 id="decorator-metadata"><a href="#decorator-metadata" class="headerlink" title="Decorator Metadata"></a>Decorator Metadata</h2><p>如今的 Metadata 提案已经从装饰器中分离出来，目前也进入了 Stage 3 阶段。经过重新设计的 Metadata 和 reflect-metadata 不是同一个玩意。</p><p>这个提案非常简单，就是新增了一个内置 Symbol —— <code>Symbol.metadata</code>。在装饰器的配合将元数据存储在类的 Symbol.metadata 下面:</p><p><br><br><br></p><p>针对装饰器协议的扩展:</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">type Decorator = (value: Input, context: &#123;</span><br><span class="line">  kind: string;</span><br><span class="line">  name: string | symbol;</span><br><span class="line">  access: &#123;</span><br><span class="line">    get?(): unknown;</span><br><span class="line">    set?(value: unknown): void;</span><br><span class="line">  &#125;;</span><br><span class="line">  isPrivate?: boolean;</span><br><span class="line">  isStatic?: boolean;</span><br><span class="line">  addInitializer?(initializer: () =&gt; void): void;</span><br><span class="line"><span class="addition">+ metadata?: Record&lt;string | number | symbol, unknown&gt;;</span></span><br><span class="line">&#125;) =&gt; Output | void;</span><br></pre></td></tr></table></figure><p><br></p><p>所有装饰器的 context 对象新增了 metadata 对象。 metadata 只是一个普通的对象，没什么特别：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function meta(key: string) &#123;</span><br><span class="line">  return (value: unknown, context: DecoratorContext) =&gt; &#123;</span><br><span class="line">    context.metadata![key] = true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@meta(&apos;inClass&apos;)</span><br><span class="line">class Foo &#123;</span><br><span class="line">  @meta(&apos;inStaticMember&apos;)</span><br><span class="line">  static staticMember = 1</span><br><span class="line"></span><br><span class="line">  @meta(&apos;inMember&apos;)</span><br><span class="line">  member = 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 类的所有装饰器共享</span><br><span class="line">expect(Foo[Symbol.metadata]).toEqual(&#123;</span><br><span class="line">  inStaticMember: true,</span><br><span class="line">  inMember: true,</span><br><span class="line">  inClass: true,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>就是这么朴实且无华。因为<strong>所有装饰器都是共享一个对象空间</strong>，避免冲突的职责就交给开发者了。</p><p>大概有两种方式：</p><ul><li>命名空间。比如单纯用字符串 key <code>库名称.{是否静态}.{装饰器位置}.{属性名}</code>，或者创建一个私有 Symbol 按嵌套的结构存储。</li><li><p>私有空间。以下是 MetaData 提案中的例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const PRIVATE_METADATA = new WeakMap();</span><br><span class="line"></span><br><span class="line">function meta(key, value) &#123;</span><br><span class="line">  return (_, context) =&gt; &#123;</span><br><span class="line">    let metadata = PRIVATE_METADATA.get(context.metadata);</span><br><span class="line"></span><br><span class="line">    if (!metadata) &#123;</span><br><span class="line">      metadata = &#123;&#125;;</span><br><span class="line">      PRIVATE_METADATA.set(context.metadata, metadata);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    metadata[key] = value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@meta(&apos;a&apos; &apos;x&apos;)</span><br><span class="line">class C &#123;</span><br><span class="line">  @meta(&apos;b&apos;, &apos;y&apos;)</span><br><span class="line">  m() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PRIVATE_METADATA.get(C[Symbol.metadata]).a; // &apos;x&apos;</span><br><span class="line">PRIVATE_METADATA.get(C[Symbol.metadata]).b; // &apos;y&apos;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><p>Anyway，解决命名冲突有无数的办法。</p><blockquote><p>🙋  那 <code>Typescript</code> 的 <code>emitDecoratorMetadata</code> 还支持吗？暂时看到相关的计划</p></blockquote><p><br><br><br><br><br></p><h2 id="简单理解依赖注入"><a href="#简单理解依赖注入" class="headerlink" title="简单理解依赖注入"></a>简单理解依赖注入</h2><p>现在开始实战部分，首先我们需要了解一下什么是依赖注入：</p><p><img src="/images/decorator-2/Untitled%201.png" alt="di"></p><p>理解依赖注入，需要搞清楚以下几个概念：</p><ul><li><strong>接口(interface)。</strong>接口是一个协议，或者是一个需求。这个由’甲方‘提出来，比如我们要一个手机，那么能“打电话”、”发短信”, 就是需求。接口是一个抽象的东西，并不是具体的实现。对于消费者来说它并不关心的内部细节、是怎么制造出来的。</li><li><strong>实现(implements)</strong>。满足接口需求的具体实现，比如“手机”这个接口的实现，可以是 iphone、小米手机、华为手机等等。</li><li><strong>依赖注入</strong>。依赖注入的意思就是<code>需求者</code>描述好自己的<code>需求</code>，然后由<code>经销商</code>来查找<strong>符合需求</strong>的<code>实现</code>，给到需求者。需求者从头到尾，不会去关心这个需求是怎么去实现的，它只关心它自己要干的事情。</li><li><strong>三种角色</strong>:<ul><li><code>需求者</code>。或者说<code>消费者</code></li><li><code>经销商</code>(容器)。我们也称为容器，他负责协调需求和实现。</li><li><code>供应商</code>。需求的具体实现者。</li></ul></li></ul><p><br><br><br></p><p>可以通过一个例子(来源<a href="https://www.notion.so/wakeapp-framework-b08cb3cb5f8e49f597aa90bbb89a1641?pvs=21" target="_blank" rel="noopener">这里</a>)来理解一下：</p><p><br></p><ol><li><p>定义需求(协议)</p><p>首先定义需求，描述我们期望得到一个怎样的东西。</p><p>需求通常使用 <code>interface</code> 来描述，当然，这并没有限制。你要一个类也可以、字符串、数字也可以，取决你的需求。</p><p>比如我想要一个手机:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface IPhone &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 打电话</span><br><span class="line">   */</span><br><span class="line">  call(num: string): void</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 发短信</span><br><span class="line">   */</span><br><span class="line">  sendMessage(num: string, message: string): void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册你的需求和标识符的绑定关系：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare global &#123;</span><br><span class="line">  interface DIMapper &#123;</span><br><span class="line">    &apos;DI.IPhone&apos;: IPhone</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>请求注入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class WeChat &#123;</span><br><span class="line">  // 注入请求</span><br><span class="line">  @inject(&apos;DI.IPhone&apos;)</span><br><span class="line">  myPhone: IPhone</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 打电话老妈</span><br><span class="line">   */</span><br><span class="line">  callMom() &#123;</span><br><span class="line">    this.myPhone.call(&apos;137****110&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现需求</p><p>接下来就是供应商来实现需求了。通常使用类来实现需求：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">@injectable()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TheIPhone</span> <span class="title">implements</span> <span class="title">IPhone</span> </span>&#123;</span><br><span class="line">  call(num: string) &#123;</span><br><span class="line">    <span class="comment">// 拨打电话流程</span></span><br><span class="line">  &#125;</span><br><span class="line">  sendMessage(num: string, <span class="attr">message</span>: string) &#123;</span><br><span class="line">    <span class="comment">// 发送短信流程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注册实现</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">configureDI((registerSingletonClass) =&gt; &#123;</span><br><span class="line">  registerSingletonClass(&apos;DI.IPhone&apos;, TheIPhone)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p><br><br><br></p><p>如果你理解了上面的例子，那么你已经懂依赖注入了。不过，当你接触到依赖注入的相关实现库时，还有听到这些概念：</p><ul><li><code>容器(Container)</code>。 就是上文提到的<code>经销商</code>，用最简单技术术语来描述的话，他就是一个<code>对象池</code>。他负责协调<code>消费者</code>需求和<code>提供商</code>的实现。</li><li><code>作用域(Scope)</code>。就是对象的存活时间和活动范围<ul><li>存活时间：比较典型的有 singleton(单例)、request(请求， 这个一句话说不清楚，你可以类比为 「HTTP 请求」，这些对象仅在这一次 HTTP 的请求周期内有效)、transient(临时，即每次 inject 请求都创建一个新的对象)。当然，根据实际的场景还可以扩展，比如在 React 组件生命周期</li><li>活动范围： 很多依赖注入库中，容器不是一个单一的对象，而是一个树状的结构，如果要限制某些对象的活动范围，或者覆盖对象的实现，可以通过 Fork 子容器的形式来实现隔离。</li></ul></li><li><code>绑定(binding)</code>。即协议的绑定，比如上面的例子中我们使用 <code>DI.IPhone</code> 字符串来绑定协议和实现。其他编程语言可以做得更加灵活，只需要声明类型，容器会根据类型的兼容性来协调注入。</li></ul><p><br></p><p>当然，一个生产级别的依赖注入实现还会涉及很多技术细节和概念，比如循环依赖、对象构造和析构、工厂、异步加载、对象生命周期管理、中间件、标签(Tagged)等等。</p><p><br></p><p>不过上面我们掌握的知识已经足够覆盖正常的开发场景了。</p><p><br><br><br></p><p><strong>依赖注入的好处就不多说了：</strong></p><ul><li>解耦。面向接口编程。</li><li>可扩展性。每个依赖注入的点就是一个扩展点。</li><li>可测试性。可以让程序职责更加单一，关注真正需要关注的内容。屏蔽干扰，让核心逻辑更容易被测试。</li></ul><p><br><br><br><br><br></p><h2 id="继续探索-typescript-装饰器的能力边界"><a href="#继续探索-typescript-装饰器的能力边界" class="headerlink" title="继续探索 Typescript 装饰器的能力边界"></a>继续探索 Typescript 装饰器的能力边界</h2><p>在上篇<a href="https://www.notion.so/Javascript-MobX-Vue-5e1c633167094d9784e602d66a5877f8?pvs=21" target="_blank" rel="noopener">文章</a>中，我们提到 Typescript 对新版的装饰器有了更严格的检查。</p><p><br></p><p>它可以约束装饰器的位置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare function injectable&lt;T, Class extends abstract new (...args: any) =&gt; T&gt;(): (</span><br><span class="line">  value: Class,</span><br><span class="line">  context: ClassDecoratorContext&lt;Class&gt;</span><br><span class="line">) =&gt; void</span><br><span class="line"></span><br><span class="line">@injectable()</span><br><span class="line">class Foo &#123;</span><br><span class="line">  // @ts-expect-error ❌ 只能装饰类</span><br><span class="line">  @injectable()</span><br><span class="line">  member = 1</span><br><span class="line"></span><br><span class="line">  // @ts-expect-error ❌ 只能装饰类</span><br><span class="line">  @injectable()</span><br><span class="line">  method() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>这还不止，我们还可以对被装饰的目标值进行约束。以依赖注入的场景来看, 旧版的装饰器很难做到根据注入的标识符来约束<code>实现</code>和<code>注入</code>。现在我们很容易做到：</p><p>先来构造<code>注入标识符</code>的类型(灵感来源于 <code>Vue</code> 的 <code>provide/inject</code>)：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface InjectionKey&lt;T&gt; extends Symbol &#123;&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>现在可以这样定义标识符：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 定义注入的协议，鸟类</span><br><span class="line">interface Bird &#123;</span><br><span class="line">  fly(): void</span><br><span class="line">  searchForFood(): void</span><br><span class="line">  breed(): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将接口和标识符实现绑定</span><br><span class="line">const BIRD_BINDING: InjectionKey&lt;Bird&gt; = Symbol(&apos;Bird&apos;)</span><br></pre></td></tr></table></figure><p><br></p><p>我们再来定义 <code>injectable</code> 装饰器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare function injectable&lt;T, Class extends abstract new (...args: any) =&gt; T&gt;(</span><br><span class="line">  // 传入 InjectionKey 类型，推断出 T 来约束 class</span><br><span class="line">  key: InjectionKey&lt;T&gt;</span><br><span class="line">): (value: Class, context: ClassDecoratorContext&lt;Class&gt;) =&gt; void</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// @ts-expect-error ❌ 没有履行 Bird 协议</span><br><span class="line">@injectable(BIRD_BINDING)</span><br><span class="line">class Eagle &#123;&#125;</span><br><span class="line"></span><br><span class="line">// ✅ 履行了 Bird 协议</span><br><span class="line">@injectable(BIRD_BINDING)</span><br><span class="line">class Pigeon implements Bird &#123;</span><br><span class="line">  fly() &#123;&#125;</span><br><span class="line">  searchForFood() &#123;&#125;</span><br><span class="line">  breed() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在可以对<code>实现者</code>的<code>协议履行</code>进行严格检查。</p><p><br><br><br></p><p>同理我们可以检查注入侧：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare function inject&lt;T&gt;(</span><br><span class="line">  key: InjectionKey&lt;T&gt;</span><br><span class="line">): (value: undefined, context: ClassFieldDecoratorContext&lt;unknown, T | undefined&gt;) =&gt; void</span><br><span class="line"></span><br><span class="line">declare function injectAll&lt;T&gt;(</span><br><span class="line">  key: InjectionKey&lt;T&gt;</span><br><span class="line">): (value: undefined, context: ClassFieldDecoratorContext&lt;unknown, T[] | undefined&gt;) =&gt; void</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Zoo &#123;</span><br><span class="line">  // @ts-expect-error ❌ 类型不匹配</span><br><span class="line">  @inject(BIRD_BINDING)</span><br><span class="line">  private unknown?: number</span><br><span class="line"></span><br><span class="line">  // ✅</span><br><span class="line">  @inject(BIRD_BINDING)</span><br><span class="line">  private bird?: Bird</span><br><span class="line"></span><br><span class="line">  // @ts-expect-error ❌ 类型不匹配</span><br><span class="line">  @injectAll(BIRD_BINDING)</span><br><span class="line">  private allBirds?: Bird</span><br><span class="line"></span><br><span class="line">  // ✅</span><br><span class="line">  @injectAll(BIRD_BINDING)</span><br><span class="line">  private birds?: Bird[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很酷?！</p><p><br><br><br><br><br></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>接下来我们把上面讲到的知识点运用起来，实现一个简易的依赖注入库。</p><p>🔴  运行环境：由于使用了较新的特性，其他构建平台暂未跟进(包括 Babel、Vite)。下面代码基于 Typescript 5.2(next) + <code>jest</code> + <code>ts-jest</code> 运行。</p><p>为了确保运行， 需要添加以下 polyfill：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// typescript polyfill</span><br><span class="line">declare global &#123;</span><br><span class="line">  interface SymbolConstructor &#123;</span><br><span class="line">    readonly metadata: unique symbol</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  interface Function &#123;</span><br><span class="line">    [Symbol.metadata]?: DecoratorMetadata</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// runtime polyfill</span><br><span class="line">if (typeof Symbol.metadata === &apos;undefined&apos;) &#123;</span><br><span class="line">  // @ts-expect-error</span><br><span class="line">  Symbol.metadata = Symbol(&apos;Symbol.metadata&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>💡  在新版的装饰器中，实现依赖注入不一定要用到 Decorator Metadata, 可以看装饰器提案中的<a href="https://github.com/tc39/proposal-decorators#access-and-metadata-sidechanneling" target="_blank" rel="noopener">例子</a>。</p></blockquote><p><br><br><br><br><br><br><br></p><h3 id="装饰器-api"><a href="#装饰器-api" class="headerlink" title="装饰器 API"></a>装饰器 API</h3><p>首先，我们把关键的装饰器 API 定义出来:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 🔴 InjectionKey 用于定义依赖注入的标识符, 可是实现标志服和协议的绑定，我们在上文介绍过了</span><br><span class="line">export interface InjectionKey&lt;T&gt; extends Symbol &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 作用域类型, 作为简单示例，我们就支持两种作用域类型</span><br><span class="line">export enum Scope &#123;</span><br><span class="line">  Singleton,</span><br><span class="line">  Transient,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 类装饰器，支持被注入的类都需要使用它来装饰</span><br><span class="line">// 可以接受一个 scope，默认为 单例</span><br><span class="line">export function injectable&lt;T, Class extends abstract new (...args: any) =&gt; T&gt;(</span><br><span class="line">  key: InjectionKey&lt;T&gt;,</span><br><span class="line">  scope?: Scope</span><br><span class="line">) &#123;</span><br><span class="line">  return (value: Class, context: ClassDecoratorContext&lt;Class&gt;) =&gt; &#123;</span><br><span class="line">    const metadata = getOrCreateMetadata(context.metadata)</span><br><span class="line"></span><br><span class="line">    if (metadata.injectable) &#123;</span><br><span class="line">      throw new Error(&apos;injectable is already defined&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    metadata.injectable = key</span><br><span class="line">    metadata.scope = scope</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 属性装饰器, 声明注入</span><br><span class="line">export function inject&lt;T&gt;(key: InjectionKey&lt;T&gt;) &#123;</span><br><span class="line">  return (value: undefined, context: ClassFieldDecoratorContext&lt;unknown, T | undefined&gt;) =&gt; &#123;</span><br><span class="line">    injectToField(&#123; key, context &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 属性装饰器, 声明注入所有绑定</span><br><span class="line">export function injectAll&lt;T&gt;(key: InjectionKey&lt;T&gt;) &#123;</span><br><span class="line">  return (value: undefined, context: ClassFieldDecoratorContext&lt;unknown, T[] | undefined&gt;) =&gt; &#123;</span><br><span class="line">    injectToField(&#123; key, multiple: true, context &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述装饰器不会对类进行改造，只是利用 Decorator Metadata 进行一些标注：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 🔴 我们存储在类 Decorator Metadata 的数据</span><br><span class="line">interface InjectionMetadata &#123;</span><br><span class="line">  // 类是否装饰了 @injectable</span><br><span class="line">  injectable?: InjectionKey&lt;unknown&gt;</span><br><span class="line">  // 作用域</span><br><span class="line">  scope?: Scope</span><br><span class="line">  // 类需要进行注入的属性</span><br><span class="line">  injections?: Map&lt;PropertyKey, Injection&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 类属性注入信息</span><br><span class="line">interface Injection &#123;</span><br><span class="line">  // 属性名</span><br><span class="line">  key: InjectionKey&lt;unknown&gt;</span><br><span class="line">  // 是否获取多个实例</span><br><span class="line">  multiple?: boolean</span><br><span class="line">  // 装饰器的上下文</span><br><span class="line">  context: ClassFieldDecoratorContext</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 Decorator Metadata 的 KEY, 使用 Symbol，避免和其他库冲突</span><br><span class="line">const METADATA_KEY: unique symbol = Symbol(&apos;METADATA_KEY&apos;)</span><br><span class="line"></span><br><span class="line">// 初始化 metadata</span><br><span class="line">function getOrCreateMetadata&lt;T&gt;(metadata: DecoratorMetadata): InjectionMetadata &#123;</span><br><span class="line">  if (metadata == null) &#123;</span><br><span class="line">    throw new Error(&apos;Decorator metadata is not defined&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return metadata[METADATA_KEY] ?? (metadata[METADATA_KEY] = &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 标记属性注入</span><br><span class="line">function injectToField(injection: Injection) &#123;</span><br><span class="line">  const &#123; context &#125; = injection</span><br><span class="line"></span><br><span class="line">  if (context.static === true) &#123;</span><br><span class="line">    throw new Error(&apos;inject cannot be used on static fields&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const metadata = getOrCreateMetadata(context.metadata)</span><br><span class="line"></span><br><span class="line">  if (metadata.injections == null) &#123;</span><br><span class="line">    metadata.injections = new Map()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (metadata.injections.has(context.name)) &#123;</span><br><span class="line">    throw new Error(`inject is already defined for $&#123;context.name.toString()&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  metadata.injections.set(context.name, injection)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试驱动开发，我们先把测试用例写了，也方便读者对我们 API 的用法有基本的了解：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 定义协议</span><br><span class="line">interface Bird &#123;</span><br><span class="line">  fly(): void</span><br><span class="line">  searchForFood(): void</span><br><span class="line">  breed(): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IZoo &#123;</span><br><span class="line">  getAllBirds(): Bird[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义标识符，并绑定协议</span><br><span class="line">const BIRD_BINDING: InjectionKey&lt;Bird&gt; = Symbol.for(&apos;Bird&apos;)</span><br><span class="line">const ZOO_KEY: InjectionKey&lt;IZoo&gt; = Symbol.for(&apos;Zoo&apos;)</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">test(&apos;property inject&apos;, () =&gt; &#123;</span><br><span class="line">  // 🔴 使用 @injectable 标注支持注入的类</span><br><span class="line">  @injectable(BIRD_BINDING)</span><br><span class="line">  class MyBird &#123;</span><br><span class="line">    fly() &#123;&#125;</span><br><span class="line">    searchForFood() &#123;&#125;</span><br><span class="line">    breed() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @injectable(BIRD_BINDING)</span><br><span class="line">  class MyBird2 &#123;</span><br><span class="line">    fly() &#123;&#125;</span><br><span class="line">    searchForFood() &#123;&#125;</span><br><span class="line">    breed() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @injectable(ZOO_KEY)</span><br><span class="line">  class Zoo implements IZoo &#123;</span><br><span class="line">    // 🔴 获取所有 Bird 实例</span><br><span class="line">    @injectAll(BIRD_BINDING)</span><br><span class="line">    birds?: Bird[]</span><br><span class="line"></span><br><span class="line">    getAllBirds() &#123;</span><br><span class="line">      return this.birds!</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 🔴 注册到容器</span><br><span class="line">  const container = new Container()</span><br><span class="line">  container.bind(BIRD_BINDING, MyBird)</span><br><span class="line">  container.bind(BIRD_BINDING, MyBird2)</span><br><span class="line">  container.bind(ZOO_KEY, Zoo)</span><br><span class="line"></span><br><span class="line">  // 测试</span><br><span class="line">  const zoo = container.get(ZOO_KEY)</span><br><span class="line"></span><br><span class="line">  expect(zoo).toBeInstanceOf(Zoo)</span><br><span class="line">  expect(zoo.getAllBirds().length).toBe(2)</span><br><span class="line">  expect(zoo.getAllBirds()[0]).toBeInstanceOf(MyBird)</span><br><span class="line">  expect(zoo.getAllBirds()[1]).toBeInstanceOf(MyBird2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="容器实现"><a href="#容器实现" class="headerlink" title="容器实现"></a>容器实现</h3><p>接下来就是实现容器了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Ctor&lt;T = unknown&gt; = new (...args: any) =&gt; T</span><br><span class="line"></span><br><span class="line">export class Container &#123;</span><br><span class="line">  // 存储绑定关系</span><br><span class="line">  private bindings: Map&lt;InjectionKey&lt;unknown&gt;, Ctor[]&gt; = new Map()</span><br><span class="line">  // 单例对象池</span><br><span class="line">  private pools: Map&lt;Ctor, unknown&gt; = new Map()</span><br><span class="line"></span><br><span class="line">  // 🔴 绑定，传入 InjectionKey 和 类实现</span><br><span class="line">  bind&lt;T&gt;(key: InjectionKey&lt;T&gt;, impl: new (...args: any) =&gt; T) &#123;</span><br><span class="line">    // 装饰器信息检查</span><br><span class="line">    if (impl[Symbol.metadata] == null) &#123;</span><br><span class="line">      throw new Error(`No metadata found for $&#123;impl.name&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const metadata = impl[Symbol.metadata]![METADATA_KEY] as InjectionMetadata | undefined</span><br><span class="line"></span><br><span class="line">    if (metadata == null || metadata.injectable == null) &#123;</span><br><span class="line">      throw new Error(`No injectable found for $&#123;impl.name&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 存储</span><br><span class="line">    if (this.bindings.has(key)) &#123;</span><br><span class="line">      this.bindings.get(key)!.push(impl)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.bindings.set(key, [impl])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 🔴 获取实例</span><br><span class="line">  get&lt;T&gt;(key: InjectionKey&lt;T&gt;): T &#123;</span><br><span class="line">    return this.resolve(key, false) as T</span><br><span class="line">  &#125;</span><br><span class="line">  // 🔴 获取所有实例</span><br><span class="line">  getAll&lt;T&gt;(key: InjectionKey&lt;T&gt;): T[] &#123;</span><br><span class="line">    return this.resolve(key, true) as T[]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 🔴 对象查找</span><br><span class="line">   */</span><br><span class="line">  private resolve(key: InjectionKey&lt;unknown&gt;, multiple: boolean): unknown &#123;</span><br><span class="line">    const binding = this.bindings.get(key)</span><br><span class="line"></span><br><span class="line">    if (binding == null) &#123;</span><br><span class="line">      throw new Error(`No binding found for $&#123;key.toString()&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!multiple &amp;&amp; binding.length &gt; 1) &#123;</span><br><span class="line">      throw new Error(`Multiple bindings found for $&#123;key.toString()&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return multiple</span><br><span class="line">      ? binding.map((impl) =&gt; this.createInstance(impl))</span><br><span class="line">      : this.createInstance(binding[0])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 🔴 对象实例化</span><br><span class="line">   */</span><br><span class="line">  private createInstance(impl: Ctor): unknown &#123;</span><br><span class="line">    const metadata = impl[Symbol.metadata]![METADATA_KEY] as InjectionMetadata</span><br><span class="line">    const &#123; scope = Scope.Singleton, injections &#125; = metadata</span><br><span class="line"></span><br><span class="line">    // 单例</span><br><span class="line">    if (scope === Scope.Singleton &amp;&amp; this.pools.has(impl)) &#123;</span><br><span class="line">      return this.pools.get(impl)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实例化</span><br><span class="line">    const instance = new impl()</span><br><span class="line"></span><br><span class="line">    // 依赖注入，递归调用</span><br><span class="line">    if (injections != null) &#123;</span><br><span class="line">      for (const injection of injections.values()) &#123;</span><br><span class="line">        const &#123; key, context, multiple &#125; = injection</span><br><span class="line">        const value = multiple ? this.getAll(key) : this.get(key)</span><br><span class="line">        // 🔴 利用新版装饰器的 access 实现注入</span><br><span class="line">        context.access.set(instance, value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (scope === Scope.Singleton) &#123;</span><br><span class="line">      this.pools.set(impl, instance)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>整个代码非常简单，这里对新版装饰器的妙用在于 <code>context.access.set(instance, value)</code> , 用起来非常方便，我们不需要关心属性的存储过程，比如<code>私有属性</code>。</p><p><br></p><p>上面的代码有一个问题没有解决，就是<code>循环依赖</code>。我们写一个测试来复现一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test(&apos;cycle dependency&apos;, () =&gt; &#123;</span><br><span class="line">  const container = new Container()</span><br><span class="line"></span><br><span class="line">  const A_KEY: InjectionKey&lt;A&gt; = Symbol(&apos;A&apos;)</span><br><span class="line">  const B_KEY: InjectionKey&lt;B&gt; = Symbol(&apos;B&apos;)</span><br><span class="line"></span><br><span class="line">  @injectable(A_KEY)</span><br><span class="line">  class A &#123;</span><br><span class="line">    @inject(B_KEY)</span><br><span class="line">    b?: B</span><br><span class="line"></span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @injectable(B_KEY)</span><br><span class="line">  class B &#123;</span><br><span class="line">    @inject(A_KEY)</span><br><span class="line">    a?: A</span><br><span class="line"></span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  container.bind(A_KEY, A)</span><br><span class="line">  container.bind(B_KEY, B)</span><br><span class="line"></span><br><span class="line">  const a = container.get(A_KEY)</span><br><span class="line">  expect(a).toBeInstanceOf(A)</span><br><span class="line">  const b = container.get(B_KEY)</span><br><span class="line">  expect(b).toBeInstanceOf(B)</span><br><span class="line">  expect(a.b).toBe(b)</span><br><span class="line">  expect(b.a).toBe(a)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的测试用例会出现<code>调用栈溢出</code>。因为 A → B 之间出现了循环依赖。这个也好办，我们新增一个缓存属性，存储正在实例化的对象，可以简单解决问题：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">export class Container &#123;</span><br><span class="line"><span class="addition">+ // 正在创建的对象</span></span><br><span class="line"><span class="addition">+ private creating: Map&lt;Ctor, unknown&gt; = new Map()</span></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 对象实例化</span><br><span class="line">   */</span><br><span class="line">  private createInstance(impl: Ctor): unknown &#123;</span><br><span class="line"><span class="addition">+   if (this.creating.has(impl)) &#123;</span></span><br><span class="line"><span class="addition">+     return this.creating.get(impl)</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line">    // ...</span><br><span class="line"><span class="addition">+   // 实例化</span></span><br><span class="line"><span class="addition">+   const instance = new impl()</span></span><br><span class="line"><span class="addition">+   // 缓存</span></span><br><span class="line"><span class="addition">+   this.creating.set(impl, instance)</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   try &#123;</span></span><br><span class="line">      // 依赖注入</span><br><span class="line">      if (injections != null) &#123;</span><br><span class="line">        for (const injection of injections.values()) &#123;</span><br><span class="line">          const &#123; key, context, multiple &#125; = injection</span><br><span class="line">          const value = multiple ? this.getAll(key) : this.get(key)</span><br><span class="line">          context.access.set(instance, value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (scope <span class="comment">=== Scope.Singleton) &#123;</span></span><br><span class="line">        this.pools.set(impl, instance)</span><br><span class="line">      &#125;</span><br><span class="line"><span class="addition">+   &#125; finally &#123;</span></span><br><span class="line"><span class="addition">+     this.creating.delete(impl)</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line"></span><br><span class="line">    return instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是装饰器的核心逻辑了。如果你对生产级别 DI 库感兴趣，可以深入看下扩展阅读提及的开源实现。</p><p>上面相关源码可以在<a href="https://github.com/ivan-94/decoractor-in-action/tree/new-di/src/di" target="_blank" rel="noopener">这里</a>找到。</p><p><br><br><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文回顾了装饰器的老搭档 <code>reflect-metadata</code> 的历史，它的愿景给装饰器提供标准化的元数据存储服务，更长远来愿景是给 JavaScript 的上层语言提供保留静态信息的接口。</p><p>但它最终没有提交给 tc39, 现在随着新的装饰器标准的发展，已经被 <code>Decorator Metadata</code> 提案取代。<code>Decorator Metadata</code> 相比 reflect-metadata 简化很多，就是新增了 <code>Symbol.metadata</code>, 配合装饰器 context.metadata，开发者可以存储任意元数据。</p><p>接着我们继续探索了 Typescript 对装饰器类型检查的增强，可以让我们写出更安全的代码。尤其在 DI 这个场景。</p><p>最后我们将上面学到的知识融会贯通，开发了一个简易的依赖注入实现。</p><p><br><br><br><br><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li>Decorator<br><a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noopener">https://github.com/tc39/proposal-decorators</a></li><li>Decorator Metadata<br><a href="https://github.com/tc39/proposal-decorator-metadata" target="_blank" rel="noopener">https://github.com/tc39/proposal-decorator-metadata</a></li><li>reflect-metadata<br><a href="https://github.com/rbuckton/reflect-metadata" target="_blank" rel="noopener">https://github.com/rbuckton/reflect-metadata</a><ul><li><a href="https://dev.to/svehla/why-reflect-metadata-suc-s-5fal" target="_blank" rel="noopener">Why reflect-metadata suc*s</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/decorators.html" target="_blank" rel="noopener">Typescript Experimental Decorator</a></li><li><a href="https://medium.com/jspoint/introduction-to-reflect-metadata-package-and-its-ecmascript-proposal-8798405d7d88" target="_blank" rel="noopener">Introduction to “reflect-metadata” package and its ECMAScript proposal</a></li></ul></li><li>DI 实现<br><a href="https://github.com/inversify/InversifyJS" target="_blank" rel="noopener">https://github.com/inversify/InversifyJS</a><br><a href="https://github.com/microsoft/tsyringe" target="_blank" rel="noopener">https://github.com/microsoft/tsyringe</a><br><a href="https://github.com/midwayjs/injection" target="_blank" rel="noopener">https://github.com/midwayjs/injection</a><br><a href="https://github.com/jeffijoe/awilix" target="_blank" rel="noopener">https://github.com/jeffijoe/awilix</a><br><a href="https://github.com/typestack/typedi" target="_blank" rel="noopener">https://github.com/typestack/typedi</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/decorator-2/Untitled.jpeg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.notion.so/Javascript
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>全新 Javascript 装饰器实战上篇：用 MobX 的方式打开 Vue</title>
    <link href="https://bobi.ink/2023/06/26/decorator/"/>
    <id>https://bobi.ink/2023/06/26/decorator/</id>
    <published>2023-06-25T16:00:00.000Z</published>
    <updated>2023-06-30T08:35:21.851Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/decorator/Untitled.jpeg" alt="cover"></p><p>去年三月份<a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noopener">装饰器提案</a>进入了 Stage 3 阶段，而今年三月份 Typescript 在 5.0 也正式支持了 <a href="https://github.com/tc39/proposal-decorators/tree/8ca65c046dd5e9aa3846a1fe5df343a6f7efd9f8" target="_blank" rel="noopener"></a>。装饰器提案距离正式的语言标准，只差临门一脚。</p><p>这也意味着旧版的装饰器(Stage 1) 将逐渐退出历史舞台。然而旧版的装饰器已经被广泛的使用，比如 MobX、Angular、NestJS… 未来较长的一段时间内，都会是新旧并存的局面。</p><p><br></p><p>本文将把装饰器语法带到 <code>Vue Reactivity API</code> 中，让我们可以像 MobX 一样，使用类来定义数据模型, 例如:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Counter &#123;</span><br><span class="line">  @observable</span><br><span class="line">  count = 1</span><br><span class="line"></span><br><span class="line">  @computed</span><br><span class="line">  get double() &#123;</span><br><span class="line">    return this.count * 2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add = () =&gt; &#123;</span><br><span class="line">    this.count++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>在这个过程中，我们可以体会到新旧装饰器版本之间的差异和实践中的各种陷阱。</p><p><br><br><br></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="/images/decorator/Untitled.png" alt="思维导图"></p><p>关于装饰器的主要 API 都在上述思维导图中，除此之外，读者可以通过下文「扩展阅读」中提及的链接来深入了解它们。</p><p><br><br><br></p><h2 id="legacy"><a href="#legacy" class="headerlink" title="Legacy"></a>Legacy</h2><p>首先，我们使用旧的装饰器来实现相关的功能。</p><p>在 Typescript 下，需要通过 <code>experimentalDecorators</code> 来启用装饰器语法:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;experimentalDecorators&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用 Babel 7 ，配置大概如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    [&quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;version&quot;: &quot;legacy&quot; &#125;]</span><br><span class="line">    [&quot;@babel/plugin-transform-class-properties&quot;, &#123;&quot;loose&quot;: true &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="observable"><a href="#observable" class="headerlink" title="@observable"></a>@observable</h3><p>我们先来实现 <code>@observable</code> 装饰器，它只能作用于「<code>类属性成员</code>」，比如:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Counter &#123;</span><br><span class="line">  @observable</span><br><span class="line">  count = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const counter = new Counter()</span><br><span class="line">expect(counter.count).toBe(1)</span><br></pre></td></tr></table></figure><p>属性值可以是<code>原始类型</code>或者<code>对象类型</code>，没有限制。</p><p>为了让 Vue 的视图可以响应它的变化，我们可以使用 <code>ref</code> 来包装它。<code>ref</code> 刚好符合我们的需求，可以放置原始类型，也可以是对象, <code>ref</code> 会将其包装为 <code>reactive</code> 。</p><p><br></p><p>初步实现如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const observable: PropertyDecorator = function (target, propertyKey) &#123;</span><br><span class="line">  if (typeof target === &apos;function&apos;) &#123;</span><br><span class="line">    throw new Error(&apos;Observable cannot be used on static properties&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (arguments.length &gt; 2 &amp;&amp; arguments[2] != null) &#123;</span><br><span class="line">    throw new Error(&apos;Observable cannot be used on methods&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const accessor: Initializer = (self) =&gt; &#123;</span><br><span class="line">    const value = ref()</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        return unref(value)</span><br><span class="line">      &#125;,</span><br><span class="line">      set(val) &#123;</span><br><span class="line">        value.value = val</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 定义getter /setter 长远</span><br><span class="line">  Object.defineProperty(target, propertyKey, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get: function () &#123;</span><br><span class="line">      // 惰性初始化</span><br><span class="line">      return initialIfNeed(this, propertyKey, accessor).get()</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function (value) &#123;</span><br><span class="line">      initialIfNeed(this, propertyKey, accessor).set(value)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下上面的代码：</p><ul><li>将装饰器的类型设置为 <code>PropertyDecorator</code>。<blockquote><p>📢 对应的类型还有： ClassDecorator、MethodDecorator、ParameterDecorator<br><br></p><p>⚠️ 旧版<em>装饰器使用位置上 Typescript 并没作类型检查，装饰器可以随意用在类、方法、属性各种位置上</em>。<br><br></p></blockquote></li><li>可以通过 <code>target</code> 的类型，来判断装饰器作用于<code>静态成员</code>上还是<code>实例成员</code>上。如果是静态成员，target 是类本身；如果是实例成员，target 为类的<code>原型对象(prototype)</code></li><li><p><code>属性装饰器</code>只会接收两个参数：类和属性名。因为属性在构造函数中创建, 在类定义阶段，获取不到更多信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  foo = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// transpile to</span><br><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.foo = 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们定义了一个新的 <code>getter</code>/<code>setter</code> 成员, 这样外部才能透明地使用 ref, 不需要加上 <code>.value</code> 后缀</p></li><li><p><code>惰性初始化</code> ref。旧版的装饰器并没有提供 <code>addInitializer</code> 这样的初始化钩子，我们曲线救国，使用惰性初始化的方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const REACTIVE_CACHE = Symbol(&apos;reactive_cache&apos;)</span><br><span class="line">export interface ReactiveAccessor &#123;</span><br><span class="line">  get(): any</span><br><span class="line">  set(value: any): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getReactiveCache(target: any): Record&lt;string | symbol, any&gt; &#123;</span><br><span class="line">  if (!hasProp(target, REACTIVE_CACHE)) &#123;</span><br><span class="line">    addHiddenProp(target, REACTIVE_CACHE, &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return target[REACTIVE_CACHE]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export type Initializer = (target: any) =&gt; ReactiveAccessor</span><br><span class="line"></span><br><span class="line">export function initialIfNeed(target: any, key: string | symbol, initializer: Initializer) &#123;</span><br><span class="line">  const cache = getReactiveCache(target)</span><br><span class="line">  // 如果属性未定义，就执行初始化</span><br><span class="line">  if (!hasProp(cache, key)) &#123;</span><br><span class="line">    cache[key] = initializer(target)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return cache[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>这里我们将信息缓存在 REACTIVE_CACHE 字段中，实现惰性初始化。</code></pre></li></ul><p><br><br><br><br><br></p><p>写个单元测试看看:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test(&apos;base type&apos;, () =&gt; &#123;</span><br><span class="line">  class A &#123;</span><br><span class="line">    @observable</span><br><span class="line">    str = &apos;str&apos;</span><br><span class="line"></span><br><span class="line">    @observable</span><br><span class="line">    num = 1</span><br><span class="line"></span><br><span class="line">    @observable</span><br><span class="line">    withoutInitialValue: any</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const a = new A()</span><br><span class="line"></span><br><span class="line">  let str</span><br><span class="line">  let num</span><br><span class="line">  let withoutInitialValue</span><br><span class="line">  // 🔴 初始值应该正常被设置</span><br><span class="line">  expect(a.str).toBe(&apos;str&apos;)</span><br><span class="line">  expect(a.num).toBe(1)</span><br><span class="line">  expect(a.withoutInitialValue).toBe(undefined)</span><br><span class="line"></span><br><span class="line">  // 🔴 属性的变动应该被检测</span><br><span class="line">  watchSyncEffect(() =&gt; &#123;</span><br><span class="line">    str = a.str</span><br><span class="line">  &#125;)</span><br><span class="line">  watchSyncEffect(() =&gt; &#123;</span><br><span class="line">    num = a.num</span><br><span class="line">  &#125;)</span><br><span class="line">  watchSyncEffect(() =&gt; &#123;</span><br><span class="line">    withoutInitialValue = a.withoutInitialValue</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  a.str = &apos;new str&apos;</span><br><span class="line">  a.num = 2</span><br><span class="line">  a.withoutInitialValue = &apos;withoutInitialValue&apos;</span><br><span class="line"></span><br><span class="line">  expect(str).toBe(&apos;new str&apos;)</span><br><span class="line">  expect(num).toBe(2)</span><br><span class="line">  expect(withoutInitialValue).toBe(&apos;withoutInitialValue&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>💥 在较新的构建工具中(比如 vite)，上述的测试大概率无法通过！为什么？</p><p><br></p><p><strong>经过调试会发现我们在 observable 中的 <code>defineProperty</code> 并没有生效？</strong></p><p><br><br><br></p><p>通过阅读 Vite 的文档可以找到一些线索，即 Typescript 的 <code>[useDefineForClassFields](https://cn.vitejs.dev/guide/features.html#usedefineforclassfields)</code>:</p><blockquote><p>从 Vite v2.5.0 开始，如果 TypeScript 的 target 是  <code>ESNext</code>  或  <code>ES2022</code>  及更新版本，此选项默认值则为  <code>true</code>。这与  <strong><code>[tsc</code> v4.3.2 及以后版本的行为](<a href="https://github.com/microsoft/TypeScript/pull/42663" target="_blank" rel="noopener">https://github.com/microsoft/TypeScript/pull/42663</a>)</strong>  一致。这也是标准的 ECMAScript 的运行时行为</p></blockquote><p><br></p><p><code>useDefineForClassFields</code> 会改变<code>类实例属性</code>的定义方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  foo = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 旧</span><br><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.foo = 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 新：useDefineForClassFields</span><br><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    Object.defineProperty(this, &apos;foo&apos;, &#123;</span><br><span class="line">      enumerable: true,</span><br><span class="line">      configurable: true,</span><br><span class="line">      writable: true,</span><br><span class="line">      value: 1,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是为什么我们装饰器内的 <code>defineProperty</code> 无法生效的原因。</p><p><br><br><br></p><p>解决办法：</p><p>方法 1： 显式关闭掉 useDefineForClassFields。如果是 Babel 需要配置 <code>@babel/plugin-transform-class-properties</code> 的 <code>loose</code> 为 true：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    [&quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;version&quot;: &quot;legacy&quot; &#125;]</span><br><span class="line">    [&quot;@babel/plugin-transform-class-properties&quot;, &#123;&quot;loose&quot;: true &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>方法 2： 或者模仿 <a href="https://www.mobxjs.com/enabling-decorators" target="_blank" rel="noopener">MobX V6</a> 的 API:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TodoList &#123;</span><br><span class="line">  @observable todos = []</span><br><span class="line"></span><br><span class="line">  @computed</span><br><span class="line">  get unfinishedTodoCount() &#123;</span><br><span class="line">    return this.todos.filter((todo) =&gt; !todo.finished).length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    makeObservable(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MobX 的 observable、computed 等装饰器只是收集了一些<strong><code>标记信息</code>，</strong> 本身不会对类进行转换，真正进行转换是在 <code>makeObservable</code> 中进行的， 而 <code>makeObservable</code> 的执行时机是在所有属性都初始化完毕之后。</p><p>由于本文只关注装饰器的能力，这里就不展开了，有兴趣的读者可以看下 MobX 的源码。</p><p><br><br><br><br><br></p><h3 id="computed"><a href="#computed" class="headerlink" title="@computed"></a>@computed</h3><p>按照同样的方法，我们来实现一下 <code>@computed</code> 装饰器，MobX 的 computed 和 Vue 的 computed 概念基本一致，就是用来做衍生数据的计算。</p><p><br></p><p>@computed 只能应用在 <code>getter</code> 上面:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const computed: MethodDecorator = function (target, propertyKey, descriptor) &#123;</span><br><span class="line">  // 不支持 static</span><br><span class="line">  if (typeof target === &apos;function&apos;) &#123;</span><br><span class="line">    throw new Error(&apos;computed cannot be used on static member&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 必须是 getter</span><br><span class="line">  if (</span><br><span class="line">    descriptor == null ||</span><br><span class="line">    typeof descriptor !== &apos;object&apos; ||</span><br><span class="line">    typeof descriptor.get !== &apos;function&apos;</span><br><span class="line">  ) &#123;</span><br><span class="line">    throw new Error(&apos;computed can only be used on getter&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const initialGetter = descriptor.get</span><br><span class="line">  const accessor: Initializer = (self) =&gt; &#123;</span><br><span class="line">    const value = vueComputed(() =&gt; initialGetter.call(self))</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        return unref(value)</span><br><span class="line">      &#125;,</span><br><span class="line">      set() &#123;</span><br><span class="line">        // readonly</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  descriptor.get = function () &#123;</span><br><span class="line">    // 惰性初始化</span><br><span class="line">    return initialIfNeed(this, propertyKey, accessor).get()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>getter/setter/method 装饰器的用法一致。会接收 <code>descriptor</code> 作为第三个参数，我们可以对 <code>descriptor</code> 进行修改，或者返回一个新的 <code>descriptor</code>。</li><li>我们使用 vue 的 computed API 对 getter 函数进行简单包装。</li></ul><p><br><br><br></p><p>测试一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test(&apos;computed&apos;, () =&gt; &#123;</span><br><span class="line">  const count = ref(0)</span><br><span class="line">  class A &#123;</span><br><span class="line">    @computed</span><br><span class="line">    get double() &#123;</span><br><span class="line">      return count.value * 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const a = new A()</span><br><span class="line">  let value</span><br><span class="line">  watchSyncEffect(() =&gt; &#123;</span><br><span class="line">    value = a.double</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  expect(value).toBe(0)</span><br><span class="line">  count.value++</span><br><span class="line">  expect(value).toBe(2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Ok, 没问题，可以正常运行。我们配合组件的实际场景再测试看看：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test(&apos;render&apos;, () =&gt; &#123;</span><br><span class="line">  class A &#123;</span><br><span class="line">    @observable</span><br><span class="line">    count = 1</span><br><span class="line"></span><br><span class="line">    @computed</span><br><span class="line">    get double() &#123;</span><br><span class="line">      return this.count * 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let count</span><br><span class="line">  const a = new A()</span><br><span class="line"></span><br><span class="line">  const Comp = defineComponent(&#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">      watchSyncEffect(() =&gt; &#123;</span><br><span class="line">        count = a.double</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      return () =&gt; &#123;</span><br><span class="line">        /* ignore */</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  const &#123; unmount &#125; = render(Comp)</span><br><span class="line"></span><br><span class="line">  let count2</span><br><span class="line">  watchSyncEffect(() =&gt; &#123;</span><br><span class="line">    count2 = a.double</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  expect(count).toBe(2)</span><br><span class="line">  expect(count2).toBe(2)</span><br><span class="line"></span><br><span class="line">  a.count++</span><br><span class="line">  expect(count).toBe(4)</span><br><span class="line">  expect(count2).toBe(4)</span><br><span class="line"></span><br><span class="line">  // 🔴 卸载</span><br><span class="line">  unmount()</span><br><span class="line"></span><br><span class="line">  a.count++</span><br><span class="line">  expect(count).toBe(4)</span><br><span class="line">  // 💥 received 4</span><br><span class="line">  expect(count2).toBe(6)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>上面的用例没有通过，<strong>在组件卸载之后，@computed 装饰的 double 就失去了响应性</strong>。Why?</p><p><br><br><br></p><p>解决这个问题之前，我们需要了解一下 <code>[effectScope](https://cn.vuejs.org/api/reactivity-advanced.html#effectscope)</code>, <code>effectScope</code> 创建一个 <code>effect 作用域</code>，可以捕获其中所创建的响应式副作用 (即计算属性和侦听器)，这样捕获到的副作用可以一起处理和销毁。</p><p><br></p><p><strong>Vue <code>setup</code> 就是包装在 effectScope 之下，如果我们的 computed 在 setup 下被初始化，就会被 setup 捕获，当组件卸载时就会被随之清理掉</strong>。</p><p><br></p><p>我们的 <code>@computed</code> 是为全局作用域设计的，不能因为某个组件卸载而被销毁掉。为了解决这个问题，我们需要自己构造一个独立的 <code>悬挂 effectScope</code> (<code>Detached effectScope</code> )：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">const accessor: Initializer = (self) =&gt; &#123;</span><br><span class="line"><span class="addition">+   // true 标记为 detached</span></span><br><span class="line"><span class="addition">+   const scope = effectScope(true)</span></span><br><span class="line"><span class="deletion">-   const value = vueComputed(() =&gt; initialGetter.call(self))</span></span><br><span class="line"><span class="addition">+   const value = scope.run(() =&gt; vueComputed(() =&gt; initialGetter.call(self)))</span></span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        return unref(value)</span><br><span class="line">      &#125;,</span><br><span class="line">      set() &#123;</span><br><span class="line">        // readonly</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>💡 watch 也会有相同的问题，读者可以自行尝试一下</p></blockquote><p><br></p><p>💥 <strong>会不会内存泄露？</strong>理论上会泄露，取决于被 computed 订阅的数据源。如果该订阅源长期未释放，可能会出现内存泄露。<br><br></p><p>解决办法是将对应的<code>类实例</code>和<code>组件</code>的生命周期绑定。当组件释放时，调用类实例的释放方法，例如：</p><p><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const providerStore = &lt;T,&gt;(store: new () =&gt; T): T =&gt; &#123;</span><br><span class="line">  const instance = new store()</span><br><span class="line">  // 将组件的 effectScope 传入实例中进行绑定</span><br><span class="line">  instance.__effect_scope__ = getCurrentScope()</span><br><span class="line">  return instance</span><br><span class="line">&#125;</span><br><span class="line">// computed 实现调整</span><br><span class="line">const scope = target.__effect_scope__ ?? effectScope(true)</span><br><span class="line">// 在 setup 中调用</span><br><span class="line">const store = providerStore(Store)</span><br></pre></td></tr></table></figure><p><br><br>比如 <code>全局Store</code> 可以和 <code>Vue App</code> 绑定，<code>页面 Store</code> 可以和<code>页面组件</code>绑定。<br><br><br>🔴 <strong>MobX computed 并没有该问题，MobX 的 computed 在<code>订阅者</code>清空时，会「<code>挂起</code>(suspend)」，清空自己的<code>订阅</code>(除非显式设置了 keepAlive)，从而可以规避这种内存泄露。详见<a href="https://github.com/mobxjs/mobx/blob/27efa3cc637e3195589874990c23d4de82c12072/packages/mobx/src/core/observable.ts%23L124" target="_blank" rel="noopener">这里</a>。<br>只能看后续 Vue 官方是否也作类似的支持了。</strong></p><p><br><br><br></p><hr><p><br><br><br></p><h2 id="new"><a href="#new" class="headerlink" title="New"></a>New</h2><p>2022/3 装饰器议案正式进入 Stage 3 阶段，按照惯例，Typescript 也在 5.0 版本加入了该功能。</p><p>新版装饰器外形如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Decorator = (</span><br><span class="line">  value: Input,</span><br><span class="line">  context: &#123;</span><br><span class="line">    kind: string</span><br><span class="line">    name: string | symbol</span><br><span class="line">    access: &#123;</span><br><span class="line">      get?(): unknown</span><br><span class="line">      set?(value: unknown): void</span><br><span class="line">    &#125;</span><br><span class="line">    private?: boolean</span><br><span class="line">    static?: boolean</span><br><span class="line">    addInitializer?(initializer: () =&gt; void): void</span><br><span class="line">  &#125;</span><br><span class="line">) =&gt; Output | void</span><br></pre></td></tr></table></figure><p><br></p><p>相比旧版的装饰器，新版的 API 形式上更加统一了，并且提供了一些上下文信息，对于开发者来说更加便利。</p><p><br><br><br></p><p>核心的变化如下：</p><ul><li><p>形式上更加统一，不管是什么位置，都遵循 <code>(value, context) ⇒ output | void</code>， 这个心智上更接近<code>管道(pipe)</code>, 接收一个 Value , 可以返回一个新的 Value 来<strong>替换旧的 Value</strong>。<br><img src="/images/decorator/Untitled%201.png" alt="linux 管道"><br>linux 管道</p><p><br></p></li><li><p><code>context</code> 提供了必要的上下文信息，对开发者来说更加便利，可以快速判断装饰器的类型、是否为静态属性、私有属性等等。</p></li><li><p>更倾向于将装饰器当做一个纯函数(管道、转换器)来使用，尽量不包含副作用(比如修改类的结构)。</p><p><br></p><p><strong>为了限制副作用，装饰器基本上屏蔽了一些底层细节，比如 descriptor，构造函数、原型对象，这些在新的装饰器中基本拿不到。</strong></p><p><br></p><p>副作用只能在 <code>context.addInitializer</code> 中调用，但是能力也非常有限。就拿<code>属性装饰器</code>来举例，initializer 通常在 class 内置的 defineProperty 之前调用，如果你在 <code>initializer</code> 中使用了 <code>defineProperty</code>，那么将被覆盖:</p><p>以 Typescript 的编译结果为例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Bar &#123;</span><br><span class="line">  @d</span><br><span class="line">  foo = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 编译结果：</span><br><span class="line">let Bar = (() =&gt; &#123;</span><br><span class="line">    var _a;</span><br><span class="line">    let _instanceExtraInitializers_1 = [];</span><br><span class="line">    let _foo_decorators;</span><br><span class="line">    let _foo_initializers = [];</span><br><span class="line">    return _a = class Bar &#123;</span><br><span class="line">            constructor() &#123;</span><br><span class="line">                // 🔴 ③ 定义属性</span><br><span class="line">                Object.defineProperty(this, &quot;foo&quot;, &#123;</span><br><span class="line">                    enumerable: true,</span><br><span class="line">                    configurable: true,</span><br><span class="line">                    writable: true,</span><br><span class="line">                    value:</span><br><span class="line">                      // 🔴 ① 先执行其他装饰器的 addInitializer 回调</span><br><span class="line">                      (__runInitializers(this, _instanceExtraInitializers_1),</span><br><span class="line">                        // 🔴 ② 属性装饰器的 initializer</span><br><span class="line">                        __runInitializers(this, _foo_initializers, 1))</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        (() =&gt; &#123;</span><br><span class="line">            _foo_decorators = [d];</span><br><span class="line">            __esDecorate(null, null, _foo_decorators, &#123; kind: &quot;field&quot;, name: &quot;foo&quot;, static: false, private: false, access: &#123; has: obj =&gt; &quot;foo&quot; in obj, get: obj =&gt; obj.foo, set: (obj, value) =&gt; &#123; obj.foo = value; &#125; &#125; &#125;, _foo_initializers, _instanceExtraInitializers_1);</span><br><span class="line">        &#125;)(),</span><br><span class="line">        _a;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><p>这样做的好处，笔者认为主要有以下几点:</p><ul><li>性能优化：旧版的装饰器可以对 class 进行魔改，这就导致了引擎在解析完 Class 体后再去执行装饰器时，最终的 Class 结构可能发生较大的改变，导致引擎的优化无法生效（来源：<a href="https://developer.aliyun.com/article/892441" target="_blank" rel="noopener">ECMAScript 双月报告：装饰器提案进入 Stage 3</a>）。</li><li>因为旧版可能会对类的结构进行破坏性魔改，这种副作用可能导致多个装饰器组合时，有难以预期的问题。</li><li>更容易测试</li></ul><p><br></p><p><strong>另外 Typescript 针对新的装饰器也提供了更严格的类型检查，比如可以约束装饰器使用的位置，旧版可以使用在任意位置，只能通过运行时进行检查</strong>。</p><p><img src="/images/decorator/Untitled%202.png" alt="Typescript 为新版装饰器提供了更严格的类型检查"></p><p>Typescript 为新版装饰器提供了更严格的类型检查</p><p><br></p><blockquote><p>💡  目前装饰器还未成为正式的语言特性，不排除后面还有特性变更。</p></blockquote><p><br></p><blockquote><p>💡  截止至文章发布的时间，Vite 使用新版装饰器还有一些问题。本文使用 Babel + Jest 来测试相关代码。</p></blockquote><p><br><br><br><br><br></p><h3 id="observable-1"><a href="#observable-1" class="headerlink" title="@observable"></a>@observable</h3><p>新版的<code>属性装饰器</code> API 如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type ClassFieldDecorator = (</span><br><span class="line">  value: undefined,</span><br><span class="line">  context: &#123;</span><br><span class="line">    kind: &apos;field&apos;</span><br><span class="line">    name: string | symbol</span><br><span class="line">    access: &#123; get(): unknown; set(value: unknown): void &#125;</span><br><span class="line">    static: boolean</span><br><span class="line">    private: boolean</span><br><span class="line">  &#125;</span><br><span class="line">) =&gt; (initialValue: unknown) =&gt; unknown | void</span><br></pre></td></tr></table></figure><ul><li>value 始终为 undefined，因为属性在类定义时不存在，无法获取到初始值</li><li>context 没有 <code>addInitializer</code> 。属性装饰器的返回值是一个函数，这个实际上就是一个 <code>initializer</code></li><li>访问不到类和类的原型</li><li>在 initializer 中也不能调用 defineProperty。原因见上文</li></ul><p>也就是说，<strong>属性装饰器基本上堵死了我们去改造属性的机会</strong>…</p><p><br><br><br></p><hr><p><br></p><p>且慢，跟随装饰器发布的还有一个<code>自动访问器</code>(Auto Accessor)的特性(🙂  越来越像 Java、C# 了）</p><p>自动访问器使用 <code>accessor</code> 关键字定义：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">  accessor x = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">  #x = 1</span><br><span class="line"></span><br><span class="line">  get x() &#123;</span><br><span class="line">    return this.#x</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set x(val) &#123;</span><br><span class="line">    this.#x = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这有啥用？稍安勿躁，它在装饰器场景有大用，先来看下它的 API:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type ClassAutoAccessorDecorator = (</span><br><span class="line">  value: &#123;</span><br><span class="line">    get: () =&gt; unknown;</span><br><span class="line">    set(value: unknown) =&gt; void;</span><br><span class="line">  &#125;,</span><br><span class="line">  context: &#123;</span><br><span class="line">    kind: &quot;accessor&quot;;</span><br><span class="line">    name: string | symbol;</span><br><span class="line">    access: &#123; get(): unknown, set(value: unknown): void &#125;;</span><br><span class="line">    static: boolean;</span><br><span class="line">    private: boolean;</span><br><span class="line">    addInitializer(initializer: () =&gt; void): void;</span><br><span class="line">  &#125;</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  get?: () =&gt; unknown;</span><br><span class="line">  set?: (value: unknown) =&gt; void;</span><br><span class="line">  init?: (initialValue: unknown) =&gt; unknown;</span><br><span class="line">&#125; | void;</span><br></pre></td></tr></table></figure><ul><li>value 接收 getter 和 setter</li><li>可以返回新的 getter 和 setter</li><li>init 可以对初始值进行<strong>_转换_</strong>。</li></ul><p><br><br><br></p><p>它的妙用在于，我们可以「兵不血刃」(不改变结构或者新增属性)地实现拦截，看看我们 observable 的实现就知道了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function observable&lt;This, Value&gt;(</span><br><span class="line">  value: ClassAccessorDecoratorTarget&lt;This, Value&gt;,</span><br><span class="line">  context: ClassAccessorDecoratorContext&lt;This, Value&gt;</span><br><span class="line">): ClassAccessorDecoratorResult&lt;This, Value&gt; | void &#123;</span><br><span class="line">  if (context.kind !== &apos;accessor&apos;) &#123;</span><br><span class="line">    throw new Error(&apos;observable can only be used on accessor&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (context.static) &#123;</span><br><span class="line">    throw new Error(&apos;observable can not be used on static accessor&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    init(val) &#123;</span><br><span class="line">      return ref(val)</span><br><span class="line">    &#125;</span><br><span class="line">    get() &#123;</span><br><span class="line">      return (value.get.call(this) as Ref&lt;Value&gt;).value</span><br><span class="line">    &#125;,</span><br><span class="line">    set(val) &#123;</span><br><span class="line">      const ref = value.get.call(this) as Ref&lt;Value&gt;</span><br><span class="line"></span><br><span class="line">      ref.value = val</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>通过 <code>context</code>，我们可以更方便地判断是否是静态成员、是否装饰在预期的位置</li><li>上述代码我们没有修改任何类的结构、新增任何属性。我们直接在 init 中将初始值转换为 ref, 相对应的 getter/setter 也作简单的改造。</li></ul><p><br></p><p>很简单是不是？只不过，这个对已有的代码倾入性太大了，所有相关的属性都需要修改为 <code>accessor</code>, 但对于 API 使用者来说没什么区别：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  @observable</span><br><span class="line">  accessor obj = &#123;</span><br><span class="line">    count: 1,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="computed-1"><a href="#computed-1" class="headerlink" title="@computed"></a>@computed</h3><p>Getter 装饰器和 Setter、Method 装饰器类型基本一致：</p><p><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type ClassGetterDecorator = (</span><br><span class="line">  value: Function,</span><br><span class="line">  context: &#123;</span><br><span class="line">    kind: &apos;getter&apos;</span><br><span class="line">    name: string | symbol</span><br><span class="line">    access: &#123; get(): unknown &#125;</span><br><span class="line">    static: boolean</span><br><span class="line">    private: boolean</span><br><span class="line">    addInitializer(initializer: () =&gt; void): void</span><br><span class="line">  &#125;</span><br><span class="line">) =&gt; Function | void</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>直接来看 computed 实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function computed&lt;This, Return, Value extends () =&gt; Return&gt;(</span><br><span class="line">  value: Value,</span><br><span class="line">  context: ClassGetterDecoratorContext&lt;This, Return&gt;</span><br><span class="line">): Value | void &#123;</span><br><span class="line">  if (context.static) &#123;</span><br><span class="line">    throw new Error(&apos;computed cannot be used on static member&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (context.kind !== &apos;getter&apos;) &#123;</span><br><span class="line">    throw new Error(&apos;computed can only be used on getter&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  context.addInitializer(function (this: unknown) &#123;</span><br><span class="line">    const scope = effectScope(true)</span><br><span class="line"></span><br><span class="line">    const val = scope.run(() =&gt; vueComputed(() =&gt; value.call(this)))</span><br><span class="line"></span><br><span class="line">    Object.defineProperty(this, context.name, &#123;</span><br><span class="line">      configurable: true,</span><br><span class="line">      enumerable: false,</span><br><span class="line">      get() &#123;</span><br><span class="line">        return unref(val)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>通过 <code>addInitializer</code> 来添加初始化逻辑(副作用)， this 为当前类的实例。旧版的装饰器并没有提供类似的时机，我们只能通过<code>惰性初始化</code>去模拟这种效果。</p><p><br></p><p>不过上面的程序也有个潜在的 BUG, 我们在新建一个 log 装饰器，组合在一起看看：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function log(value: Function, context: ClassGetterDecoratorContext) &#123;</span><br><span class="line">  return function (this: unknown) &#123;</span><br><span class="line">    console.log(&apos;start calling...&apos;)</span><br><span class="line">    return value.apply(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">  @observable</span><br><span class="line">  accessor count = 1</span><br><span class="line"></span><br><span class="line">  @log</span><br><span class="line">  @computed</span><br><span class="line">  get double() &#123;</span><br><span class="line">    return this.count * 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，我们会发现并没有打印 <code>start calling...</code> 邪恶的副作用…</p><p><br><br><br></p><p>主要原因是上述代码我们在 <code>addInitializer</code> 中引用的 ‘value’ 是类原始的 getter 值，而我们又重新用 defineProperty 覆盖了属性，导致 @log 装饰的值丢失了。</p><p><br></p><p>实际上在新版的装饰器中，更符合规范的用法是：<strong>返回新的值来替换旧的值</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const COMPUTED_CACHE: unique symbol = Symbol(&apos;computed_cache&apos;)</span><br><span class="line"></span><br><span class="line">export function computed&lt;This, Return, Value extends () =&gt; Return&gt;(</span><br><span class="line">  value: Value,</span><br><span class="line">  context: ClassGetterDecoratorContext&lt;This, Return&gt;</span><br><span class="line">): Value | void &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  // 🔴 初始化缓存对象</span><br><span class="line">  context.addInitializer(function (this: unknown) &#123;</span><br><span class="line">    if (!Object.prototype.hasOwnProperty.call(this, COMPUTED_CACHE)) &#123;</span><br><span class="line">      Object.defineProperty(this, COMPUTED_CACHE, &#123;</span><br><span class="line">        configurable: true,</span><br><span class="line">        enumerable: false,</span><br><span class="line">        value: new Map(),</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return function (this: Object) &#123;</span><br><span class="line">    const cache = this[COMPUTED_CACHE] as Map&lt;string | symbol, Ref&lt;Return&gt;&gt;</span><br><span class="line">    if (!cache.has(context.name)) &#123;</span><br><span class="line">      // 🔴 惰性初始化</span><br><span class="line">      const scope = effectScope(true)</span><br><span class="line"></span><br><span class="line">      const val = scope.run(() =&gt; vueComputed(() =&gt; value.call(this)))!</span><br><span class="line"></span><br><span class="line">      cache.set(context.name, val)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return unref(cache.get(context.name))</span><br><span class="line">  &#125; as Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>上面的代码中，我们返回的新的函数来取代原有的 <code>getter</code>，另外在 <code>addInitializer</code> 中初始化缓存属性。我们建议在 <code>addInitializer</code> 中一次性将需要的属性都初始化完毕，避免在 getter 中动态去添加新的属性，<a href="https://mathiasbynens.be/notes/shapes-ics" target="_blank" rel="noopener">利好 JavaScript 引擎的优化</a>。</p><p><br></p><p>这样做的好处是更符合新版装饰器的心智和设计意图，也可以保证装饰器按照组合的顺序调用。</p><p><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要详细对比了新版和旧版的装饰器差异，通过实战将装饰器的能力和陷阱挖掘出来。</p><p><br></p><p>总得来说，新版的装饰器更加统一直观、更容易入手，在能力上也克制地收敛了。不过目前社区上大量的库和框架还停留在 Stage 1 装饰器，升级和改造需要较大的成本，我们可以暂时观望观望。</p><p><br></p><p>下一步：装饰器比较复杂的应用是依赖注入，当前的依赖注入库都深度依赖 <code>reflect-metadata</code> 来实现。而 <a href="https://github.com/tc39/proposal-decorator-metadata?spm=a2c6h.12873639.article-detail.8.68bd13c4Dt6Qt7" target="_blank" rel="noopener">Decorator Metadata</a> 目前也进入了 Stage 3 阶段，很快就会和我们见面(Typescript 5.2)，届时我们再聊聊如何实现依赖注入(🐶 看你们的点赞)。</p><p><br><br><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><strong><a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noopener">proposal-decorators</a></strong></li><li><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html" target="_blank" rel="noopener">Typescript 5.0</a> 发布日志</li><li><a href="https://mp.weixin.qq.com/s/QnWez2sEWuL8j8GVDmBNTA" target="_blank" rel="noopener">TypeScript 5.0 将支持全新的装饰器写法！</a></li><li><a href="https://developer.aliyun.com/article/892441" target="_blank" rel="noopener">ECMAScript 双月报告：装饰器提案进入 Stage 3</a></li><li><a href="https://cn.vitejs.dev/guide/features.html#usedefineforclassfields" target="_blank" rel="noopener">vite typescript <code>useDefineForClassFields</code></a></li><li><a href="https://babeljs.io/docs/babel-plugin-proposal-decorators" target="_blank" rel="noopener">@babel/plugin-proposal-decorators</a></li><li>Javascript 引擎优化机制:<ul><li><a href="https://mathiasbynens.be/notes/shapes-ics" target="_blank" rel="noopener">JavaScript engine fundamentals: Shapes and Inline Caches</a></li><li><a href="https://mathiasbynens.be/notes/prototypes" target="_blank" rel="noopener">JavaScript engine fundamentals: optimizing prototypes</a></li></ul></li><li><a href="https://cn.mobx.js.org/refguide/action.html" target="_blank" rel="noopener">MobX</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/decorator/Untitled.jpeg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;去年三月份&lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的快乐与苦恼</title>
    <link href="https://bobi.ink/2023/06/21/happiness/"/>
    <id>https://bobi.ink/2023/06/21/happiness/</id>
    <published>2023-06-20T16:00:00.000Z</published>
    <updated>2023-06-21T10:28:32.450Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/happiness/Untitled.jpeg" alt="Universe"></p><blockquote><p>“<strong>我们朝九晚五上班下班，就是为了有朝一日去探索宇宙的</strong>”<br>    —— 宇宙探索编辑部</p></blockquote><p>随着大环境的下行，互联网行业也受到一定的冲击，哀鸿遍野。</p><p>笔者也没有幸免，培养起来的人马陆续被优化，留下一丢光杆司令，我也回到的业务一线，心里很不是滋味。留下来的人，也不知道这艘船什么时候会沉没… 为了活命而拼命挣扎（内卷）</p><p>负面情绪和焦虑不停侵扰，以至于怀疑，当初选的这条路是不是正确的。</p><p>捡起买了多年，但是一直没看的<code>《人月神话》</code>,  开篇就讲了程序员这个职业的乐趣和苦恼，颇有共鸣，所以拿出来给大家分享</p><p>不管过去多少年，不管你的程序载体是纸带、还是 JavaScript，不管程序跑在高对比(high contract)的终端、还是 iPhone，程序员的快乐和烦恼并没有变化。</p><p>尽管国内软件行业看起来不是那么健康。我相信很多人真正热爱的是编程，而不仅仅是一份工作，就是那种纯粹的热爱。你有没有：</p><ul><li>为了修改一个 Bug，茶饭不思</li><li>为了一个 idea，可以凌晨爬起来，决战到天亮</li><li>我们享受没有人打扰的午后</li><li>梦想着参与到一个伟大的开源项目</li><li>有强烈的分享欲，希望我们的作品可以帮助到更多人, 希望能得到用户的反馈，即使是一个点赞</li><li>…</li></ul><p><br><br><br></p><h2 id="我们的快乐"><a href="#我们的快乐" class="headerlink" title="我们的快乐"></a>我们的快乐</h2><blockquote><p>《人月神话》：</p><p>首先，<strong>这种快乐是一种创建事物的纯粹快乐</strong>。如同小孩在玩泥巴时感到快乐一样，成年人喜欢创建事物，特别是自己进行设计。我想这种快乐是上帝创造世界的折射，一种呈现在每片独特的、崭新的树叶和雪花上的喜悦。<br><br><br>其次，<strong>这种快乐来自于开发对他人有用的东西</strong>。内心深处，我们期望我们的劳动成果能够被他人使用，并能对他们有所帮助。从这一角度而言，这同小孩用粘士为“爸爸的办公室”捏制铅笔盒没有任何本质的区别。<br><br><br>第三，<strong>快乐来自于整个过程体现出的一股强大的魅力——将相互啮合的零部件组装在一起，看到它们以精妙的方式运行着，并收到了预期的效果。</strong>比起弹球游戏机或自动电唱机所具有的迷人魅力，程序化的计算机毫不逊色。<br><br><br>第四，<strong>这种快乐是持续学习的快乐，它来自于这项工作的非重复特性</strong>。人们所面临的问题总有这样那样的不同，因而解决问题的人可以从中学习新的事物，有时是实践上的，有时是理论上的，或者兼而有之。<br><br><br>最后，<strong>这种快乐还来自于在易于驾驭的介质上工作</strong>。程序员，就像诗人一样，几乎仅仅在单纯的思考中工作。程序员凭空地运用自己的想象，来建造自己的“城堡”。很少有创造介质如此灵活，如此易于精炼和重建，如此容易实现概念上的设想(不过我们将会看到，容易驾驭的特性也有它自己的问题)。<br><br><br>然而程序毕竞同诗歌不同，它是实实在在的东西;它可以移动和运行，能独立产生可见的输出;它能打印结果，绘制图形，发出声音，移动支架。神话和传说中的魔术在我们的时代已变成现实。在键盘上键入正确的咒语，屏幕会活动、变幻，显示出前所未有的也不可能存在的事物。</p></blockquote><p><br></p><p>编程就是一种纯粹创造的快乐，而且它的成本很低，我们只需要一台电脑，一个趁手的编辑器，一段不被人打扰的整块时间，然后进入心流状态，脑海中的想法转换成屏幕上闪烁的字符。<br>这是多巴胺带给我们的快乐。</p><p><img src="/images/happiness/Untitled.png" alt="飞机引擎"></p><p><br><br><br></p><p>我们也有「<code>机械崇拜</code>」，软件不亚于传统的机械的复杂构造。 它远比外界想象的要复杂和苛刻，而我们享受将无数零部件有机组合起来，点击——成功运行的快感。</p><p>我们享受复杂的问题，被抽象、拆解成一个个简单的问题， 认真描绘分层的弧线以及每个模块轮廓，谨慎设计它的每个锯齿和接口。</p><p>我们崇尚有序，赞赏清晰的边界， 为的就是我们创造的世界能够稳定发展。</p><p><br></p><p>我们认为懒惰是我们的优点，我们也崇拜自动化，享受我们数据通过我们建设的管道在不同模块、系统或者机器中传递和加工；享受程序像多米诺骨牌一样，自动构建、测试、发布、部署、分发到每个用户的手中，优雅地跑起来。</p><p>因为懒，我们时常追求创造出能够取代自己的工具，让我们能腾出时间在新的世界探索。比如可以制造出我们的 <a href="https://baike.baidu.com/item/MOSS/23288071?fr=aladdin" target="_blank" rel="noopener">Moss</a>，帮我们治理让每个程序的生命周期，让它们优雅地死去又重生。</p><p><br></p><p>我们是一群乐于分享和学习的群体，有繁荣的技术社区、各种技术大会、技术群…</p><p>不管是分享还是编程本身，其实都是希望我们的作品能被其他人用到，能产生价值：</p><ul><li>我们都有开源梦，多少人梦想着能参与那些广为人知开源项目。很少有哪个行业，有这么一群人,  能够自我组织，用爱发电、完全透明地做出一个个伟大的作品。</li><li>我们总会怀揣着乐观的设想，基于这种设想，我们会趋向打造更完美的作品，想象未来各种高并发、极端的场景，我们的程序能够游刃有余。</li><li>我们总是不满足于现有的东西，乐于不停地改进，造出更多的轮子，甚至不惜代价推翻重来</li><li>我们更会懊恼，自己投入大量精力的项目，无人问津，甚至胎死腹中。</li></ul><p><br></p><p>看着它们，从简单到繁杂，这是一种迭代的快乐。</p><p><br><br><br><br><br></p><h2 id="我们的苦恼"><a href="#我们的苦恼" class="headerlink" title="我们的苦恼"></a>我们的苦恼</h2><blockquote><p>《人月神话》<br>然而这个过程并不全都是快乐的。我们只有事先了解一些编程固有的苦恼，这样，当它们真的出现时，才能更加坦然地面对。<br><br><br>首先，<strong>苦恼来自追求完美</strong>。因为计算机是以这样的方式来变戏法的: 如果咒语中的一个字符、一个停顿，没有与正确的形式一致，魔术就不会出现(现实中，很少有人类活动会要求如此完美，所以人类对它本来就不习惯)。实际上，我认为，学习编程最困难的部分，是将做事的方式向追求完美的方向调整”。</p><p><br><br>其次，<strong>苦恼来自由他人来设定目标、供给资源和提供信息</strong>。编程人员很少能控制工作环境和工作目标。用管理的术语来说，个人的权威和他所承担的责任是不相配的。不过，似乎在所有的领域中，对要完成的工作，很少能提供与责任相一致的正式权威。而现实情况中，实际(相对于形式)的权威来自于每次任务的完成。</p><p><strong>对于系统编程人员而言，对其他人的依赖是一件非常痛苦的事情</strong>。他依靠其他人的程序，而这些程序往往设计得并不合理、实现拙劣、发布不完整(没有源代码或测试用例)或者文档记录得很糟。所以，系统编程人员不得不花费时间去研究和修改，而它们在理想情况下本应该是可拿的、完整的。</p><p><br><br>下一个苦恼 —— <strong>概念性设计是有趣的，但寻找琐碎的bug却是一项重复性的活动</strong>。伴随着创造性活动的，往往是枯燥沉闷的时间和艰苦的劳动。程序编制工作也不例外。</p><p><br><br>另<strong>外，人们发现调试和查错往往是线性收敛的，或者更糟糕的是，具有二次方的复杂度</strong>。结果，测试一拖再拖，寻找最后一个错误比第一个错误将花费更多的时间。</p><p><br><br>最后一个苦恼，有时也是一种无奈 —— <strong>当投入了大量辛苦的劳动，产品在即将完成或者终于完成的时候，却己显得陈旧过时</strong>。可能是同事和竞争对手己在追逐新的、更好的构思;也许替代方案不仅仅是在构思，而且己经在安排了。<br><br></p></blockquote><p>前阵子读到了 @<a href="https://www.zhihu.com/people/doodlewind" target="_blank" rel="noopener">doodlewind</a> 的 <a href="https://zhuanlan.zhihu.com/p/595759878" target="_blank" rel="noopener">全职开源，出海创业：我的 2022</a>，说的是他 all in 去做 AFFiNE 。我眼里只有羡慕啊，能够找到 all in 的事业…</p><p><br><br><br></p><p>这些年 OKR 也很火，我们公司也跟风了一年; 后面又回到了 KPI，轰轰烈烈搞全员KPI, 抓着每个人,  要定自己的全年KPI;  后年裁员，KPI 就不再提起了…</p><p>这三个阶段的演变很有意思，第一个阶段，期望通过 OKR 上下打通，将目标捆在一起，让团队自己驱动自己。实际上实施起来很难，让团队和个人自我驱动起来并不是一件容易的事情，虽然用的是 OKR，但内核还是 KPI，或者说 OKR 变成了领导的 OKR。<br>后面就变成了 KPI, 限定团队要承担多少销售额，交付多少项目；<br>再后来 KPI 都没有了，换成要求每个人设定自己工作日历，不能空转，哪里项目缺资源，就调配到哪里，彻底沦为了人矿…</p><p>能让我们 all in 的事情，首先得是我们认同的事情，其次我们能在这件事情上深度参与和发挥价值，并获得预期的回报。这才能实现「自我驱动」</p><p>对于大部分人来说，很少有这种工作机会，唯一值得 all in的，恐怕就只有自己了。</p><p><br><br><br></p><p>所以程序员的苦恼很多，虽然编程是一个创造性的工作，但是我们的工作是由其他人来设定目标和提供资源的。</p><p>也就是说我们只不过是困在敏捷循环里面的一颗螺丝钉，每天在早会上机械复读着：昨天干了什么，今天要干什么。<br>企业总会想法设法量化我们的工作，最好是像流水线一样透明、可预测。</p><p><br></p><p>培训机构四个月就能将高中生打造成可以上岗敲代码的程序员。我们这个行业已经不存在我们想象中高门槛。程序员可能就是新时代的蓝领工人，如果我们的工作是重复的、可预见的，那本质上就没什么区别了。</p><hr><p><br></p><p>追求完美是好事，也是坏事。苛刻的编译器会提高开发的门槛，但同样可以降低我们犯错的概率。</p><p>计算机几乎不会犯错的，只是我们不懂它，而人经常会犯错。相比苛刻的计算机，人更加可怕：</p><ul><li>应付领导或产品拍脑袋的需求</li><li>接手屎山代码</li><li>浪费时间的会议</li><li>狼性文化</li><li>…</li></ul><p><br><br><br></p><hr><p><br></p><p>还有一个苦恼是技术的发展实在太快了，时尚的项目生命周期太短，而程序员又是一群喜新厌旧的群体。</p><p>比如在前端，可能两三年前的项目就可以被定义为”老古董”了，上下文切换到这种项目会比较痛苦。不幸的是，这些老古董可能会因为某些程序员的偏见，出现破窗效应，慢慢沦为屎山。</p><p>我们虽然苦恼于项目的腐败，而大多数情况我们也是推手。</p><p><br></p><p>我们还有很多苦恼：</p><ul><li>35 岁危机，继续做技术还是转管理</li><li>面试的八股文</li><li>内卷</li><li>被 AI 取代</li><li>…</li></ul><p><br><br><br></p><p>对于读者来说，是快乐多一些呢？还是苦恼多一些呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/happiness/Untitled.jpeg&quot; alt=&quot;Universe&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“&lt;strong&gt;我们朝九晚五上班下班，就是为了有朝一日去探索宇宙的&lt;/strong&gt;”&lt;br&gt;    —— 宇宙探
      
    
    </summary>
    
      <category term="程序人生" scheme="https://bobi.ink/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>前端如何破解 CRUD 的循环</title>
    <link href="https://bobi.ink/2023/06/16/crud/"/>
    <id>https://bobi.ink/2023/06/16/crud/</id>
    <published>2023-06-15T16:00:00.000Z</published>
    <updated>2023-06-16T02:05:00.408Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/crud/Untitled.jpeg" alt="Untitled"></p><p>据说，西西弗斯是一个非常聪明的国王，但他也非常自负和狂妄。他甚至敢欺骗神灵，并把死者带回人间。为此，他被宙斯（Zeus）惩罚，被迫每天推着一块巨石上山，但在接近山顶时，巨石总是会滚落下来，他不得不重新开始推石头，永远困在这个循环中…</p><p>很多开发工作也如此单调而乏味，比如今天要讲的中后台开发的场景。中后台业务基本上就是一些数据的增删改查、图表，技术含量不高，比较容易范式化。</p><p>前端如何破除 CRUD 的单调循环呢？</p><p><br><br><br><br><br></p><h2 id="低代码"><a href="#低代码" class="headerlink" title="低代码"></a>低代码</h2><p>过去几年前端的低代码很火，这些<code>低代码平台</code>通常支持创建<code>数据模型</code>后，一键生成对应的增删改查页面：</p><p><br></p><p><img src="/images/crud/Untitled.png" alt="Untitled"></p><p><br></p><aside><br>💡 本文提及的低代码是<code>狭义</code>的<code>低代码</code>，你可以认为就是<code>可视化搭建平台</code>。<br><br></aside><p><br></p><p>低代码在过去几年就是 「雷声大，雨点小」，跟现在的 AI 颇为相似。</p><p>不管是大厂还是小厂都在搞低代码，包括笔者也参与过几个低代码项目，但是小厂支撑不起来这样的资源投入，最后都胎死腹中。我相信很多读者也经历过这种情况。<br>大部分公司只是尾随市场营销噱头，盲目跟风，压根就没有做这种低代码平台资源准备和沉淀。</p><p>作为前端，能参与到低代码项目的开发是一件非常兴奋的事情，毕竟是少数前端能主导的项目，架构、组件设计、编辑器的实现可玩性很高，可以跟同行吹很久。</p><p>作为用户(开发者)呢？可能会<a href="https://www.zhihu.com/question/561025857" target="_blank" rel="noopener">排斥和质疑</a>，不管怎么说，它并没有发挥市场所期望的价值。</p><p><br></p><p>最主要的原因是：<strong>它解决不了复杂的问题</strong>。</p><p><br></p><p>低代码直观、门槛低， 前期开发确实很爽，可视化数据建模、拖拉拽生成页面、流程编排，很快就可以把一些简单的业务开发出来。</p><p>然而软件编码本身占用研发流程的比例，据 <code>ChatGPT</code> 估算大约只有 20% ~ 30%。而且业务持续变化，代码也需要持续迭代。试想一下如何在这些低代码平台上进行重构和检索？</p><p><br><br><br></p><p>总的来说，有一些缺点：</p><ul><li><p><strong>复杂的业务逻辑用低代码可能会更加复杂。</strong>低代码应该是特定领域问题的简化和抽象，如果只是单纯将原有的编码工作转换为 GUI 的模式，并没有多大意义。</p><p>  例如流程编排，若要用它从零搭建一个复杂的流程，如果照搬<code>技术语言</code>去表达它，那有可能是个地狱：</p><p>  <img src="/images/crud/Untitled%201.png" alt="Untitled"></p><p>  理想的<strong>流程编排的节点应该是抽象程度更高的、内聚的<code>业务节点</code>，来表达<code>业务流程</code>的流转。然而</strong>这些节点的设计和开发其实是一件非常有挑战性的事情。</p></li><li><p><strong>软件工程是持续演进的，在可维护性方面，目前市面上的低代码平台并不能提供可靠的辅助和验证。</strong>因此企业很难将核心的稳态业务交给这些平台。</p></li><li>还有很多… 平台锁定，缺乏标准，性能问题、复用、扩展性、安全问题、黑盒，可迁移性，研发成本高，可预测性/可调试性差，高可用，版本管理，不能自动化…</li></ul><p><br><br><br></p><p>当然，低代码有低代码的适用场景，比如解决特定领域问题(营销活动页面，海报，数据大屏，表单引擎、商城装修、主页)，POC 验证。<strong>即一些临时的/非核心的敏态业务</strong>。</p><aside><br>💡 目前有些低代码平台也有「出码能力」，让二开有了一定的可行性。<br><br></aside><aside><br>💡 AI 增强后的低代码可能会更加强大。但笔者依旧保持观望的态度，毕竟准确地描述软件需求，本身就是就是软件研发的难题之一，不然我们也不需要 DDD中的各种方法论，开各种拉通会，或许也不需要需求分析师，产品…<br><br>非专业用户直接描述需求来产出软件，大多是不切实际的臆想<br></aside><p><br><br><br><br><br></p><h2 id="中间形态"><a href="#中间形态" class="headerlink" title="中间形态"></a>中间形态</h2><p>有没有介于可视化低代码平台和专业代码之间的中间形态？既能保持像低代码平台易用性，同时维持代码的灵活性和可维护性。</p><p>我想那就是 DSL(<code>domain-specific language</code>) 吧? <strong>DSL 背后体现的是对特定领域问题的抽象，其形式和语法倒是次要的。</strong></p><aside><br>💡 DSL 的形式有很多，可以创建一门新的微语言(比如 SQL, GraphQL)；可以是一个 JSON 或者 YAML 形式；也可以基于一门现有的<code>元语言</code>(比如 Ruby、Groovy，Rust…)来创建，这些元语言，提供的元编程能力，可以简洁优雅地表达领域问题，同时能够复用<code>元语言</code> 本身的语言能力和基础设施。<br><br></aside><p><strong>严格上可视化低代码平台也是一种‘可视化’ 的 DSL，笔者认为它的局限性更多还是来源‘可视化’，相对的，它优点也大多来源’可视化‘</strong>。</p><blockquote><p>这又牵扯到了持续了半个多世纪的： GUI vs CLI（程序化/文本化） 之争。这个在《UNIX 编程艺术》中有深入的探讨。命令行和命令语言比起可视化接口来说，更具表达力，尤其是针对复杂的任务。另外命令行接口具有高度脚本化的能力。缺点就是需要费劲地记忆，易用性差，透明度低。当问题规模变大、程序的行为日趋单一、过程化和重复时， CLI 也常能发挥作用。<br><br><br>如果按照<code>友好度</code>和问题域的<code>复杂度/规模</code>两个维度来划分，可以拉出以下曲线：<br><br><br><img src="/images/crud/Untitled%202.png" alt="Untitled"></p><p>中间会出现一个交叉点，在这个交叉点之后，命令行的简要行和表达力变得要比避免记忆负担更有价值。</p><p>《反 Mac 接口》一书中也进行了总结：可视化接口在处理小数量物体简单行为的情况下，工作的很好，但是当行为或物体的数量增加是，直接操作很快就编程机械重复的苦差…</p></blockquote><p><strong>也就是说，DSL 的形式会约束 DSL 本身的表达能力。</strong></p><p><br></p><p>正如前文说的，如果‘低代码’仅仅是将原本的编码工作转换为 GUI 形式，其实并没有多大意义，因为没有抽象。</p><p>反例：</p><p><img src="/images/crud/Untitled%203.png" alt="JSON GUI vs  JSON"></p><p>JSON GUI vs JSON</p><p><br><br><br></p><p>正例： VSCode 案例</p><p><img src="/images/crud/Untitled%204.png" alt="Untitled"></p><p><img src="/images/crud/Untitled%205.png" alt="Untitled"></p><p>充分利用 GUI 的优势，提供更好的目录组织、文本提示、数据录入的约束和校验。</p><p><br><br><br></p><p>我们可能会说 GUI 形式用户体验更好，门槛低更低，不用关心底层的细节。<strong>其实并不一定是 GUI 带来的，而是抽象后的结果。GUI 只不过是一种接口形式</strong>。</p><p><br></p><p>回到正题，为了摆脱管理后台 CRUD 的 「西西弗斯之石」： 我们可以创建一个 DSL，这个 DSL 抽象了管理端的各种场景，将繁琐的实现细节、重复的工作封装起来，暴露简洁而优雅的用户接口(User Interface)。</p><aside><br>💡 小结。DSL 是可视化低代码与 pro code 之间的中间中间形态，权衡了易用性/灵活性和实现成本。DSL 的形式会直接影响它的表达能力，但比形式更重要的是 DSL 对特定问题域的抽象。<br><br>我们不必重新发明一门语言，而是复用元语言的能力和生态，这基本上是零成本。<br></aside><p><br><br><br><br><br><br><br></p><h2 id="抽象过程"><a href="#抽象过程" class="headerlink" title="抽象过程"></a>抽象过程</h2><p>典型的增删改查页面：</p><p><img src="/images/crud/Untitled%206.png" alt="Untitled"></p><p>分析过程：</p><ol><li>后端增删改查主要由两大组件组成: <code>表单</code>和<code>表格</code>。</li><li>而表单和表格又由更原子的’<code>字段</code>’组成。字段的类型决定了存储类型、录入方式、和展示方式</li><li>字段有两种形态：<code>编辑态</code>和<code>预览态</code>。表格列、详情页通常是预览态，而表单和表格筛选则使用编辑态。</li></ol><p><br></p><p><img src="/images/crud/Untitled%207.png" alt="Untitled"></p><p>借鉴低代码平台的<code>组件库</code>/<code>节点库</code>，我们可以将这些‘字段’ 提取出来， 作为表单和表格的‘原子’单位， 这里我们给它取个名字，就叫<code>原件</code>(<code>Atomic</code>)吧。</p><p><img src="/images/crud/Untitled%208.png" alt="Untitled"></p><p><code>原件</code>将取代组件库里面的<code>表单组件</code>，作为我们 <code>CRUD</code> 页面的<strong>最小组成单位</strong>。它有且只有职责：</p><p><img src="/images/crud/Untitled%209.png" alt="Untitled"></p><ul><li>数据类型和校验。原件代表的是一种数据类型，可以是<code>基础类型</code>，比如数字、字符串、布尔值、枚举；也可以是基础类型上加了一些约束和交互，比如邮件、手机号码、链接；甚至可能有<code>业务属性</code>，比如用户，商品，订单，二维码。</li><li>数据的预览。</li><li>数据的录入，严格约束为 <code>value</code>/<code>onChange</code> 协议。好处是方便进行状态管理，可能保证原件实现的统一性。</li></ul><p><br><br><br></p><p>接着组合原件来实现表单和表格组件，满足 CRUD 场景：</p><p><img src="/images/crud/Untitled%2010.png" alt="Untitled"></p><p>理想状态下，我们仅需声明式地指定表格的列和原件类型，其余的技术细节应该隐藏起来。表格伪代码示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建包含 名称、创建时间、状态三列的表格，其中可以搜索名称和创建时间</span></span><br><span class="line">Table(</span><br><span class="line">  columns(</span><br><span class="line">    column(名称，name, queryable=<span class="literal">true</span>)</span><br><span class="line">    column(创建时间, created, data-range, queryable=<span class="literal">true</span>)</span><br><span class="line">    column(状态, status, select, options=[&#123;label: 启用，value: 1, &#123;label: 禁用， value: 0&#125;&#125;])</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br></p><p>表单伪代码示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建包含 名称、状态、地址的表单</span></span><br><span class="line">Form(</span><br><span class="line">  item(名称，name, required=<span class="literal">true</span>)</span><br><span class="line">  item(状态，status, select, options=[&#123;label: 启用，value: 1, &#123;label: 禁用， value: 0&#125;&#125;])</span><br><span class="line">  item(地址, address, address)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br></p><p>如上所示，本质上，开发者就应该只关注业务数据本身，而应该忽略掉前端技术实现的噪音(比如状态管理、展示风格、分页、异常处理等等)。</p><p><br><br><br></p><p>表格和表单为了适应不同的需求，还会衍生出不同的展现形式：</p><p><img src="/images/crud/Untitled%2011.png" alt="Untitled"></p><p><code>原件</code> + <code>核心的表单/表格能力</code> + <code>场景/展示形式</code>，一套「组合拳」下来，基本就可以满足常见的后台 CRUD 需求了。</p><p><br><br><br><br><br></p><h2 id="约定大于配置"><a href="#约定大于配置" class="headerlink" title="约定大于配置"></a>约定大于配置</h2><p>前端的在研发流程中相对下游，如果上游的产品定义，UI 设计，后端协议没有保持一致性，就会苦于应付各种混乱的差异，复用性将无从谈起。</p><p>为了最小化样板代码和沟通成本，实现开箱即用的效果。我们最好拉通上下游，将相关的规范确定下来，前端开发者应该扮演好串联的角色。</p><p><br></p><p>这些规范包含但不限于：</p><ul><li>页面的布局</li><li>UI 风格</li><li>提示语</li><li>验证规则</li><li>数据的存储格式</li><li>通用的接口(比如文件上传，导入导出)</li><li>…</li></ul><p><img src="/images/crud/Untitled%2012.png" alt="Untitled"></p><p>组件库可以内置这些约定，或者提供全局的配置方式。这些规范固化后，我们就享受开箱即用的快感了。</p><p><br><br><br><br><br></p><h2 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h2><p>基于上述思想，我们开发了一套<a href="https://wakeadmin.wakedata.com/components-doc/" target="_blank" rel="noopener">组件库</a>(基于 Vue 和 element-ui)，配合一套简洁的 DSL，来快速开发 CRUD 页面。</p><p><br></p><aside><br>💡 <strong><em>这套组件库耦合了我们自己的约定</em></strong>。因此可能不适用于外部通用的场景。本文的意义更多是想启发读者，去构建适合自己的一套解决方案。<br><br></aside><p><strong>列表页定义：</strong></p><p><img src="/images/crud/Untitled%2013.png" alt="Untitled"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; defineFatTable &#125; from &apos;@wakeadmin/components&apos;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 表格项类型</span><br><span class="line"> */</span><br><span class="line">export interface Item &#123;</span><br><span class="line">  id: number</span><br><span class="line">  name: string</span><br><span class="line">  createDate: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const MyTable = defineFatTable&lt;Item&gt;((&#123; column &#125;) =&gt; &#123;</span><br><span class="line">  // 可以在这里放置 Vue hooks</span><br><span class="line">  return () =&gt; (&#123;</span><br><span class="line">    async request(params) &#123;</span><br><span class="line">      /* 数据获取，自动处理异常和加载状态 */</span><br><span class="line">    &#125;,</span><br><span class="line">    // 删除操作</span><br><span class="line">    async remove(list, ids) &#123;</span><br><span class="line">      /*列删除*/</span><br><span class="line">    &#125;,</span><br><span class="line">    // 表格列</span><br><span class="line">    columns: [</span><br><span class="line">      // queryable 标记为查询字段</span><br><span class="line">      column(&#123; prop: &apos;name&apos;, label: &apos;名称&apos;, queryable: true &#125;),</span><br><span class="line">      column(&#123; prop: &apos;createDate&apos;, valueType: &apos;date-range&apos;, label: &apos;创建时间&apos;, queryable: true &#125;),</span><br><span class="line">      column(&#123;</span><br><span class="line">        type: &apos;actions&apos;,</span><br><span class="line">        label: &apos;操作&apos;,</span><br><span class="line">        actions: [&#123; name: &apos;编辑&apos; &#125;, &#123; name: &apos;删除&apos;, onClick: (table, row) =&gt; table.remove(row) &#125;],</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>语法类似于 Vue defineComponent，传入一个’setup’, 。这个 setup 中可以放置一些逻辑和状态或者 Vue hooks，就和 Vue defineComponent 定义一样灵活。</p><p>返回关于表格结构的”声明”。最优的情况下，开发者只需要定义表格结构和后端接口，其余的交由组件库处理。</p><p>当然复杂的定制场景也能满足，这里可以使用 JSX，监听事件，传递组件支持的任意 props 和 slots。</p><p><br><br><br></p><p><strong>表单页示例:</strong></p><p><img src="/images/crud/Untitled%2014.png" alt="Untitled"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; defineFatForm &#125; from &apos;@wakeadmin/components&apos;</span><br><span class="line">import &#123; ElMessageBox &#125; from &apos;element-plus&apos;</span><br><span class="line"></span><br><span class="line">export default defineFatForm&lt;&#123;</span><br><span class="line">  // 🔴 这里的泛型变量可以定义表单数据结构</span><br><span class="line">  name: string</span><br><span class="line">  nickName: string</span><br><span class="line">&#125;&gt;((&#123; item, form, consumer, group &#125;) =&gt; &#123;</span><br><span class="line">  // 🔴 这里可以放置 Vue Hooks</span><br><span class="line"></span><br><span class="line">  // 返回表单定义</span><br><span class="line">  return () =&gt; (&#123;</span><br><span class="line">    // FatForm props 定义</span><br><span class="line">    initialValue: &#123;</span><br><span class="line">      name: &apos;ivan&apos;,</span><br><span class="line">      nickName: &apos;狗蛋&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    submit: async (values) =&gt; &#123;</span><br><span class="line">      await ElMessageBox.confirm(&apos;确认保存&apos;)</span><br><span class="line">      console.log(&apos;保存成功&apos;, values)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // 🔴 子节点</span><br><span class="line">    children: [</span><br><span class="line">      item(&#123; prop: &apos;name&apos;, label: &apos;账号名&apos; &#125;),</span><br><span class="line">      item(&#123;</span><br><span class="line">        prop: &apos;nickName&apos;,</span><br><span class="line">        label: &apos;昵称&apos;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><aside><br>💡 和 tailwind 配合食用更香。我们假设整体的页面是符合UI规范的，细微的调整使用 tw 会很方便<br><br></aside><p><br><br><br></p><p><strong>全局配置：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; provideFatConfigurable &#125; from &apos;@wakeadmin/components&apos;</span><br><span class="line">import &#123; Message &#125; from &apos;element-ui&apos;</span><br><span class="line"></span><br><span class="line">export function injectFatConfigurations() &#123;</span><br><span class="line">  provideFatConfigurable(&#123;</span><br><span class="line">    // ...</span><br><span class="line">    // 统一处理 images 原件上传</span><br><span class="line">    aImagesProps: &#123;</span><br><span class="line">      action: &apos;/upload&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    // 统一 date-range 原件属性</span><br><span class="line">    aDateRangeProps: &#123;</span><br><span class="line">      rangeSeparator: &apos;至&apos;,</span><br><span class="line">      startPlaceholder: &apos;开始日期&apos;,</span><br><span class="line">      endPlaceholder: &apos;结束日期&apos;,</span><br><span class="line">      valueFormat: &apos;yyyy-MM-dd&apos;,</span><br><span class="line">      shortcuts: [</span><br><span class="line">        &#123;</span><br><span class="line">          text: &apos;最近一周&apos;,</span><br><span class="line">          onClick(picker: any) &#123;</span><br><span class="line">            picker.$emit(&apos;pick&apos;, getTime(7))</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          text: &apos;最近一个月&apos;,</span><br><span class="line">          onClick(picker: any) &#123;</span><br><span class="line">            picker.$emit(&apos;pick&apos;, getTime(30))</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          text: &apos;最近三个月&apos;,</span><br><span class="line">          onClick(picker: any) &#123;</span><br><span class="line">            picker.$emit(&apos;pick&apos;, getTime(90))</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>更多示例和深入讲解见<a href="https://wakeadmin.wakedata.com/components-doc/" target="_blank" rel="noopener">这里</a>。</p><p><br><br><br><br><br></p><h2 id="更多实现"><a href="#更多实现" class="headerlink" title="更多实现"></a>更多实现</h2><p>前端社区有很多类似的产品，比如：</p><ul><li><a href="https://xrender.fun/" target="_blank" rel="noopener">XRender</a>。中后台「表单/表格/图表」开箱即用解决方案</li><li><a href="https://procomponents.ant.design/docs/intro" target="_blank" rel="noopener">Antd ProComponents</a>。ProComponents 是基于 Ant Design 而开发的模板组件，提供了更高级别的抽象支持，开箱即用。可以显著的提升制作 CRUD 页面的效率，更加专注于页面</li><li><a href="https://github.com/baidu/amis" target="_blank" rel="noopener">百度 Amis</a> 。 用 JSON 作为 DSL，来描述界面</li></ul><p>读者不妨多参考参考。</p><p><br><br><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单来说，我们就是从提供「<strong>毛坯房</strong>」升级到了「<strong>精装房</strong>」，精装房的设计基于我们对市场需求的充分调研和预判。目的是对于 80% 的用户场景，可以实现拎包入住，当然也允许用户在约束的范围内改装。</p><p>本文主要阐述的观点：</p><ul><li>低代码平台的高效和易用大多来源于抽象，而不一定是 GUI，GUI ≠ 低代码。</li><li>摆脱「西西弗斯之石」 考验的是开发者的抽象能力，识别代码中固化/重复的逻辑。将模式提取出来，同时封装掉底层的实现细节。最终的目的是让开发者将注意力关注到业务本身，而不是技术实现细节。</li><li>用声明式、精简、高度抽象 DSL 描述业务 。DSL 的形式会约束他的表达能力，我们并不一定要创建一门新的语言，最简单的是复用元语言的生态和能力。</li><li>约定大于配置。设计风格、交互流程、数据存储等保持一致性，才能保证抽象收益的最大化。因此规范很重要。这需要我们和设计、产品、后端深入沟通，达成一致。</li><li>沉淀原件。低代码平台的效率取决于平台提供的组件能力、数量和粒度。比如前端的组件库，亦或者流程引擎的节点，都属于原件的范畴。</li><li>要求不要太高，这并不是一个万精油方案，我们期望能满足 80% 常见的场景，这已经是一个很好的成绩。至于那 20% 的个性需求，还是从毛坯房搞起吧。</li></ul><p><br><br><br><br><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://github.com/ascoders/weekly/issues/319" target="_blank" rel="noopener">精读《低代码逻辑编排》</a></li><li>UNIX 编程艺术</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/crud/Untitled.jpeg&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;据说，西西弗斯是一个非常聪明的国王，但他也非常自负和狂妄。他甚至敢欺骗神灵，并把死者带回人间。为此，他被宙斯（Zeus）惩罚，被迫每天推着一块巨石上山，
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>如何实现支持跨 Vue 2/3 的组件库</title>
    <link href="https://bobi.ink/2023/06/11/component-for-vue2-3/"/>
    <id>https://bobi.ink/2023/06/11/component-for-vue2-3/</id>
    <published>2023-06-10T16:00:00.000Z</published>
    <updated>2023-06-11T14:21:51.353Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><p><img src="/images/component-for-vue2-3/Untitled.jpeg" alt="Untitled"></p><p>Vue 3 已经<a href="https://vue-js.com/topic/5f65624c96b2cb0032c38550" target="_blank" rel="noopener">发布</a>三年，我们有较多项目还停留在 Vue 2。Vue 3 的升级是比较割裂的。</p><p>我们主要做的是 <code>2B</code> 业务，项目、模块、分支都非常多，升级的成本和风险都比较高。</p><p>我们目前的策略是 “新旧并存，渐进式升级”， 旧的项目就尽量不变了，新的项目强制使用新的技术栈。利用<code>微前端</code>架构，新旧应用可以灵活地组合起来。</p><p>因此我们的业务组件库、工具库之类需要考虑兼容旧的 Vue 2 项目。这篇文章，就向大家展示我们开发跨版本组件库，其中的决策和实现过程。</p><p><br><br><br></p><h2 id="方案决策"><a href="#方案决策" class="headerlink" title="方案决策"></a>方案决策</h2><p>实现跨版本的组件都多种方案，下面列举分析几种主要方案：</p><p><br></p><p><strong>方案一：使用 Vue SFC / 模板</strong></p><p>单纯从外观上看 Vue 2 / 3 在模板的语法上<a href="https://v3-migration.vuejs.org/zh/breaking-changes/v-model.html" target="_blank" rel="noopener">差别并不大</a>。在 <a href="https://blog.vuejs.org/posts/vue-2-7-naruto" target="_blank" rel="noopener">Vue 2.7</a> 开始内置了对 <code>script setup</code> 也有了较好的支持。</p><p>理论上，我们可以编写一份代码，然后分别针对 2 / 3 编译两份输出。</p><p><img src="/images/component-for-vue2-3/Untitled.png" alt="总体流程如上"></p><p>总体流程如上</p><p><strong>笔者提供了一个简单的 DEMO 来验证了这个方案的可行性，详见<a href="https://github.com/wakeadmin/cvv-sfc-demo" target="_blank" rel="noopener">这里</a>。</strong></p><ul><li>优点<ul><li>模板是 Vue 的第一公民，不需要为了兼容不同版本改变原有的开发习惯。学习成本比较低</li><li>支持静态编译，比如可以针对不同的版本进行条件编译，<strong>优化包体积</strong>。另外可以<strong>保留<a href="https://cn.vuejs.org/guide/extras/rendering-mechanism.html#compiler-informed-virtual-dom" target="_blank" rel="noopener">Vue 模板编译优化</a>机制</strong>。</li><li>使用公开标准语法，不需要 hack 或者关心太多框架底层的差异。</li></ul></li><li>缺点<ul><li>构建相对复杂，需要两份代码输出。</li><li>灵活性较差。模板语法差异很小，但不以为着没有差异，当需要处理某些跨版本差异时可能会比较棘手。比如<a href="https://v3-migration.vuejs.org/zh/breaking-changes/render-function-api.html" target="_blank" rel="noopener">向下透传事件、props 或者 slots</a> , <a href="https://v3-migration.vuejs.org/zh/breaking-changes/v-bind.html" target="_blank" rel="noopener">v-bind.sync 废弃了</a> 、<a href="https://v3-migration.vuejs.org/zh/breaking-changes/key-attribute.html" target="_blank" rel="noopener">template v-for key</a> <strong>、</strong>v-model 协议变化。</li><li>⚠️ 语法固化，为了兼容 Vue 2，template 语法需要停留在 Vue 3.0，这意味着后续发布的新特性可能无法使用，比如 <code>defineModel</code>，<code>defineOptions</code>。</li></ul></li></ul><p><br><br><br><br><br></p><p><strong>方案 2： 渲染函数</strong></p><p>Vue 2 和 Vue 3 都支持渲染函数，但是两者之间有非常大的差异。<strong>详细的差异对比可以看笔者整理的这篇文档： <a href="https://www.notion.so/Vue-2-3-302cbe0e37794345bbfbd89e32d617db?pvs=21" target="_blank" rel="noopener">Vue 2/3 渲染函数差异以及兼容方案</a></strong></p><p><br></p><p><strong>那 Vue 官方的 JSX 插件呢？</strong></p><p>Vue 2/3 JSX Babel (<strong><a href="https://github.com/vuejs/jsx-vue2" target="_blank" rel="noopener">jsx-vue2</a>、<a href="https://github.com/vuejs/babel-plugin-jsx" target="_blank" rel="noopener">babel-plugin-jsx</a></strong>)插件加了一些语法糖，来简化渲染函数的编写，但是这两个插件的语法完全是两个东西。</p><p>因此这个方案不在我们的考虑之列。</p><p><br><br><br><br><br></p><p><strong>方案 3：标准的 JSX</strong></p><p>那为什么不用标准的 <code>JSX</code> 呢？使用统一的 JSX 语法，转换为不同版本的渲染函数。</p><p><img src="/images/component-for-vue2-3/Untitled%201.png" alt="Untitled"></p><p>使用标准的 JSX 语法，意味着：</p><ul><li><p>不需要任何 <code>Babel</code> 插件，能够被市面上主流的编译器(如 tsc， swc，esbuild)直接处理。<br>例如 Typescript</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">/** tsconfig.json */</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"jsx"</span>: <span class="string">"react-jsx"</span>,</span><br><span class="line">    <span class="attr">"jsxImportSource"</span>: <span class="string">"JSX 运行时名称"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<strong>运行时</strong>转换到对应版本的渲染函数。</p></li><li>Typescript friendly。纯 TSX，不需要额外插件(比如 <code>Volar</code>)辅助。</li><li><p>使用习惯上接近 <code>React</code>。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">/** 🔴 1. 事件订阅  **/</span><br><span class="line">// 🤮</span><br><span class="line"><span class="deletion">- &lt;input vOn:click=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;input vOn:click_stop_prevent=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line">// 👍 使用 on* 注册时间</span><br><span class="line"><span class="addition">+ &lt;input onClick=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line"></span><br><span class="line">/** 🔴 2. 没有指令  **/</span><br><span class="line">// 🤮</span><br><span class="line"><span class="deletion">- &lt;input v-show=&#123;this.visible&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;input vModel=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;input vModel_trim=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;A v-model=&#123;[val, "argument", ["modifier"]]&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;a v-loading=&#123;val&#125; /&gt;;</span></span><br><span class="line"></span><br><span class="line">// 👍 没有语法糖</span><br><span class="line"><span class="addition">+ &lt;input modelValue=&#123;val&#125; onUpdate:modelValue=&#123;handleValChange&#125; /&gt;</span></span><br><span class="line"><span class="addition">+ &lt;input style=&#123;&#123;display: this.visible ? 'block' : 'none' &#125;&#125; /&gt;</span></span><br><span class="line"><span class="addition">+ &lt;a &#123;...withDirectives([[vLoading, val]])&#125;&gt;</span></span><br><span class="line"></span><br><span class="line">/** 🔴 3. slots  **/</span><br><span class="line">// 🤮</span><br><span class="line"><span class="deletion">- &lt;MyComponent&gt;</span></span><br><span class="line"><span class="deletion">-   &lt;header slot="header"&gt;header&lt;/header&gt;</span></span><br><span class="line"><span class="deletion">-   &lt;footer slot="footer"&gt;footer&lt;/footer&gt;</span></span><br><span class="line"><span class="deletion">- &lt;/MyComponent&gt;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">- const scopedSlots = &#123;</span></span><br><span class="line"><span class="deletion">-   header: () =&gt; &lt;header&gt;header&lt;/header&gt;,</span></span><br><span class="line"><span class="deletion">-   footer: () =&gt; &lt;footer&gt;footer&lt;/footer&gt;</span></span><br><span class="line"><span class="deletion">- &#125;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">- &lt;MyComponent scopedSlots=&#123;scopedSlots&#125; /&gt;</span></span><br><span class="line"></span><br><span class="line">// 👍 对齐 vue 3</span><br><span class="line"><span class="addition">+ const App = &#123;</span></span><br><span class="line"><span class="addition">+   setup() &#123;</span></span><br><span class="line"><span class="addition">+     const slots = &#123;</span></span><br><span class="line"><span class="addition">+       bar: () =&gt; &lt;span&gt;B&lt;/span&gt;,</span></span><br><span class="line"><span class="addition">+     &#125;;</span></span><br><span class="line"><span class="addition">+     return () =&gt; (</span></span><br><span class="line"><span class="addition">+       &lt;A v-slots=&#123;slots&#125;&gt;</span></span><br><span class="line"><span class="addition">+         &lt;div&gt;A&lt;/div&gt;</span></span><br><span class="line"><span class="addition">+       &lt;/A&gt;</span></span><br><span class="line"><span class="addition">+     );</span></span><br><span class="line"><span class="addition">+   &#125;,</span></span><br><span class="line"><span class="addition">+ &#125;;</span></span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><ul><li><p>优点</p><ul><li>构建很简单，使用标准的 JSX 只需构建一次。不需要引入特定的编译器，使用 <code>Typescript CLI</code>，<code>esbuild</code> 就可以直接编译。</li><li>Typescript Friendly, 另外相比 <code>vue-tsc</code> 编译结果会好一点。</li><li>灵活性。毋庸置疑，<code>JSX</code> 的灵活性，可操行性太强了。</li><li>相对模板编译来说，可控一点(Hackable)。</li><li>可以替换官方的 JSX 库，除了本文介绍的<code>跨版本组件库</code>场景，在日常 Vue 2/3 应用开发中也可以使用啊。</li></ul></li><li><p>缺点</p><ul><li>使用 <code>JSX</code> 则意味着放弃<a href="https://cn.vuejs.org/guide/extras/rendering-mechanism.html#compiler-informed-virtual-dom" target="_blank" rel="noopener">模板编译优化</a>的机会，比如动态节点标注，预字符串化，缓存，静态提升等等。</li><li>为了抹平版本之间的差异，多了一层抽象转换(主要是 Vue 2 上)，会有一些性能损耗。</li><li>实现上需要熟知两个版本之间的差异性。比较 hack</li><li>可读性较差，相比 <code>React</code> 简洁的 Api，Vue 上的一些特殊的框架特性，还是会让代码有些不太优雅，比如指令、Slot</li></ul></li></ul><p>后面我们选择了 <code>JSX</code> 方案，因为实现起来更简单，方案更加可控，尤其是应对后续的版本更新。</p><p><br><br><br><br><br></p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>构建跨版本的组件库，需要考虑的不仅仅是组件语法问题。Vue 2/3 从底层的 API 到渲染函数、再到应用层的组件库、路由、多语言等等，都出现了割裂。我们得兼顾这些变化。</p><p><br></p><ol><li><strong>分层策略</strong></li></ol><p><img src="/images/component-for-vue2-3/Untitled%202.png" alt="Untitled"></p><p>我们按照引用关系进行分层：</p><ul><li><strong><code>API 层</code></strong>。好在 Vue 3 大部分特性(主要是 <code>Composition API</code> 和 <code>defineComponent</code>) 已经下放到了 Vue 2，我们只需要使用 <a href="https://github.com/vueuse/vue-demi" target="_blank" rel="noopener">vue-demi</a> 就可以无缝使用这些核心的 API。<br>相对应的，上层的组件库、适配器代码禁止直接导入 ‘vue’</li><li><strong><code>视图语法层</code></strong>。就如上文说的，我们会封装一个 jsx-runtime, 抹平 Vue 2/3 在渲染函数上的差异。</li><li><strong><code>适配器层</code></strong>。应用层的各种类库的适配。比如我们公司主要使用 element-ui, 新旧版本的差异会在 element-adapter 中处理，并暴露统一接口。</li><li><strong><code>组件库层</code></strong>。最后我们的组件库基于下层提供的抽象能力，实现跨版本。</li><li><strong><code>应用</code></strong>。上层的 Vue 2 / 3 应用。下层的适配器，会根据应用使用的 Vue 版本，动态切换适配。</li></ul><p><br><br><br></p><p><strong>2) 新版本优先策略</strong></p><p>在封装适配器 或者 jsx-runtime 时，当新旧版本出现差异时，我们如何抉择？</p><p>这里采用的是“新版本优先”的策略，举一些例子：</p><ul><li>JSX 的语法对齐 Vue 3 的渲染函数。</li><li>只使用 Composition API</li><li>只使用 defineComponent</li></ul><p>换句话说，如果情况允许，我们始终以 Vue 3 为基准。</p><p><br><br><br></p><p><strong>3) 短板优先策略</strong></p><p>短板对齐是实现兼容的基础策略，主要分两个方面：</p><ul><li>削头: 并不是所有 Vue 3 的特性都能下放到 Vue 2, 比如 <code>Fragment</code>、<code>Teleport</code>、<code>Suspense</code>/<code>await setup</code>。我们只能放弃这些功能。</li><li>补尾：针对一些 Vue 2 的短板，需要一些额外的工作，比如 <a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">Vue 2 响应式系统的局限性</a>。</li></ul><p><br><br><br></p><p><strong>4) 回退策略</strong></p><p>对于一些无法抹平的差异，可以按照不同的版本特殊处理。可以使用 vue-demi 的 <code>isVue2</code> 来分条件处理。</p><p><br><br><br><br><br></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="api-兼容：vue-demi"><a href="#api-兼容：vue-demi" class="headerlink" title="API 兼容：vue demi"></a>API 兼容：vue demi</h3><p><a href="https://github.com/vueuse/vue-demi" target="_blank" rel="noopener">vue-demi</a> 为实现跨 Vue 版本的库提供基础的支持。它的主要策略：</p><ul><li><code>&lt;=2.6</code>: 导出  <code>vue</code> + <code>@vue/composition-api</code>.</li><li><code>2.7</code>: 导出  <code>vue</code> ( Vue 2.7 内置支持 Composition API).</li><li><code>&gt;=3.0</code>: 导出  <code>vue</code>, 模拟了 Vue 2 的<code>set</code> 、 <code>del</code> API.</li></ul><p>vue-demi 的实现很简单，就是在 npm 的 <code>postinstall</code> 钩子中，判断当前环境安装的 vue 库版本，决定导入的库。</p><p>在我们的场景中，除了 Composition API 和一些基础类型信息还不够，我们 Fork 了 vue-demi 来扩充了一些填充物，进一步抹平一些差异。</p><p><br><br><br><br><br></p><h3 id="渲染语法：jsx-runtime-的实现"><a href="#渲染语法：jsx-runtime-的实现" class="headerlink" title="渲染语法：JSX runtime 的实现"></a>渲染语法：JSX runtime 的实现</h3><p>JSX runtime 的实现并不涉及太复杂的技术，主要还是处理渲染函数的繁琐 API 差异。</p><p>文章篇幅有限，这里我就不展开讲细节了。<strong>⚠️ 完整的差异对比和应对方式可以看这里</strong>：</p><p><br></p><p><a href="https://www.notion.so/Vue-2-3-302cbe0e37794345bbfbd89e32d617db?pvs=21" target="_blank" rel="noopener">🎉Vue 2 / 3 渲染函数的差异 🎉</a></p><p><br></p><p>简单来说，我们的 JSX 语法以 Vue 3 为基准，主要涉及事件订阅、slots、指令的转换。</p><p><br></p><p><img src="/images/component-for-vue2-3/Untitled%203.png" alt="Untitled"></p><p>具体实现可以看<a href="https://github.com/wakeadmin/tools/tree/main/packages/h" target="_blank" rel="noopener">这里</a></p><p><br><br><br><br><br></p><h3 id="组件定义与-typescript-支持"><a href="#组件定义与-typescript-支持" class="headerlink" title="组件定义与 Typescript 支持"></a>组件定义与 Typescript 支持</h3><p>Typescript + Volar 就是一门玄学，类型‘体操’几乎占据了开发的三分之一时间。主要问题：</p><ul><li>Vue 2/3 类型定义和导出有细微的差别。我们的 jsx-runtime 要求一致的类型。</li><li>JSX 的 slots 不支持类型检查。渲染函数毕竟不是 Vue 的第一公民，slots 在 JSX 下无法类型检查。</li><li>为了兼容 options API, <code>defineComponent</code> 类型定义和推导比较<a href="https://github.com/vuejs/core/blob/a95e612b252ae59eaf56e0b8ddba66948d4ac20e/packages/runtime-core/src/apiDefineComponent.ts#L44" target="_blank" rel="noopener">复杂</a>。</li><li>泛型组件实现比较复杂，Volar 泛型的支持也比较玄学。</li></ul><p><br><br><br></p><p>为了能够更好地定义跨版本的组件，提供更好的类型支持，我们打算简化 <code>defineComponent</code>。为了避免命名冲突，尚且命名为 <code>declareComponent</code> 吧, 这个函数有以下职责：</p><ul><li>为实现跨版本支持提供必要约束。<code>declareComponent</code> 裁剪掉了 <code>Options API</code>, 只保留 setup、props、render 等属性。强制走 <code>Composition API</code>。</li><li>为 JSX (比如 v-slots 属性)提供更好类型检查支持</li><li>同时兼容 vue template 的类型检查 (<code>volar</code>)。</li><li>在运行时抹平一些跨版本的差异。绝大部分差异，Vue 2.7 在 <code>defineComponent</code> 方法内部已经抹平了。还有一些 <code>inheritAttrs</code> 带来的<a href="https://www.notion.so/Vue-2-3-302cbe0e37794345bbfbd89e32d617db?pvs=21" target="_blank" rel="noopener">隐式差异</a>，<strong>declareComponent 直接关闭了 <code>inheritAttrs</code></strong> 。</li><li>补全短板，并且向下保持兼容。Vue 2 已经不更新了，我们想要支持一些新的特性，比如泛型。</li></ul><p><br></p><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Counter = declareComponent(&#123;</span><br><span class="line">  name: &apos;Counter&apos;,</span><br><span class="line">  // 定义 props</span><br><span class="line">  props: declareProps&lt;&#123;</span><br><span class="line">    initialValue: number</span><br><span class="line">  &#125;&gt;(</span><br><span class="line">    // ⚠️ 和 defineComponent 一样，我们还是需要显式定义 props, 否则会被当做 attrs</span><br><span class="line">    [&apos;initialValue&apos;]</span><br><span class="line">  ),</span><br><span class="line"></span><br><span class="line">  // 定义事件</span><br><span class="line">  emits: declareEmits&lt;&#123; change: (value: number) =&gt; void &#125;&gt;(),</span><br><span class="line"></span><br><span class="line">  // 定义插槽</span><br><span class="line">  // slots: declareSlots&lt;&#123; foo: &#123; a: number &#125; &#125;&gt;(),</span><br><span class="line"></span><br><span class="line">  // setup</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    const count = ref(props.initialValue)</span><br><span class="line">    const handleClick = () =&gt; &#123;</span><br><span class="line">      count.value++</span><br><span class="line"></span><br><span class="line">      emit(&apos;change&apos;, count.value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return () =&gt; (</span><br><span class="line">      &lt;div title=&quot;count&quot; onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">        count: &#123;count.value&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>为了实现这个目标，我们先来看下 <code>Volar</code> 是如何推断组件的类型：</p><p><br></p><p>大致的推导过程如下, 其次可以参考 <code>vue-tsc</code> 的编译输出或者 Vue <code>defineComponent</code> 的类型声明。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// https://github.com/vuejs/language-tools/blob/71240c78f1a205605f4c079a299b2701250ef9be/packages/vue-component-type-helpers/index.d.ts#L5</span><br><span class="line">export type ComponentProps&lt;T&gt; = T extends new () =&gt; &#123; $props: infer P &#125;</span><br><span class="line">  ? NonNullable&lt;P&gt;</span><br><span class="line">  : T extends (props: infer P, ...args: any) =&gt; any</span><br><span class="line">  ? P</span><br><span class="line">  : &#123;&#125;</span><br><span class="line"></span><br><span class="line">export type ComponentSlots&lt;T&gt; = T extends new () =&gt; &#123; $slots: infer S &#125;</span><br><span class="line">  ? NonNullable&lt;S&gt;</span><br><span class="line">  : T extends (props: any, ctx: &#123; slots: infer S &#125;, ...args: any) =&gt; any</span><br><span class="line">  ? NonNullable&lt;S&gt;</span><br><span class="line">  : &#123;&#125;</span><br><span class="line"></span><br><span class="line">export type ComponentEmit&lt;T&gt; = T extends new () =&gt; &#123; $emit: infer E &#125;</span><br><span class="line">  ? NonNullable&lt;E&gt;</span><br><span class="line">  : T extends (props: any, ctx: &#123; emit: infer E &#125;, ...args: any) =&gt; any</span><br><span class="line">  ? NonNullable&lt;E&gt;</span><br><span class="line">  : &#123;&#125;</span><br><span class="line"></span><br><span class="line">export type ComponentExposed&lt;T&gt; = T extends new () =&gt; infer E</span><br><span class="line">  ? E</span><br><span class="line">  : T extends (props: any, ctx: &#123; expose(exposed: infer E): any &#125;, ...args: any) =&gt; any</span><br><span class="line">  ? NonNullable&lt;E&gt;</span><br><span class="line">  : &#123;&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Vue 2.x</span><br><span class="line"> */</span><br><span class="line">export type Vue2ComponentSlots&lt;T&gt; = T extends new () =&gt; &#123; $scopedSlots: infer S &#125;</span><br><span class="line">  ? NonNullable&lt;S&gt;</span><br><span class="line">  : T extends (props: any, ctx: &#123; slots: infer S &#125;, ...args: any) =&gt; any</span><br><span class="line">  ? NonNullable&lt;S&gt;</span><br><span class="line">  : &#123;&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>简单来说 <code>defineComponent</code> 方法最终输出的组件的类型外观长这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type YourComponent = new (...args: any[]): &#123;</span><br><span class="line">  $props: Props 类型</span><br><span class="line">  $emit: 事件类型</span><br><span class="line">  $slots: 插槽类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>💡 那 Typescript 的 JSX 怎么对组件进行类型检查呢？这个可以参考 Typescript 的 <a href="https://www.typescriptlang.org/docs/handbook/jsx.html" target="_blank" rel="noopener">JSX 文档</a>，还有 Vue 的 JSX <a href="https://github.com/vuejs/core/blob/a95e612b252ae59eaf56e0b8ddba66948d4ac20e/packages/vue/jsx.d.ts#L3" target="_blank" rel="noopener">类型定义</a>。简单说也是从上述的 <code>$props</code> 中推导的。</p></blockquote><p><br><br><br></p><p>我们的 <code>declareComponent</code> 只要保持和上面的类型兼容，就可以让 <code>volar</code> 在 vue template 下进行类型检查了。</p><p><br></p><p>因为刨除掉了不必要的 Options API, 相比 defineComponent, 类型定义可以简化很多:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function declareComponent&lt;</span><br><span class="line">  Props extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Emit extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Slots extends &#123;&#125; = &#123;&#125;</span><br><span class="line">&gt;(</span><br><span class="line">  options: SimpleComponentOptions&lt;Props, Emit, Expose, Slots&gt;</span><br><span class="line">): DefineComponent&lt;Props, Emit, Expose, Slots&gt; &#123;</span><br><span class="line">  /// .. 实现忽略，简单封装 defineComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 简化 defineComponent API, 只保留 Composition API</span><br><span class="line">export type SimpleComponentOptions&lt;</span><br><span class="line">  Props extends &#123;&#125;,</span><br><span class="line">  Emit extends &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125;,</span><br><span class="line">  Slots extends &#123;&#125;</span><br><span class="line">&gt; = &#123;</span><br><span class="line">  name?: string</span><br><span class="line">  props?: Props</span><br><span class="line">  emits?: Emit</span><br><span class="line">  slots?: Slots</span><br><span class="line">  expose?: Expose</span><br><span class="line">  setup: (</span><br><span class="line">    props: Props,</span><br><span class="line">    ctx: SetupContext&lt;Emit, DefaultSlots &amp; Slots, Expose, Data&gt;</span><br><span class="line">  ) =&gt; Promise&lt;RenderFunction | void&gt; | RenderFunction | void</span><br><span class="line">  inheritAttrs?: boolean</span><br><span class="line">  serverPrefetch?(): Promise&lt;any&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export interface ComponentInstance&lt;</span><br><span class="line">  Props extends &#123;&#125;,</span><br><span class="line">  Emit extends &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125;,</span><br><span class="line">  Slots extends &#123;&#125;</span><br><span class="line">&gt; &#123;</span><br><span class="line">  // props 定义</span><br><span class="line">  $props: Props &amp;</span><br><span class="line">    // 🔴 将 emit 转换为 on* 形式，方便 JSX 场景使用</span><br><span class="line">    EmitsToProps&lt;Emit&gt; &amp; &#123; &apos;v-slots&apos;?: Partial&lt;VSlotType&lt;Slots&gt;&gt; &#125; &amp; &#123;</span><br><span class="line">      // 🔴 扩展了 v-slots 的定义，方便 JSX 场景使用</span><br><span class="line">      &apos;v-children&apos;?: VChildrenType&lt;Slots&gt;</span><br><span class="line">    &#125; &amp; &#123;</span><br><span class="line">      ref?: RefType&lt;Expose | Expose[]&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  // 🔴 支持 volar 推断 slots</span><br><span class="line">  $slots: VSlotType&lt;Slots&gt;</span><br><span class="line">  // 🔴 支持 volar 推断 事件</span><br><span class="line">  $emit: EmitFn&lt;Emit&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以对比 Vue 的 DefineComponent 看看</span><br><span class="line">export interface DefineComponent&lt;</span><br><span class="line">  Props extends &#123;&#125;,</span><br><span class="line">  Emit extends &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125;,</span><br><span class="line">  Slots extends &#123;&#125;</span><br><span class="line">&gt; &#123;</span><br><span class="line">  new (...args: any[]): ComponentInstance&lt;Props, Emit, Expose, Slots&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>那怎么支持泛型组件吗？</strong></p><p><br><br><br><br><br></p><h3 id="泛型组件"><a href="#泛型组件" class="headerlink" title="泛型组件"></a><strong>泛型组件</strong></h3><blockquote><p>Volar 需要升级到最新版本。</p></blockquote><blockquote><p>Volar 的泛型支持比较玄学，我建议不要随意尝试！</p></blockquote><p>Vue 3.3 官方正式支持了<a href="https://blog.vuejs.org/posts/vue-3-3" target="_blank" rel="noopener">泛型 SFC</a> 和 defineComponent, 笔者实测 Volar 这块支持还有待改进。但是不妨碍我们进行初步的尝试。</p><p>上文的 <code>declareComponent</code> 写法是不支持泛型组件的。有两种方式可以实现泛型组件的声明，先来看一个比较简单的：</p><ol><li><p><strong>类型断言</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 🔴 使用泛型定义 props、emit 和 expose 等类型</span><br><span class="line">interface Props&lt;T&gt; &#123;</span><br><span class="line">  list: T[]</span><br><span class="line">  filter: (item: T) =&gt; boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 📢 这里要用 type</span><br><span class="line">type Emit&lt;T&gt; = &#123;</span><br><span class="line">  add: (item: T) =&gt; void</span><br><span class="line">  change: (list: T[]) =&gt; void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Expose&lt;T&gt; = &#123;</span><br><span class="line">  open: (item: T) =&gt; void</span><br><span class="line">  list: T[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Slots&lt;T&gt; = &#123;</span><br><span class="line">  foo: (list: T[]) =&gt; any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const GenericBar = declareComponent(&#123;</span><br><span class="line">  props: declareProps&lt;Props&lt;any&gt;&gt;([]),</span><br><span class="line">  emits: declareEmits&lt;Emit&lt;any&gt;&gt;(),</span><br><span class="line">  expose: declareExpose&lt;Expose&lt;any&gt;&gt;(),</span><br><span class="line">  slots: declareSlots&lt;Slots&lt;any&gt;&gt;(),</span><br><span class="line">  setup(props, ctx) &#123;</span><br><span class="line">    expectType&lt;any[]&gt;(props.list)</span><br><span class="line">    ctx.emit(&apos;change&apos;, [])</span><br><span class="line">    ctx.slots.foo?.([])</span><br><span class="line">    ctx.expose(&#123;</span><br><span class="line">      list: [],</span><br><span class="line">      open() &#123;</span><br><span class="line">        // ignore</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    return &#123;&#125; as any</span><br><span class="line">  &#125;,</span><br><span class="line">  // 🔴 重新断言，支持 泛型</span><br><span class="line">&#125;) as new &lt;T&gt;(...args: any[]) =&gt; ComponentInstance&lt;Props&lt;T&gt;, Emit&lt;T&gt;, Expose&lt;T&gt;, Slots&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">;&lt;GenericBar</span><br><span class="line">  list=&#123;[1, 2]&#125;</span><br><span class="line">  filter=&#123;(i) =&gt; &#123;</span><br><span class="line">    expectType&lt;number&gt;(i)</span><br><span class="line">    return true</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  onAdd=&#123;(i) =&gt; &#123;</span><br><span class="line">    expectType&lt;number&gt;(i)</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  onChange=&#123;(i) =&gt; &#123;</span><br><span class="line">    expectType&lt;number[]&gt;(i)</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  v-slots=&#123;&#123;</span><br><span class="line">    foo(i) &#123;</span><br><span class="line">      expectType&lt;number[]&gt;(i)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;&lt;/GenericBar&gt;</span><br></pre></td></tr></table></figure><p> <br></p><p>上面的方式在 JSX 表现正常，<strong>但是目前 Volar 在 vue template 并不支持。</strong></p><blockquote><p>💡 <strong>这里也有一些冷知识。</strong>假设 目标类型约束了 <code>Index Signature</code>, 比如 <code>{[key: string]: Function }</code>, 那么 <code>interface</code> 是无法赋值给它的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; interface Indexed &#123;</span><br><span class="line">&gt;   [key: string]: Function</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; interface Foo &#123;</span><br><span class="line">&gt;   hello: () =&gt; void</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; declare let a: Indexed</span><br><span class="line">&gt; declare let b: Foo</span><br><span class="line">&gt;</span><br><span class="line">&gt; a = b // 🚨 Index signature for type &apos;string&apos; is missing in type &apos;Foo&apos;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>如果使用 <code>type</code> 创建类型就可以:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; type Bar = &#123;</span><br><span class="line">&gt;   hello: () =&gt; void</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; declare let c: Bar</span><br><span class="line">&gt; a = c // it&apos;s work</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>笔者推测，应该<strong>是 interface 允许 <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces" target="_blank" rel="noopener">合并</a>，不是静态的，因此不能安全地满足 Index Signature 的约束</strong>。</p><p>了解更多：</p><p><a href="https://stackoverflow.com/questions/60697214/how-to-fix-index-signature-is-missing-in-type-error" target="_blank" rel="noopener">How to fix “Index signature is missing in type” error?</a></p></blockquote><p> <br><br> <br></p></li><li><p><strong>函数形式</strong></p><p>Vue 3.3 的 <code>defineComponent</code> 新增了一种<a href="https://cn.vuejs.org/api/general.html#definecomponent" target="_blank" rel="noopener">函数签名形式</a>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Comp = defineComponent(</span><br><span class="line">  &lt;T extends string | number&gt;(props: &#123; msg: T; list: T[] &#125;) =&gt; &#123;</span><br><span class="line">    // 就像在 &lt;script setup&gt; 中一样使用组合式 API</span><br><span class="line">    const count = ref(0)</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      // 渲染函数或 JSX</span><br><span class="line">      return &lt;div&gt;&#123;count.value&#125;&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 去掉注释，泛型会失效</span><br><span class="line">  // 目前仍然需要手动声明运行时的 props</span><br><span class="line">  // &#123;</span><br><span class="line">  //  props: [&apos;msg&apos;, &apos;list&apos;]</span><br><span class="line">  /// &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>尴尬的是，Vue 组件必须显式定义 props 参数，不然会被当做 attrs 处理。所以，当你将上面的<strong>props 参数注释去掉时，泛型就会失效了 😀</strong> 。</p><p>另外一件尴尬的事情是，截止目前为止，用上面语法创建的组件，在 Volar 上并不能得到很好的支持(只能正确推断 props)。</p><p><br></p><p>但使用 <a href="https://cn.vuejs.org/api/sfc-script-setup.html#generics" target="_blank" rel="noopener">SFC 泛型语法</a> 则会表现好一点。SFC 有什么特殊？</p><p>我使用 vue-tsc 将组件编译了一下，大概结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare const _default: &lt;T&gt;(</span><br><span class="line">  // 🔴 props 类型</span><br><span class="line">  __VLS_props: &#123;</span><br><span class="line">    list: T[]</span><br><span class="line">    filter: (item: T) =&gt; boolean</span><br><span class="line">  &#125; &amp; VNodeProps &amp;</span><br><span class="line">    AllowedComponentProps &amp;</span><br><span class="line">    ComponentCustomProps,</span><br><span class="line"></span><br><span class="line">  // 🔴 context 类型</span><br><span class="line">  __VLS_ctx?:</span><br><span class="line">    | Pick&lt;</span><br><span class="line">        &#123;</span><br><span class="line">          props: &#123;</span><br><span class="line">            list: T[]</span><br><span class="line">            filter: (item: T) =&gt; boolean</span><br><span class="line">          &#125;</span><br><span class="line">          expose(exposed: &#123; data: Ref&lt;T[] | null | undefined&gt; &#125;): void</span><br><span class="line">          attrs: any</span><br><span class="line">          slots: &#123;</span><br><span class="line">            foo: (scope: &#123; list: T[] &#125;) =&gt; any</span><br><span class="line">          &#125;</span><br><span class="line">          emit: &#123;</span><br><span class="line">            change: [T[]]</span><br><span class="line">            foo: [T, number]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;attrs&apos; | &apos;emit&apos; | &apos;slots&apos;</span><br><span class="line">      &gt;</span><br><span class="line">    | undefined</span><br><span class="line">) =&gt; // 🔴 返回值</span><br><span class="line">VNode &amp; &#123;</span><br><span class="line">  __ctx?:</span><br><span class="line">    | &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">          list: T[]</span><br><span class="line">          filter: (item: T) =&gt; boolean</span><br><span class="line">        &#125;</span><br><span class="line">        expose(exposed: &#123; data: Ref&lt;T[] | null | undefined&gt; &#125;): void</span><br><span class="line">        attrs: any</span><br><span class="line">        slots: &#123;</span><br><span class="line">          foo: (scope: &#123; list: T[] &#125;) =&gt; any</span><br><span class="line">        &#125;</span><br><span class="line">        emit: &#123;</span><br><span class="line">          change: [T[]]</span><br><span class="line">          foo: [T, number]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    | undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SFC 的编译结果多出了 <code>__ctx</code> 字段，实际上 Volar 就是从 __ctx 中提取了相关类型。</p><aside><br>💡 __ctx 应该是 volar 的内部实现细节，不排除后面会变动<br><br></aside><p>那我们现在就模仿它，重构一下 <code>declareComponent</code> 的签名:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface DefineComponentContext&lt;</span><br><span class="line">  Emit extends ObjectEmitsOptions = &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Slots extends &#123; [key: string]: Function &#125; = &#123;&#125;,</span><br><span class="line">  Attrs extends &#123;&#125; = &#123;&#125;</span><br><span class="line">&gt; &#123;</span><br><span class="line">  attrs: Attrs</span><br><span class="line">  slots: Slots</span><br><span class="line">  emit: EmitFn&lt;Emit&gt;</span><br><span class="line">  expose: ExposeFn&lt;Expose&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function declareComponent&lt;</span><br><span class="line">  Props extends &#123;&#125;,</span><br><span class="line">  Emit extends ObjectEmitsOptions = &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Slots extends &#123; [key: string]: Function &#125; = &#123;&#125;,</span><br><span class="line">  Attrs extends &#123;&#125; = &#123;&#125;</span><br><span class="line">&gt;(</span><br><span class="line">  setup: (</span><br><span class="line">    props: Props,</span><br><span class="line">    ctx: DefineComponentContext&lt;Emit, Expose, Slots, Attrs&gt;</span><br><span class="line">  ) =&gt; Promise&lt;RenderFunction | void&gt; | RenderFunction | void,</span><br><span class="line">  options?: &#123;</span><br><span class="line">    props?: Array&lt;keyof Props&gt; | ComponentObjectPropsOptions&lt;Partial&lt;Props&gt;&gt;</span><br><span class="line">    name?: string</span><br><span class="line">    inheritAttrs?: boolean</span><br><span class="line">    serverPrefetch?(): Promise&lt;any&gt;</span><br><span class="line">  &#125;</span><br><span class="line">): (</span><br><span class="line">  props: PropsType&lt;Props, Emit, Slots, Expose&gt;,</span><br><span class="line">  ctx: DefineComponentContext&lt;Emit, Expose, Slots, Attrs&gt;</span><br><span class="line">) =&gt; VNode &amp; &#123;</span><br><span class="line">  // 🛑</span><br><span class="line">  __ctx: &#123;</span><br><span class="line">    emit: EmitFn&lt;Emit&gt;</span><br><span class="line">    slots: Slots</span><br><span class="line">    expose: ExposeFn&lt;Expose&gt;</span><br><span class="line">    attrs: Attrs</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo&lt;T&gt;(</span><br><span class="line">  props: &#123; list: T[]; filter: (item: T) =&gt; boolean &#125;,</span><br><span class="line">  ctx: DefineComponentContext&lt;</span><br><span class="line">    &#123; change: (list: T[]) =&gt; void; add: (item: T) =&gt; void &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      open: (item: T) =&gt; void</span><br><span class="line">      list: T[]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      foo: (list: T[]) =&gt; any</span><br><span class="line">    &#125;</span><br><span class="line">  &gt;</span><br><span class="line">) &#123;</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    // render</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ⚠️ props 还是要定义</span><br><span class="line">Foo.props = [&apos;list&apos;, &apos;filter&apos;]</span><br><span class="line"></span><br><span class="line">export default declareComponent(Foo)</span><br></pre></td></tr></table></figure><p>目前 Volar 在泛型的支持上还有不少的坑。比如上面的示例中事件处理器的泛型变量会推断为 unknown。让子弹再飞一会吧。</p></li></ol><p><br><br><br><br><br> </p><h3 id="element-adapter"><a href="#element-adapter" class="headerlink" title="element-adapter"></a>element-adapter</h3><p>实现的原理和 vue-demi 类似，在 postinstall 时决定使用哪个版本。项目的结构如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scripts/             <span class="comment"># 和 vue-demi 一样，实现了 postinstall 和切换 CLI</span></span><br><span class="line">  postinstall.mjs</span><br><span class="line">  switch-cli.mjs</span><br><span class="line">src/</span><br><span class="line">  shared/</span><br><span class="line">  v2/                <span class="comment"># element-ui 导出</span></span><br><span class="line">    components/</span><br><span class="line">      Table.js</span><br><span class="line">      Slide.js</span><br><span class="line">      ...</span><br><span class="line">  v3/                <span class="comment"># element-plus 导出</span></span><br><span class="line">    components/</span><br><span class="line">      ...</span><br><span class="line">types/               <span class="comment"># 重新声明组件的类型信息。</span></span><br><span class="line">  alert.d.ts</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p><br> </p><p>大部分组件不需要特殊处理，重新导出就行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> &#123; Button &#125; from <span class="string">'element-ui'</span>;</span><br></pre></td></tr></table></figure><p><br> </p><p>有一些组件参数名称发生了变化，则以 element-plus 为基准做一下调整：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; TimePicker as ElTimePicker &#125; from &apos;element-ui&apos;</span><br><span class="line">import &#123; h &#125; from &apos;@wakeadmin/h&apos;</span><br><span class="line"></span><br><span class="line">import &#123; normalizeDateFormat &#125; from &apos;../../shared/date-format&apos;</span><br><span class="line"></span><br><span class="line">export const TimePicker = &#123;</span><br><span class="line">  functional: true,</span><br><span class="line">  render(_, context) &#123;</span><br><span class="line">    const &#123; format, selectableRange, valueFormat, ...other &#125; = context.props</span><br><span class="line"></span><br><span class="line">    // vue3 pickerOptions 提取到了全局</span><br><span class="line">    other.pickerOptions = &#123;</span><br><span class="line">      ...other.pickerOptions,</span><br><span class="line">      format: format &amp;&amp; normalizeDateFormat(format),</span><br><span class="line">      selectableRange,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (valueFormat) &#123;</span><br><span class="line">      other.valueFormat = normalizeDateFormat(valueFormat)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return h(</span><br><span class="line">      ElTimePicker,</span><br><span class="line">      Object.assign(&#123;&#125;, context.data, &#123; props: other, attrs: undefined &#125;),</span><br><span class="line">      context.slots()</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br> </p><p>另外，我们也会移植一些 element-plus 的新组件，比如 <code>TreeSelect</code>。</p><p>对于 icon 这类差异比较大，我们直接放弃了。可以使用外部图标库或者 SVG 组件库（参考这个<a href="https://github.com/wakeadmin/tools/tree/main/packages/icons" target="_blank" rel="noopener">实现</a>跨版本的 SVG 图标库）。</p><p><br><br><br><br><br> </p><h3 id="router-adapter"><a href="#router-adapter" class="headerlink" title="router-adapter"></a>router-adapter</h3><p>我们的组件库是可能会涉及到路由的订阅和操作。因为 vue-router API 差异并不大，处理起来会简单很多。</p><p>不管是 vue 2 还是 3，vue-router 都会在组件实例上挂载相关的 API, 我们直接获取就行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface RouteLike &#123;</span><br><span class="line">  query: Record&lt;string, any&gt;</span><br><span class="line">  params: Record&lt;string, any&gt;</span><br><span class="line">  hash: string</span><br><span class="line">  path: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export type RouteLocation =</span><br><span class="line">  | string</span><br><span class="line">  | &#123;</span><br><span class="line">      query?: Record&lt;string, any&gt;</span><br><span class="line">      hash?: string</span><br><span class="line">      path?: string</span><br><span class="line">      name?: string</span><br><span class="line">      params?: Record&lt;string, any&gt;</span><br><span class="line">      replace?: boolean</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">export interface RouterLike &#123;</span><br><span class="line">  push(to: RouteLocation): Promise&lt;any&gt;</span><br><span class="line">  replace(to: RouteLocation): Promise&lt;any&gt;</span><br><span class="line">  back(): void</span><br><span class="line">  forward(): void</span><br><span class="line">  go(delta: number): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function useRouter() &#123;</span><br><span class="line">  const instance = getCurrentInstance()</span><br><span class="line"></span><br><span class="line">  if (isVue2) &#123;</span><br><span class="line">    return (instance?.proxy?.$root as &#123; $router: RouterLike &#125; | undefined)?.$router</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return (instance?.root?.proxy as unknown as &#123; $router: RouterLike &#125;)?.$router</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ... useRoute 同理</span><br></pre></td></tr></table></figure><p><br> </p><p>其他的库可以采取类似的策略。</p><p><br><br><br><br><br> </p><h3 id="🎉-开源-🎉"><a href="#🎉-开源-🎉" class="headerlink" title="🎉 开源 🎉"></a>🎉 开源 🎉</h3><p>借着这篇文章，我们也将相关的<a href="https://github.com/wakeadmin" target="_blank" rel="noopener">程序开源了</a>! 希望能帮助到大家！</p><ul><li><a href="https://github.com/wakeadmin/tools/tree/main/packages/h" target="_blank" rel="noopener">jsx-runtime 实现</a></li><li><a href="https://github.com/wakeadmin/components" target="_blank" rel="noopener">组件库实现</a></li></ul><p>欢迎 Fork Star PR</p><p><br><br><br><br><br> </p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://www.notion.so/Vue-2-3-302cbe0e37794345bbfbd89e32d617db?pvs=21" target="_blank" rel="noopener">Vue 2/3 渲染函数差异以及兼容方案</a></li><li><a href="https://github.com/vuejs/core/pull/7963" target="_blank" rel="noopener">feat(types): <code>defineComponent()</code> with generics support</a></li><li><a href="https://cn.vitejs.dev/config/" target="_blank" rel="noopener">vitejs</a></li><li><a href="https://github.com/vitejs/vite-plugin-vue" target="_blank" rel="noopener">https://github.com/vitejs/vite-plugin-vue</a></li><li><a href="https://github.com/vitejs/vite-plugin-vue2" target="_blank" rel="noopener">https://github.com/vitejs/vite-plugin-vue2</a></li><li><a href="https://github.com/vuejs/babel-plugin-jsx" target="_blank" rel="noopener">https://github.com/vuejs/babel-plugin-jsx</a></li><li><a href="https://github.com/vuejs/jsx-vue2" target="_blank" rel="noopener">https://github.com/vuejs/jsx-vue2</a></li><li><a href="https://github.com/vuejs/language-tools" target="_blank" rel="noopener">https://github.com/vuejs/language-tools</a></li><li><a href="https://github.com/vuejs/vue-loader/" target="_blank" rel="noopener">https://github.com/vuejs/vue-loader/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/component-for-vue2-3/Untitled.jpeg&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;Vue 3 已经&lt;a href=&quot;https://vue-js.com/topic/5f6562
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>现代前端框架的渲染模式</title>
    <link href="https://bobi.ink/2023/06/05/render-patterns/"/>
    <id>https://bobi.ink/2023/06/05/render-patterns/</id>
    <published>2023-06-04T16:00:00.000Z</published>
    <updated>2023-06-05T03:25:04.885Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要参考的内容来源是<a href="https://www.patterns.dev/" target="_blank" rel="noopener">patterns.dev</a>。这个网站收录了许多实用的前端设计模式，大家赶紧收藏起来！</p></blockquote><p><br></p><p>React 发布已经十年了，笔者接触前端差不多也有十年时间了。说实话，如果没有 <a href="https://search.douban.com/book/subject_search?search_text=head+first&amp;cat=1001" target="_blank" rel="noopener">Head First 系列图书</a>，我可能都没有走上编程这条道路。</p><p><br></p><p><img src="/images/render-patterns/Untitled.png" alt="Head first"><br>Head first</p><p><br></p><p>尽管现在看来这系列图书内容可能过时了。</p><p>Head First 系列图书让我知道，原来编程也可以这么通俗易懂的，对于刚接触这个领域的同学来说，从这里可以获得很多信心和成就感。<br>这种风格也一直影响着我，学习和工作、传道授业过程中，我会努力把复杂的事情简化、通俗化，提炼本质。</p><p><br><br><br></p><p>这十年，前端渲染方式一直在演进，我觉得大概可以分为以下三个阶段：</p><p><img src="/images/render-patterns/Untitled%201.png" alt="Untitled"></p><ul><li>传统 SSR: 那时候前端还没有分离，在 JSP、ASP、Ruby on Rails、Django 这些 MVC 框架下，通过模板来渲染页面。jQuery 是这个阶段的主角</li><li>前后端分离：从 Node.js 发布，到目前为止，是前端发展最迅速的 10 年。<br>前后端分离的典型代表是 Angular 和 React、Vue 等框架，我觉得，促进前后端分离的主要原因还是<strong>随着需求的复杂化，分工精细化了</strong>。 前端可以专注于 UI 的设计和交互逻辑。后端只需要提供 API，不需要关心前端的具体实现。</li><li>同构前端：这几年前端框架的发展进入的深水区，随着云原生、容器技术、Serverless、边缘计算等底层技术设施的普及，也让‘前端’生存范围延展到服务端。前端开始寻求 <code>UX</code> 和 <code>DX</code> 的平衡点</li></ul><p><br><br><br><br><br></p><p>通过这篇文章，你就可以知道近些年前端渲染模式的演变。</p><p>废话不多说，直接开始吧。</p><p><br><br><br><br><br></p><h2 id="csr-客户端渲染"><a href="#csr-客户端渲染" class="headerlink" title="CSR - 客户端渲染"></a>CSR - 客户端渲染</h2><p><img src="/images/render-patterns/Untitled%202.png" alt="Untitled"></p><p>这个我们再熟悉不过了， 即前端页面在浏览器中渲染，服务端仅仅是静态资源服务器(比如 nginx)。</p><p>初始的 HTML 文件只是一个空壳，我们需要等待 JavaScript 包加载和执行完毕，才能进行交互，白屏时间比较长。</p><ul><li>优点<ul><li>部署简单</li><li>页面过渡、功能交互友好</li><li>适合复杂交互型应用程序开发</li></ul></li><li>缺点<ul><li><code>SEO</code> 不友好</li><li>白屏时间长</li><li>可能需要复杂的状态管理。时至今日，状态管理方面的轮子还在不停地造</li></ul></li></ul><p><br><br><br><br><br></p><h2 id="ssr-服务端渲染"><a href="#ssr-服务端渲染" class="headerlink" title="SSR - 服务端渲染"></a>SSR - 服务端渲染</h2><p><img src="/images/render-patterns/Untitled%203.png" alt="Untitled"></p><p>为了解决 SEO 和白屏问题，各大框架开始支持在服务端渲染 HTML 字符串。</p><p>SSR 把数据拉取放到了服务端，因为离数据源比较近，数据拉取的速度会快一点。但这也不是完全没有副作用，因为需要在服务端等待数据就绪, <code>TTFB(Time to First Byte)</code> 相比 CSR 会长一点。</p><p>SSR 只是给我们准备好了初始的数据和 HTML, 实际上和 CSR 一样，我们还是需要加载完整的<code>客户端程序</code>，然后在浏览器端重新渲染一遍(更专业的说是 <code>Hydration  水合/注水</code>)，才能让 DOM 有交互能力。</p><p><strong>也就说， <code>FCP(First Contentful Paint)</code> 相比 CSR 提前了, 但是 <code>TTI(Time to Interactive)</code> 并没有太多差别。只是用户可以更快地看到内容了。</strong></p><blockquote><p>hydration 的主要目的是挂载事件处理器、触发副作用等等</p></blockquote><p>优点</p><ul><li>SEO 友好</li><li>用户可以更快看到内容了</li></ul><p>缺点</p><ul><li>部署环境要求。需要 Nodejs 等 JavaScript 服务端运行环境</li><li>需要包含完整的 JavaScript 客户端渲染程序，<code>TTI</code> 还有改善空间</li></ul><p><br><br><br><br><br><br><br></p><h2 id="ssg-静态生成"><a href="#ssg-静态生成" class="headerlink" title="SSG - 静态生成"></a>SSG - 静态生成</h2><p><img src="/images/render-patterns/Untitled%204.png" alt="Untitled"></p><p>对于完全静态的页面，比如博客，公司主页等等，也可以使用 SSG 静态渲染。</p><p>和 SSR 的区别是，SSG 是在<code>构建时</code>渲染的。</p><p>和 CSR 一样，因为是静态的，所以在服务端不需要渲染运行时，部署在静态服务器就行了。</p><p>VuePress、VitePress、Gatsby、Docusaurus 这些框架都属于 SSG 的范畴。</p><p><br><br><br></p><p>优点</p><ul><li>相比 SSR, 因为不需要服务端运行时、数据拉取，TTFB/FCP 等都会提前。</li></ul><p>缺点</p><ul><li>和 SSR 一样，也有客户端渲染程序、需要进行 Hydrate。<br>对于<code>内容为中心</code>的站点来说，实际上并不需要太多交互，客户端程序还有较大压缩的空间。</li><li>在构建时渲染，如果内容变更，需要重新构建，比较麻烦</li></ul><p><br><br><br><br><br><br><br></p><h2 id="isg-增量静态生成"><a href="#isg-增量静态生成" class="headerlink" title="ISG - 增量静态生成"></a>ISG - 增量静态生成</h2><p><img src="/images/render-patterns/Untitled%205.png" alt="Untitled"></p><p>ISG 是 SSG 的升级版。解决 SSG 内容变更繁琐问题。</p><p>ISG 依旧会在构建时预渲染页面，但是这里多出了一个<code>服务端运行时</code>，这个运行时会按照一定的过期/刷新策略(通常会使用 <strong><a href="https://web.dev/stale-while-revalidate/" target="_blank" rel="noopener">stale-while-revalidate</a></strong> )来重新生成页面。</p><p><br><br><br><br><br><br><br></p><h2 id="progressive-hydration-渐进水合"><a href="#progressive-hydration-渐进水合" class="headerlink" title="Progressive Hydration - 渐进水合"></a>Progressive Hydration - 渐进水合</h2><p><img src="/images/render-patterns/Untitled%206.png" alt="Untitled"></p><p>上文提到，常规的 SSR 通常需要完整加载客户端程序(上图的 bundle.js)，水合之后才能得到可交互页面，这就导致 <code>TTI</code> 会偏晚。</p><p>最直接的解决办法就是压缩客户端程序的体积。那么自然会想到使用<code>代码分割</code>(code splitting)技术。<br><code>渐进式水合 （Progressive Hydration ）</code> 就是这么来的。</p><p>如上图，我们使用<code>代码分割</code>的方式，将 Foo、Bar 抽取为<code>异步组件</code>，抽取后<code>主包</code>的体积下降了，<code>TTI</code> 就可以提前了。</p><p>而 Foo、Bar 可以按照一定的策略来按需加载和水合，比如在视口可见时、浏览器空闲时，或者交给 <code>React Concurrent Mode</code> 根据交互的优先级来加载。</p><p>React 18 官方支持了渐进式水合（官方叫 <code>Selective Hydration</code>）。</p><p>要深入了解 Progress Hydration, 可以看这个<a href="https://www.youtube.com/watch?v=k-A2VfuUROg&amp;t=960s" target="_blank" rel="noopener">视频</a>。</p><p><br><br><br><br><br></p><h2 id="ssr-with-streaming-流式-ssr"><a href="#ssr-with-streaming-流式-ssr" class="headerlink" title="SSR with streaming - 流式 SSR"></a>SSR with streaming - 流式 SSR</h2><p><img src="/images/render-patterns/Untitled%207.png" alt="Untitled"></p><p>这个很好理解。尤其是在最近 <code>ChatGPT</code> 这么火。ChatGPT API 有两种响应模式：普通响应、流式响应</p><ul><li><a href="https://react.dev/reference/react-dom/server/renderToString" target="_blank" rel="noopener">renderToString</a> → 普通响应。即 SSR 会等待完整的 HTML 渲染完毕后，才给客户端发送第一个字节。</li><li><a href="https://react.dev/reference/react-dom/server/renderToNodeStream" target="_blank" rel="noopener">renderToNodeStream</a> → 流式响应。渲染多少，就发送多少。就像 ChatGPT 聊天消息一样，一个字一个字的蹦，尽管接收完整消息的时间可能差不多，用户体验却相差甚远。</li></ul><p>浏览器能够很好地处理 HTML 流，快速地将内容呈现给用户，而不是白屏干等。</p><p>下面这张图可以更直观感受两者区别：</p><p><img src="/images/render-patterns/Untitled%208.png" alt="来源：[https://mxstbr.com/thoughts/streaming-ssr/](https://mxstbr.com/thoughts/streaming-ssr/)"></p><p>来源：<a href="https://mxstbr.com/thoughts/streaming-ssr/" target="_blank" rel="noopener">https://mxstbr.com/thoughts/streaming-ssr/</a></p><p>对于常规的流式 SSR，优化效果可能没有我们想象的那么明显。<strong>因为框架还是得等数据拉取完成之后才能开始渲染</strong>。因此，除非是比较复杂、长序列的 HTML 树，至上而下需要较长时间的渲染，否则效果并不明显。</p><p><br><br><br></p><p>优点</p><ul><li>相比普通响应，流式响应可以提前 TTFB 和 FCP, 浏览器不用空转等待，可以连续绘制。</li></ul><p>缺点</p><ul><li><strong>数据拉取是 TTFB/FCP 的主要阻塞原因。为了解决这个问题，下文的 <code>Selective Hydration</code> 如何巧妙地解决这个问题。</strong></li></ul><p><br><br><br><br><br></p><h2 id="selective-hydration-选择性水合"><a href="#selective-hydration-选择性水合" class="headerlink" title="Selective Hydration - 选择性水合"></a>Selective Hydration - 选择性水合</h2><p><img src="/images/render-patterns/Untitled%209.png" alt="Untitled"></p><p><code>选择性水合（Progressive Hydration）</code> 是 <code>渐进式水合(Progressive Hydration)</code> 和 <code>流式SSR(SSR with Streaming)</code> 的升级版。<strong>主要通过选择性地跳过‘<code>慢组件</code>’，避免阻塞，来实现更快的 HTML 输出， 从而让流式响应发挥应有的作用。</strong></p><blockquote><p><code>慢组件</code>通常指的是：需要异步获取数据、体积较大、或者是计算量比较复杂的组件。</p></blockquote><p>比较典型的<code>慢组件</code>是异步数据获取的组件, 如下图，未开启 Selective Hydration 的情况，会等待所有异步任务完成后才开始输出，而 Selective Hydration 可以跳过这些组件，等待它们就绪后，继续输出。</p><p><img src="/images/render-patterns/Untitled%2010.png" alt="Untitled"></p><p>我们可以在最新的 Next.js(当前是 13.4) 演示一下。</p><details><br> <summary>没有开启 Selective Hydration 的 Demo:</summary><br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function delay(time: number) &#123;</span><br><span class="line">  return new Promise((resolve) =&gt; setTimeout(resolve, time))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取关键数据</span><br><span class="line"> */</span><br><span class="line">function getCrucialData() &#123;</span><br><span class="line">  return delay(1000).then(() =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      data: Math.random(),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getData(time: number) &#123;</span><br><span class="line">  return delay(time).then(() =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      data: Math.random(),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Foo = async () =&gt; &#123;</span><br><span class="line">  const data = await getData(1000)</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;foo: &#123;data.data&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Bar = async () =&gt; &#123;</span><br><span class="line">  const data = await getData(2000)</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;bar: &#123;data.data&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 页面 🔴</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">export default async function WithoutSelective() &#123;</span><br><span class="line">  // 获取关键数据</span><br><span class="line">  const crucialData = await getCrucialData()</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Without Selective&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;This page is rendered without Selective Hydration.&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;crucial data: &#123;crucialData.data&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Foo&gt;&lt;/Foo&gt;</span><br><span class="line">      &lt;Bar&gt;&lt;/Bar&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>运行结果：浏览器等待响应的时间为 3s<br><img src="/images/render-patterns/Untitled%2011.png" alt="Untitled"><br>即所有<code>服务端组件（Server Component）</code> 就绪后才会有实际的内容输出。<br><br></details><p><br><br><br></p><p>开启 Selective Hydration 很简单，我们只需要用 Suspend 包裹起来，提示 React 这可能是一个‘慢组件’，可以跳过他：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default async function WithoutSelective() &#123;</span><br><span class="line">  // 获取关键数据</span><br><span class="line">  const crucialData = await getCrucialData()</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Without Selective&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;This page is rendered without Selective Hydration.&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;crucial data: &#123;crucialData.data&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Suspense fallback=&quot;foo loading&quot;&gt;</span><br><span class="line">        &lt;Foo&gt;&lt;/Foo&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">      &lt;Suspense fallback=&quot;bar loading&quot;&gt;</span><br><span class="line">        &lt;Bar&gt;&lt;/Bar&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>现在来看运行结果：</p><p><img src="/images/render-patterns/Untitled%2012.png" alt="Untitled"></p><p>明显 TTFB 提前了！但是完整的请求时间没变。</p><p><br></p><p>当 Foo 和 Bar 就绪后，Next.js 会将渲染结果写入流中。怎么做到的？</p><p><br></p><p>看一眼 HTML 就知道了：</p><p><img src="/images/render-patterns/Untitled%2013.png" alt="Untitled"></p><p>对于<code>慢组件</code>，React 会先渲染 Suspend 的 fallback 内容，并留一个插槽。</p><p>继续往下看，可以看到 Foo、Bar 的渲染结果：</p><p><img src="/images/render-patterns/Untitled%2014.png" alt="Untitled"></p><p>接着将渲染结果替换掉插槽。用于后续的水合。</p><p><br><br><br><br><br></p><p>总之，在服务端，Selective Hydration 在 SSR With Streaming 的基础上，通过选择性地跳过一些低优先级的慢组件来优化了 TTFB(主要的，相对于 FCP 等指标也优化了)，更快地向用户呈现页面。</p><p>在客户端 Selective Hydration 的运行过程同 Progressive Hydration 。</p><p>关于 Selective Hydration 细节，可以阅读以下文章：</p><ul><li><a href="https://github.com/reactwg/react-18/discussions/130" target="_blank" rel="noopener">New in 18: Selective Hydration</a></li><li><a href="https://github.com/reactwg/react-18/discussions/37" target="_blank" rel="noopener">New Suspense SSR Architecture in React 18</a></li></ul><p><br><br><br><br><br><br><br></p><h2 id="islands-architecture-岛屿架构"><a href="#islands-architecture-岛屿架构" class="headerlink" title="Islands Architecture - 岛屿架构"></a>Islands Architecture - 岛屿架构</h2><p><img src="/images/render-patterns/Untitled%2015.png" alt="Untitled"></p><p>近两年，<strong>去 JavaScript 成为一波小趋势</strong>，这其中的典型代表是 <code>Islands Architecture</code> (岛屿架构)和 <code>React Server Component</code>(RSC, React 服务端组件)。</p><p>它们主张是：<strong>在服务端渲染，然后去掉不必要 JavaScript</strong></p><p>岛屿架构的主要代表是 <code>Astro</code>。如上图，Astro 在服务端渲染后，<strong>默认情况下，在客户端侧没有客户端程序和水合的过程。而对于需要 JavaScript 增强，实现动态交互的组件，需要显式标记为岛屿。</strong></p><p><br></p><p>这有点类似 Progressive Hydration 的意思。但是还是有很大的差别：</p><ul><li>岛屿是在<code>去 JavaScript</code> 这个背景下的交互增强手段。按 Astro 解释是： 你可以将‘岛屿’想象成在一片由<em>静态（不可交互）的 HTML</em> 页面中的<em>动态岛屿</em></li><li>每个岛屿都是独立加载、局部水合。而 Progressive Hydration 是整棵树水合的分支，只不过延后了。</li><li>岛屿可以框架无关。</li></ul><p><br></p><p>去 JavaScript 后，可以缓解典型的 SSR <code>TTI</code> 问题。<strong>但是岛屿架构并不能通吃所有的场景，最擅长的是”内容为中心“的站点，即当静态的页面比重远高于动态比重时，去 JavaScript 的收益才是显著的。</strong></p><p><br><br><br><br><br></p><h2 id="react-server-component-react-服务端组件"><a href="#react-server-component-react-服务端组件" class="headerlink" title="React Server Component - React 服务端组件"></a>React Server Component - React 服务端组件</h2><p><img src="/images/render-patterns/Untitled%2016.png" alt="Untitled"></p><p>在笔者看来，<code>React Server Component(RSC)</code> 本质上和岛屿架构的目的是一样的，都是去 JavaScript。只是实现的手段不同。</p><p><br></p><p>这是 Next.js 官方文档的示例图：和岛屿架构类似，对于静态的内容推荐使用 <code>Server Component (SC),</code> 而需要交互增强的，可以使用 <code>Client Component (CC)</code>。</p><p><img src="/images/render-patterns/Untitled%2017.png" alt="Untitled"></p><p><br></p><p>顾名思义，RSC <strong>就是只能在服务端运行的组件</strong>。下面简单对比一下两者的区别：</p><table><thead><tr><th></th><th>Server Component</th><th>Client Component</th></tr></thead><tbody><tr><td>运行环境</td><td>服务端</td><td>- 服务端 + 客户端</td></tr><tr><td>- 仅客户端</td></tr><tr><td>JavaScript</td><td>服务端组件依赖的相关程序对客户端不可见。</td></tr><tr><td>在这里实现了 ‘去 JavaScript’</td><td>需要打包分发给客户端</td></tr><tr><td>水合</td><td>不需要水合</td><td>需要水合</td></tr><tr><td>支持 async</td><td>Y</td><td>N</td></tr><tr><td>支持状态(state, context)</td><td>N</td><td>Y</td></tr><tr><td>支持事件、副作用</td><td>N</td><td>Y</td></tr></tbody></table><blockquote><p>RSC 优点类似 React Hooks 出来之前的<a href="https://web.archive.org/web/20170621181013/https://facebook.github.io/react/docs/components-and-props.html" target="_blank" rel="noopener">函数组件</a>: 就是一个普通的函数，不能使用 hooks，没有状态，只会被调用一次。</p></blockquote><p>你可以通过 <a href="https://nextjs.org/docs/getting-started/react-essentials" target="_blank" rel="noopener">Next.js 的文档</a>，深入学习 RSC。React 官方的<a href="https://github.com/reactwg/server-components/discussions" target="_blank" rel="noopener">讨论组</a>也是不错的一手学习场地。</p><p><br><br><br></p><p><strong>那么相比岛屿架构呢？</strong></p><p>优点</p><ul><li>Server Component 和 Client Component 都是 React 框架的组件，尽管有些区别，但是心智模型是统一的。</li><li>React Server Component 是 React 框架下一体化的原生解决方案，支持和 Selective Hydration 配合使用。岛屿架构只是一个架构模式。</li><li>可以进行更细粒度和更灵活的组合。</li></ul><p>缺点</p><ul><li>Server Component 和 Client Component 还是有较大差别，在组合、通信上也有较多限制，需要开发者规划好服务端和客户端的边界。初期有一定上手门槛。<br>当然，Islands 可能也有类似的问题。</li></ul><p><br><br><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文篇幅较长，我给大家整理了这些渲染模式的发展历程和关系脉络</p><p><img src="/images/render-patterns/Untitled%2018.png" alt="Untitled"></p><p>任何技术的迭代都是有其动机和脉络。不推荐大家面向热度编程，大部分情况下，做到‘知其然，也知其所以然’，就足够了。</p><p><br><br><br><br><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://www.patterns.dev/posts/react-selective-hydration" target="_blank" rel="noopener">Pattern dev</a></li><li><a href="https://nextjs.org/docs/getting-started/react-essentials" target="_blank" rel="noopener">Next.js</a></li><li><a href="https://nextjs.org/docs/pages/building-your-application/data-fetching/incremental-static-regeneration" target="_blank" rel="noopener">Next.js Incremental Static RegenerationExamples</a></li><li><a href="https://github.com/reactwg/server-components/discussions" target="_blank" rel="noopener">reactwg/<strong>server-components</strong></a></li><li><strong><a href="https://dev.to/this-is-learning/is-0kb-of-javascript-in-your-future-48og" target="_blank" rel="noopener">Is 0kb of JavaScript in your Future?</a></strong></li><li><a href="https://jasonformat.com/islands-architecture/" target="_blank" rel="noopener">Islands Architecture</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文主要参考的内容来源是&lt;a href=&quot;https://www.patterns.dev/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;patterns.dev&lt;/a&gt;。这个网站收录了许多实用的前端设计模式，大家赶紧收藏起来！
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>岛屿架构</title>
    <link href="https://bobi.ink/2023/06/01/island-pattern/"/>
    <id>https://bobi.ink/2023/06/01/island-pattern/</id>
    <published>2023-05-31T16:00:00.000Z</published>
    <updated>2023-06-01T10:07:58.113Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1516091877740-fde016699f2c?ixlib=rb-4.0.3&amp;q=85&amp;fm=jpg&amp;crop=entropy&amp;cs=srgb&amp;w=6000" alt="https://images.unsplash.com/photo-1516091877740-fde016699f2c?ixlib=rb-4.0.3&amp;q=85&amp;fm=jpg&amp;crop=entropy&amp;cs=srgb&amp;w=6000"></p><p>好久没跟大家见面了。这两三年一直专注于公司的开发工作，做了很多事情，但回头看看，感觉这两年一直在吃 ’老本‘，前端相关的技术也没怎么追了。</p><p>现在重新捡起笔吧！补补课，记录一些最近学到的新东西，以及过去几年总结。</p><p>首先从岛屿架构开始吧。</p><h2 id="岛屿架构"><a href="#岛屿架构" class="headerlink" title="岛屿架构"></a>岛屿架构</h2><p>岛屿架构(<a href="https://www.patterns.dev/posts/islands-architecture" target="_blank" rel="noopener">Islands Architecture</a>) 如今已经不是新鲜的概念了，社区上已经有了较多成熟的方案。</p><p>概览图：</p><p><img src="/images/island-pattern/Untitled.png" alt="Untitled"></p><p><br><br><br><br><br></p><p>这其中的典型代表是 <a href="https://docs.astro.build/zh-cn/concepts/islands/" target="_blank" rel="noopener">Astro</a>。Astro 对岛屿架构的解释，也非常直观：</p><blockquote><p>“Astro 群岛“指的是<code>静态 HTML</code> 中的<code>交互性的 UI 组件</code>。一个页面上可以有多个岛屿，并且每个岛屿都被<code>独立呈现</code>。<strong>你可以将它们想象成在一片由静态（不可交互）的 HTML 页面中的动态岛屿</strong>。</p></blockquote><p>从上面这句话的定义中可以提炼一些要点：</p><ul><li>静态 HTML。</li><li>交互性的 UI 组件。</li><li>多个岛屿，支持独立呈现。</li></ul><p><br><br><br></p><p>为了解析这些要点，我们还是得简单了解一下 Astro 这个框架的特性。</p><p>Astro 宣称自己是 ‘<strong><code>zero-JS frontend architecture</code></strong>’，即 Astro 在服务端渲染静态 HTML，客户端中不需要加载额外的 JS 就能完整呈现内容。</p><p><br><br><br><br><br><br><br></p><hr><p>写一个简单 DEMO 试试：</p><p>React 组件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; useState &#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">export const Counter = () =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0)</span><br><span class="line"></span><br><span class="line">  return &lt;div onClick=&#123;() =&gt; setCount((i) =&gt; i + 1)&#125;&gt;click me to increment: &#123;count&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Astro 文件：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">import Layout from '../layouts/Layout.astro';</span><br><span class="line">import Card from '../components/Card.astro';</span><br><span class="line">import &#123; Counter &#125; from '../components/Counter';</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Layout</span> <span class="attr">title</span>=<span class="string">"Welcome to Astro."</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">role</span>=<span class="string">"list"</span> <span class="attr">class</span>=<span class="string">"link-card-grid"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Card</span></span></span><br><span class="line"><span class="tag">        <span class="attr">href</span>=<span class="string">"https://docs.astro.build/"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">title</span>=<span class="string">"Documentation"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">body</span>=<span class="string">"Learn how Astro works and explore the official API docs."</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Card</span></span></span><br><span class="line"><span class="tag">        <span class="attr">href</span>=<span class="string">"https://astro.build/integrations/"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">title</span>=<span class="string">"Integrations"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">body</span>=<span class="string">"Supercharge your project with new frameworks and libraries."</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  ...;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这语法，astro 集大家之所长，吸取了 Vue SFC 和 React 的 JSX, 还有 MDX。</p><p><img src="/images/island-pattern/Untitled%201.png" alt="Untitled"></p><p>运行后， 服务端直出 HTML，除了 HMR ，没有引入额外的 JavaScript。真 Zero JS!</p><p><br><br><br><br><br></p><hr><p>然而，这个有别于典型的 SSR 框架。SSR 也是在服务端渲染完整 HTML 树，但是在客户端依然需要加载完整的视图框架代码，然后进行水合(Hydration)，才能让页面变得可交互:</p><p><img src="/images/island-pattern/Untitled%202.png" alt="Untitled"></p><p>那 Astro 没有 JS，显然是无法与用户进行动态交互的。Astro 的解决办法就是 <code>岛屿架构</code>, 我们只需将需要动态交互的页面模块声明为岛屿，如下图，页头和图片轮播就是可交互的岛屿。</p><p><img src="/images/island-pattern/Untitled%203.png" width="400px"></p><p>来源：astro 文档</p><p><br><br><br><br><br><br><br></p><hr><p>现在将 React 组件声明为岛屿：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">---</span></span><br><span class="line">import Layout from '../layouts/Layout.astro';</span><br><span class="line">import Card from '../components/Card.astro';</span><br><span class="line">import &#123; Counter &#125; from '../components/Counter';</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"></span><br><span class="line">&lt;Layout title="Welcome to Astro."&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line"><span class="deletion">-    &lt;Counter/&gt;</span></span><br><span class="line"><span class="addition">+    &lt;Counter client:load /&gt;</span></span><br><span class="line">    &lt;ul role="list" class="link-card-grid"&gt;</span><br><span class="line">      &lt;Card</span><br><span class="line">        href="https://docs.astro.build/"</span><br><span class="line">        title="Documentation"</span><br><span class="line">        body="Learn how Astro works and explore the official API docs."</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Card</span><br><span class="line">        href="https://astro.build/integrations/"</span><br><span class="line">        title="Integrations"</span><br><span class="line">        body="Supercharge your project with new frameworks and libraries."</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">&lt;/Layout&gt;</span><br></pre></td></tr></table></figure><p>我们只需将对应的 React 组件加上 <code>client:load</code> 指令，Astro 就是将其识别为岛屿，该 React 组件的代码及其相关依赖会被打包到一起，在客户端端加载和水合。</p><p><img src="/images/island-pattern/Untitled%204.png" alt="Untitled"></p><p>现在我们的 Counter 组件在客户端就是一个可交互的状态了。Astro 基本上没有什么上手门槛，建议读者自己玩一下。有机会再展开讲一下它的实现原理。</p><hr><p><br><br><br><br><br></p><p>有了‘岛屿’赋能的 Astro 架构：</p><p><img src="/images/island-pattern/Untitled%205.png" alt="Untitled"></p><p>Astro 在服务端渲染完整的 HTML 树，然后在客户端中按需加载岛屿代码，并进行水合。看起来有点像微前端、或者 iframe 这样的机制。</p><p>现在来回顾一下开头提到的 <code>‘要点’</code>：</p><table><thead><tr><th></th><th>岛屿架构</th><th>SSR + CSR</th><th>CSR</th></tr></thead><tbody><tr><td>静态 HTML</td><td>静态 HTML 优先，无 JavaScript</td><td>服务端渲染 HTML 初始内容, 包含完整的客户端副本</td><td>完全在客户端加载渲染</td></tr><tr><td>交互性的 UI 组件</td><td>默认完全静态，通过岛屿局部增强可交互性</td><td>全局可交互</td><td>全局可交互</td></tr><tr><td>多个岛屿，支持独立呈现</td><td>岛屿之间互相独立，可以独立加载和交互</td><td>完整加载。可以通过代码分块 + <a href="https://www.patterns.dev/posts/progressive-hydration" target="_blank" rel="noopener">https://www.patterns.dev/posts/progressive-hydration</a> 实现按需加载</td><td>完整加载。可以通过代码分块实现按需加载</td></tr></tbody></table><p><br><br><br><br><br></p><h2 id="岛屿架构的优势"><a href="#岛屿架构的优势" class="headerlink" title="岛屿架构的优势"></a>岛屿架构的优势</h2><p>岛屿架构非常适合<code>以内容为中心</code>的网站，比如博客，文档网站，新闻网站等等。在 Astro 的定位非常清晰，它把站点类型分为两种：</p><ul><li>内容为中心 → 也称为 网站 → Astro 擅长</li><li>交互为中心的 → 也称为 Web 应用程序 → 应该使用 Next.js 或者 Nuxt.js 这样的框架</li></ul><p>在岛屿架构擅长的场景中，Astro 给出了比较：</p><ul><li><a href="https://twitter.com/t3dotgg/status/1437195415439360003" target="_blank" rel="noopener">Astro vs. SPA (Next.js)</a> - 94% less JavaScript</li><li><a href="https://twitter.com/jlengstorf/status/1442707241627385860?lang=en" target="_blank" rel="noopener">Astro vs. SPA (Next.js)</a> - 34% 更快地加载</li><li><a href="https://vanntile.com/blog/next-to-astro" target="_blank" rel="noopener">Astro vs. SPA (Next.js)</a> – 65% 网络使用减少</li><li><a href="https://www.youtube.com/watch?v=2ZEMb_H-LYE&amp;t=8163s" target="_blank" rel="noopener">Astro vs. SPA (Remix, SvelteKit)</a> - “这令人置信的 Google Lighthouse 分数”</li><li><a href="https://www.youtube.com/watch?v=2ZEMb_H-LYE&amp;t=8504s" target="_blank" rel="noopener">Astro vs. Qwik</a> - 43% 更快的 TTI</li></ul><p><br><br><br><br><br></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>岛屿架构本身概念并不复杂，是前端框架和工程化发展的一个阶段性质变结果。</p><p>前后端分离(分工上)还是不变的趋势，相比传统的 MPA ，岛屿架构更加现代化，拥有更好的开发体验。</p><p>相比 SPA，岛屿架构在<code>以内容为中心</code>的场景下，优势也非常明显。</p><p><br><br><br><br><br></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.patterns.dev/posts/islands-architecture" target="_blank" rel="noopener">Islands Architecture</a></li><li><a href="https://jasonformat.com/islands-architecture/" target="_blank" rel="noopener">Islands Architecture</a></li><li><a href="https://www.youtube.com/watch?v=k-A2VfuUROg" target="_blank" rel="noopener">Rendering on the Web: Performance Implications of Application Architecture</a></li><li><a href="https://dev.to/this-is-learning/is-0kb-of-javascript-in-your-future-48og" target="_blank" rel="noopener">Is 0kb of JavaScript in your Future?</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1516091877740-fde016699f2c?ixlib=rb-4.0.3&amp;amp;q=85&amp;amp;fm=jpg&amp;amp;crop=entropy&amp;amp;cs=srgb&amp;am
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Electron 低延迟视频流播放方案探索</title>
    <link href="https://bobi.ink/2020/04/05/video-stream/"/>
    <id>https://bobi.ink/2020/04/05/video-stream/</id>
    <published>2020-04-04T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.331Z</updated>
    
    <content type="html"><![CDATA[<p>好久不见，接近四个月没更新博客了! </p><p>去年<a href="https://juejin.im/post/5e0010866fb9a015fd69c645#comment" target="_blank" rel="noopener">最后一篇</a>文章介绍了我们的 Electron 桌面客户端的一些优化措施，这篇文章也跟我们正在开发的 Electron 客户端有一定关系。最近我们正在预研在 Electron 页面中实时播放会议视频流的方案。</p><p><br></p><p><img src="/images/video-push/conf.jpeg" alt></p><p><br></p><p>视频会议界面是最后一块没有被 Web 取代的页面, 它完全用原生开发的，所以开发效率比较低，比如要做一些动画效果开发很痛苦，难以响应多变的产品需求。所以我们在想: <strong>能不能将 Web 页面端来播放底层库 WebRTC 接收到的视频流</strong>? <strong>或者为什么不直接通过浏览器的 WebRTC API 来进行通讯呢</strong>？</p><p>先回答后者，因为我们视频会议这块的逻辑处理、音视频处理已经被抽取成独立的、跨平台的模块，统一进行维护；另外浏览器的 WebRTC API 提供的接口非常高级，就像一个黑盒一样，无法定制化、扩展，遇到问题也很难诊断和处理, 受限于浏览器。最大的原因还是变动有点大，时间上不允许。</p><p>因此目前只能选前者，即底层库给 Electron 页面推送视频流，在页面实时播放。 再此之前，笔者几乎没有接触过音视频开发，我能想到的是通过类似直播的方式，底层库作为”主播端”, Web 页面作为”观众端”。</p><p><img src="/images/video-push/overall.png" alt></p><p><br></p><p>因为视频流只是在本地进行转发，所以我们不需要考虑各种复杂的网络情况、带宽限制。唯一的要求是低延迟，低资源消耗：</p><ul><li>我们视频会议语音和视频是分离的。 只有一路混合语音，通过 SIP 传输。而会议视频则可能存在多路，使用 WebRTC 进行传输。我们不需要处理语音(由底层库直接播放), 这就要求我们的视频播放延迟不能太高, 出现语音和视频不同步。</li><li>不需要考虑浏览器兼容性。Electron 浏览器版本为 Chrome 80</li><li>本地转发，不需要考虑网络情况、带宽限制</li></ul><p><br><br><br></p><p><strong>最近因为工作需要才有机会接触到音视频相关的知识，我知道的只是皮毛，所以文章肯定存在不少问题，敬请斧正</strong>。下面，跟着音视频小白的我，一起探索探索有哪些方案。</p><p><br><br><br></p><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#①-典型的web直播方案">① 典型的Web直播方案</a><ul><li><a href="#rtmp-推流">RTMP 推流</a></li><li><a href="#rtmp-拉流">RTMP 拉流</a></li><li><a href="#rtmp-低延迟优化">RTMP 低延迟优化</a></li></ul></li><li><a href="#②-jsmpeg--broadwayjs">② JSMpeg &amp; BroadwayJS</a><ul><li><a href="#relay-服务器">Relay 服务器</a></li><li><a href="#推送">推送</a></li><li><a href="#视频播放">视频播放</a></li><li><a href="#多进程优化">多进程优化</a></li><li><a href="#简单说一下-broadwayjs">简单说一下 Broadway.js</a></li></ul></li><li><a href="#③-直接渲染-yuv">③ 直接渲染 YUV</a></li><li><a href="#扩展阅读">扩展阅读</a></li></ul><!-- /TOC --><p><br><br><br></p><h2 id="①-典型的web直播方案"><a href="#①-典型的web直播方案" class="headerlink" title="① 典型的Web直播方案"></a>① 典型的Web直播方案</h2><p>Web 直播有很多方案(参考这篇文章：<a href="https://imweb.io/topic/5a542e43a192c3b460fce3a8" target="_blank" rel="noopener">《Web 直播，你需要先知道这些》</a>):</p><ul><li><strong>RTMP (Real Time Messaging Protocol)</strong> 属于 Adobe。延时低，实时性较好。不过浏览器需要借助 Flash 才能播放; 但是我们也可以转换成 HTTP/Websocket 流喂给 <a href="https://github.com/bilibili/flv.js/tree/master/docs" target="_blank" rel="noopener"><code>flv.js</code></a> 实现播放。</li><li><strong>RTP (Real-time Transport Protocol)</strong> <a href="https://www.jianshu.com/p/17997567d828" target="_blank" rel="noopener">WebRTC 底层就基于 RTP/RTCP</a>。实时性非常好，适用于视频监控、视频会议、IP 电话。</li><li><strong>HLS (Http Live Streaming)</strong> 苹果提出的基于 HTTP 的流媒体传输协议。Safari 支持较好，高版本 Chrome 也支持，也有一些比较成熟的第三方方案。</li></ul><p><br></p><p>HLS 延迟太高，不符合我们的要求，所以一开始就放弃了。搜了很多资料，很多都是介绍 RTMP 的，可见 RTMP 在国内采用有多广泛, 因此我们打算试试:</p><p><br></p><p>首先是搭建 RMTP 服务器，可以直接基于 <a href="https://github.com/illuspas/Node-Media-Server" target="_blank" rel="noopener">Node-Media-Server</a>，代码很简单:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NodeMediaServer = <span class="built_in">require</span>(<span class="string">'node-media-server'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// RMTP 服务器, 用于RTMP 推流和拉流</span></span><br><span class="line">  rtmp: &#123;</span><br><span class="line">    port: <span class="number">1935</span>, <span class="comment">// 1935 是RTMP的标准端口</span></span><br><span class="line">    chunk_size: <span class="number">0</span>,</span><br><span class="line">    gop_cache: <span class="literal">false</span>,</span><br><span class="line">    ping: <span class="number">30</span>,</span><br><span class="line">    ping_timeout: <span class="number">60</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// HTTP / WebSocket 流，暴露给 flv.js</span></span><br><span class="line">  http: &#123;</span><br><span class="line">    port: <span class="number">8000</span>,</span><br><span class="line">    allow_origin: <span class="string">'*'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nms = <span class="keyword">new</span> NodeMediaServer(config)</span><br><span class="line">nms.run()</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="rtmp-推流"><a href="#rtmp-推流" class="headerlink" title="RTMP 推流"></a>RTMP 推流</h3><p><a href="http://www.ffmpeg.org" target="_blank" rel="noopener"><code>ffmpeg</code></a> 是音视频开发的必备神器，本文将通过它来捕获摄像头，进行各种转换和处理，最后进行视频流推送。 下面看看怎么用 ffmpeg 进行 RTMP 推流。</p><p>首先进行视频采集，下面命令列举所有支持的设备类型：</p><blockquote><p>本文的所有命令都在 macOS 下面执行, 其他平台用法差不多，自行搜索</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -devices</span></span><br><span class="line">Devices:</span><br><span class="line"> D. = Demuxing supported</span><br><span class="line"> .E = Muxing supported</span><br><span class="line"> --</span><br><span class="line"> D  avfoundation    AVFoundation input device</span><br><span class="line"> D  lavfi           Libavfilter virtual input device</span><br><span class="line">  E sdl,sdl2        SDL2 output device</span><br></pre></td></tr></table></figure><p><br></p><p><code>macOS</code> 下通常使用 <code>avfoundation</code> 进行设备采集, 下面列举当前终端所有支持的输入设备:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> fmpeg -f avfoundation -list_devices <span class="literal">true</span> -i <span class="string">""</span></span></span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] AVFoundation video devices:</span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] [0] FaceTime HD Camera</span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] [1] Capture screen 0</span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] AVFoundation audio devices:</span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] [0] Built-in Microphone</span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] [1] Boom2Device</span><br></pre></td></tr></table></figure><p><br></p><p>我们将使用 <code>FaceTime HD Camera</code> 这个输入设备来采集视频，并推送 RTMP 流：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -r 30 -i <span class="string">"FaceTime HD Camera"</span> -c:v libx264 -preset superfast -tune zerolatency -an -f flv rtmp://localhost/live/<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p><br></p><p>稍微解释一下上面的命令:</p><ul><li><code>-f avfoundation -r 30 -i &quot;FaceTime HD Camera&quot;</code> 表示从 <code>FaceTime HD Camera</code> 中以 30 fps 的帧率采集视频</li><li><code>-c:v libx264</code> 输出视频的编码格式是 H.264,  RTMP 通常采用H.264 编码</li><li><code>-f flv</code> 指的视频的封包格式, RTMP 一般采用 flv 封包格式。</li><li><code>-an</code> 忽略音频流</li><li><code>-preset superfast -tune zerolatency</code> H.264 的转码预设参数和调优参数。会影响视频质量和压缩率</li></ul><p><br></p><blockquote><p><strong>封包格式(format)</strong>和<strong>编码(codec)</strong>是音视频开发中最基础的概念。<br><br><br><strong>封包格式</strong>: 相当于一种储存视频信息的容器，将编码好的音频、视频、或者是字幕、脚本之类的文件根据相应的规范组合在一起，从而生成一个封装格式的文件。常见的封包格式有 avi、mpeg、flv、mov 等<br><br><br><strong>编码格式</strong>: 编码主要的目的是为了压缩。从设备采集到的音视频流称为裸码流(rawvideo 格式, 即没有经过编码压缩处理的数据)。举例：一个 720p，30fps，60min 的电影，裸流大小为：12Bx1280x720x30x60x100 = 1.9T。这不管在文件系统上存储、还是在网络上传输，成本都太高了，所以我们需要编码压缩。 H264 是目前最常见的编码格式之一。</p></blockquote><p><br><br><br></p><h3 id="rtmp-拉流"><a href="#rtmp-拉流" class="headerlink" title="RTMP 拉流"></a>RTMP 拉流</h3><p>最简单的，我们可以使用 <a href="http://www.ffmpeg.org/ffplay.html" target="_blank" rel="noopener"><code>ffplay</code></a> (ffmpeg 提供的工具套件之一) 播放器来测试推流和拉流是否正常:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffplay rtmp://localhost/live/<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p><br></p><p>Flash 已经过时， 为了在 Web 页面中实现 RTMP 流播放，我们还要借助 <a href="https://github.com/bilibili/flv.js" target="_blank" rel="noopener"><code>flv.js</code></a>。 flvjs 估计大家都很熟悉(花边：如何看待哔哩哔哩的 flv.js 作者月薪不到 5000 元？)，它是 B 站开源的 flv 播放器。按照官方的介绍：</p><blockquote><p>flv.js works by transmuxing FLV file stream into ISO BMFF (Fragmented MP4) segments, followed by feeding mp4 segments into an HTML5 <code>&lt;video&gt;</code> element through <code>Media Source Extensions API</code>.</p></blockquote><p><br></p><p>上面提到，flv(Flash Video) 是一个视频封包格式，<code>flvjs</code> 做的就是<strong>把 flv 转换成 Fragmented MP4(ISO BMFF) 封包格式</strong>，然后喂给<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Media_Source_Extensions_API" target="_blank" rel="noopener">Media Source Extension API, MSE</a>, 接着我们将 MSE 挂载到 <code>&lt;video&gt;</code> 就可以直接播放了, 它的架构如下:</p><p><br></p><p><img src="/images/video-push/flv-arch.png" alt></p><p><br><br><br></p><p>flvjs 支持通过 HTTP Streaming、 WebSocket 或者自定义数据源等多种形式拉取二进制视频流。下面示例通过 flvjs 来拉取 <code>node-media-server</code> 的视频流:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/flv.js/1.5.0/flv.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;video id=<span class="string">"video"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span></span><br><span class="line">&lt;button id=<span class="string">"play"</span>&gt;play&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  if (flvjs.isSupported()) &#123;</span></span><br><span class="line"><span class="regexp">    const videoElement = document.getElementById('video');</span></span><br><span class="line"><span class="regexp">    const play = document.getElementById('play');</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    const flvPlayer = flvjs.createPlayer(</span></span><br><span class="line"><span class="regexp">      &#123;</span></span><br><span class="line"><span class="regexp">        type: 'flv',</span></span><br><span class="line"><span class="regexp">        isLive: true,</span></span><br><span class="line"><span class="regexp">        hasAudio: false,</span></span><br><span class="line"><span class="regexp">        url: 'ws:/</span><span class="regexp">/localhost:8000/</span>live/test.flv<span class="string">',</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        enableStashBuffer: true,</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    flvPlayer.attachMediaElement(videoElement);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    play.onclick = () =&gt; &#123;</span></span><br><span class="line"><span class="string">      flvPlayer.load();</span></span><br><span class="line"><span class="string">      flvPlayer.play();</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>完整示例代码在<a href="https://github.com/ivan-94/video-push/tree/master/rtmp" target="_blank" rel="noopener">这里</a></p></blockquote><p><br><br><br></p><h3 id="rtmp-低延迟优化"><a href="#rtmp-低延迟优化" class="headerlink" title="RTMP 低延迟优化"></a>RTMP 低延迟优化</h3><p><strong>推流端</strong></p><p><code>ffmpeg</code> 推流端可以通过一些控制参数来降低推流的延迟，主要优化方向是提高编码的效率、减少缓冲大小，当然有时候要牺牲一些代码质量和带宽。 这篇文章 <a href="https://blog.csdn.net/fireroll/article/details/51902018" target="_blank" rel="noopener">ffmpeg 的转码延时测试与设置优化</a> 总结了一些优化措施可以参考一下:</p><ul><li>关闭 sync-lookahead</li><li>降低 rc-lookahead，但别小于 10,默认是-1</li><li>降低 threads(比如从 12 降到 6)</li><li>禁用 rc-lookahead</li><li>禁用 b-frames</li><li>缩小 GOP</li><li>开启 x264 的 -preset fast/faster/verfast/superfast/ultrafast 参数</li><li>使用-tune zerolatency 参数</li></ul><p><br></p><p><strong>node-media-server</strong></p><p>NMS 也可以通过降低缓冲大小和<a href="https://github.com/ossrs/srs/wiki/v1_CN_LowLatency" target="_blank" rel="noopener">关闭 GOP Cache</a> 来优化延迟。</p><p><br></p><p><strong>flvjs 端</strong></p><p>flvjs 可以开启 <code>enableStashBuffer</code> 来提高实时性。 实际测试中，flvjs 可能会出现’累积延迟’现象，可以通过<a href="https://github.com/bilibili/flv.js/issues/258" target="_blank" rel="noopener">手动 seek</a>来纠正。</p><p><br><br><br></p><p>经过一番折腾，优化到最好的延迟是 400ms，往下就束手无策了(对这块熟悉的同学可以请教一下)。而且在对接到底层库实际推送时，播放效果并不理想，出现各种卡顿、延迟。由于时间和知识有限，我们很难定位到具体的问题在哪， 所以我们暂时放弃了这个方案。</p><p><br><br><br></p><h2 id="②-jsmpeg-amp-broadwayjs"><a href="#②-jsmpeg-amp-broadwayjs" class="headerlink" title="② JSMpeg &amp; BroadwayJS"></a>② JSMpeg &amp; BroadwayJS</h2><p>Jerry Qu 写得 <a href="https://imququ.com/post/html5-live-player-2.html" target="_blank" rel="noopener">《HTML5 视频直播（二）》</a> 给了我不少启发，得知了 <a href="https://github.com/phoboslab/jsmpeg" target="_blank" rel="noopener"><code>JSMpeg</code></a> 和 <a href="https://github.com/mbebenita/Broadway" target="_blank" rel="noopener"><code>Broadwayjs</code></a> 这些方案</p><p><strong>这两个库不依赖于浏览器的 video 的播放机制，使用纯 JS/WASM 实现视频解码器，然后直接通过 Canvas2d 或 WebGL 绘制出来</strong>。Broadwayjs 目前不支持语音，JSMpeg 支持语音(基于 WebAudio)。</p><p><br></p><p>经过简单的测试, 相比 RTMP， JSMpeg 和 BroadwayJS 延迟都非常低，基本符合我们的要求。下面简单介绍一下 JSMpeg 用法。Broadwayjs 用法差不多, 下文会简单带过。它们的基本处理过程如下：</p><p><br></p><p><img src="/images/video-push/jsmpeg.png" alt></p><p><br></p><h3 id="relay-服务器"><a href="#relay-服务器" class="headerlink" title="Relay 服务器"></a>Relay 服务器</h3><p>因为 ffmpeg 无法向 Web 直接推流，因此我们还是需要创建一个中转（relay）服务器来接收视频推流，再通过 WebSocket 转发给页面播放器。</p><p>ffmpeg 支持 HTTP、TCP、UDP 等各种推流方式。HTTP 推流更方便我们处理, 因为是本地环境，这些网络协议不会有明显的性能差别。</p><p>下面创建一个 HTTP 服务器来接收推流，推送路径是 <code>/push/:id</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.server = http</span><br><span class="line">  .createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = req.url || <span class="string">'/'</span></span><br><span class="line">    <span class="keyword">if</span> (!url.startsWith(<span class="string">'/push/'</span>)) &#123;</span><br><span class="line">      res.statusCode = <span class="number">404</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> id = url.slice(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止超时</span></span><br><span class="line">    res.connection.setTimeout(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转发出去</span></span><br><span class="line">    req.on(<span class="string">'data'</span>, (c) =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.broadcast(id, c)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    req.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(port)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>接着通过 <code>WebSocket</code> 将流转发出去, 页面可以通过 <code>ws://localhost:PORT/pull/{id}</code> 拉取视频流:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 webSocket 拉取流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">this</span>.wss = <span class="keyword">new</span> ws.Server(&#123;</span><br><span class="line">  server: <span class="keyword">this</span>.server,</span><br><span class="line">  <span class="comment">// 通过 /pull/&#123;id&#125; 拉流</span></span><br><span class="line">  verifyClient: <span class="function">(<span class="params">info, cb</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (info.req.url &amp;&amp; info.req.url.startsWith(<span class="string">'/pull'</span>)) &#123;</span><br><span class="line">      cb(<span class="literal">true</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cb(<span class="literal">false</span>, <span class="literal">undefined</span>, <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.wss.on(<span class="string">'connection'</span>, (client, req) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> url = req.url</span><br><span class="line">  <span class="keyword">const</span> id = url.slice(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;prefix&#125;</span>new player attached: <span class="subst">$&#123;id&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> buzy = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> listener = &#123;</span><br><span class="line">    id,</span><br><span class="line">    onMessage: <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 推送</span></span><br><span class="line">      <span class="keyword">if</span> (buzy) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      buzy = <span class="literal">true</span></span><br><span class="line">      client.send(data, &#123; <span class="attr">binary</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span> <span class="title">ack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        buzy = <span class="literal">false</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.attachListener(listener)</span><br><span class="line"></span><br><span class="line">  client.on(<span class="string">'close'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;prefix&#125;</span> player dettached: <span class="subst">$&#123;id&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">this</span>.detachListener(listener)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p>这里同样使用 ffmpeg 作为推送示例:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -r 30 -i <span class="string">"FaceTime HD Camera"</span> -f mpegts -codec:v mpeg1video -an  -bf 0 -b:v 1500k -maxrate 2500k http://localhost:9999/push/<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p>稍微解释一下 ffmpeg 命令</p><ul><li><code>-f mpegts -codec:v mpeg1video -an</code> 指定使用 MPEG-TS 封包格式， 并使用 mpeg1 视频编码，忽略音频</li><li><code>-bf 0</code> JSMpeg 解码器暂时不能正确地处理 B 帧。所以这些将 B 帧禁用。关于什么是 I/B/P 帧, 参考这篇<a href="https://www.jianshu.com/p/b3d1004229db" target="_blank" rel="noopener">文章</a></li><li><code>-b:v 1500k -maxrate 2500k</code> 设置推流的平均码率和最大码率。经过测试，JSMpeg 码率过高容易出现花屏和数组越界崩溃。</li></ul><p>另外 JSMpeg 还要求，视频的宽度必须是 2 的倍数。ffmpeg 可以通过滤镜(filter)或设置视频尺寸(-s)来解决这个问题, 不过多余转换都要消耗一定 CPU 资源的：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i in.mp4 -f mpeg1video -vf "crop=iw-mod(iw\,2):ih-mod(ih\,2)" -bf 0 out.mpg</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"video-canvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jsmpeg.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'video-canvas'</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> url = <span class="string">'ws://localhost:9999/pull/test'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> player = <span class="keyword">new</span> JSMpeg.Player(url, &#123;</span></span><br><span class="line"><span class="undefined">    canvas: canvas,</span></span><br><span class="line"><span class="javascript">    audio: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">    pauseWhenHidden: <span class="literal">false</span>,</span></span><br><span class="line"><span class="undefined">    videoBufferSize: 8 * 1024 * 1024,</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>API 很简单，上面我们传递一个画布给 JSMpeg，禁用了 Audio, 并设置了一个较大的缓冲区大小, 来应对一些码率波动。</p><p><br></p><blockquote><p>完整代码见<a href="https://github.com/ivan-94/video-push/tree/master/jsmpeg" target="_blank" rel="noopener">这里</a></p></blockquote><p><br><br><br></p><h3 id="多进程优化"><a href="#多进程优化" class="headerlink" title="多进程优化"></a>多进程优化</h3><p>实际测试下来，JSMpeg 视频延迟在 100ms - 200ms 之间。当然这还取决于视频的质量、终端的性能等因素。</p><p>受限于终端性能以及解码器效率, 对于平均码率(笔者粗略测试大概为 2000k)较高的视频流，JSMpeg 有很大概率会出现花屏或者内存访问越界问题(memory access out of bounds)。</p><p><img src="/images/video-push/jsmpeg-problems.png" alt></p><p><br></p><p>因此我们不得不通过压缩视频的质量、降低视频分辨率等手段来降低视频码率。然而这并不能根本解决问题，这是使用 JSMpeg 的痛点之一。详见<a href="https://github.com/phoboslab/jsmpeg#performance-considerations" target="_blank" rel="noopener">JSMpeg 的性能说明</a></p><p><br></p><p>因为解码本身是一个 CPU 密集型的操作，且由浏览器来执行，CPU 占用还是挺高的(笔者机器单个页面单个播放器, CPU 占用率在 16%左右)，而且 JSMpeg 播放器一旦异常崩溃会难以恢复。</p><p>在我们的实际应用场景中，一个页面可能会播放多路视频, 如果所有视频都在浏览器主进程中进行解码渲染，页面操作体验会很差。 所以最好是将 JSMpeg 分离到 Worker 中, <strong>一来保证主进程可以响应用户的交互，二来 JSMpeg 崩溃不会连累主进程</strong>。</p><p>好在将 JSMpeg 放在 Worker 中执行容易: Worker 中支持独立 WebSocket 请求，另外 Canvas 通过 <code>transferControlToOffscreen()</code> 方法创建 <code>OffscreenCanvas</code> 对象并传递给 Worker，实现 canvas 离屏渲染。</p><p>先来看看 <code>worker.js</code>, 和上面的代码差不多，主要是新增了 worker 通讯:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">importScripts(<span class="string">'./jsmpeg.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.window = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'message'</span>, (evt) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = evt.data</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (data.type) &#123;</span><br><span class="line">    <span class="comment">// 创建播放器</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'create'</span>:</span><br><span class="line">      <span class="keyword">const</span> &#123; url, canvas, ...config &#125; = data.data</span><br><span class="line">      <span class="keyword">this</span>.id = url</span><br><span class="line">      <span class="keyword">this</span>.player = <span class="keyword">new</span> JSMpeg.Player(url, &#123;</span><br><span class="line">        canvas,</span><br><span class="line">        audio: <span class="literal">false</span>,</span><br><span class="line">        pauseWhenHidden: <span class="literal">false</span>,</span><br><span class="line">        videoBufferSize: <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>,</span><br><span class="line">        ...config,</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁播放器</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'destroy'</span>:</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.player) &#123;</span><br><span class="line">          <span class="keyword">this</span>.player.destroy()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.postMessage(&#123; <span class="attr">type</span>: <span class="string">'destroyed'</span> &#125;)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(LOGGER_FREFIX + <span class="string">'销毁失败: '</span>, global.id, err)</span><br><span class="line">        <span class="keyword">this</span>.postMessage(&#123;</span><br><span class="line">          type: <span class="string">'fatal'</span>,</span><br><span class="line">          data: err,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就绪</span></span><br><span class="line"><span class="keyword">this</span>.postMessage(&#123; <span class="attr">type</span>: <span class="string">'ready'</span>, <span class="attr">data</span>: &#123;&#125; &#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>再来看看主进程, 通过 <code>transferControlToOffscreen()</code> 生成离屏渲染画布，让 JSMpeg 可以无缝迁移到 Worker:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.getElementById(<span class="string">'video'</span>)</span><br><span class="line"><span class="keyword">const</span> wk = <span class="keyword">new</span> Worker(<span class="string">'./jsmpeg.worker.js'</span>)</span><br><span class="line"></span><br><span class="line">wk.onmessage = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> data = evt.data</span><br><span class="line">  <span class="keyword">switch</span> (data.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ready'</span>:</span><br><span class="line">      <span class="comment">// 创建 OffscreenCanvas 对象</span></span><br><span class="line">      <span class="keyword">const</span> oc = video.transferControlToOffscreen()</span><br><span class="line"></span><br><span class="line">      wk.postMessage(</span><br><span class="line">        &#123;</span><br><span class="line">          type: <span class="string">'create'</span>,</span><br><span class="line">          data: &#123;</span><br><span class="line">            canvas: oc,</span><br><span class="line">            url: <span class="string">'ws://localhost:9999/pull/test'</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        [oc] <span class="comment">// 注意这里</span></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="简单说一下-broadway-js"><a href="#简单说一下-broadway-js" class="headerlink" title="简单说一下 Broadway.js"></a>简单说一下 Broadway.js</h3><p>还有一个类似 JSMpeg 的解决方案 ———— <a href="https://github.com/mbebenita/Broadway" target="_blank" rel="noopener">Broadwayjs</a>。 它是一个 <code>H.264</code> 解码器, 通过 <a href="https://github.com/emscripten-core/emscripten" target="_blank" rel="noopener"><code>Emscripten</code></a> 工具从 Android 的 H.264 解码器转化而成。它支持接收 H.264 裸流，不过也有一些限制：不支持 <a href="https://github.com/mbebenita/Broadway#encoding-video" target="_blank" rel="noopener"><code>weighted prediction for P-frames</code> &amp; <code>CABAC entropy encoding</code></a>。</p><p><br></p><p>推送示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation  -r 30 -i <span class="string">"FaceTime HD Camera"</span>  -f rawvideo -c:v libx264 -pix_fmt yuv420p -vprofile baseline -tune zerolatency -coder 0 -bf 0 -flags -loop -wpredp 0 -an  http://localhost:9999/push/<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p><br><br><br></p><p>客户端示例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.getElementById(<span class="string">'video'</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="string">`ws://localhost:9999/pull/test`</span></span><br><span class="line"><span class="keyword">const</span> player = <span class="keyword">new</span> Player(&#123;</span><br><span class="line">  canvas: video,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(url)</span><br><span class="line">ws.binaryType = <span class="string">'arraybuffer'</span></span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = evt.data</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data !== <span class="string">'string'</span>) &#123;</span><br><span class="line">    player.decode(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(data))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get command from server: '</span>, data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>完整代码看<a href="https://github.com/ivan-94/video-push/tree/master/broadway" target="_blank" rel="noopener">这里</a></p></blockquote><p>经过测试，同等质量和尺寸的视频流 JSMpeg 和 Broadway CPU 消耗差不多。但是 Broadway 视频流不受码率限制，没有花屏和崩溃现象。当然, 对于高质量视频, ffmpeg 转换和 Broadway 播放, 资源消耗都非常惊人。</p><p><br></p><p>其他类似的方案:</p><ul><li><a href="https://github.com/ChihChengYang/wfs.js" target="_blank" rel="noopener">wfs</a> html5 player for raw h.264 streams.</li></ul><p><br><br><br></p><h2 id="③-直接渲染-yuv"><a href="#③-直接渲染-yuv" class="headerlink" title="③ 直接渲染 YUV"></a>③ 直接渲染 YUV</h2><p><strong>回到文章开始，其实底层库从 WebRTC 中拿到的是 YUV 的原始视频流, 也就是没有经过编码压缩的一帧一帧的图像。上文介绍的方案都有额外的解封包、解编码的过程，最终输出的也是 YUV 格式的视频帧，它们的最后一步都是将这些 YUV 格式视频帧转换成 RGB 格式，渲染到 Canvas 中</strong>。</p><p><strong>那能不能将原始的 YUV 视频帧直接转发过来，直接在 Cavans 上渲染不就得了</strong>？ 将去掉中间的解编码过程, 效果怎样？试一试。</p><p><br></p><blockquote><p>此前已经有文章做过这方面的尝试: <a href="https://juejin.im/post/5de29d7be51d455f9b335efa" target="_blank" rel="noopener">《IVWEB 玩转 WASM 系列-WEBGL YUV 渲染图像实践》</a>。我们参考它搞一个。</p></blockquote><p>至于什么是 <code>YUV</code>，我就不科普, 自行搜索。 YUV 帧的大小可以根据这个公式计算出来： <code>(width * height * 3) &gt;&gt; 1</code>,<br><strong>即 <code>YUV420p</code> 的每个像素占用 1.5 bytes</strong>。</p><p>因此我们只需要知道视频的大小, 就可以切割视频流，将视频帧分离出来了。 下面新建一个中转服务器来接收推流, 在这里将 YUV 裸流切割成一帧一帧图像数据，下发给浏览器：</p><p><br></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> parsed = <span class="keyword">new</span> URL(<span class="string">'http://host'</span> + url)</span><br><span class="line">  <span class="keyword">let</span> id = parsed.searchParams.get(<span class="string">'id'</span>),</span><br><span class="line">    width = parsed.searchParams.get(<span class="string">'width'</span>),</span><br><span class="line">    height = parsed.searchParams.get(<span class="string">'height'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nwidth = <span class="built_in">parseInt</span>(width)</span><br><span class="line">  <span class="keyword">const</span> nheight = <span class="built_in">parseInt</span>(height)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> frameSize = (nwidth * nheight * <span class="number">3</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按照字节大小切割流</span></span><br><span class="line">  <span class="keyword">const</span> stream = req.pipe(<span class="keyword">new</span> Splitter(frameSize))</span><br><span class="line"></span><br><span class="line">  stream.on(<span class="string">'data'</span>, (c) =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.broadcast(id, c)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/ivan-94/video-push/blob/master/yuv/size-split.js" target="_blank" rel="noopener"><code>Splitter</code></a> 根据固定字节大小切割 Buffer。 </p><p><br></p><p>如果渲染 YUV ？ 可以参考 <a href="https://github.com/phoboslab/jsmpeg/blob/master/src/webgl.js" target="_blank" rel="noopener">JSMpeg WebGL 渲染器</a>, <a href="https://github.com/mbebenita/Broadway/blob/master/Player/YUVCanvas.js" target="_blank" rel="noopener">Broadway.js WebGL 渲染器</a>。 具体如何渲染就不展开了， 下面直接将 Broadway.js 的 <a href="https://github.com/mbebenita/Broadway/blob/master/Player/YUVCanvas.js" target="_blank" rel="noopener"><code>YUVCanvas.js</code></a> 直接拿过来用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> YUVCanvas(&#123;</span><br><span class="line">  canvas: video,</span><br><span class="line">  type: <span class="string">'yuv420'</span>,</span><br><span class="line">  width: width,</span><br><span class="line">  height: height,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 WebSocket 接收 YUV 帧. 并抽取出 YUV 分量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ylen = width * height</span><br><span class="line">  <span class="keyword">const</span> uvlen = (width / <span class="number">2</span>) * (height / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  renderer.render(</span><br><span class="line">    buff.subarray(<span class="number">0</span>, ylen),</span><br><span class="line">    buff.subarray(ylen, ylen + uvlen),</span><br><span class="line">    buff.subarray(ylen + uvlen, ylen + uvlen + uvlen),</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><blockquote><p>需要注意的是：JSMpeg 和 Broadway 的 Canvas 渲染都要求视频的宽度必须是 8 的倍数。不符合这个要求的会报错，<a href="https://juejin.im/post/5de29d7be51d455f9b335efa" target="_blank" rel="noopener">《IVWEB 玩转 WASM 系列-WEBGL YUV 渲染图像实践》</a> 处理了这个问题。</p></blockquote><p><br></p><p>最后看看 ffmpeg 推送示例:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -r 30 -i <span class="string">"FaceTime HD Camera"</span> -f rawvideo -c:v rawvideo -pix_fmt yuv420p <span class="string">"http://localhost:9999/push?id=test&amp;width=320&amp;height=240"</span></span></span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>完整代码看<a href="https://github.com/ivan-94/video-push/tree/master/yuv" target="_blank" rel="noopener">这里</a></p></blockquote><p><br><br><br></p><p>下面看看简单资源消耗对比。 笔者设备是 15 款 Macboook pro, 视频源采集自摄像头，分辨率 320x240、像素格式 uyvy422、帧率 30。</p><p><em>下表 <code>J</code> 表示 <code>JSMpeg</code>、<code>B</code> 表示 <code>Broadway</code>、<code>Y</code> 表示 <code>YUV</code></em></p><table><thead><tr><th></th><th>CPU (J/B/Y)</th><th>内存 (J/B/Y)</th><th>平均码率 (J/B/Y)</th></tr></thead><tbody><tr><td>ffmpeg</td><td>9% / 9% / 5%</td><td>12MB / 12MB / 9MB</td><td>1600k / 200k / 27000k</td></tr><tr><td>服务器</td><td>0.6% / 0.6% /1.4%</td><td>18MB / 18MB / 42MB</td><td>N/A</td></tr><tr><td>播放器</td><td>16% / 13% / 8%</td><td>70MB / 200MB / 50MB</td><td>N/A</td></tr></tbody></table><p><br></p><p>从结果来看，直接渲染 YUV 综合占用的资源最少。因为没有经过压缩，码率也是非常高的，不过本地环境不受带宽限制，这个问题也不大。我们还可以利用<code>requestAnimationFrame</code> 由浏览器来调度播放的速率，丢掉积累的帧，保持低延迟播放。</p><p><br><br><br></p><p>本文完</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://juejin.im/post/5ab851b6f265da23826df601" target="_blank" rel="noopener">直播原理与 web 直播实战</a></li><li><a href="https://juejin.im/post/5de29d7be51d455f9b335efa" target="_blank" rel="noopener">IVWEB 玩转 WASM 系列-WEBGL YUV 渲染图像实践</a></li><li><a href="https://github.com/ossrs/srs/wiki/v1_CN_LowLatency" target="_blank" rel="noopener">低延时直播应用</a></li><li><a href="https://zhuanlan.zhihu.com/p/100519553" target="_blank" rel="noopener">基于 H5 的直播协议和视频监控方案</a></li><li><a href="https://imququ.com/post/html5-live-player-2.html" target="_blank" rel="noopener">HTML5 视频直播（二）</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久不见，接近四个月没更新博客了! &lt;/p&gt;
&lt;p&gt;去年&lt;a href=&quot;https://juejin.im/post/5e0010866fb9a015fd69c645#comment&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最后一篇&lt;/a&gt;文章介绍
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
</feed>
