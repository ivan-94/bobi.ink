<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bobi.ink</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bobi.ink/"/>
  <updated>2023-07-28T01:18:47.138Z</updated>
  <id>https://bobi.ink/</id>
  
  <author>
    <name>Ivan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2023年了，我还是选择 MobX</title>
    <link href="https://bobi.ink/2023/07/28/mobx/"/>
    <id>https://bobi.ink/2023/07/28/mobx/</id>
    <published>2023-07-27T16:00:00.000Z</published>
    <updated>2023-07-28T01:18:47.138Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/mobx/Untitled.jpeg" alt="Untitled"></p><p>时至今日，前端的各种状态管理方案仍层出不穷，花式百样，争议不断，尤其是 React 社区。那我为什么要“背道而驰”，选择基本没什么声音的 MobX 呢？</p><p>这篇文章会深入探讨 MobX 背后的面向对象范式之争，以及可变数据与不可变数据之争。篇幅有点长，读者耐心读读会有收获。在阅读时，建议多留意一下目录，把握整篇文章叙述结构。</p><p><br><br><br></p><h2 id="面向对象与函数式之争"><a href="#面向对象与函数式之争" class="headerlink" title="面向对象与函数式之争"></a>面向对象与函数式之争</h2><p>首当其冲的是面向对象和函数式编程之争。MobX 背后代表的是面向对象思想 。</p><p><br></p><p>我问 <code>ChatGPT</code>, <strong>面向对象的优势是什么</strong>：</p><blockquote><p>**🤖 ChatGPT 曰:</p></blockquote><p>面向对象编程可以将复杂的现实世界中的问题抽象成易于理解和管理的对象，通过对象之间的交互来解决问题。这种对象抽象的方法可以使得程序设计更加直观、简单，可以更好地描述复杂系统中的各个组成部分和它们之间的关系。**</p><blockquote><p>面向对象编程（Object-oriented programming）具有以下优势：</p><ol><li>抽象化：<strong>通过面向对象编程，可以将复杂的现实世界中的问题抽象成易于理解和管理的对象，并通过对象之间的交互来解决问题。这种抽象化的方法使得程序设计更加直观、简单，使得开发人员更容易理解和维护代码</strong>。</li><li>封装性：面向对象编程提供了封装的机制，将对象的属性和方法封装在一起，只暴露必要的接口给外部使用，避免了对内部实现细节的直接暴露，从而提高了代码的安全性和可维护性。</li><li>继承性：面向对象编程提供了继承的机制，通过继承，子类可以继承父类的属性和方法，并在此基础上进行扩展和修改。这种继承的机制可以避免代码重复，提高代码的可重用性和可维护性。</li><li>多态性：面向对象编程提供了多态的机制，通过多态，同一种方法可以在不同的对象上产生不同的行为。多态性可以提高程序的灵活性和可扩展性，使得程序更加适应复杂多变的需求。</li><li>代码复用：面向对象编程提供了模块化的机制，可以将代码分解成多个模块，实现代码的复用和重构。这种模块化的机制可以使得代码更加易于管理和维护，提高了代码的可重用性和可维护性</li></ol></blockquote><p><br></p><p>这是一个教科书式的回答。</p><p><br><br><br></p><h3 id="抽象能力"><a href="#抽象能力" class="headerlink" title="抽象能力"></a>抽象能力</h3><p>我又问 ChatGPT, 在抽象能力上面向对象相比函数式有什么优势?</p><blockquote><p>🤖 ChatGPT 曰:</p><p>在抽象能力上，面向对象和函数式编程都有其独特的优势。</p><p>面向对象编程的优势在于其能够将复杂的问题抽象成对象，并通过对象之间的交互来解决问题。面向对象编程提供了封装、继承、多态等机制，可以将代码分解成多个独立的模块，使得代码更加易于维护和修改，减少了代码的耦合，提高了代码的灵活性和可维护性。<strong>在面向对象编程中，对象是程序的基本组成单元，对象之间通过消息传递来实现交互，从而实现了高度的抽象能力</strong>。面向对象编程还提供了丰富的设计模式，可以帮助开发人员更好地组织和管理代码，提高代码的可读性、可维护性和可扩展性。</p><p>函数式编程的优势在于其强调函数的纯度和不可变性，可以将函数看作是数学中的函数，而不是过程式编程中的函数。函数式编程提供了高阶函数、闭包、柯里化等机制，可以将函数看作是一等公民，可以进行组合、抽象和重用，从而实现了高度的抽象能力。在函数式编程中，函数是程序的基本组成单元，函数之间通过函数调用来实现交互，从而实现了高度的模块化和组合能力。函数式编程还提供了丰富的函数组合和递归等技术，可以帮助开发人员更好地组织和管理代码，提高代码的可读性、可维护性和可扩展性。</p><p>总的来说，在抽象能力上，面向对象和函数式编程都具有其独特的优势，可以根据具体的应用场景选择适合的编程范式。</p></blockquote><p><br></p><p>又一个教科书式的回答，谁都不得罪，请收下我的膝盖！</p><p><br></p><p>ChatGPT 回答总是那么八面玲珑，它也知道应该规避二元论，世界上并没有绝对的非黑即白。因此，我们脱离场景去讨论孰好孰坏，都是在耍流氓。</p><p><br></p><p>我们将上面 ChatGPT 的回答再归纳一下：</p><table><thead><tr><th></th><th>面向对象</th><th>函数式</th></tr></thead><tbody><tr><td>抽象单位</td><td>对象</td><td>函数</td></tr><tr><td>行为和数据的关系</td><td>数据和行为合并。强调现实世界问题的抽象还原。</td><td>数据和行为分离。强调数据不可变性、行为无副作用</td></tr><tr><td>机制</td><td>封装、继承、多态等</td><td>高阶函数、闭包、柯里化、递归等</td></tr><tr><td>抽象能力实现</td><td>对象之间的交互、引用</td><td>函数组合</td></tr></tbody></table><p><br></p><p>OK，我觉得文章都让 ChatGPT 来写好了，继续问：<strong>分别举一些面向对象和函数式擅长的场景</strong></p><p><br><br><br></p><blockquote><p>🤖 ChatGPT 曰:</p><p>面向对象编程和函数式编程各有擅长的场景，具体如下：</p><p>面向对象编程：</p><ol><li>GUI 编程：面向对象编程可以很好地用于 GUI 编程，因为 GUI 程序通常涉及到许多对象之间的交互，面向对象编程可以将这些对象和它们之间的关系进行抽象和封装，从而使得程序更加易于理解和管理。</li><li>游戏开发：面向对象编程可以很好地用于游戏开发，因为游戏通常涉及到许多对象之间的交互，面向对象编程可以将这些对象和它们之间的关系进行抽象和封装，从而使得游戏逻辑更加易于理解和管理。</li><li>企业级应用：面向对象编程可以很好地用于开发大型的企业级应用，因为企业级应用通常需要涉及到多个模块之间的交互，面向对象编程可以将这些模块和它们之间的关系进行抽象和封装，从而使得程序更加易于理解和管理。</li></ol><p>函数式编程：</p><ol><li>并发编程：函数式编程可以很好地用于并发编程，因为函数式编程强调不可变性和无副作用，可以避免并发问题，使得并发编程更加安全和可靠。</li><li>数据分析：函数式编程可以很好地用于数据分析，因为函数式编程提供了丰富的高阶函数和数据处理函数，可以方便地处理和分析大量的数据。</li><li>数学计算：函数式编程可以很好地用于数学计算，因为函数式编程强调函数抽象和高阶函数，可以方便地实现数学函数和算法，使得数学计算更加简单和高效。</li></ol><p>总之，面向对象编程和函数式编程各有擅长的场景，需要根据具体的应用需求来选择合适的编程范式</p></blockquote><p><br><br><br></p><p>有人说：面向对象就是计算机软件对现实世界的阐述，当我们能直观的描述业务场景，就能很好的编写代码。</p><p><br></p><p><strong>面向对象的优势在于可以将复杂的现实世界中的问题抽象成易于理解和管理的对象。换句话说它可以比较直接/自然地表达业务对象和业务关系。这个比较契合人类对这个世界的朴素理解。</strong></p><p><br></p><p>比如 DDD（一个用来应对复杂业务的研发方法论） 方法论中，基本都以面向对象作为它的建模范式，因为面向对象编程能够直观地表达 DDD 中的模型概念。</p><blockquote><p>💡 也有使用函数式来实现 DDD 的，非常少见</p></blockquote><blockquote><p>💡 即使是面向对象编程中，通常也会面临“贫血模型” 和 “充血模型” 之争。采用充血模式大概率是某些技术上的妥协。<br>按照「正统」的面向对象思想，对象是充血的，有血(数据)有肉(行为)的对象。DDD 中也是鼓励使用充血模型。</p></blockquote><p><br></p><p>在前端领域, 面向对象范式在很多场景也有很大的优势：</p><ul><li>游戏开发。这是面向对象的传统强项，游戏通常包含许多不同类型的对象，如角色、道具、地图等等。利用面向对象编程的优势，可以更加方便地对这些对象进行管理和操作，从而实现更加复杂和精细的游戏系统</li><li>复杂的交互客户端。比如图像处理软件、低代码编辑器，这类「重」前端软件。</li><li>复杂的业务系统。比如 ERP、电子商务。比较少见，因为前端业务通常比较薄。</li></ul><p>这些场景共有的特征是：<strong>它们有复杂的数据结构和对象关系，这些对象之间需要紧密合作才能完成业务。</strong></p><p><br></p><p>比如面向对象可以直观地表示树、图这种复杂的关系：</p><p><img src="/images/mobx/Untitled.png" alt="Untitled"></p><p><br></p><p>面向对象语言提供了成熟的抽象机制(类、接口、继承、属性、方法、访问控制、多态)、社区上也沉淀了丰富的设计方法论(设计模式、UML、DDD)。</p><p>更神奇的是，面向对象曾经被认为是 <code>GUI</code> 开发的不二法门，当然这个已经被 React 等框架打破了，在前端领域，类函数式/数据驱动引领的 UI 开发已经是主流，甚至影响了平台(比如 Flutter, SwiftUI)。</p><p><br></p><p>再来看看，目前比较主流的状态管理方案, 比如 <a href="https://redux.js.org/" target="_blank" rel="noopener">Redux</a>/Redux Toolkit、<a href="https://docs.pmnd.rs/zustand/getting-started/comparison#state-model" target="_blank" rel="noopener">Zustand</a>、Recoil、<a href="https://pinia.vuejs.org/zh/introduction.html" target="_blank" rel="noopener">Pinia</a>等等。</p><p><img src="/images/mobx/Untitled%201.png" alt="Untitled"></p><p><br></p><p>这类以状态（State）为中心的状态管理器中，任何对象都只是一个序列化<code>文档</code>的一个<code>片段</code>(slice)。</p><blockquote><p>💡 就是一个对象文档，从后端的角度看来，这些就是 <code>DTO</code> 这类的结构化对象，没有业务含义，只是数据。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 伪代码</span><br><span class="line"></span><br><span class="line">// 状态</span><br><span class="line">const state = &#123;</span><br><span class="line">  tree: &#123;</span><br><span class="line">    root: &#123;</span><br><span class="line">      id: ID,</span><br><span class="line">      name: NAME,</span><br><span class="line">      active: true,</span><br><span class="line">      hidden: false,</span><br><span class="line">      properties: &#123;&#125;,</span><br><span class="line">      parent: undefined,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: ID,</span><br><span class="line">          name: NAME,</span><br><span class="line">          active: true,</span><br><span class="line">          hidden: false,</span><br><span class="line">          properties: &#123;&#125;,</span><br><span class="line">          parent: undefined,</span><br><span class="line">          children: [],</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 方法</span><br><span class="line">const methods = &#123;</span><br><span class="line">  walk(fn: (node: Node) =&gt; void) &#123;&#125;,</span><br><span class="line">  // ...</span><br><span class="line">  addChild(parentId: string, node: Node): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 衍生数据</span><br><span class="line">const selectors = &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这类状态管理方案，在面临复杂的对象关系时，有以下缺陷：</p><ol><li><p><strong>没有更细的粒度(模块)。</strong></p><p>这类方案通常只支持 <a href="https://docs.pmnd.rs/zustand/guides/slices-pattern" target="_blank" rel="noopener">Store 水平分割</a>(slice，本质上最终都会合入一个全局的树，对象之间没有清晰的边界)。<br>面向对象方案则以对象为抽象粒度，可以随意组合，来表示复杂的事物关系。</p><p>而函数式编程语言的一等公民——函数，尽管它有灵活的复合能力，它非常擅长处理数据，但无法在对象关系上发挥太多作用。</p></li><li><p>无法表达引用关系。</p><p>这些状态都是 <code>Plain Data</code>，通常还是不可变数据，无法维持稳定的内存引用 , 难以传递引用。</p></li><li><p>行为和数据结构不是亲密绑定。</p><p>这也是面向对象和函数式的主要区别，函数式主导数据和行为分离。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// zustand</span><br><span class="line">export const createBearSlice = (set) =&gt; (&#123;</span><br><span class="line">  bears: 0,</span><br><span class="line">  addBear: () =&gt; set((state) =&gt; (&#123; bears: state.bears + 1 &#125;)),</span><br><span class="line">  eatFish: () =&gt; set((state) =&gt; (&#123; fishes: state.fishes - 1 &#125;)),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>尽管这类<code>状态管理库</code>看上去将数据和行为组织在一起，但是和类还是有本质的区别：</p><ul><li><strong>体现在了调用方式上</strong>。类体系下，我们可以用 object.method() 形式，而 store 体系下，我们通常需要自行传递上下文: store.method(object)。</li><li><strong>在传递上</strong>。比如将数据传递给视图或者某个组件：面向对象通常直接传递对象或者模型，我们可以在这个对象上直接访问相关的数据和行为，对象本身是<strong><code>自包含</code></strong>的；而函数式，传递的是数据，就只有数据。</li></ul></li><li><p>裸露的数据。数据结构通常应该作为一种内部的实现细节封装起来，目前大部分 类 Redux 库都无法实施访问控制，更别说是抽象了(比如接口)。</p><p>毕竟现在是数据驱动视图的时代，我们通常不认为「数据」就是内部实现。</p></li><li><p>不支持复杂的数据结构</p></li></ol><p><br><br><br></p><p>不过面向对象也可能走向另外一种极端，就是过度设计、过度抽象，导致抽象的层级过深，最终也丧失的透明性。典型的症状是：什么都要套用一下设计模式、大量的类、类层级深、过渡的分层。</p><p><br></p><p><strong>笔者看来，应该将面向对象当做一个朴素的业务对象/关系映射器</strong>，所谓的过度设计/抽象，不过是提前设想了多余的场景，杀鸡用了牛刀。这其实是每个技术人都会犯的毛病。</p><p><br><br><br><br><br></p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p><img src="/images/mobx/Untitled%202.png" alt="Untitled"></p><p>这些类 Redux 状态管理库，通常都有类似的规约，如上图。单向数据流、数据和行为分离、数据只能通过 actions/dispatch 修改、使用 selector 计算状态等等。</p><p>为了履行这些规约，这些库通常会创造一套自己的 DSL 。</p><p>在这些规约下，一方面，代码可以保持一致性。另一方面，可以最大程度，确保用户按照库的理念执行，并保证用户可以安全地享受库提供的便利(比如调试、时间旅行、镜像)，实现双赢：</p><p>Pinia 示例</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// pinia 示例</span><br><span class="line">import &#123; defineStore &#125; from &apos;pinia&apos;</span><br><span class="line"></span><br><span class="line">export const useTodos = defineStore(&apos;todos&apos;, &#123;</span><br><span class="line">  state: () =&gt; (&#123;</span><br><span class="line">    /** @type &#123;&#123; text: string, id: number, isFinished: boolean &#125;[]&#125; */</span><br><span class="line">    todos: [],</span><br><span class="line">    /** @type &#123;&apos;all&apos; | &apos;finished&apos; | &apos;unfinished&apos;&#125; */</span><br><span class="line">    filter: &apos;all&apos;,</span><br><span class="line">    // 类型将自动推断为 number</span><br><span class="line">    nextId: 0,</span><br><span class="line">  &#125;),</span><br><span class="line">  getters: &#123;</span><br><span class="line">    finishedTodos(state) &#123;</span><br><span class="line">      // 自动补全！ ✨</span><br><span class="line">      return state.todos.filter((todo) =&gt; todo.isFinished)</span><br><span class="line">    &#125;,</span><br><span class="line">    unfinishedTodos(state) &#123;</span><br><span class="line">      return state.todos.filter((todo) =&gt; !todo.isFinished)</span><br><span class="line">    &#125;,</span><br><span class="line">    /**</span><br><span class="line">     * @returns &#123;&#123; text: string, id: number, isFinished: boolean &#125;[]&#125;</span><br><span class="line">     */</span><br><span class="line">    filteredTodos(state) &#123;</span><br><span class="line">      if (this.filter === &apos;finished&apos;) &#123;</span><br><span class="line">        // 调用其他带有自动补全的 getters ✨</span><br><span class="line">        return this.finishedTodos</span><br><span class="line">      &#125; else if (this.filter === &apos;unfinished&apos;) &#123;</span><br><span class="line">        return this.unfinishedTodos</span><br><span class="line">      &#125;</span><br><span class="line">      return this.todos</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    // 接受任何数量的参数，返回一个 Promise 或不返回</span><br><span class="line">    addTodo(text) &#123;</span><br><span class="line">      // 你可以直接变更该状态</span><br><span class="line">      this.todos.push(&#123; text, id: this.nextId++, isFinished: false &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>在 MobX 这类面向对象的方案上， 并没有统一约束和指导。 MobX 文档上唯一相关的指导就是 <a href="https://www.mobxjs.com/defining-data-stores" target="_blank" rel="noopener"><strong>定义数据存储</strong></a>。</p><p><img src="/images/mobx/Untitled%203.png" alt="Untitled"></p><p><br></p><p>好事！我们站起来了，没有镣铐，我们自由了。我们可以随意组织自己的代码，应用各种牛逼的设计模式。</p><p><br></p><p>但是怎么把钱了挣？我们只知道面向「对象」，我们有太多选择。没有任何约束，组织松散，每个人的代码可能都不一样，可能项目就会很快失控，越来越糟糕…</p><blockquote><p>💡 其实 MobX 社区也有其他选项，那就是 <a href="https://github.com/mobxjs/mobx-state-tree" target="_blank" rel="noopener">https://github.com/mobxjs/mobx-state-tree</a> 和 <a href="https://mobx-keystone.js.org/" target="_blank" rel="noopener">mobx-keystone</a>，只不过还是得跪着。</p></blockquote><p>所以站着挣钱很难。文章的进度条还很长，后面我还会继续讲这些约束。</p><p><br></p><p>说一句宽慰自己的话：关键还看人，设计完全看开发者经验和组织，Redux 有严格的数据变更和订阅约束，照样可以写出面条、巨石代码。</p><p><br><br><br><br><br></p><h3 id="返璞归真"><a href="#返璞归真" class="headerlink" title="返璞归真"></a>返璞归真</h3><p>时尚的潮流总是那么飘忽不定：</p><ul><li>有人叫嚣着<a href="https://www.notion.so/2023-MobX-67374c0c4ded4f409770b93b3717bf64?pvs=21" target="_blank" rel="noopener">去 Typescript</a></li><li>Alpine.js 说它能免构建运行，就跟“以前”一样</li><li>别用 tailwindcss，用 unocss</li><li>React 换名字叫 PHP</li><li>…</li></ul><p><br></p><p>2023 要返璞归真，放弃追求时尚，Less is more，回归朴素编程。</p><p>第一个示范就是用好编程语言提供的原生能力。</p><p>在 JavaScript/Typescript 或者其他主流编程语言，面向对象都是原生公民，功能成熟而强大，我们可能真的不需要其他的轮子。</p><p><br></p><p>我们可以举一些返璞归真例子：</p><ul><li>RESTful。这是一个大家都知道，也是最容易被误用规范。可以 RESTful 实际上并没有发明新的技术，它就是 HTTP 原本样子，比如 URL 表示服务器的资源，HTTP METHOD 表示对资源的操作方式，用 HTTP STATUS 表示操作的状态… 目前多少声称自己是 REST API, 然后自己重新发明了野生协议？</li><li>React vs Vue。另一个例子是 React 和 Vue，在 React 中组件就是一个纯粹的函数，所有输入都在一个 props 中，不需要区分属性，事件还是插槽，组件树就是函数的“复合”，不需要学习 JavaScript 语言之外的概念。这也使得他的 API 非常的简洁和稳定，Typescript 支持也是基本开箱即用。<br>Vue 引入了较多概念，当然在 Vue 3 下有所改善，如果读者站着库作者的角度上看，Vue 真是复杂不是一丁半点。<br>Vue，Angular，小程序，越来越多的框架引入了自己的 DSL。好处就是给开发者提供一个受控的开发体验和使用范围，稳定的接口也给了框架实现者也有了更多的优化空间和实现的替换能力。<br>坏处也比较明显，开发者要学习新的概念和语法；框架实现也会变得复杂，实现者需要保证 DX，需要给 DSL 配套类型检查，编译和测试套件，开发者工具… 这是一个很大的工程</li></ul><blockquote><p>💡 以上说法可能存在争议，两者理念存在差异，Vue 的设计更多是 Port from HTML，而 React 是 Keep in JavaScript</p></blockquote><p>讲这么多，无非那个道理，<strong>时尚一直在变，我们除了向外求，也可以向里求</strong>。</p><p>面向对象就是摆在眼前的，现成的「状态管理」方案。而且复杂的应用不仅仅是状态管理问题，面向对象方案有广泛的适应性。</p><p><br><br><br><br><br></p><h2 id="可变数据与不可变数据之争"><a href="#可变数据与不可变数据之争" class="headerlink" title="可变数据与不可变数据之争"></a>可变数据与不可变数据之争</h2><h3 id="两大门派"><a href="#两大门派" class="headerlink" title="两大门派"></a>两大门派</h3><p>不可变数据和可变数据是另一处两极分化。</p><p>Vue 和 MobX 为代表的可变响应式数据结构，还有 Redux 为代表的不可变数据。</p><p>可变数据的好处对是数据的操作符合习惯，毕竟 JavaScript 并不是一门函数式编程语言。这也使得它在变更不可变数据的时候会比较繁琐，且效率也不高的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; create &#125; from &apos;zustand&apos;</span><br><span class="line"></span><br><span class="line">const useCountStore = create((set) =&gt; (&#123;</span><br><span class="line">  nested: &#123; count: 0 &#125;,</span><br><span class="line">  inc: () =&gt;</span><br><span class="line">    set((state) =&gt; (&#123;</span><br><span class="line">      nested: &#123; ...state.nested, count: state.nested.count + 1 &#125;,</span><br><span class="line">    &#125;)),</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p><br></p><p>有趣的是，为了像操作可变数据一样“自然”，也有 <a href="https://immerjs.github.io/immer/" target="_blank" rel="noopener">immer</a> 这些库:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; produce &#125; from &apos;immer&apos;</span><br><span class="line"></span><br><span class="line">const nextState = produce(baseState, (draft) =&gt; &#123;</span><br><span class="line">  draft[1].done = true</span><br><span class="line">  draft.push(&#123; title: &apos;Tweet about it&apos; &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>那何不直接使用可变数据呢？</p><p>你问 ChatGPT，它会告诉你不可变数据有很多好处，比如：</p><ul><li><strong><code>安全性</code></strong>：不可变数据类型的值不能被修改，因此在多线程或并发编程中更加安全。避免了数据竞争和数据不一致的问题。<br>—— JavaScript 是单线程的，基本上不需要考虑这个问题。</li><li><strong><code>可预测性</code></strong>：不可变数据类型的值不会被修改，因此程序的行为更加可预测。在调试和测试时更加方便。<br>—— 数据如果可以被随意修改，导致的 Bug 通常很隐晦，而且很难排查。</li><li><strong><code>可缓存性</code></strong>：不可变数据类型的值不会被修改，因此可以进行缓存优化，提高程序的效率。<br>—— 不可变数据可以被安全地缓存，相对应的基于它的计算结果也可以被缓存。React memo 函数就是基于这种假设。<br>—— 可以提高比对的效率。可不变数据通常只需要全等比较(===) 就可以判断是否变更。而可变数据引用可能是固定的。<br>—— 可镜像。比如实现「时间旅行」，可以高效地序列化</li></ul><p><br><br><br><br><br></p><h3 id="可预测性"><a href="#可预测性" class="headerlink" title="可预测性"></a>可预测性</h3><p>类 Redux 的状态管理器实际上就是 <code>CQRS</code>(Command and Query Responsibility Segregation) 架构，就是把将应用程序中的读和写操作分离。这种架构在后端 DDD 实现中，也被广泛推荐。</p><p><img src="/images/mobx/Untitled%204.png" alt="服务端 CQRS 架构"></p><p>服务端 CQRS 架构</p><p><br><br><br></p><p>在本文的场景中，CQRS 的主要好处还是实现数据变更的「可预测性」。</p><p>我们大可不必像后端程序那样，定义一堆 Query 类、Command 类、QueryHandler 类、CommandHandler 类。</p><p><br></p><p>MobX 也提供了 Action 的概念，对于大型项目，我们都推荐只在 action 方法下去变更状态：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; configure &#125; from &apos;mobx&apos;</span><br><span class="line"></span><br><span class="line">configure(&#123;</span><br><span class="line">  // 强制开启 action</span><br><span class="line">  enforceActions: &apos;always&apos;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>只允许在 action 中变更状态：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Todo &#123;</span><br><span class="line">  id = Math.random()</span><br><span class="line">  @observable title = &apos;&apos;</span><br><span class="line">  @observable finished = false</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    makeObservable(this)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @action</span><br><span class="line">  toggle() &#123;</span><br><span class="line">    this.finished = !this.finished</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当状态在 action 之外被修改时，控制台会输出警告。另外配合 MobX 开发工具，我们也可以对这些 Action 和状态进行跟踪。</p><p><br><br><br><br><br></p><h3 id="时间旅行"><a href="#时间旅行" class="headerlink" title="时间旅行"></a>时间旅行</h3><p>「时间旅行」是类 Redux 的状态管理器的另一个杀手器。时间旅行可以有两种理解：一个是开发调试上，另一个是应用本身需要具备历史回溯能力(即撤销/重做, 甚至多人协作)。</p><p><br></p><blockquote><p>💡 换句话说，一种是满足开发需求，一种是满足业务需求。</p></blockquote><p><br></p><p>先来看开发调试。时间旅行并不是不可变数据的专属，比如 Vuex、Pinia、MobX-state-tree 这些状态管理库都能做到。它们的实现的条件和过程如下：</p><ul><li>Single Store。Store 是全局的，方便被跟踪</li><li>配套开发者工具(比如 Redux DevTool, Vue DevTool)。举例 Pinia ，它会在 Action 执行前后触发订阅事件，开发者工具可以在这些事件触发时，对 Store 进行一次镜像拷贝。有了这些镜像历史之后，就可以实现回滚操作啦。</li><li>另外状态管理库还需要在 HMR、Store Patch 上提供支持。</li></ul><p>这种「时间旅行」可以给我们的开发和调试带来极致的体验，很甜。</p><p>我们使用野生的面向对象方案，比较难实现这种效果，而且需要开发者工具的支持。 实际上，「时间旅行」的开发体验通常也不是我们选择这类方案的主要原因。</p><blockquote><p>如果想要在 MobX 上实现时间旅行，建议使用 MobX-state-tree</p></blockquote><p><br><br><br></p><hr><p><br><br><br></p><p>另一种时间旅行是满足业务上的需求，比如实现撤销/重做，甚至多人协作。</p><p>针对这种需求，笔者有以下建议：</p><ol><li>Single Store。建议将需要进行’时间旅行‘核心数据聚合到一个类中，而不是分散在不同的 Store，方便对状态进行统一管理(镜像和 patch)，实现起来也会简单很多。</li><li>单向数据流/CQRS 分离。即我们上一节介绍的内容，限制读写分离，避免意外的修改，另外可以将 action 作为一个进行镜像化的时机。</li><li>如果想要实现多人协作的需求，建议配合更专业 <code>yjs</code> 等 CDRT 方案去实现。</li></ol><p><br></p><p>对于树状结构的 Store，我们这里就简单介绍一个「镜像化」的思路。假设我们的 Store 是一颗树状结构：</p><p><img src="/images/mobx/Untitled%205.png" alt="Untitled"></p><p><br></p><p>我们可以设计一个 Serializable 接口：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实现序列化，时间旅行功能。</span><br><span class="line"> */</span><br><span class="line">export interface Serializable&lt;T = any&gt; &#123;</span><br><span class="line">  applySnapshot(snapshot: T): void</span><br><span class="line">  toSnapshot(): T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>让需要实现镜像化的 Model 和 Store 都实现这个接口, 我们只需自顶向下调用 toSnapshot 就可以构造一个镜像:</p><p><img src="/images/mobx/Untitled%206.png" alt="Untitled"></p><p><br></p><p>但这种效率并不高，一个小的变动就需要序列化一棵树。我们可以在这个基础上再加上一些脏标记或者版本号之类的，来避免不必要的序列化：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface Serializable&lt;T = any&gt; &#123;</span><br><span class="line">  applySnapshot(snapshot: T): void</span><br><span class="line">  toSnapshot(): T</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 脏标记, 返回一个 boolean 表示是否成功标记</span><br><span class="line">   * reason 表示变更的原因</span><br><span class="line">   * source 表示变更触发的源头, 默认是 this</span><br><span class="line">   */</span><br><span class="line">  markDirty(reason: string, source?: any): boolean</span><br><span class="line"></span><br><span class="line">  isDirty(): boolean</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 父级</span><br><span class="line">   */</span><br><span class="line">  administrator: Serializable&lt;any&gt; | null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>镜像化的过程，类似于 DOM 的事件冒泡机制的形式:</p><p><img src="/images/mobx/Untitled%207.png" alt="Untitled"></p><p>假设我们在 Model Foo 中执行了 Action，我们就将 Model Foo 标记为 dirty，接着<code>冒泡调用</code>父级的 markDirty， 直到根节点终止。接下来，从根节点开始向下递归调用 <code>toSnapshot</code>, 如果节点没有被标记为 Dirty ，那么返回之前缓存的结果就行了。</p><p>对于复杂的场景，笔者还是建议配合 yjs 这类库区实现。后续会有专门的文章来介绍这块，敬请期待。</p><p><br><br><br><br><br><br><br></p><h3 id="精细渲染"><a href="#精细渲染" class="headerlink" title="精细渲染"></a>精细渲染</h3><p>精细渲染是视图框架实现高性能渲染的一<a href="https://juejin.cn/post/7251763342954512440" target="_blank" rel="noopener">个重要方向之一</a>。可变数据和不可变数据的两者各有千秋.</p><p><br></p><p>可变数据，我们通常使用响应式数据(事件/订阅模式)的方案，在渲染过程中收集数据订阅，当这些数据变更时，触发对应组件的渲染。</p><p><img src="/images/mobx/Untitled%208.png" alt="Untitled"></p><p>举个例子，View 2.1 订阅了 bar，那么 bar 变更时，仅需重新渲染 View 2.1。</p><p><br></p><hr><p><br></p><p>而不可变数据的精细化渲染则是基于<code>不可变数据</code>的<code>可缓存性</code>，那对应的组件就是<code>缓存函数</code>（记忆函数，memoize）。也就是说，如果视图依赖的数据没有变更，那么可以假设不需要重新渲染视图：</p><p><img src="/images/mobx/Untitled%209.png" alt="Untitled"></p><p>假设 bazz 修改了:</p><p><img src="/images/mobx/Untitled%2010.png" alt="Untitled"></p><p>视图层自上而下比对，如果输入(props or state) 不变，就可以跳过渲染。</p><p><br></p><p>实际应用中，<strong>不可变数据的精细化的实施成本相对较高</strong>。如果严格按照这套逻辑，我们通常需要分离状态，将衍生数据、 组件都标记为 <code>memoize</code> (组件使用 React.memo 或 PureComponent，衍生数据使用 useMemo)。</p><blockquote><p>💡  为了解决繁琐的 memo 逻辑，React 在 React Conf 2021 上曾提出过 <a href="https://www.youtube.com/watch?v=lGEMwh32soc" target="_blank" rel="noopener">React Forget</a> 的计划。</p></blockquote><blockquote><p>Svelte 则是另外一种思路，通过静态编译阶段分析数据变更的影响范围，并生成变更拦截代码。更加精细和高效</p></blockquote><p>结论就是，在精细化渲染方面，响应式数据则更容易实施，没有那么多心智负担，<strong>对于初级开发者也不太容易写出性能差的应用</strong>。</p><p><br><br><br><br><br></p><h2 id="应用到视图"><a href="#应用到视图" class="headerlink" title="应用到视图"></a>应用到视图</h2><p>接下来我们讨论如何将我们的 Store 注入到视图，以及这些 Store 对象生命周期的管理。</p><p><br></p><h3 id="注入视图层"><a href="#注入视图层" class="headerlink" title="注入视图层"></a>注入视图层</h3><p>视图注入有两种方式。一种是利用视图框架提供的 Context/provide-inject 功能：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// in vue</span><br><span class="line">// 提供</span><br><span class="line">const store = new Store()</span><br><span class="line">provide(key, store)</span><br><span class="line">onUnmounted(() =&gt; dispose(store))</span><br><span class="line"></span><br><span class="line">// 页面消费</span><br><span class="line">const store = inject(key)</span><br></pre></td></tr></table></figure><p>稍微封装一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Disposable &#123;</span><br><span class="line">  dispose?: () =&gt; void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createStore&lt;T extends new () =&gt; T&gt;(Store: T) &#123;</span><br><span class="line">  const key: InjectionKey&lt;T&gt; = Symbol(Store.name)</span><br><span class="line"></span><br><span class="line">  const _provide = () =&gt; &#123;</span><br><span class="line">    const store = new Store()</span><br><span class="line">    provide(key, store)</span><br><span class="line"></span><br><span class="line">    onUnmounted(() =&gt; &#123;</span><br><span class="line">      // 销毁</span><br><span class="line">      ;(store as Disposable).dispose?.()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const _inject = () =&gt; &#123;</span><br><span class="line">    return inject(key)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return [_provide, _inject]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">const [provideMyStore, useMyStore] = createStore(MyStore)</span><br><span class="line"></span><br><span class="line">// provide in parent view</span><br><span class="line">provideMyStore()</span><br><span class="line"></span><br><span class="line">// consume in children view</span><br><span class="line">useMyStore()</span><br></pre></td></tr></table></figure><p>大部分简单的场景，这已经足够了。</p><p><br></p><hr><p><br></p><p>更复杂的场景，比如 Store 对象之间有复杂的依赖关系，这些对象的作用域和生命周期规则也比较复杂。这时候就可以考虑引入<code>依赖注入</code>方案了, 比如<a href="https://github.com/mgechev/injection-js" target="_blank" rel="noopener">injection-js</a>、<a href="https://github.com/inversify/InversifyJS" target="_blank" rel="noopener">inversify</a>、<a href="https://github.com/Microsoft/tsyringe" target="_blank" rel="noopener">tsyringe</a>。</p><p><br></p><p>依赖注入的优势，笔者就不在这里展开说了。下面是笔者公司<a href="https://www.notion.so/wakeapp-framework-b08cb3cb5f8e49f597aa90bbb89a1641?pvs=21" target="_blank" rel="noopener">内部框架</a>的代码示例：</p><ol><li><p>创建模型： CounterModel.ts</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;injectable, page&#125; <span class="keyword">from</span> <span class="string">'@wakeapp/framework'</span></span><br><span class="line"><span class="keyword">import</span> &#123; makeObservable, observable &#125; <span class="keyword">from</span> <span class="string">'mobx'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明需求映射</span></span><br><span class="line">declare global &#123;</span><br><span class="line">  interface DIMapper &#123;</span><br><span class="line">    <span class="string">'DI.CounterModel'</span>: CounterModel</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line">@injectable()</span><br><span class="line">@page()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterModel</span> </span>&#123;</span><br><span class="line">  @observable</span><br><span class="line">  count: number = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  constrcutor() &#123;</span><br><span class="line">    makeObservable(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  increment = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.count++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  decrement = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.count--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费 CounterPage.tsx</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useInject &#125; <span class="keyword">from</span> <span class="string">'@wakeapp/framework'</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">'mobx-react'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 observer 包裹，让组件可以监听 mobx 响应式数据的变动</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CounterPage = observer(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> counter = useInject(<span class="string">'DI.CounterModel'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">onClick</span>=<span class="string">&#123;counter.increment&#125;</span>&gt;</span>&#123;counter.count&#125;<span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>更多介绍，可以见<a href="https://www.notion.so/wakeapp-framework-b08cb3cb5f8e49f597aa90bbb89a1641?pvs=21" target="_blank" rel="noopener">这里</a></p><p><br><br><br><br><br></p><h3 id="对象生命周期"><a href="#对象生命周期" class="headerlink" title="对象生命周期"></a>对象生命周期</h3><p>模型对象的生命周期如何管理呢?</p><p>大部分情况下，我们都不需要复杂的对象生命管理，让它随页面而生，随页面销毁而死就行了，比如上一节提到的第一种视图注入方案。我们只需要在视图根节点或者页面节点创建 Store，在节点销毁时 dispose 掉。</p><p><br><br><br></p><p>如果使用<code>依赖注入</code>的方式就可以对对象进行更精细的生命周期管理。比如：</p><table><thead><tr><th>类型</th><th>描述</th><th>挂靠对象</th><th>场景</th></tr></thead><tbody><tr><td>singleton</td><td>单例。在整个应用生命周期内存在，有且只有一个实例</td><td>应用</td><td>全局数据，跨页面共享数据</td></tr><tr><td>container</td><td>子容器单例。 singleton 实际上就是在全局容器的单例</td><td>子容器</td><td>数据隔离</td></tr><tr><td>page</td><td>页面。和页面的生命周期挂靠，在当前页面中，有且只有一个实例。 <br> 可以认为就是为每个页面创建 container</td><td>页面</td><td>需要在同一个页面组件层级下共享的数据。</td></tr><tr><td>request</td><td>请求。在一次请求中有且只有一个实例。</td><td>请求</td><td></td></tr><tr><td>transient 默认</td><td>临时。每次请求都会创建一个实例</td><td></td><td>临时数据</td></tr></tbody></table><p>更详细的介绍可以看看 <a href="https://github.com/inversify/InversifyJS" target="_blank" rel="noopener">InversifyJS</a>、<a href="https://github.com/Microsoft/tsyringe" target="_blank" rel="noopener">tsyringe</a> 等库的文档。注意，大部分情况我们都不需要用到这么复杂的方案。</p><blockquote><p>💡 关于 SSR 的支持，由于篇幅有限，这里就不展开了</p></blockquote><p><br><br><br><br><br></p><h2 id="mobx-in-vue"><a href="#mobx-in-vue" class="headerlink" title="MobX in Vue"></a>MobX in Vue</h2><p>尽管 MobX 也提供了 <a href="https://www.npmjs.com/package/mobx-vue-lite" target="_blank" rel="noopener">Vue 绑定</a>，但是总觉得奇奇怪怪的，实际上也很少人这么用。</p><p><br><br><br></p><p>那为什么不直接基于 Vue 的 reactive API 封装类 MobX API, 支持使用 class 来编写呢？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export class CounterModel &#123;</span><br><span class="line">  @observable</span><br><span class="line">  count: number = 0</span><br><span class="line"></span><br><span class="line">  constrcutor() &#123;</span><br><span class="line">    makeObservable(this)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  increment = () =&gt; &#123;</span><br><span class="line">    this.count++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  decrement = () =&gt; &#123;</span><br><span class="line">    this.count--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说干就干，相关实现源码请见<a href="https://github.com/wakeadmin/tools/tree/main/packages/framework/src/reactive" target="_blank" rel="noopener">这里</a>， 我在 《<a href="https://juejin.cn/post/7248801590113763386" target="_blank" rel="noopener">全新 Javascript 装饰器实战上篇：用 MobX 的方式打开 Vue</a>》中也介绍过，这里懒得展开说了。</p><p><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要探讨笔者为什么选择 MobX 放在自己的武器库中：</p><ul><li>面向对象 VS 函数式，探讨面向对象范式的优势和适用场景</li><li>回归朴素编程，利用编程语言原生的能力把事情做好，放弃不必要的约束和时尚</li><li>现代状态管理库需要处理的各种问题，比如可预测性，时间旅行，精细化渲染</li><li>最后介绍如何和视图结合，以及管理复杂的对象生命周期</li></ul><p><br><br><br></p><p>2023 年了，如果视图框架趋于稳定(往服务端方向卷了)， 而状态管理器还是一个火山爆发期（可以看看 <a href="https://juejin.cn/post/7195513281228898363#heading-50" target="_blank" rel="noopener">2023 再看 React 状态管理库</a>）。</p><p><br></p><p>我还是坚持还是<a href="https://juejin.cn/post/6844903848255946766#heading-1" target="_blank" rel="noopener">三年前那句话</a>；大部分情况你不需要状态管理，其次你不需要复杂的状态管理：</p><ul><li>如果组件或者页面可以做到自包含，那么完全没必要使用状态管理，更没必要为了某些状态管理器的「最佳实践」将状态外部化。</li><li>你不需要复杂的状态管理。简单的状态管理，可以使用视图框架内置的一些能力，比如 Vue 的 provide/inject， React 的 Context。再复杂的，可以使用与视图框架心智模型相近的方案，比如 Vue + Pinia，React + Hox？</li></ul><p><br></p><p>本文的标题是我选择 MobX 的原因，并不代表我推荐你无脑地使用它。</p><p>笔者是 MobX 的重度使用者，过去几年在若干复杂的项目中应用过，这些项目不乏有 IM 应用、低代码编辑器、图形编辑器。</p><p>如果你的场景再复杂一点，特别是需要能够直观地表达对业务的抽象，对象之间有复杂的交互，那这便是面向对象的强项。当然复杂的应用不仅仅需要状态管理，面向对象方案都有较强的普适性。</p><p>不过因为它过于灵活，缺乏约束，不是所有团队都能适应，也很容易写出难以维护的代码。</p><p>时至今日，不是 MobX 「热度」不再，而是 MobX 所代表的面向对象范式光芒被暂时屏蔽了。但历史总有峰回路转的时候。</p><p><br><br><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://www.zhihu.com/question/546185320/answer/2608425396" target="_blank" rel="noopener">如何看待新开源的前端 DDD 框架 Remesh?</a></li><li><a href="https://www.zhihu.com/question/401914770/answer/2065218097" target="_blank" rel="noopener">前端是否有必要引入领域驱动设计(DDD)？</a></li><li><a href="https://github.com/jherr/which-react-state-manager" target="_blank" rel="noopener">which-react-state-manager</a></li><li><a href="https://zhuanlan.zhihu.com/p/32107541" target="_blank" rel="noopener">从时间旅行的乌托邦，看状态管理的设计误区</a></li><li><a href="https://juejin.cn/post/7195513281228898363#heading-50" target="_blank" rel="noopener">2023 再看 React 状态管理库</a></li><li><a href="https://juejin.cn/post/7153071955405439012" target="_blank" rel="noopener">React 状态管理器，我是这样选的</a></li><li><a href="https://zhuanlan.zhihu.com/p/408512128" target="_blank" rel="noopener">使用函数式语言实践DDD</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/mobx/Untitled.jpeg&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;时至今日，前端的各种状态管理方案仍层出不穷，花式百样，争议不断，尤其是 React 社区。那我为什么要“背道而驰”，选择基本没什么声音的 MobX 呢？
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>AI 调教师：绘制 ER 图</title>
    <link href="https://bobi.ink/2023/07/26/ai-build-er/"/>
    <id>https://bobi.ink/2023/07/26/ai-build-er/</id>
    <published>2023-07-25T16:00:00.000Z</published>
    <updated>2023-07-26T01:57:28.331Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ai-build-er/Untitled.png" alt="Untitled"></p><p><br></p><p><img src="/images/ai-build-er/Untitled.gif" alt="Untitled"></p><p>在上一篇文章中，我们<a href="https://juejin.cn/post/7258150367120310332" target="_blank" rel="noopener">让 ChatGPT 来帮我们写 SQL 语句</a>, 现在我们再挑战一下，让 ChatGPT 来帮我们数据建模。</p><p><br></p><p>如上图，我们希望能做到比如：</p><ul><li>创建数据模型，让 ChatGPT 帮我们推断表应该包含的字段、字段类型、主键、索引、表之间的关联关系等等</li><li>优化数据模型。对现有的数据模型进行扩展和优化</li><li>对数据模型及其字段进行增删改。</li><li>…</li></ul><p><br></p><p>要 ChatGPT 处理这么「复杂」的需求，其实有点难度。我们从最简单的需求开始，先让 ChatGPT 将用户的需求转换为数据模型，并返回 JSON 格式：</p><p><br></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">你是一个数据库建模专家, 你会根据用户的提示进行数据库概念建模, 假设实体(表)有多个字段(属性), 这些字段支持以下类型:</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Boolean</span><br><span class="line"><span class="bullet">- </span>Date</span><br><span class="line"><span class="bullet">- </span>DateTime</span><br><span class="line"><span class="bullet">- </span>Timestamp</span><br><span class="line"><span class="bullet">- </span>Integer</span><br><span class="line"><span class="bullet">- </span>Decimal</span><br><span class="line"><span class="bullet">- </span>Long</span><br><span class="line"><span class="bullet">- </span>Double</span><br><span class="line"><span class="bullet">- </span>Float</span><br><span class="line"><span class="bullet">- </span>String</span><br><span class="line"><span class="bullet">- </span>Text</span><br><span class="line"><span class="bullet">- </span>LongText</span><br><span class="line"><span class="bullet">- </span>JSON</span><br><span class="line"><span class="bullet">- </span>Reference</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">引用关系的描述：</span><br><span class="line"></span><br><span class="line">其中 Reference 类型表示对其他实体的引用，比如 引用了 B 实体的 b 字段，会这样表示: &#123;"type": "Reference", "target": "B", "property": "b", "cardinality": "OneToMany" &#125;</span><br><span class="line"></span><br><span class="line">cardinality 可选值有: OneToOne, OneToMany, ManyToOne, ManyToMany</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">如果是主键，需要将字段的 primaryKey 设置为 true</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">举个例子，用户输入: """创建一个用户, 这个用户有多个地址"""", 你应该返回：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line"><span class="code">    "name": "User",</span></span><br><span class="line"><span class="code">    "title": "用户",</span></span><br><span class="line"><span class="code">    "properties": [</span></span><br><span class="line"><span class="code">      &#123;</span></span><br><span class="line"><span class="code">        "name": "id",</span></span><br><span class="line"><span class="code">        "title": "用户唯一 id",</span></span><br><span class="line"><span class="code">        "primaryKey": true,</span></span><br><span class="line"><span class="code">        "type": &#123; "type": "Long" &#125;</span></span><br><span class="line"><span class="code">      &#125;,</span></span><br><span class="line"><span class="code">      &#123;</span></span><br><span class="line"><span class="code">        "name": "name",</span></span><br><span class="line"><span class="code">        "title": "用户名",</span></span><br><span class="line"><span class="code">        "type": &#123; "type": "String" &#125;</span></span><br><span class="line"><span class="code">      &#125;</span></span><br><span class="line"><span class="code">    ]</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line"><span class="code">    "name": "Address",</span></span><br><span class="line"><span class="code">    "title": "地址",</span></span><br><span class="line"><span class="code">    "properties": [</span></span><br><span class="line"><span class="code">      &#123;</span></span><br><span class="line"><span class="code">        "name": "id",</span></span><br><span class="line"><span class="code">        "title": "唯一 id",</span></span><br><span class="line"><span class="code">        "primaryKey": true,</span></span><br><span class="line"><span class="code">        "type": &#123; "type": "Long" &#125;</span></span><br><span class="line"><span class="code">      &#125;,</span></span><br><span class="line"><span class="code">      &#123;</span></span><br><span class="line"><span class="code">        "name": "value",</span></span><br><span class="line"><span class="code">        "title": "详细地址",</span></span><br><span class="line"><span class="code">        "type": &#123; "type": "String" &#125;</span></span><br><span class="line"><span class="code">      &#125;,</span></span><br><span class="line"><span class="code">      &#123;</span></span><br><span class="line"><span class="code">        "name": "userId",</span></span><br><span class="line"><span class="code">        "title": "用户引用",</span></span><br><span class="line"><span class="code">        "type": &#123; "type": "Reference", "target": "User", "property": "id", "cardinality": "ManyToOne" &#125;</span></span><br><span class="line"><span class="code">      &#125;</span></span><br><span class="line"><span class="code">    ]</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">你可以根据问题创建多个对象，以数组的形式返回。上面的例子只是一个格式示范, 不要照搬，你需要根据用户的提示, 以及你的数据库建模的丰富经验和行业的最佳实践来回答。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">以 JSON 数组的格式回答，不要解释</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">当你无法理解请求时， 请回答直接返回：</span><br><span class="line"></span><br><span class="line">[SORRY]</span><br><span class="line"></span><br><span class="line">不要解释</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p><br></p><p>这个 Prompt 结构算是比较典型：</p><ul><li>角色定义。数据库建模专家</li><li>任务。将用户需求转换为概念模型</li><li>规则。字段的类型，引用关系的描述，主键</li><li>输出规则。输出 JSON，如果失败就返回 <code>[SORRY]</code></li><li>示例。</li></ul><p><br></p><p>这个 Prompt 大部分情况运行还好，调试的过程中发现的一些坑，也体现在 Prompt 里面了，比如</p><p><br></p><ul><li>我们想让它返回 JSON 格式，但是它可能会夹带一些解释，导致没办法直接 JSON.parse</li><li>它可能会直接照搬我们给它的示例</li></ul><p><br></p><p>这是我们最初的 Prompt 版本，仅支持创建新数据模型，而且没有结合已有的数据模型上下文来输出结果。我们还需要继续优化。</p><p><br><br><br><br><br></p><h1 id="设计原子操作"><a href="#设计原子操作" class="headerlink" title="设计原子操作"></a>设计原子操作</h1><p>在需求明确之后，我们首先需要设计接入 AI 的原子操作，在上面的需求中，我们无非是希望通过 AI 对我们的数据模型进行<code>增删改</code>。当然这不是简单的转换，我们还希望 ChatGPT 能在这里发挥<code>推导</code>和<code>演绎</code>的能力。</p><p><br></p><p>基于此，我们设计了以下原子操作</p><ul><li>表操作<ul><li>新增表</li><li>修改表</li><li>重命名表</li><li>删除表</li></ul></li><li>字段操作<ul><li>创建字段</li><li>修改字段</li><li>重命名字段</li><li>删除字段</li></ul></li></ul><p>另外我们还要考虑安全性的约束，比如不能删除和引用不存在的表和字段。</p><p><br></p><p>于是，我们重新整理了 Prompt 需求：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">You are an expert in conceptual modeling for relational databases. let's play a game, You need to parsing user inputs and converting them into a series of TASKs.</span><br><span class="line"></span><br><span class="line">Here are some rules:</span><br><span class="line"></span><br><span class="line">Rule 1: The following descriptions are equivalent:</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>table, entity, model, 实体,表,数据对象, 模型</span><br><span class="line"><span class="bullet">- </span>field, property, 字段, 属性, 表字段, 表属性,实体属性</span><br><span class="line"><span class="bullet">- </span>name,名称,名,标识符</span><br><span class="line"><span class="bullet">- </span>title,标题,中文名</span><br><span class="line"><span class="bullet">- </span>rename, 重命名,修改标识符, 修改名称</span><br><span class="line"><span class="bullet">- </span>retitle, 重命名标题,修改标题</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">Rule 2: The types of TASK:</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>createTable:</span><br><span class="line">  - name: table name in upper camel case</span><br><span class="line">  - title: table title in chinese</span><br><span class="line"><span class="bullet">- </span>updateTable:</span><br><span class="line">  - name</span><br><span class="line">  - title</span><br><span class="line"><span class="bullet">- </span>renameTable</span><br><span class="line">  - name</span><br><span class="line">  - newName: the new table new in upper camel case</span><br><span class="line"><span class="bullet">- </span>removeTable:</span><br><span class="line">  - name</span><br><span class="line"><span class="bullet">- </span>addField:</span><br><span class="line">  - table: table name</span><br><span class="line">  - name: field name in lower camel case</span><br><span class="line">  - title: field title in chinese</span><br><span class="line">  - type: field type</span><br><span class="line"><span class="code">    - Boolean</span></span><br><span class="line"><span class="code">    - Date</span></span><br><span class="line"><span class="code">    - DateTime</span></span><br><span class="line"><span class="code">    - Timestamp</span></span><br><span class="line"><span class="code">    - Integer</span></span><br><span class="line"><span class="code">    - Decimal</span></span><br><span class="line"><span class="code">    - Long</span></span><br><span class="line"><span class="code">    - Double</span></span><br><span class="line"><span class="code">    - Float</span></span><br><span class="line"><span class="code">    - String</span></span><br><span class="line"><span class="code">    - Text</span></span><br><span class="line"><span class="code">    - LongText</span></span><br><span class="line"><span class="code">    - JSON</span></span><br><span class="line"><span class="code">    - Reference: reference to other table</span></span><br><span class="line">  - reference: reference to other table field, for example: Table.field</span><br><span class="line">  - referenceCardinality: OneToOne, OneToMany, ManyToOne, ManyToMany</span><br><span class="line">  - primaryKey: optional, true or false</span><br><span class="line">  - notNull: optional, true or false</span><br><span class="line"><span class="bullet">- </span>removeField: remove the table field</span><br><span class="line">  - table</span><br><span class="line">  - name</span><br><span class="line"><span class="bullet">- </span>updateField: update the table field</span><br><span class="line">  - table</span><br><span class="line">  - name</span><br><span class="line">  - title</span><br><span class="line">  - type</span><br><span class="line">  - reference</span><br><span class="line">  - referenceCardinality</span><br><span class="line">  - primaryKey</span><br><span class="line">  - notNull</span><br><span class="line"><span class="bullet">- </span>renameField: rename the table field</span><br><span class="line">  - table</span><br><span class="line">  - name: old field name</span><br><span class="line">  - newName: new field name in lower camel case</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">Rule 3: CANNOT reference non-existent tables.</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">Rule 4: please response in chinese</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>在这里我们要求 ChatGPT 将用户的输入转换为一系列的 <code>Task</code>。以及这些 Task 的 <code>Schema</code>。</p><blockquote><p>💡  这里为什么使用英文？有两个原因, ChatGPT 大部分的训练集是英文；还有中文在表述相同的事情占用的 Token 通常要高于英语。</p></blockquote><p><br><br><br><br><br><br><br></p><h1 id="few-shot-prompting"><a href="#few-shot-prompting" class="headerlink" title="Few-shot Prompting"></a>Few-shot Prompting</h1><p>我们描述好需求了，但是还没有告诉 ChatGPT 应该返回怎样的数据，ChatGPT 只能自己 YY 了：</p><p><img src="/images/ai-build-er/Untitled%201.png" alt="Untitled"></p><p><br><br><br></p><p>解决办法是给 ChatGPT 更多示例，这种技巧称之为 “<a href="https://learningprompt.wiki/docs/chatGPT/tutorial-extras/Few-Shot%20Prompting" target="_blank" rel="noopener"><code>Few-Shot Prompting</code></a>”，像 ChatGPT 这种统计模型，实际上是读不懂我们上面的需求的，它是基于“概率预测”来输出内容。</p><p>我们在上面 Prompt 的基础上加上一些示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Here is same demo:</span><br><span class="line"></span><br><span class="line"><span class="section">#### START OF DEMO 1</span></span><br><span class="line"></span><br><span class="line">Given Tables:</span><br><span class="line"></span><br><span class="line">"""</span><br><span class="line">[not table here]</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">USER: """删除订单表"""</span><br><span class="line">ASSISTANT: """订单表不存在，无法删除"""</span><br><span class="line">explain: If the manipulated table is not in 'Given tables', you should stop the game</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """给所有表都加上更新时间和创建时间"""</span><br><span class="line">ASSISTANT: """不存在表，无法添加字段"""</span><br><span class="line">explain: table not exist</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER:"""创建一个用户, 这个用户有多个地址"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">%%createTable name="User" title="用户"%%</span><br><span class="line">%%createTable name="Address" title="地址"%%</span><br><span class="line"></span><br><span class="line">%%addField table="User" name="id" title="用户 id" type="Long" primaryKey="true" notNull="true"%%</span><br><span class="line">%%addField table="User" name="name" title="用户名" type="String" notNull="true"%%</span><br><span class="line">%%addField table="User" name="avatar" title="头像" type="String" %%</span><br><span class="line">%%addField table="User" name="home" title="主页" type="String" %%</span><br><span class="line"></span><br><span class="line">%%addField table="Address" name="id" title="地址 id" type="Long" primaryKey="true" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="userId" title="用户引用" type="Reference" reference="User.id" referenceCardinality="ManyToOne" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="street" title="街道" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="city" title="城市" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="state" title="州" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="country" title="国家" type="String" notNull="true"%%</span><br><span class="line">"""</span><br><span class="line">explain: create User and Address Table, User has many Address, Address belongs to User, so Address to User is ManyToOne.</span><br><span class="line"></span><br><span class="line"><span class="section">#### END of DEMO 1</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="section">#### START OF DEMO 2</span></span><br><span class="line"></span><br><span class="line">Given tables:</span><br><span class="line"></span><br><span class="line">"""</span><br><span class="line">Table A (</span><br><span class="line">  foo: Long;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Table B (</span><br><span class="line">  bar: Long;</span><br><span class="line">)</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """修改 A 的 foo 标题为用户唯一标识"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">%%updateField table="A" name="foo" title="用户唯一标识" %%</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """将 B 重命名为账号"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">%%updateTable name="B" title="账号"%%</span><br><span class="line">%%renameTable name="B" newName="Account"%%</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """将所有表下的所有属性名称都加上 o 前缀"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">%%renameField table="A" name="foo" newName="oFoo" %%</span><br><span class="line">%%renameField table="B" name="bar" newName="oBar" %%</span><br><span class="line">"""</span><br><span class="line">explain: rename all fields in given tables</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """删除 C"""</span><br><span class="line">ASSISTANT: """C 不存在，无法删除"""</span><br><span class="line">explain: If the manipulated table is not in 'Given tables'</span><br><span class="line"></span><br><span class="line"><span class="section">#### END of DEMO 2</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### START OF DEMO 3</span></span><br><span class="line"></span><br><span class="line">Given tables:</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line"><span class="section"># 用户</span></span><br><span class="line"></span><br><span class="line">Table User (</span><br><span class="line">id: Long, PrimaryKey;</span><br><span class="line">name: String;</span><br><span class="line">age: String;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """完善和优化用户"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">%%addField table="User" name="avatar" title="头像" type="String" %%</span><br><span class="line">%%addField table="User" name="home" title="主页" type="String" %%</span><br><span class="line">%%addField table="User" name="password" title="密码" type="String" notNull="true" %%</span><br><span class="line">"""</span><br><span class="line">explain: improve User Table</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """创建地址表"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">%%createTable name="Address" title="地址"%%</span><br><span class="line">%%addField table="Address" name="id" title="地址 id" type="Long" primaryKey="true" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="street" title="街道" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="city" title="城市" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="state" title="州" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="country" title="国家" type="String" notNull="true"%%</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="section">#### END of DEMO 3</span></span><br><span class="line"></span><br><span class="line">Ok, FORGET the DEMO given tables above, let's start the new game</span><br><span class="line"></span><br><span class="line"><span class="section">#### START GAME</span></span><br><span class="line"></span><br><span class="line">Given Tables:</span><br><span class="line"></span><br><span class="line">$&#123;tables ?? '[not table here]'&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """$&#123;input&#125;"""</span><br><span class="line">ASSISTANT: """</span><br></pre></td></tr></table></figure><p><br></p><p>这些示例覆盖了很多场景：</p><ul><li>数据模型为空时。各种安全性的检查</li><li>表结构、关联关系的推导</li><li>表结构的增删改</li><li>输出的格式</li><li>…</li></ul><p><br><br><br></p><p>你可能有这些疑问：</p><p><strong>为什么需要这么多示例？</strong></p><p>这些示例只是覆盖了各种已知的交互场景，如果没有给 ChatGPT 提供相关的示例，它并不知道怎么处理或者处理效果不好。未来随着更多场景被扩展， 示例会越来越多。</p><p><br><br><br></p><p>为什么使用 <code>%%&lt;&gt;%%</code> 这种格式，而不是 JSON？</p><p>ChatGPT 很‘任性’， 它不一定听你话，只返回 JSON。而且我们可能需要等待所有消息接收完毕之后才能开始处理，%%&lt;&gt;%% 则能以流的形式一边接收一边处理。最后就是它的结构更容易描述</p><p><br><br><br></p><p><img src="/images/ai-build-er/Untitled%202.png" alt="Untitled"></p><p><strong>Prompt 这么长？Token 够吗？</strong></p><p>这个版本的 Prompt 在没有算上数据模型上下文的情况下，已经达到 2000+ token 了。好在现在 GPT 3.5 有 16k 版本，GPT 4 最少也有 8k, 是够用的。当然 GPT4 有点小贵</p><p><br><br><br><br><br></p><p>执行效果：</p><p><img src="/images/ai-build-er/Untitled%203.png" alt="Untitled"></p><p>这里发现了一个有趣的想象，ChatGPT 模仿我们的示例套路(USER、ASSISTANT)，继续重复输出了很多内容。<strong>这实锤 ChatGPT 就是复读机了</strong>。</p><p>通过反复的调试，你会发现，我们在一开始定义的”需求规则” 对 ChatGPT 的影响微乎其微，甚至会直接忽略它们。<strong>它更多是从示例中学习规律</strong>。</p><p>那怎么避免这种重复呢？可以通过 ChatGPT API 的 <code>stop</code> 参数来告诉它什么时候终止。这里我们设置为 <code>&quot;&quot;&quot;</code> 即可。</p><p><br><br><br><br><br></p><h1 id="思维链"><a href="#思维链" class="headerlink" title="思维链"></a>思维链</h1><p>上面的 Prompt 还有一些缺陷。我们发现 ChatGPT 就是一个复读机，基本上只会照搬我们的示例。主要的原因是 ChatGPT 只知道结果，而不知道过程，所以推理能力就比较有限。</p><p>因此我们就需要引入 Few-shot Prompt 的进阶技巧 —— <strong><a href="https://learningprompt.wiki/docs/chatGPT/tutorial-tips/%E6%8A%80%E5%B7%A78%EF%BC%9AFew-Shot%20Chain%20of%20Thought" target="_blank" rel="noopener">Few-Shot Chain of Thought</a>：</strong></p><p><br></p><blockquote><p>通过向大语言模型展示一些少量的样例，并在样例中解释推理过程，大语言模型在回答提示时也会显示推理过程。这种推理的解释往往会引导出更准确的结果。</p></blockquote><p><br><br><br></p><p>继续重构和改进：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">You are an expert in the conceptual design of relational databases, and you need to parse the user's input according to the following steps, and then convert it into a series of operation tasks.</span><br><span class="line"></span><br><span class="line">Step 1: Analyze which tables need to be created. You should infer the fields, types, primary keys, relationships, indices, etc. of the table.</span><br><span class="line">Step 2: Analyze which tables need to be deleted.</span><br><span class="line">Step 3: Analyze which tables need to be updated, including adding fields, deleting fields, modifying field types, modifying field names, etc.</span><br><span class="line">Step 4: Analyze unsafe operations, such as repeated creation, deletion of non-existent tables, modification of non-existent tables, modification of non-existent fields, deletion of non-existent fields, etc. If there are unsafe operations, immediately terminate and return an error message.</span><br><span class="line">Step 5: Convert the analysis results into the form of %%&lt;action&gt; &lt;key&gt;="&lt;value&gt;"%% to return, and the action structure must conform to the defined Action type:</span><br><span class="line"></span><br><span class="line">\<span class="code">`\`</span>\`typescript</span><br><span class="line">type Action = CreateTable | UpdateTable | RemoveTable | AddField | RemoveField | updateField | RenameField;</span><br><span class="line"></span><br><span class="line">type CreateTable = &#123;</span><br><span class="line">  action: 'createTable';</span><br><span class="line">  name: string; // table name in upper camel case</span><br><span class="line">  title: string; // table name in chinese</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type UpdateTable = &#123;</span><br><span class="line">  action: 'updateTable';</span><br><span class="line">  name: string; // table name in upper camel case</span><br><span class="line">  title: string; // table name in chinese</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type RemoveTable = &#123;</span><br><span class="line">  action: 'removeTable';</span><br><span class="line">  name: string;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type FieldType =</span><br><span class="line">  | 'Boolean'</span><br><span class="line">  | 'Data'</span><br><span class="line">  | 'DateTime'</span><br><span class="line">  | 'Timestamp'</span><br><span class="line">  | 'Integer'</span><br><span class="line">  | 'Decimal'</span><br><span class="line">  | 'Long'</span><br><span class="line">  | 'Double'</span><br><span class="line">  | 'Float'</span><br><span class="line">  | 'String'</span><br><span class="line">  | 'Text'</span><br><span class="line">  | 'LongText'</span><br><span class="line">  | 'JSON'</span><br><span class="line">  | 'Reference';</span><br><span class="line"></span><br><span class="line">type ReferenceCardinality = 'OneToOne' | 'OneToMany' | 'ManyToOne' | 'ManyToMany';</span><br><span class="line"></span><br><span class="line">type AddField = &#123;</span><br><span class="line">  action: 'addField';</span><br><span class="line">  table: string; // table name</span><br><span class="line">  name: string; // field name in lower camel case</span><br><span class="line">  title: string; // field name in chinese</span><br><span class="line">  type: FieldType;</span><br><span class="line">  reference?: string; // reference to other table field, for example: Table.field</span><br><span class="line">  referenceCardinality?: ReferenceCardinality;</span><br><span class="line">  primaryKey?: boolean;</span><br><span class="line">  notNull?: boolean;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type RemoveField = &#123;</span><br><span class="line">  action: 'removeField';</span><br><span class="line">  table: string; // table name</span><br><span class="line">  name: string; // field name</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type updateField = &#123;</span><br><span class="line">  action: 'updateField';</span><br><span class="line">  table: string; // table name</span><br><span class="line">  name: string; // field name in lower camel case</span><br><span class="line">  title?: string; // field name in chinese</span><br><span class="line">  type?: FieldType;</span><br><span class="line">  reference?: string; // reference to other table field, for example: Table.field</span><br><span class="line">  referenceCardinality?: ReferenceCardinality;</span><br><span class="line">  primaryKey?: boolean;</span><br><span class="line">  notNull?: boolean;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type RenameField = &#123;</span><br><span class="line">  action: 'renameField';</span><br><span class="line">  table: string; // table name</span><br><span class="line">  name: string; // field name in lower camel case</span><br><span class="line">  newName: string; // new field name in lower camel case</span><br><span class="line">&#125;;</span><br><span class="line">\<span class="code">`\`</span>\`</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>上面的 Prompt 做了以下几点改进：</p><p><br></p><ul><li>我们拆解了整个推导的过程：<ul><li>第一步：识别需要创建的表格，以及对应的字段、字段类型、主键、关联关系等等</li><li>第二步：识别需要删除的表格</li><li>第三步：识别需要更新的字段</li><li>第四步：识别不安全的操作，如果存在不安全的操作就终止生成</li><li>第五步：将上面的结果转换为 DSL。</li></ul></li><li>我们使用 Typescript 来描述 DSL 的 Schema。我在上一篇文章*<strong>*<a href="https://juejin.cn/post/7259188522308550716" target="_blank" rel="noopener">AI 调教师：聊聊 TypeChat 以及 ChatGPT 形式化输出</a></strong> 大概介绍过 ChatGPT 的形式化输出能力。ChatGPT 可能很好地识别 Typescript</li></ul><p><br><br><br></p><p>接着我们再优化示例，加上上述的推导步骤：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Here is same demo:</span><br><span class="line"></span><br><span class="line"><span class="section">#### START OF DEMO 1</span></span><br><span class="line"></span><br><span class="line">Given Tables:</span><br><span class="line"></span><br><span class="line">"""</span><br><span class="line">[not table here]</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">USER: """删除订单表"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">step 1: 不需要创建表</span><br><span class="line">step 2: 删除订单表</span><br><span class="line">step 3: 不需要更新表</span><br><span class="line">step 4: 未定义任何表，订单表不存在, 终止</span><br><span class="line"></span><br><span class="line">结果: 不能删除订单表, 订单表不存在</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """给所有表都加上更新时间和创建时间"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">step 1: 不需要创建表</span><br><span class="line">step 2: 不需要删除表</span><br><span class="line">step 3: 不存在表，不需要更新操作</span><br><span class="line">step 4: 未定义任何表, 没有可以更新的表，终止</span><br><span class="line"></span><br><span class="line">结果：不存在表，无法添加字段</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER:"""创建一个用户, 这个用户有多个地址"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">step 1: 需要创建用户表和地址表, 用户和地址是一对多关系，所以地址表需要有一个用户引用字段。推断用户表应该包含 id、name、avatar、home 字段，地址表应该包含 id、userId、street、city、state、country 字段。</span><br><span class="line">step 2: 不需要删除表</span><br><span class="line">step 3: 不需要更新表</span><br><span class="line">step 4: 操作安全</span><br><span class="line">step 5: 输出结果</span><br><span class="line"></span><br><span class="line">%%createTable name="User" title="用户"%%</span><br><span class="line">%%createTable name="Address" title="地址"%%</span><br><span class="line"></span><br><span class="line">%%addField table="User" name="id" title="用户 id" type="Long" primaryKey="true" notNull="true"%%</span><br><span class="line">%%addField table="User" name="name" title="用户名" type="String" notNull="true"%%</span><br><span class="line">%%addField table="User" name="avatar" title="头像" type="String" %%</span><br><span class="line">%%addField table="User" name="home" title="主页" type="String" %%</span><br><span class="line"></span><br><span class="line">%%addField table="Address" name="id" title="地址 id" type="Long" primaryKey="true" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="userId" title="用户引用" type="Reference" reference="User.id" referenceCardinality="ManyToOne" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="street" title="街道" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="city" title="城市" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="state" title="州" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="country" title="国家" type="String" notNull="true"%%</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line"><span class="section">#### END of DEMO 1</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="section">#### START OF DEMO 2</span></span><br><span class="line"></span><br><span class="line">Given tables:</span><br><span class="line"></span><br><span class="line">"""</span><br><span class="line">Table A (</span><br><span class="line">  foo: Long;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Table B (</span><br><span class="line">  bar: Long;</span><br><span class="line">)</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """修改 A 的 foo 标题为用户唯一标识"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">step 1: 不需要创建表</span><br><span class="line">step 2: 不需要删除表</span><br><span class="line">step 3: 更新 A 表的 foo 字段的 title 为 '用户唯一标识'</span><br><span class="line">step 4: 操作安全</span><br><span class="line">step 5: 输出结果</span><br><span class="line"></span><br><span class="line">%%updateField table="A" name="foo" title="用户唯一标识" %%</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """将 B 重命名为账号"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">step 1: 不需要创建表</span><br><span class="line">step 2: 不需要删除表</span><br><span class="line">step 3: 更新 B 表的 name 为 'Account', title 为 '账号'</span><br><span class="line">step 4: 操作安全</span><br><span class="line">step 5: 输出结果</span><br><span class="line"></span><br><span class="line">%%updateTable name="B" title="账号"%%</span><br><span class="line">%%renameTable name="B" newName="Account"%%</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """将所有表下的所有属性名称都加上 o 前缀"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">step 1: 不需要创建表</span><br><span class="line">step 2: 不需要删除表</span><br><span class="line">step 3: 更新 A 表的 foo 字段的 name 为 'oFoo', B 表的 bar 字段的 name 为 'oBar'</span><br><span class="line">step 4: 操作安全</span><br><span class="line">step 5: 输出结果</span><br><span class="line"></span><br><span class="line">%%renameField table="A" name="foo" newName="oFoo" %%</span><br><span class="line">%%renameField table="B" name="bar" newName="oBar" %%</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """删除 A 的 bar 字段"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">step 1: 不需要创建表</span><br><span class="line">step 2: 不需要删除表</span><br><span class="line">step 3: 删除 A 表的 bar 字段</span><br><span class="line">step 4: A 表不存在 bar 字段，终止</span><br><span class="line"></span><br><span class="line">结果： A 表不存在 bar 字段，无法删除</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """删除 C"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">step 1: 不需要创建表</span><br><span class="line">step 2: 删除 C 表</span><br><span class="line">step 3: 不需要更新表</span><br><span class="line">step 4: C 不存在，终止</span><br><span class="line"></span><br><span class="line">结果： C 不存在，无法删除</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line"><span class="section">#### END of DEMO 2</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### START OF DEMO 3</span></span><br><span class="line"></span><br><span class="line">Given tables:</span><br><span class="line"></span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line"><span class="section"># 用户</span></span><br><span class="line"></span><br><span class="line">Table User (</span><br><span class="line">  id: Long, PrimaryKey;</span><br><span class="line">  name: String;</span><br><span class="line">  age: String;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """完善和优化用户"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">step 1: User 已存在，不需要创建表, 扩展 User 表，增加 avatar、home、password 字段</span><br><span class="line">step 2: 不需要删除表</span><br><span class="line">step 3: 不需要更新表</span><br><span class="line">step 4: 操作安全</span><br><span class="line">step 5: 输出结果</span><br><span class="line"></span><br><span class="line">%%addField table="User" name="avatar" title="头像" type="String" %%</span><br><span class="line">%%addField table="User" name="home" title="主页" type="String" %%</span><br><span class="line">%%addField table="User" name="password" title="密码" type="String" notNull="true" %%</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """创建地址表"""</span><br><span class="line">ASSISTANT: """</span><br><span class="line">step 1: 创建地址表，推断增加 id、street、city、state、country 字段</span><br><span class="line">step 2: 不需要删除表</span><br><span class="line">step 3: 不需要更新表</span><br><span class="line">step 4: 操作安全</span><br><span class="line">step 5: 输出结果</span><br><span class="line"></span><br><span class="line">%%createTable name="Address" title="地址"%%</span><br><span class="line">%%addField table="Address" name="id" title="地址 id" type="Long" primaryKey="true" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="street" title="街道" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="city" title="城市" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="state" title="州" type="String" notNull="true"%%</span><br><span class="line">%%addField table="Address" name="country" title="国家" type="String" notNull="true"%%</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="section">#### END of DEMO 3</span></span><br><span class="line"></span><br><span class="line">Ok, FORGET the DEMO given tables above, let's start the new game</span><br><span class="line"></span><br><span class="line"><span class="section">#### START GAME</span></span><br><span class="line"></span><br><span class="line">Given Tables:</span><br><span class="line"></span><br><span class="line">$&#123;tables ?? '[not table here]'&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">USER: """$&#123;input&#125;"""</span><br><span class="line">ASSISTANT: """</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>运行结果：</p><p><img src="/images/ai-build-er/Untitled%204.png" alt=" GPT 3.5"></p><p>GPT 3.5</p><p><br><br><br></p><p><img src="/images/ai-build-er/Untitled%205.png" alt="GPT 4"></p><p>GPT 4</p><p><br><br><br><br><br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>加入了思维链(Chain of Thought) 之后，结果相对更可控了。但是还是不够完美，现在还有以下问题：</p><ul><li>Token 占用过大。尽管我们可以选择支持更大 Token 的模型，然而我们还要考虑未来为更多场景的加入示例、对话历史需要预留的空间，还有就是成本问题。</li><li>不支持多轮对话或者用户纠正机制。这个需要从交互上进行优化，比如提供执行确定，重新生成等等</li><li>回答效果还有待优化。并没有发挥出 ChatGPT 强大的联想能力，其实这是一件挺矛盾的事情，示例不够，GPT 输出的结果可能不符合要求，多了有可能抑制它的「创造性」？</li></ul><p><br><br><br></p><p>我觉得后面还有这些优化的方向：</p><ol><li><p>转换为多步骤 Prompt(<code>multi-step Prompt</code>)。典型的例子可以看 OpenAI 官方的 <a href="https://github.com/openai/openai-cookbook/blob/main/examples/Unit_test_writing_using_a_multi-step_prompt.ipynb" target="_blank" rel="noopener">Unit test writing using a multi-step prompt</a> 。我们上文的例子就是大锅炖，其实还可以继续拆解和引导 ChatGPT 展开细节。比如单元测试就拆解了三个步骤：</p><ol><li><strong>Explain(解释)</strong>: 给一个 Python 函数，让 GPT 解释它做了什么，为什么这么做.</li><li><strong>Plan(计划)</strong>: 让 GPT 列举针对这个函数单元测试的计划。如果这个计划太短，我们就请 GPT 进一步阐述更多单元测试的思路</li><li><strong>Execute(执行)</strong>: 最后，让 GPT 将上述计划的用例转换为单元测试</li></ol><p>同理，这些思路也可以用在我们的「数据建模」的场景</p></li><li><p>模型微调(Fine-tune)。上面的 Prompt 已经列举了较多的示例，已经占据了很多 Token 空间，如果要达到生产可用的级别，我们还需要积累更多的样本，微调出专用的模型是更好的选择。</p></li><li>使用更高级的模型。比如 GPT 4 的效果会比 3.5 好上很多</li></ol><p><br><br><br></p><p>虽然还达不到「生产可用」的级别，但在这期间我们也总结了对接 AI 到已有系统的一些<code>工作流</code>：</p><ul><li>确定需求。</li><li>系统原子操作的拆解。我们的主要工作就是让 AI 将用户的自然语言需求转换为这些原子操作。</li><li>设计 DSL。设计 AI 输出的 DSL 形式，需要兼顾 AI 和已有系统的处理能力</li><li>推理过程步骤设计。让 AI 模型知道结果是如何得到的，可以提升输出结果的准确性。</li><li>提供案例。案例越多，输出的结果就越可控</li><li>调优。这个调试的过程很难一步到位，就是测试、重建、测试、重建的过程。而且我们很难对它进行单元测试诸如此类的。</li></ul><p><br><br><br></p><p>后面我们还会继续优化，如果读者有更好的建议请和我交流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/ai-build-er/Untitled.png&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/ai-build-er/Untitled.gif&quot; alt=&quot;Untitled&quot;
      
    
    </summary>
    
      <category term="AI" scheme="https://bobi.ink/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>AI 调教师：聊聊 TypeChat 以及ChatGPT 形式化输出</title>
    <link href="https://bobi.ink/2023/07/24/typechat/"/>
    <id>https://bobi.ink/2023/07/24/typechat/</id>
    <published>2023-07-23T16:00:00.000Z</published>
    <updated>2023-07-24T03:27:27.183Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/typechat/Untitled%201.png" alt="Untitled"></p><p>Typescript 之父(微软)在 7月 21 号发布了一个有趣的项目—— <code>[Typechat](https://github.com/microsoft/TypeChat)</code>。<strong>旨在使用 AI 来连接自然语言和应用的 Schema / API</strong>。说白话就是使用 Typescript 类型信息来约束 ChatGPT 输出内容的结构。</p><p>我们早已见证过 ChatGPT 的强大，如果想要对接到我们已有的软件系统，通常会要求它输出 JSON 这类形式化、结构化的数据。如果你调教过 ChatGPT 就会发现， 它的输出结果往往没那么靠谱。为了让它输出符合要求的内容，我们需要给出足够的上下文信息和示例，并且这个调教过程也比较玄学。</p><p>本文就来看看 Typechat 是如何让 ChatGPT 输出符合需求的内容</p><p><br></p><h1 id="chatgpt-的能力和缺陷"><a href="#chatgpt-的能力和缺陷" class="headerlink" title="ChatGPT 的能力和缺陷"></a>ChatGPT 的能力和缺陷</h1><h3 id="chatgpt-看起来很擅长处理代码"><a href="#chatgpt-看起来很擅长处理代码" class="headerlink" title="ChatGPT 看起来很擅长处理代码"></a>ChatGPT 看起来很擅长处理代码</h3><p><img src="/images/typechat/Untitled%202.png" alt="扮演一个 linux 终端"></p><p>扮演一个 linux 终端</p><p><br></p><p><img src="/images/typechat/Untitled%203.png" alt="扮演一个 Javascript 执行器"></p><p>扮演一个 Javascript 执行器</p><p><br></p><p><img src="/images/typechat/Untitled%204.png" alt="扮演 Typescript"></p><p>扮演 Typescript</p><p><br></p><p>这能说明 ChatGPT 的预训练集中包含了丰富的编程语言相关的内容。</p><p><br><br><br><br><br></p><h2 id="连续对话和纠错机制"><a href="#连续对话和纠错机制" class="headerlink" title="连续对话和纠错机制"></a>连续对话和纠错机制</h2><p><img src="/images/typechat/Untitled%205.png" alt="Untitled"></p><p>众所周知， ChatGPT 生成的内容存在一定的随机性和不稳定性，很难一步到位。读者们作为开发者我们经常使用它来生成代码，应该能够体会到。</p><p>这个问题怎么解决呢？大概有以下几个方向</p><ul><li>可以和 ChatGPT 连续对话，引导它，反问它、纠正它</li><li>给 ChatGPT 提供更详细的上下文信息</li><li>使用一些对话的技巧：Chain of thought, 让 ChatGPT 学习推理的过程</li><li>模型微调。</li></ul><p>最后是平常心，开放地对待， AI 不是无所不能的，我们可能用尽的所有技巧， 也可能无法令人满意的答案。</p><p><br><br><br></p><h2 id="dsl-输出"><a href="#dsl-输出" class="headerlink" title="DSL 输出"></a>DSL 输出</h2><p>如果我们想要让 AI 连接到其他生态，比如连接到软件系统、控制硬件设备、实现各种自动化流程，在现在这个阶段，我们需要让 ChatGPT 输出结构化的数据，比如 JSON、XML、或者其他常见的 DSL。</p><p><img src="/images/typechat/Untitled%206.png" alt="Untitled"></p><p>就像我们开头说的 “ <em>Typechat 旨在使用 AI 来连接自然语言和应用的 Schema / API</em>”,  结合上面的流程图理解，你应该就能体会到这句话的意思。<strong><code>AI</code> 在这里就是一个<code>连接者</code>，让用户可以使用<code>自然语言</code>和我们的<code>应用系统</code>进行交互，AI 在这里的责任就是将<code>自然语言</code>翻译为我们应用系统能够处理的 <code>DSL</code></strong>。</p><p><br></p><p>ChatGPT 已经具备这样的能力：</p><p><img src="/images/typechat/Untitled%207.png" alt="绘制 mermaid 流程图"></p><p>绘制 mermaid 流程图</p><p><br></p><p><img src="/images/typechat/Untitled%208.png" alt="输出 JSON"></p><p>输出 JSON</p><p><br></p><p>如果你要求输出更复杂的数据结构，则需要使用 <a href="https://learningprompt.wiki/docs/chatGPT/tutorial-extras/Few-Shot%20Prompting" target="_blank" rel="noopener">Few-shot</a> Prompt 等手段，<strong>在受限的 Token 范围内，给 ChatGPT足够的案例和上下文信息</strong>。</p><p>除此之外，OpenAI 官方在 613 版本的 GPT 3.5 和 4 带来了<code>函数调用</code>的能力(<a href="https://platform.openai.com/docs/guides/gpt/function-calling" target="_blank" rel="noopener">Function Calling</a>), 可以帮助开发者通过 API 方式实现类似于 ChatGPT 插件的数据交互能力。让开发者可以使用  JSON Schema 来描述你的函数接口，GPT 会根据用户的输入，决定调用哪个函数，并组装符合 Schema 要求的 JSON 数据。</p><p>以下是 OpenAI 的官方示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 🔴 函数接口定义</span></span><br><span class="line">functions = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"get_current_weather"</span>,</span><br><span class="line">        <span class="string">"description"</span>: <span class="string">"Get the current weather in a given location"</span>,</span><br><span class="line">        <span class="string">"parameters"</span>: &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"object"</span>,</span><br><span class="line">            <span class="string">"properties"</span>: &#123;</span><br><span class="line">                <span class="string">"location"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">                    <span class="string">"description"</span>: <span class="string">"The city and state, e.g. San Francisco, CA"</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"unit"</span>: &#123;<span class="string">"type"</span>: <span class="string">"string"</span>, <span class="string">"enum"</span>: [<span class="string">"celsius"</span>, <span class="string">"fahrenheit"</span>]&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"required"</span>: [<span class="string">"location"</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 🔴 用户输入</span></span><br><span class="line">messages = [&#123;<span class="string">"role"</span>: <span class="string">"user"</span>, <span class="string">"content"</span>: <span class="string">"What's the weather like in Boston?"</span>&#125;]</span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">response = openai.ChatCompletion.create(</span><br><span class="line">    model=<span class="string">"gpt-3.5-turbo-0613"</span>,</span><br><span class="line">    messages=messages,</span><br><span class="line">    functions=functions,</span><br><span class="line">    function_call=<span class="string">"auto"</span>,  <span class="comment"># auto is default, but we'll be explicit</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">response_message = response[<span class="string">"choices"</span>][<span class="number">0</span>][<span class="string">"message"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 🔴 GPT 会告诉你最终需要调用哪个函数以及它的参数，也可能不会调用任何东西</span></span><br><span class="line"><span class="keyword">if</span> response_message.get(<span class="string">"function_call"</span>):</span><br></pre></td></tr></table></figure><p>gpt-3.5-turbo-0613、gpt-4-0613 针对 Function calling 这种场景做了微调，实际上这些 ‘函数’ 也是注入到 <code>system</code> prompt 里面，同样会占用请求的 Token。在旧的版本理论上也可以实现类似的效果。我会在后续的文章中专门介绍 Function calling。</p><p><br></p><p>实际上，Function Calling 还是不完美，比如无法保证严格按照我们给定的 JSON  Schema 输出，不支持复杂的 JSON Schema，缺乏灵活性等等。现在我们开始介绍本文的主角 —— typechat</p><p><br><br><br><br><br></p><h1 id="typechat"><a href="#typechat" class="headerlink" title="TypeChat"></a>TypeChat</h1><p>TypeChat 是微软刚发布一个有趣的项目，不同于 Function calling， 它使用 Typescript 类型来作为 「Schema」，要求 ChatGPT 返回符合这个类型定义的数据。</p><p>在 <code>Typechat</code> 中，先定义好 ChatGPT 的响应类型，即 <code>Schema</code>, 例如:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">type Response = &#123;</span><br><span class="line">    items: Item[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type Item = &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    quantity: number;</span><br><span class="line">    size?: string;</span><br><span class="line">    notes?: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求 ChatGPT 返回 JSON 格式，并符合上述的 Response 类型。接着输入用户需求：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Could I get a blueberry muffin and a grande latte?</span><br></pre></td></tr></table></figure><p>最后 ChatGPT 返回结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"items"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"blueberry muffin"</span>,</span><br><span class="line">      <span class="string">"quantity"</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"latte"</span>,</span><br><span class="line">      <span class="string">"quantity"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">"size"</span>: <span class="string">"grande"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><p>那么它是怎么工作的？我们在上一节对 ChatGPT 的能力做了大概的分析，你可以将它们结合起来想想：</p><ul><li>ChatGPT 擅长扮演“代码”执行器,  这其中也包括 Typescript</li><li>ChatGPT 的缺点就是不稳定、随机性。解决办法就给出更多的信息、推理步骤，通过连续对话、反复纠正它。</li><li>ChatGPT 通过给出足够的指示，可以输出‘符合’需求的结构化数据。</li></ul><p><br><br><br><br><br></p><p>Typechat 就是运用了上述思路：</p><p><img src="/images/typechat/Untitled%209.png" alt="Untitled"></p><ul><li>将类型定义和用户需求一起投喂给 ChatGPT，要求它返回指定类型的 JSON数据</li><li>将返回的数据喂给 Typescript 进行检查</li><li>如果类型错误，将错误结果丢回 ChatGPT，重新纠正</li></ul><p><br><br><br></p><p>它的 Prompt 非常简单。 请求的 Prompt：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createRequestPrompt(request: string) &#123;</span><br><span class="line">      return `You are a service that translates user requests into JSON objects of type &quot;$&#123;validator.typeName&#125;&quot; according to the following TypeScript definitions:\n` +</span><br><span class="line">          `\`\`\`\n$&#123;validator.schema&#125;\`\`\`\n` +</span><br><span class="line">          `The following is a user request:\n` +</span><br><span class="line">          `&quot;&quot;&quot;\n$&#123;request&#125;\n&quot;&quot;&quot;\n` +</span><br><span class="line">          `The following is the user request translated into a JSON object with 2 spaces of indentation and no properties with the value undefined:\n`;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><br></p><p>纠错 Prompt：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createRepairPrompt(validationError: string) &#123;</span><br><span class="line">        return `The JSON object is invalid for the following reason:\n` +</span><br><span class="line">            `&quot;&quot;&quot;\n$&#123;validationError&#125;\n&quot;&quot;&quot;\n` +</span><br><span class="line">            `The following is a revised JSON object:\n`;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><p>翻译流程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function translate(request: string) &#123;</span><br><span class="line">        let prompt = typeChat.createRequestPrompt(request);</span><br><span class="line">        let attemptRepair = typeChat.attemptRepair;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            const response = await model.complete(prompt);</span><br><span class="line">            if (!response.success) &#123;</span><br><span class="line">                return response;</span><br><span class="line">            &#125;</span><br><span class="line">            const responseText = response.data;</span><br><span class="line">            const startIndex = responseText.indexOf(&quot;&#123;&quot;);</span><br><span class="line">            const endIndex = responseText.lastIndexOf(&quot;&#125;&quot;);</span><br><span class="line">            if (!(startIndex &gt;= 0 &amp;&amp; endIndex &gt; startIndex)) &#123;</span><br><span class="line">                return error(`Response is not JSON:\n$&#123;responseText&#125;`);</span><br><span class="line">            &#125;</span><br><span class="line">            const jsonText = responseText.slice(startIndex, endIndex + 1);</span><br><span class="line">            // 🔴 类型检查</span><br><span class="line">            const validation = validator.validate(jsonText);</span><br><span class="line">            if (validation.success) &#123;</span><br><span class="line">                return validation;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!attemptRepair) &#123;</span><br><span class="line">                return error(`JSON validation failed: $&#123;validation.message&#125;\n$&#123;jsonText&#125;`);</span><br><span class="line">            &#125;</span><br><span class="line">            // 🔴 修复</span><br><span class="line">            prompt += `$&#123;responseText&#125;\n$&#123;typeChat.createRepairPrompt(validation.message)&#125;`;</span><br><span class="line">            attemptRepair = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><p>Typechat 与 Function calling 对比：</p><ul><li>Typescript 可以更简洁、灵活地定义复杂的数据类型；</li><li>Typechat 也加入了简单的纠错机制，进一步保证结果的可靠性。</li></ul><p><br></p><p>它们都改变不了 ChatGPT 的特性，结果依然不一定是可靠的。目前 Typechat  只有一轮纠正，其实际的效果、Token 消耗量等还有待验证。</p><p><br><br><br><br><br><br><br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面我们简单介绍了 ChatGPT 的一些特性和缺陷。接着引入了 Typechat，它给我们提供了一个较新的思路：使用 Typescript 类型来定义 ChatGPT 的输出结构，然后通过 Typescript 来验证输出结果，循环纠正 ChatGPT。</p><p>本文的要点：</p><ul><li>ChatGPT 看起来很擅长处理编程语言。比如 Typescript，这就给 Typechat 的实现奠定了基础。</li><li>使用 Typescript 类型作为 Schema，这本身就可以给 ChatGPT 提供较为严谨的上下文信息。</li><li>ChatGPT 的回答是随机的、不稳定，很难做到一步到位。在实际使用中，需要通过多次对话和纠正才能得到较为完善的结果。所以 Typechat 就引入了自动纠错机制，让 ChatGPT 输出更加稳定。</li><li>编程语言是严苛的，具备可‘纠错性’。我们可以将代码错误信息反馈给 ChatGPT 来完善答案。Typechat 就是利用了这点，其他编程语言也可以轻松实现类似的效果，很快其他语言应该也会有类似的库出来</li></ul><p><br></p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://github.com/microsoft/TypeChat" target="_blank" rel="noopener">https://github.com/microsoft/TypeChat</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/typechat/Untitled%201.png&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;Typescript 之父(微软)在 7月 21 号发布了一个有趣的项目—— &lt;code&gt;[Typechat](https://githu
      
    
    </summary>
    
      <category term="AI" scheme="https://bobi.ink/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>AI 调教师系列开篇： MySQL 专家</title>
    <link href="https://bobi.ink/2023/07/21/ai-sql-master/"/>
    <id>https://bobi.ink/2023/07/21/ai-sql-master/</id>
    <published>2023-07-20T16:00:00.000Z</published>
    <updated>2023-07-21T09:17:38.044Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ai-sql-master/Untitled.jpeg" alt="cover"></p><p>ChatGPT 在年初爆火，成为街头巷尾热议的话题。现在的 AI 应该算是目前最卷的赛道了，从卖账号、套壳客户端、 割韭菜教程、大厂争先发布自己的大模型…</p><p>作为普通开发者，搞底层大模型不是人人都能企及，下场割韭菜实在卷不过别人，追新也需要付出很多精力。眼前貌似就只有一条路，着眼于 AI 的应用层，看能不能给自己的垂直赛道赋赋能？ 或者针对个人而言，能不能利用 AI 提高工作效率？</p><p><br></p><p>所以我开一个新坑, 以前端开发者视角， 记录一下作为一个 「AI 调教师」在 <code>AI 应用层</code>的一些实践记录, 没有高谈阔论，就一些碎碎念。</p><p><br><br><br></p><h1 id="一种全新的人机交互模式"><a href="#一种全新的人机交互模式" class="headerlink" title="一种全新的人机交互模式"></a>一种全新的人机交互模式</h1><p>今年二月份，我们就开始尝试将 ChatGPT 接入到我们的工具中，如下图：</p><p><img src="/images/ai-sql-master/Untitled.png" alt="AI对话框"></p><p><br></p><p>就是这样的一个<code>对话框</code>，现在大家可能司空见惯了。那时候并不常见，毕竟 Microsoft Office Copilot、<code>ChatGPT 插件</code>什么的都还没发布。在当时想出这个点子的时候，我一整夜睡不着觉，第二天四五点就决定起床，肝了一天搞出这样的效果。</p><blockquote><p>😂 不知道有没有人跟我一样，一兴奋就会睡不着觉</p></blockquote><p><br></p><p>这是一种全新的系统交互方式，即用<code>自然语言</code>来操控整个系统。怎么操控法呢？</p><p><img src="/images/ai-sql-master/Untitled%201.png" alt="指令"></p><p><br></p><ul><li>这个对话框是全局的<code>常驻</code>的，用户可以随时通过快捷键或者悬浮按钮唤起</li><li>每个页面都可以扩展自己的指令，比如进入数据建模页面，就注册 <code>SQL 专家</code>、<code>数据建模</code>等指令，离开后就销毁：<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React 代码</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (model.readonly) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册扩展</span></span><br><span class="line">  <span class="keyword">return</span> registerExtension(&#123;</span><br><span class="line">    key: <span class="string">'数据建模(测试)'</span>,</span><br><span class="line">    match: <span class="string">'数据建模(测试)'</span>,</span><br><span class="line">    type: ExtensionType.Command,</span><br><span class="line">    description: <span class="string">'数据模型创建和修改'</span>,</span><br><span class="line">    onSend(context) &#123;</span><br><span class="line">      <span class="comment">// ... 实现</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure></li></ul><p><br></p><p><img src="/images/ai-sql-master/Untitled%202.png" alt="指令系统"><br>指令系统</p><p><br></p><p><code>指令</code>类似于现在的 <code>ChatGPT 插件</code>，用于扩展 ChatGPT 的能力边界。</p><p>对话框只是提供了 AI 对话的能力(机制)，而具体的业务、上下文信息只有页面自己最清楚，因此就让页面自己提供与 AI 对接的接口。</p><p>目前的实现方式是通过 <code>#</code> 来唤起选择具体指令，未来我们会利用 ChatGPT 最新的 <a href="https://platform.openai.com/docs/guides/gpt/function-calling" target="_blank" rel="noopener">Function Calling</a> 实现类似 <code>ChatGPT 插件</code> 一样的自然语言调用能力。</p><p><br><br><br><br><br></p><h1 id="mysql-专家"><a href="#mysql-专家" class="headerlink" title="MySQL 专家"></a>MySQL 专家</h1><p>我们第一个接入的 <code>AI 的大腿</code>，就是给我们的<code>数据建模工具</code>接入 <code>AI  生成 SQL 语句</code>的功能：</p><p><img src="/images/ai-sql-master/Untitled.png" alt="对话框"></p><p>如上图所示，我们可以使用自然语言的形式，基于我们已创建的数据模型来做以下事情：</p><ul><li>生成 MySQL 建表、 增删改查语句</li><li>给出优化的建议</li><li>检查是否符合关系型数据的范式等等…</li></ul><p><br></p><p>建表语句：</p><p><img src="/images/ai-sql-master/Untitled%203.png" alt="建表语句"></p><p><br></p><p>优化建议：</p><p><img src="/images/ai-sql-master/Untitled%204.png" alt="优化建议"></p><p>还有很多场景…</p><p><br><br><br><br><br></p><h1 id="prompt-实现"><a href="#prompt-实现" class="headerlink" title="Prompt 实现"></a>Prompt 实现</h1><p>几乎零成本就可以拥有一个 「MySQL 专家」。它的 Prompt 其实很简单！</p><p><br></p><p>首先需要将已创建的数据模型序列化，作为上下文喂给 ChatGPT, 例如：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#会员主档</span></span><br><span class="line">Table m_member (</span><br><span class="line">  <span class="symbol">id:</span> Long, PrimaryKey;</span><br><span class="line">  <span class="symbol">tenant_id:</span> Long; <span class="comment">#租户id</span></span><br><span class="line">  <span class="symbol">unique_account_id:</span> String; <span class="comment">#会员一账通id</span></span><br><span class="line">  <span class="symbol">status:</span> Integer; <span class="comment">#会员状态</span></span><br><span class="line">  <span class="symbol">unique_identifier_key:</span> String; <span class="comment">#会员唯一标识键</span></span><br><span class="line">  <span class="symbol">unique_identifier:</span> String; <span class="comment">#会员唯一标识的值</span></span><br><span class="line">  <span class="symbol">ext_json:</span> String; <span class="comment">#自定义扩展字段</span></span><br><span class="line">  <span class="symbol">clubs:</span> String; <span class="comment">#会员所属的俱乐部</span></span><br><span class="line">  <span class="symbol">channel:</span> String; <span class="comment">#渠道</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#俱乐部会员</span></span><br><span class="line">Table club_member_do (</span><br><span class="line">  <span class="symbol">id:</span> Long, PrimaryKey; <span class="comment">#实体唯一标识符</span></span><br><span class="line">  <span class="symbol">tenant_id:</span> Long; <span class="comment">#租户id</span></span><br><span class="line">  <span class="symbol">club_id:</span> Long; <span class="comment">#俱乐部id</span></span><br><span class="line">  <span class="symbol">unique_account_id:</span> String; <span class="comment">#会员一账通id</span></span><br><span class="line">  <span class="symbol">member_no:</span> String; <span class="comment">#会员卡号</span></span><br><span class="line">  <span class="symbol">level_num:</span> Integer; <span class="comment">#会员等级编号</span></span><br><span class="line">  <span class="symbol">level_expired_time:</span> DateTime; <span class="comment">#等级过期时间</span></span><br><span class="line">  <span class="symbol">nickname:</span> String; <span class="comment">#昵称</span></span><br><span class="line">  <span class="symbol">channel:</span> String; <span class="comment">#渠道</span></span><br><span class="line">  <span class="symbol">certificate_type:</span> String; <span class="comment">#证件类型</span></span><br><span class="line">  <span class="symbol">certificate_no:</span> String; <span class="comment">#证件号码</span></span><br><span class="line">  <span class="symbol">email:</span> String; <span class="comment">#邮箱</span></span><br><span class="line">  <span class="symbol">country_code:</span> String; <span class="comment">#国家编码</span></span><br><span class="line">  <span class="symbol">address:</span> String; <span class="comment">#详细地址信息</span></span><br><span class="line">  <span class="symbol">ext_json:</span> String; <span class="comment">#扩展字段</span></span><br><span class="line">  <span class="symbol">status:</span> Integer; <span class="comment">#俱乐部会员状态</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#会员变动日志</span></span><br><span class="line">Table m_member_operation_log (</span><br><span class="line">  <span class="symbol">id:</span> Long; <span class="comment">#实体唯一标识符</span></span><br><span class="line">  <span class="symbol">tenant_id:</span> Long; <span class="comment">#租户ID</span></span><br><span class="line">  <span class="symbol">club_id:</span> Long; <span class="comment">#俱乐部Id</span></span><br><span class="line">  <span class="symbol">unique_account_id:</span> String; <span class="comment">#一账通ID</span></span><br><span class="line">  <span class="symbol">operation_type:</span> String; <span class="comment">#操作类型</span></span><br><span class="line">  <span class="symbol">remark:</span> String; <span class="comment">#操作备注</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>这个 DSL 的格式无所谓，ChatGPT 自然语言的处理能力非常强，只要你给出的信息符合一定的规律，格式并不重要。</p><p><br></p><p>完整的 Prompt(<code>system</code>) 模板如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你是一个 MySQL 专家，你会根据用户给出的概念模型，创建专业、高性能 SQL 语句， 以及回答用户关于数据库的任何问题，提出建设性意见。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">假设实体(或者表)有多个字段(或者属性), 这些字段支持以下类型:</span><br><span class="line"></span><br><span class="line">- Boolean</span><br><span class="line">- Date</span><br><span class="line">- DateTime</span><br><span class="line">- Timestamp</span><br><span class="line">- Integer</span><br><span class="line">- Decimal</span><br><span class="line">- Long</span><br><span class="line">- Double</span><br><span class="line">- Float</span><br><span class="line">- String</span><br><span class="line">- Text</span><br><span class="line">- LongText</span><br><span class="line">- JSON</span><br><span class="line">- Reference : 表示对其他表的引用</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">这是概念模型：</span><br><span class="line"></span><br><span class="line">$&#123;conception&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">用户输入： &quot;&quot;&quot;$&#123;input&#125;&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>这是一个很简单的 Prompt，但也揭示了我们写 Prompt 的<a href="https://learningprompt.wiki/docs/chatGPT/tutorial-extras/ChatGPT%20Prompt%20Framework" target="_blank" rel="noopener">主要框架</a>：</p><ul><li><strong>能力与角色</strong>（Capacity and Role）：一上来就给它带个帽子，定义好它的角色和能力</li><li><strong>洞察力</strong>（Insight）：背景信息和上下文。即我们携带了数据模型工具中提取出来的 <code>模型 DSL</code>， 以及 DSL 的基础规则</li><li><strong>指令</strong>（Statement）：要求 ChatGPT 做什么。这个由后续的用户给出</li></ul><p><br></p><p>这里我们也使用了一些<a href="https://learningprompt.wiki/docs/chatGPT/tutorial-tips/%E6%8A%80%E5%B7%A75%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E6%8C%87%E4%BB%A4%E5%92%8C%E9%9C%80%E8%A6%81%E5%A4%84%E7%90%86%E7%9A%84%E6%96%87%E6%9C%AC%E5%88%86%E5%BC%80" target="_blank" rel="noopener">特殊符号</a>, 比如 <code>---</code> <code>&quot;&quot;&quot;</code> , 对文本进行分段，可以提升 AI 反馈的准确性</p><p><br></p><p>因为 ChatGPT 语言模型已经预训练了很多数据库相关的语料，所以回答的效果还不错，不需要太多的指示(即 <code>[Zero-Shot Prompting](https://learningprompt.wiki/docs/chatGPT/tutorial-extras/Zero-Shot%20Prompts)</code>)。</p><blockquote><p>💡  你可以通过这个<a href="https://sdk.vercel.ai/r/25O12Mq" target="_blank" rel="noopener">链接试一试效果</a></p></blockquote><p><br><br><br><br><br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>「AI 调教师」系列的第一篇文章以一个最简单的示例开始， 这是我为数不多比较短的文章了。如果你想给已有的工具接入 AI 能力，兴许这种方式就是最好的开始，从已有的工具中提取出相关上下文信息，投喂给 AI 来实现智能问答。</p><p>下一篇文章，我们将进一步深化，讲讲如何利用 AI 来实现<code>数据建模</code>(画 ER 图)，敬请期待。同时求赞求关注求收藏，你也可以直接订阅这个专栏。</p><p><br><br><br></p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p>本文用到的技巧</p><ul><li><a href="https://learningprompt.wiki/docs/chatGPT/tutorial-extras/Zero-Shot%20Prompts" target="_blank" rel="noopener">Zero-Shot Prompts</a></li><li><a href="https://learningprompt.wiki/docs/chatGPT/tutorial-tips/%E6%8A%80%E5%B7%A75%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E6%8C%87%E4%BB%A4%E5%92%8C%E9%9C%80%E8%A6%81%E5%A4%84%E7%90%86%E7%9A%84%E6%96%87%E6%9C%AC%E5%88%86%E5%BC%80" target="_blank" rel="noopener">技巧 5：使用特殊符号指令和需要处理的文本分开</a></li><li><a href="https://learningprompt.wiki/docs/chatGPT/tutorial-extras/ChatGPT%20Prompt%20Framework" target="_blank" rel="noopener">CRISPE Prompt Framework</a></li></ul><p>学习 Prompt</p><ul><li><a href="https://learningprompt.wiki/docs/chatGPT/tutorial-basics/%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%20&amp;%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/scenario-1-ask-questions" target="_blank" rel="noopener">Learning Prompt</a></li><li><a href="https://www.deeplearning.ai/short-courses/chatgpt-prompt-engineering-for-developers/" target="_blank" rel="noopener">ChatGPT Prompt Engineering for Developers</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/ai-sql-master/Untitled.jpeg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;ChatGPT 在年初爆火，成为街头巷尾热议的话题。现在的 AI 应该算是目前最卷的赛道了，从卖账号、套壳客户端、 割韭菜教程、大厂争先发布
      
    
    </summary>
    
      <category term="AI" scheme="https://bobi.ink/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>2B or not 2B: 前端大泥球</title>
    <link href="https://bobi.ink/2023/07/20/to-be-shit/"/>
    <id>https://bobi.ink/2023/07/20/to-be-shit/</id>
    <published>2023-07-19T16:00:00.000Z</published>
    <updated>2023-07-20T03:05:33.711Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/to-be-shit/Untitled.jpeg" alt="cover"></p><p>今天给大家带来的是 2B 领域的一个架构难题，我们最终也没有找到一个较好「解决」方案， 或者说它本来就是一个伪命题。</p><p>让我慢慢跟你道来…</p><p><br><br><br></p><h1 id="软件的划分模式"><a href="#软件的划分模式" class="headerlink" title="软件的划分模式"></a>软件的划分模式</h1><p>首先从软件系统的划分模式讲起。<strong>软件系统的划分有很多种方式，拆分的目的无非都是：分治、复用、隔离、扩展性、抽象等等。</strong></p><p><br></p><hr><p><br></p><p><strong>最为常见的便是<code>分层架构</code></strong></p><p>分层架构将软件系统划分为若干层次，每个层次都是相互独立的，各自负责不同的功能和职责，通过明确的接口和协议进行通信，从而实现系统的可扩展性、可维护性、可测试性、可重用性等特点。</p><p>比如一个典型的 Web 系统的“三层架构”：</p><ul><li><code>表示层（Presentation Layer）</code>：负责用户界面、用户交互和用户输入输出等功能，通过 Web 页面或者客户端应用来展示和控制数据的呈现方式。</li><li><code>业务逻辑层（Business Logic Layer</code>）：负责系统的业务逻辑处理、数据处理和其他业务规则的实现，为表示层提供数据和业务逻辑的支持。</li><li><code>数据访问层（Data Access Layer）</code>：负责数据的存储和访问，为业务逻辑层提供数据访问的接口和实现。</li></ul><p><img src="/images/to-be-shit/Untitled.png" alt="分层"></p><p><br></p><hr><p><br></p><p><strong>微服务架构</strong></p><p>随着系统的复杂化，我们需要将系统拆分为更小的子系统，来解决性能、维护性、扩展性等诸多问题。比如引入了微服务、微前端等解决方案，这个本质上是一种<code>垂直方向的拆分</code>：</p><p><img src="/images/to-be-shit/Untitled%201.png" alt="垂直拆分"></p><p>甚至我们在应用内部还会进一步拆分, 按照业务聚合度拆分成不同的模块：</p><p><img src="/images/to-be-shit/Untitled%202.png" alt="领域拆分"></p><p>这就是分治的魅力吧。</p><p><br><br><br><br><br></p><h1 id="多业态"><a href="#多业态" class="headerlink" title="多业态"></a>多业态</h1><p>在 2B 领域，让我们更棘手的是，还要面临<code>多业态问题</code>。</p><p><br></p><p><strong>什么是多业态？</strong></p><p>让 <code>ChatGPT</code> 来解释一下：<em>多业态是指一个企业或者品牌在不同的业务领域或行业中拥有不同的业态，例如同一个品牌既可以开设餐厅，也可以开设酒店、咖啡店、快餐店、影院等不同的业态。多业态的企业或品牌通过在不同的业态中提供不同的产品和服务，以满足不同消费者的需求和偏好，增加企业的收入和市场份额</em>。</p><p><strong>多业态并不是一种结果，而是一种手段</strong>。比如在垂直领域耕耘多年的企业，想要扩大创收，就会将触角伸到其他行业，即所谓的跨界。还有就是一些初创企业，就像无头苍蝇一样，将网撒向不同的行业，来摸索出路。</p><p>我们就是属于后者。不过也有可能前期策略是在模仿<code>有赞</code> 的嫌疑(<em>毕竟有赞在 18、19 年是当红的 SaaS 炸子鸡</em>)，铺设了很多行业：医药、教育、文旅、零售、地产、汽车…</p><p>也就是说在这种「广撒网」的商业策略下, 我们需要在「一套代码」中适配“多业态”：</p><p><img src="/images/to-be-shit/Untitled%203.png" alt="多业态"></p><p>然而多业态并不是简单的<code>垂直方向</code>的进一步细分，而是多了一个<code>维度</code>。如果说分层是 1D、 垂直划分是 2D、再加上多业态，就是 3D 了！</p><p><strong>这些<code>行业多态</code>会横向击穿垂直拆分后的模块壁垒，行业的多样性会渗透到程序的各个角落，开闭原则形同虚设。不管是前端还是后端，这是都是一个非常大的挑战。</strong></p><p>现状就是本文标题中讲的，多了一个维度之后，对开发而言是灾难性性，整个项目就是一个大泥球。</p><p>所有行业的代码都堆砌在一起，充斥着各种区分行业的 if/else 语句、耦合牵扯、渗透在项目的各个角落… 总之这可能是程序生涯难得一见的代码屎山！</p><p><img src="/images/to-be-shit/Untitled%204.png" alt="给大家一个直观的体验"><br>给大家一个直观的体验</p><p><br><br><br></p><p>垂直的软件拆分有很多方法论，比如微服务、 DDD。而多业态，在软件行业并找不到太多这样的最佳实践。</p><p>且不论这是否是战略上的错误。作为技术开发我们只能服从它， 并需求在战术上进行弥补。<strong>企业对软件开发的要求并不会因此降低，它还是会要求你的代码要区别「复用性」，要能快速应变各种需求、支持快速迭代…</strong></p><p><img src="/images/to-be-shit/Untitled%205.png" alt="产品架构"><br>产品架构</p><p><br></p><p>上图是我们团队基本结构，也是<code>产品结构</code>(康威定律)、更体现了我们的<code>项目交付模式</code>。很多非 SasS 化的 2B 公司的应该都是这类模式。</p><p>对我们来说更大的挑战在于：<strong>下游的项目能尽量复用上游的功能，避免重复工作，并且要求上游的更新能向下传递，甚至不排除下游合并到上游的可能性。</strong></p><p>能感受到它的难度了吗？</p><p><br><br><br></p><h1 id="怎么解决？"><a href="#怎么解决？" class="headerlink" title="怎么解决？"></a>怎么解决？</h1><h2 id="战略上的调整"><a href="#战略上的调整" class="headerlink" title="战略上的调整"></a>战略上的调整</h2><p>从近几年组织架构上面的调整，可以反映软件架构的战略调整，它定下整个研发体系的基调。另外这些变化，也反映了我们对 2B 行业探索和认知上面的变化：</p><p><img src="/images/to-be-shit/Untitled%206.png" alt="单体团队"></p><p>初创团队就是一个单体团队(左图所示)，接着开始多行业撒网，原本的项目上慢慢堆砌出各种行业的形态(右图所示)。</p><p><br></p><hr><p><br></p><p><img src="/images/to-be-shit/Untitled%207.png" alt="拆分事业部"></p><p>随着业务发展起来，一些发展较好的行业成立了事业部，专门负责项目的交付。</p><p><br></p><hr><p><br></p><p><img src="/images/to-be-shit/Untitled%208.png" alt="行业标品"></p><p>随着行业的深入，事业部慢慢积累起来了更多行业 <code>Known How</code>，通用的标品已经无法满足需求，事业部开始成立<code>行业标品团队</code>，在行业标准化产品上做更多深入的定制开发；另外事业部内部继续细分专门的交付团队。</p><blockquote><p>💡 行业 Known How 指的是某个行业内部特定的、非公开的知识和技术，通常只有在该行业内部的从业人员才能够掌握和理解。这些知识和技术可能包括行业内部的标准、工艺、流程、技术、经验等方面的内容，是行业内部的核心竞争力和商业机密。</p></blockquote><p>到这个阶段「产品研发」开发的「标品」就处于一种比较尴尬的位置。一来它毕竟不是为特定行业打造的，已经不能满足行业的定制化需求，无法实现开箱即用；二来产品研发部门离真实的客户也比较远，很容易闭门造车，产品没有经过市场打磨，质量较差。</p><p>人们开始对「产品研发部」的价值产生了怀疑。</p><p><br></p><hr><p><br></p><p><img src="/images/to-be-shit/Untitled%209.png" alt="平台化"></p><p>于是「产品研发」的出路是继续做下沉，不再做所谓的大而全标品，而是做好核心的<code>平台化能力</code>，比如会员体系、CDP、SCRM、MA(Marketing Automation)…</p><p>这些平台化能力，剥离了具体的行业属性，并向未来的 SaaS 化靠拢。</p><p><br></p><hr><p><br><br><br></p><p><strong>多业态的架构难题，从笔者的角度来看，在战术上是基本是无解的</strong>。通过上面的战略调整可以看出，我们慢慢规避了这些问题。</p><p>也就说，我们没有解决它，而是绕过了它，甚至说我们放弃了这条路线也不为过。</p><p>通过上面的调整我们可以看到：</p><ul><li>覆盖的行业在慢慢收敛，不赚钱的、走不通的行业干脆就放弃了。</li><li>另一方面，在具体行业和平台上更加专注，不再追求打造一个大而全的、可以覆盖多行业的单一产品。</li></ul><p><br><br><br><br><br></p><h2 id="战术上的适配"><a href="#战术上的适配" class="headerlink" title="战术上的适配"></a>战术上的适配</h2><p>虽然，我们最终通过战略上的调整规避了多业态架构难题，但这毕竟是「<code>果</code>」。推动战略上调整的「<code>因</code>」，并不是因为战术上的实施难度，而是企业的市场适应。</p><p>虽然战略的调整可以从根上解决了问题，但这是一个漫长的演进过程(大概五年)。 一开始我们也预料不到现在的结局。因此在过去相当长的时间内，我们一直都在尝试<code>战术层面</code>去解决多业态问题。</p><p>下面讲一讲，前端是怎么应对这些问题。</p><p><br><br><br></p><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>首先确立一些行事的原则，作为后面具体实施的指导方向， 比如：</p><ul><li><strong>统一规范</strong>。完整的项目版图设计到很多团队、上下游的参与，我们必须统一规范。</li><li><strong>保持沟通</strong>。因为我们需要拉通上下游，进行一些知识和代码的传递，沟通是很重要的。</li><li><strong>更新/联动，隔离/复用机制</strong>。我们需要在框架层面提供代码上下游更新、联动，复用、隔离等机制。</li><li><strong>生态共建</strong>。规定上下游团队需要一起共建生态，沉淀知识和行业 Known How.</li><li><strong>互不影响、独立开发、独立部署</strong>。</li><li><strong>开闭原则</strong>。对下游扩展开放，对修改关闭。</li><li><strong>分离关注点</strong>。</li></ul><p><br><br><br></p><h3 id="确立共建的范围和上下游的协作关系"><a href="#确立共建的范围和上下游的协作关系" class="headerlink" title="确立共建的范围和上下游的协作关系"></a>确立共建的范围和上下游的协作关系</h3><p><img src="/images/to-be-shit/Untitled%2010.png" alt="协同"></p><p>即定义了一些团队之间的协作规范，比如：</p><ul><li>上下游团队之间责任划分、共建的范围</li><li>沟通机制</li><li>发布更新的频率和形式</li><li>分支规范等等</li></ul><p><br><br><br></p><h3 id="宏观上：行业隔离-业务聚合"><a href="#宏观上：行业隔离-业务聚合" class="headerlink" title="宏观上：行业隔离/业务聚合"></a>宏观上：行业隔离/业务聚合</h3><p>在宏观的层面上，定义了两大措施或建议：</p><ol><li><strong>行业隔离</strong>。为了隔离不同业态，我们提出了两个措施<ul><li>分支隔离。不同业态有不同的分支前缀(比如<code>团队名/dev</code>、<code>团队名/master</code>)，从而做到开发上互不干扰。可以从上游标品团队的分支中<code>单向合并</code>，来实现下游同步</li><li>模块/文件的隔离。在这里我们主要使用<code>业态扩展名</code>， 比如 <code>index.js</code>、<code>index.ky.js</code>、<code>index.home.js</code>, 有点类似于 <code>React Native</code>（<code>*.android.js</code>, <code>*.ios.js</code>） 或者 <code>Taro</code> 的特定平台文件。在编译时，根据当前业态进行条件编译。</li></ul></li><li><p><strong>按照业务聚合</strong>。模块按照业务进行聚合，而不是根据菜单/职能：</p><ul><li>❌  菜单。这个问题主要出在 B 端，很多前端理所当然会按照导航菜单来拆分应用，问题就是菜单并不一定能准确地表达业务的边界，而且菜单是多变的，受运营的影响比较大。<br>这个我在 <a href="https://www.notion.so/b590284a71934f97a1db71ef967fbc5a?pvs=21" target="_blank" rel="noopener">微前端的落地和治理实战</a> 中也有讨论</li><li><p>❌  职能聚合。例如, 全局按照职能划分目录，所有业务模块都堆在一起</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">  /components</span><br><span class="line">  A.js</span><br><span class="line">    B.js</span><br><span class="line">  /pages</span><br><span class="line">  /api</span><br><span class="line">  /...</span><br></pre></td></tr></table></figure></li><li><p>✅ 业务聚合。<strong>按照业务领域的边界进行垂直的拆分：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">A 领域</span><br><span class="line">  /components</span><br><span class="line">  /pages</span><br><span class="line">  /api</span><br><span class="line"></span><br><span class="line">B 领域</span><br><span class="line">  /components</span><br><span class="line">  /pages</span><br><span class="line">  /api</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><br><br><br><br><br></p><h3 id="微观上：复用和扩展模式"><a href="#微观上：复用和扩展模式" class="headerlink" title="微观上：复用和扩展模式"></a>微观上：复用和扩展模式</h3><p>宏观的分支、业态扩展名可以实现<code>行业隔离</code>，让多个团队在同一个仓库下互不干扰，又可以融合开发。</p><p>而微观上层面，主要关注代码的复用和扩展机制，目的则是让行业能够最大限度地「复用」<code>标品</code>的功能和代码。</p><p><br><br><br></p><p>笔者在实践过程中，总结了很多「设计模式」， 比如：</p><table><thead><tr><th>模式</th><th>灵感来源</th><th>概要说明</th><th>适用场景</th></tr></thead><tbody><tr><td>原子能力组合模式</td><td>低代码平台，前端组件化搭建，流程编排</td><td>先对应用程序进行分层，再组成拆分原子能力。实现自上而下的可组合。</td><td>应用的整体架构</td></tr><tr><td>插件模式</td><td>VSCode、各种支持插件的工具</td><td>分离关注点，提取核心能力和外壳。通过插件接口扩展核心能力。</td><td>固定、稳定的业务</td></tr><tr><td>钩子模式</td><td>很多 Web 框架都提供了钩子函数、或者生命周期方法，对框架进行扩展</td><td>预留插槽，按需填充。</td><td>+ 适合比较固化的业务流程，比如登录、下单<br> + 适合比较固化的界面布局，通过插槽扩展某个区块的显示</td></tr><tr><td>覆盖模式</td><td>依赖注入</td><td>通过依赖注入覆盖原有的实现</td><td></td></tr><tr><td>继承模式</td><td>类继承</td><td>在覆盖模式基础深入定制</td><td>实现文件级别的覆盖，完全重新实现功能。和 index 导出兼容。业态隔离</td></tr><tr><td>重复/隔离模式</td><td>React Native、Taro 条件编译</td><td>无可退路的退路。拷贝代码，深度定制，互不干扰</td><td>差异性较大，没有合理扩展方案的情况</td></tr></tbody></table><p>由于文章篇幅原因，<strong>关于这些设计模式的细节，请<a href="https://www.notion.so/358c4bafc42b42acacab2c74f3f21593?pvs=21" target="_blank" rel="noopener">移步到这里</a></strong></p><p><br><br><br><br><br></p><h1 id="没有银弹"><a href="#没有银弹" class="headerlink" title="没有银弹"></a>没有银弹</h1><p>在多业态的架构难题上，笔者并没有想到行之有效的办法。反而随着战略的调整，这个问题变得不再重要。</p><p>上文介绍的战术适配，也仅仅能够实现「隔离」问题。而「复用」问题，我只是给出了一些设计模式，实际执行起来比较困难：一则是需求的变化和多样性足以打破各种美好的假设； 二来这会提升复杂度，不是所有开发者都具备良好的架构设计素养。</p><p>最后，随着市场的变化，驱动企业战略上的调整，企业家逐渐放弃了在产品上做大做全的幻想。 我们的各种挣扎，最终不过是炮灰，并没有太多实际的意义。</p><p><br><br><br></p><p>当然，对我来说也不是一无所获，<strong>历史经验教训</strong>:</p><ul><li>不要过度追求复用。它是一把双刃剑，重复不见得就是坏事，我们需要在复用性和隔离性之间权衡利弊。</li><li>不要追求大而全。更要做深做精。</li><li>用奥卡姆剃刀做减法。放弃那些不切实际的幻想。</li><li>战略和战术配合。不要只在战术层面钻牛角尖。</li><li>Keep it simple and stupid。 简单即是美，在设计和开发过程中，尽量追求简单和易于理解的方案，避免过度设计和复杂性。关注用户最核心的需求。</li></ul><p><br></p><p>本文完，求赞求收藏求转发。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/to-be-shit/Untitled.jpeg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天给大家带来的是 2B 领域的一个架构难题，我们最终也没有找到一个较好「解决」方案， 或者说它本来就是一个伪命题。&lt;/p&gt;
&lt;p&gt;让我慢慢跟你道
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>TypeScript 接口合并， 你不知道的妙用</title>
    <link href="https://bobi.ink/2023/07/17/ts-interface-merge/"/>
    <id>https://bobi.ink/2023/07/17/ts-interface-merge/</id>
    <published>2023-07-16T16:00:00.000Z</published>
    <updated>2023-07-17T06:34:55.473Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ts-interface-merge/Untitled.jpeg" alt="Untitled"></p><p><br></p><h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><p><a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces" target="_blank" rel="noopener">声明合并(Declaration Merging)</a> 是 <code>Typescript</code> 的一个高级特性，顾名思义，<code>声明合并</code>就是将相同名称的一个或多个声明合并为单个定义。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Box &#123;</span><br><span class="line">  height: number;</span><br><span class="line">  width: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Box &#123;</span><br><span class="line">  scale: number;</span><br><span class="line">&#125;</span><br><span class="line">let box: Box = &#123; height: 5, width: 6, scale: 10 &#125;;</span><br><span class="line"></span><br><span class="line">interface Cloner &#123;</span><br><span class="line">  clone(animal: Animal): Animal;</span><br><span class="line">&#125;</span><br><span class="line">interface Cloner &#123;</span><br><span class="line">  clone(animal: Sheep): Sheep;</span><br><span class="line">&#125;</span><br><span class="line">interface Cloner &#123;</span><br><span class="line">  clone(animal: Dog): Dog;</span><br><span class="line">  clone(animal: Cat): Cat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Cloner 将合并为</span><br><span class="line">//interface Cloner &#123;</span><br><span class="line">//  clone(animal: Dog): Dog;</span><br><span class="line">//  clone(animal: Cat): Cat;</span><br><span class="line">//  clone(animal: Sheep): Sheep;</span><br><span class="line">//  clone(animal: Animal): Animal;</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>声明合并最初的设计目的是为了解决早期 <code>JavaScript</code> 模块化开发中的类型定义问题。</p><ul><li>早期的 JavaScript 库基本都使用全局的<code>命名空间</code>，比如  <code>jQuery</code>  使用 <code>$</code>, <code>lodash</code> 使用 <code>_</code>。这些库通常还允许对命名空间进行扩展，比如 jQuery 很多插件就是扩展 $ 的原型方法</li><li>早期很多 Javascript 库也会去扩展或覆盖 JavaScript 内置对象的原型。比如古早的 RxJS 就会去 「Monkey Patching」 JavaScript 的 Array、Function 等内置原型对象。</li></ul><p><br><br><br></p><p>尽管这些方案在当今已经属于「反模式」了，但是在 Typescript 2012 年发布那个年代， jQuery 还是王者。</p><p><br></p><p>Typescript 通过类型合并这种机制，支持将分散到不同的文件中的命名空间的类型定义合并起来，避免编译错误。</p><p>现在是 ES Module 当道， 命名空间的模式已经不再流行。但是不妨碍 <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces" target="_blank" rel="noopener">声明合并</a> 继续发光发热，本文就讲讲它几个有趣的使用场景。</p><p><br><br><br><br><br></p><h1 id="jsx-内置组件声明"><a href="#jsx-内置组件声明" class="headerlink" title="JSX 内置组件声明"></a>JSX 内置组件声明</h1><p>Typescript 下，内置的组件(<code>Host Components</code>) 都挂载在 <code>JSX</code> 命名空间下的 <code>IntrinsicElements</code> 接口中。例如 Vue 的 JSX 声明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// somehow we have to copy=pase the jsx-runtime types here to make TypeScript happy</span><br><span class="line">import type &#123;</span><br><span class="line">  VNode,</span><br><span class="line">  IntrinsicElementAttributes,</span><br><span class="line">  ReservedProps,</span><br><span class="line">  NativeElements</span><br><span class="line">&#125; from &apos;@vue/runtime-dom&apos;</span><br><span class="line"></span><br><span class="line">// 🔴 全局作用域</span><br><span class="line">declare global &#123;</span><br><span class="line">  namespace JSX &#123;</span><br><span class="line">    export interface Element extends VNode &#123;&#125;</span><br><span class="line">    export interface ElementClass &#123;</span><br><span class="line">      $props: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    export interface ElementAttributesProperty &#123;</span><br><span class="line">      $props: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 🔴 内置组件定义</span><br><span class="line">    export interface IntrinsicElements extends NativeElements &#123;</span><br><span class="line">      // allow arbitrary elements</span><br><span class="line">      // @ts-ignore suppress ts:2374 = Duplicate string index signature.</span><br><span class="line">      [name: string]: any</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    export interface IntrinsicAttributes extends ReservedProps &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>我们也可以随意地扩展 IntrinsicElements，举个例子，我们开发了一些 <code>Web Component</code> 组件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare global &#123;</span><br><span class="line">  namespace JSX &#123;</span><br><span class="line">    export interface IntrinsicElements &#123;</span><br><span class="line">      &apos;wkc-header&apos;: &#123;</span><br><span class="line">        // props 定义</span><br><span class="line">        title?: string;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>💡 上面例子中 JSX 是放在 <code>global</code> 空间下的，某些极端的场景下，比如有多个库都扩展了它，或者你即用了 Vue 又用了 React， 那么就会互相污染。<br> 现在 Typescript 也支持 JSX 定义的局部化，配合 <a href="https://www.typescriptlang.org/tsconfig#jsxImportSource" target="_blank" rel="noopener">jsxImportSource</a> 选项来开启， 参考 <a href="https://github.com/vuejs/core/blob/main/packages/vue/jsx-runtime/index.d.ts" target="_blank" rel="noopener">Vue 的实现</a></p></blockquote><p><br><br><br><br><br></p><h1 id="vue-全局组件声明"><a href="#vue-全局组件声明" class="headerlink" title="Vue 全局组件声明"></a>Vue 全局组件声明</h1><p>和 JSX 类似， Vue 全局组件、全局属性等声明也通过接口合并来实现。下面是 vue-router 的代码示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare module &apos;@vue/runtime-core&apos; &#123;</span><br><span class="line">  // Optional API 扩展</span><br><span class="line">  export interface ComponentCustomOptions &#123;</span><br><span class="line">    beforeRouteEnter?: TypesConfig extends Record&lt;&apos;beforeRouteEnter&apos;, infer T&gt;</span><br><span class="line">      ? T</span><br><span class="line">      : NavigationGuardWithThis&lt;undefined&gt;</span><br><span class="line">    beforeRouteUpdate?: TypesConfig extends Record&lt;&apos;beforeRouteUpdate&apos;, infer T&gt;</span><br><span class="line">      ? T</span><br><span class="line">      : NavigationGuard</span><br><span class="line">    beforeRouteLeave?: TypesConfig extends Record&lt;&apos;beforeRouteLeave&apos;, infer T&gt;</span><br><span class="line">      ? T</span><br><span class="line">      : NavigationGuard</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 组件实例属性</span><br><span class="line">  export interface ComponentCustomProperties &#123;</span><br><span class="line">    $route: TypesConfig extends Record&lt;&apos;$route&apos;, infer T&gt;</span><br><span class="line">      ? T</span><br><span class="line">      : RouteLocationNormalizedLoaded</span><br><span class="line">    $router: TypesConfig extends Record&lt;&apos;$router&apos;, infer T&gt; ? T : Router</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 🔴 全局组件</span><br><span class="line">  export interface GlobalComponents &#123;</span><br><span class="line">    RouterView: TypesConfig extends Record&lt;&apos;RouterView&apos;, infer T&gt;</span><br><span class="line">      ? T</span><br><span class="line">      : typeof RouterView</span><br><span class="line">    RouterLink: TypesConfig extends Record&lt;&apos;RouterLink&apos;, infer T&gt;</span><br><span class="line">      ? T</span><br><span class="line">      : typeof RouterLink</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>上面我们见识了 JSX 使用 <code>declare global</code>  来挂载<code>全局作用域</code>，而 <code>declare module *</code> 则可以挂载到<code>具体模块的作用域</code>中。</p><p><br></p><p>另外，我们在定义 Vue Route 时，通常会使用 meta 来定义一些路由元数据，比如标题、权限信息等,  也可以通过上面的方式来实现：</p><p><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare module &apos;vue-router&apos; &#123;</span><br><span class="line">  interface RouteMeta &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 是否显示面包屑, 默认 false</span><br><span class="line">     */</span><br><span class="line">    breadcrumb?: boolean</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 标题</span><br><span class="line">     */</span><br><span class="line">    title?: string</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 所需权限</span><br><span class="line">     */</span><br><span class="line">    permissions?: string[]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const routes: RouteRecordRaw[] = [ </span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/club/plugins&apos;,</span><br><span class="line">    name: &apos;custom-club-plugins&apos;,</span><br><span class="line">    component: () =&gt; import(&apos;./plugins&apos;),</span><br><span class="line">    // 现在 meta 就支持类型检查了</span><br><span class="line">    meta: &#123;</span><br><span class="line">      breadcrumb: true,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h1 id="依赖注入：实现标识符和类型信息绑定"><a href="#依赖注入：实现标识符和类型信息绑定" class="headerlink" title="依赖注入：实现标识符和类型信息绑定"></a>依赖注入：实现标识符和类型信息绑定</h1><p>还有一个比较有趣的使用场景，即依赖注入。我们在使用 <code>[InversifyJS](https://github.com/inversify/InversifyJS)</code> 这里依赖注入库时，通常都会使用字符串或者 Symbol 来作为依赖注入的<code>标识符</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// inversify 示例</span><br><span class="line">// 定义标识符</span><br><span class="line">const TYPES = &#123;</span><br><span class="line">    Warrior: Symbol.for(&quot;Warrior&quot;),</span><br><span class="line">    Weapon: Symbol.for(&quot;Weapon&quot;),</span><br><span class="line">    ThrowableWeapon: Symbol.for(&quot;ThrowableWeapon&quot;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@injectable()</span><br><span class="line">class Ninja implements Warrior &#123;</span><br><span class="line">    @inject(TYPES.Weapon) private _katana: Weapon;</span><br><span class="line">    @inject(TYPES.ThrowableWeapon) private _shuriken: ThrowableWeapon;</span><br><span class="line">    public fight() &#123; return this._katana.hit(); &#125;</span><br><span class="line">    public sneak() &#123; return this._shuriken.throw(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>但是这种标识符没有关联任何类型信息，无法进行类型检查和推断。</p><p><br></p><p>于是，笔者就想到了<code>接口合并</code>。能不能利用它来实现标识符和类型之间的绑定？答案是可以的：</p><p>我们可以声明一个全局的 <code>DIMapper</code> 接口。这个接口的 key 为依赖注入的标识符，value 为依赖注入绑定的类型信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare global &#123;</span><br><span class="line">  interface DIMapper &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>接下来，依赖注入的『供应商』，就可以用来声明标识符和注入类型的绑定关系：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface IPhone &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 打电话</span><br><span class="line">   */</span><br><span class="line">  call(num: string): void</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 发短信</span><br><span class="line">   */</span><br><span class="line">  sendMessage(num: string, message: string): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 表示 DI.IPhone 这个标识符关联的就是 IPhone 接口类型</span><br><span class="line">declare global &#123;</span><br><span class="line">  interface DIMapper &#123;</span><br><span class="line">    &apos;DI.IPhone&apos;: IPhone</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>我们稍微改造一下依赖注入相关方法的实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取所有依赖注入标识符</span><br><span class="line"> */</span><br><span class="line">export type DIIdentifier = keyof DIMapper;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 计算依赖注入值类型</span><br><span class="line"> */</span><br><span class="line">export type DIValue&lt;T extends DIIdentifier&gt; = DIMapper[T];</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 注册依赖</span><br><span class="line"> */</span><br><span class="line">export function registerClass&lt;I extends DIIdentifier, T extends DIValue&lt;I&gt;&gt;(</span><br><span class="line">  identifier: I,</span><br><span class="line">  target: new (...args: never[]) =&gt; T,</span><br><span class="line">): void</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取依赖</span><br><span class="line"> */</span><br><span class="line">export function useInject&lt;I extends DIIdentifier, T extends DIValue&lt;I&gt;&gt;(</span><br><span class="line">  identifier: I,</span><br><span class="line">  defaultValue?: T,</span><br><span class="line">): T</span><br></pre></td></tr></table></figure><p><br></p><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo &#123;&#125;</span><br><span class="line">class MI &#123;</span><br><span class="line">  call(num: string) &#123;&#125;</span><br><span class="line">  sendMessage(num: string, message: string) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">registerClass(&apos;DI.IPhone&apos;, Foo) // ❌ 这个会报错，Foo 不符合 IPhone 接口</span><br><span class="line">registerClass(&apos;DI.IPhone&apos;, MI) // ✅ OK!</span><br><span class="line"></span><br><span class="line">const phone = useInject(&apos;DI.IPhone&apos;) // phone 自动推断为 IPhone 类型</span><br></pre></td></tr></table></figure><blockquote><p>💡 对于依赖注入，我在 <a href="https://juejin.cn/post/7250356064989397053" target="_blank" rel="noopener">全新 JavaScript 装饰器实战下篇：实现依赖注入</a>， 介绍了另外一种更加严格和友好的方式。</p></blockquote><p><br><br><br><br><br></p><h1 id="事件订阅"><a href="#事件订阅" class="headerlink" title="事件订阅"></a>事件订阅</h1><p>同样的办法也可以用于<code>事件订阅</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare global &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 声明 事件 标识符和类型的映射关系</span><br><span class="line">   * @example 扩展定义</span><br><span class="line">   * declare global &#123;</span><br><span class="line">   *   interface EventMapper &#123;</span><br><span class="line">   *     &apos;Event.foo.success&apos;: ISuccessMessage</span><br><span class="line">   *   &#125;</span><br><span class="line">   * &#125;</span><br><span class="line">   */</span><br><span class="line">  interface EventMapper &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 事件名称</span><br><span class="line"> */</span><br><span class="line">export type EventName = keyof EventMapper;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 事件参数</span><br><span class="line"> */</span><br><span class="line">export type EventArgument&lt;T extends EventName&gt; = EventMapper[T];</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>EventBus 实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export class EventBus &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 监听事件</span><br><span class="line">   */</span><br><span class="line">  on&lt;N extends EventName, A extends EventArgument&lt;N&gt;&gt;(event: N, callback: (arg: A) =&gt; void) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 触发事件</span><br><span class="line"></span><br><span class="line">   */</span><br><span class="line">  emit&lt;N extends EventName, A extends EventArgument&lt;N&gt;&gt;(event: N, arg: A) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h1 id="动态类型插槽"><a href="#动态类型插槽" class="headerlink" title="动态类型插槽"></a>动态类型插槽</h1><p>还有一个比较脑洞的例子，我之前封装过一个 Vue i18n 库，因为  Vue 2/3 差异有点大，所以我就拆了两个库来实现，如下图。<code>i18n</code> 用于  <code>Vue 3</code> + <code>vue-i18n@&gt;=9</code>, <code>i18n-legacy</code> 用于 <code>Vue 2</code> + <code>vue-i18n@8</code>。</p><p>但是两个库大部分的实现是一致的，这些共性部分就提取到 <code>i18n-shared</code> ：</p><p><img src="/images/ts-interface-merge/Untitled.png" alt="Untitled"></p><p>然而 <code>i18n-shared</code> 并不耦合 <code>Vue</code> 和 <code>vue-i18n</code> 的版本，也不可能将它们声明为依赖项， 那么它相关 API 的类型怎么办呢？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// i18n-shared 代码片段</span><br><span class="line">export interface I18nInstance &#123;</span><br><span class="line">  /**</span><br><span class="line">   * vue 插件安装</span><br><span class="line">   * 🔴 VueApp 是 Vue App 的实例</span><br><span class="line">   */</span><br><span class="line">  install(app: VueApp): void;</span><br><span class="line"></span><br><span class="line">  // 🔴 vue-i18n 的实例</span><br><span class="line">  i18n: VueI18nInstance;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取全局实例</span><br><span class="line"> * @returns</span><br><span class="line"> */</span><br><span class="line">export function getGlobalInstance(): I18nInstance &#123;</span><br><span class="line">  if (globalInstance == null) &#123;</span><br><span class="line">    throw new Error(`请先使用 createI18n 创建实例`);</span><br><span class="line">  &#125;</span><br><span class="line">  return globalInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取全局 vue i18n 实例</span><br><span class="line"> */</span><br><span class="line">export function getGlobalI18n(): I18nInstance[&apos;i18n&apos;] &#123;</span><br><span class="line">  return getGlobalInstance().i18n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>这里用<code>泛型</code>也解决不了问题。</p><p>一些奇巧淫技还得是类型合并。我在这里就巧妙地使用了类型合并来创建<code>类型插槽。</code></p><p>首先在 <code>i18n-shared</code> 下预定义一个接口：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 🔴 供子模块详细定义类型参数</span><br><span class="line"> */</span><br><span class="line">export interface I18nSharedTypeParams &#123;</span><br><span class="line">  // VueI18nInstance: vue i18n 实例类型</span><br><span class="line">  // FallbackLocale</span><br><span class="line">  // VueApp 应用类型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 提取参数</span><br><span class="line">// @ts-expect-error</span><br><span class="line">type ExtraParams&lt;T, V = I18nSharedTypeParams[T]&gt; = V;</span><br><span class="line"></span><br><span class="line">export type VueApp = ExtraParams&lt;&apos;VueApp&apos;&gt;;</span><br><span class="line">export type VueI18nInstance = ExtraParams&lt;&apos;VueI18nInstance&apos;&gt;;</span><br></pre></td></tr></table></figure><p><br></p><p>定义了一个接口 <code>I18nSharedTypeParams</code>，<strong>它具体的类型由下级的库来注入</strong>，我尚且把它命名为 “<code>动态类型插槽</code>” 吧。</p><p>现在 <code>i18n</code> 和 <code>i18n-legacy</code> 就可以根据自己的依赖环境来配置它了：</p><p><br><br><br></p><p>i18n-legacy:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import VueI18n from &apos;vue-i18n&apos;; // vue-i18n@8</span><br><span class="line">import Vue from &apos;vue&apos;; // vue@2</span><br><span class="line"></span><br><span class="line">declare module &apos;i18n-shared&apos; &#123;</span><br><span class="line">  export interface I18nSharedTypeParams &#123;</span><br><span class="line">    VueI18nInstance: VueI18n;</span><br><span class="line">    VueApp: typeof Vue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>i18n:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; VueI18n, Composer &#125; from &apos;vue-i18n&apos;; // vue-i18n@9+</span><br><span class="line">import &#123; App &#125; from &apos;vue&apos;; // vue@3</span><br><span class="line"></span><br><span class="line">declare module &apos;i18n-shared&apos; &#123;</span><br><span class="line">  interface I18nSharedTypeParams &#123;</span><br><span class="line">    VueI18nInstance: VueI18n&lt;any, any, any&gt; | Composer&lt;any, any, any&gt;;</span><br><span class="line">    VueApp: App;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>💡 源码可以<a href="https://github.com/wakeadmin/tools/blob/db3809305e5698ac31a130319f430377a0e9c1be/packages/i18n-shared/src/types.ts#L45" target="_blank" rel="noopener">看这里</a></p></blockquote><p><br><br><br><br><br></p><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>当你深入了解了类型合并之后，你可能会在越来越多的地方发现它的身影。这毕竟是 TypeScript 为数不多，支持动态去扩展类型的特性。</p><p>更多的场景，读者可以开开脑洞，比如：</p><ul><li><code>unplugin-vue-components</code>  Vue 组件自动导入是如何支持类型检查的？</li><li><a href="https://github.com/posva/unplugin-vue-router" target="_blank" rel="noopener">unplugin-vue-router</a> 如何实现支持类型检查的 vue-router?</li><li>给插件系统加上类型检查</li><li>…</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/ts-interface-merge/Untitled.jpeg&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;初识&quot;&gt;&lt;a href=&quot;#初识&quot; class=&quot;headerlink&quot; title=&quot;初
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>微前端的落地和治理实战</title>
    <link href="https://bobi.ink/2023/07/13/microfrontend/"/>
    <id>https://bobi.ink/2023/07/13/microfrontend/</id>
    <published>2023-07-12T16:00:00.000Z</published>
    <updated>2023-07-13T02:11:54.631Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/microfrontend/Untitled.png" alt="Untitled"></p><p>微前端实现原理、框架选型之类的文章比较泛滥，我不打算讲这些玩意，本文主要来源于笔者过去一年落地微前端的一手经验，尽量不讲技术细节，而是讲一个体系化的方案是怎么搭建起来。</p><p>文章较长，耐心看完保证会有收获。</p><h1 id="背景与痛点"><a href="#背景与痛点" class="headerlink" title="背景与痛点"></a>背景与痛点</h1><p>首先来看下业务背景，方便读者了解我们为什么选择微前端，以及其他相关技术选型的原因。</p><p>前端在架构上面的变化远落后于后端，后端的架构已经经历了微服务、中台化、DDD 改造的腥风血雨…</p><p>在改造成微前端之前, 我们也是一个巨型的<code>单体应用</code>，后面随着业务的复杂化，业务和团队进一步进行拆分， 我们的前端项目也根据<a href="https://zh.wikipedia.org/zh-hans/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener"><code>康威定律</code></a>，进化成为了‘<code>多页应用</code>’， 如下图所示：</p><p><img src="/images/microfrontend/Untitled%201.png" alt="多页"></p><p><br></p><p>我们主要做的是 2B 业务，做 <a href="https://zh.wikipedia.org/zh-hans/%E6%A6%82%E5%BF%B5%E9%AA%8C%E8%AF%81" target="_blank" rel="noopener">POC</a>(概念验证) 和<code>私有化部署</code>是家常便饭，在已有的架构下，我们需要应用某些配置可能会牵扯多个项目，比如主题、文案、接口配置等信息的修改，需要针对多个项目进行创建分支、修改代码、构建、发布、部署… 一系列繁琐的流程</p><p>主要原因是我们的业务系统经过长期、多团队、多业态的迭代，积累了大量的技术债。</p><ul><li>技术栈老旧，开发效率低，我们想要应用新的技术和规范，但碍于项目体量大、质量差，重构举步维艰。</li><li>子应用的拆分没有固定的范式。有些模块按照团队拆分出独立的仓库，有些仓库则采用 MonoRepo。前者仓库之间存在大量重复代码、缺乏管理；而后者 MonoRepo 则越来越臃肿, 职责不清晰，编译缓慢, 逐渐也演变成了<code>巨石应用</code>。</li><li>基于多页的子应用缺乏管理，规范/标准不统一。无法统一控制视觉呈现、共享的功能和依赖。造成重复工作</li><li>新旧项目、第三方应用集成都很复杂。</li><li>多行业、多团队的项目特性，导致工程管理复杂，扩展性差。</li><li>部署方式原始。</li><li>应用按照菜单聚合，而不是按照业务聚合</li><li>…</li></ul><p><br></p><blockquote><p>💡  怎么理解 “应用按照菜单聚合，而不是按照业务聚合” 呢？</p><p><img src="/images/microfrontend/Untitled%202.png" alt="菜单聚合"></p><p><strong>朴素的多页应用通常按照“菜单”来拆分应用，比如按照上图的顶级 Tab。</strong></p><p>后面来这一个这样的需求，a 应用的某些功能菜单需要在 b Tab 下展示，这时候就傻眼了：</p><ul><li>把 a 的相关代码搬运到 b？如果后面菜单又改了怎么办？再说，你能搬得动吗？</li><li>用 iframe 将 a 套在 b 应用下？</li></ul></blockquote><p><br><br><br></p><p>因此我们亟需一套新的架构，<strong>能统一管理不同团队业务线、同时能够保持原本的独立性和灵活性</strong>。这时候微前端架构就进入了我们的考察范围：</p><p><img src="/images/microfrontend/Untitled%203.png" alt="星状"></p><p>我们需要一个「底座」将不同的应用聚合起来，将原本<code>离散</code>的应用通过一个<code>基座</code>串联起来：</p><ul><li><strong>离散的应用结构，转换为星状结构。</strong>基座可以统一管理子应用。</li><li><strong>开发者可以更专注于业务的开发</strong>。基座会提供配套的登录会话管理、权限管理、菜单管理、路由管理、主题管理等方案，子应用只需关心业务功能本身的开发。</li><li><strong>更容易地集成应用</strong>。不管是自己的业务应用、老旧系统、还是外部第三方应用，都可以在极少改动的情况下集成进来。</li><li><strong>视觉统一</strong>。</li><li><strong>拆分巨石应用，让子应用可以按照“业务聚合”</strong>。<strong>不再耦合菜单</strong>， 让应用更轻量、内聚、更可维护</li></ul><blockquote><p>💡  使用微前端之后，子应用不再耦合菜单，菜单由基座来管理和组合，菜单可以被放在任意位置。</p></blockquote><p><br></p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><strong>由于我们原本就是<code>多页应用</code>的架构，所以基于<code>路由分发</code> + <code>基座形式</code>的微前端方案是一种比较自然的选择</strong>。整体项目架构如下：</p><p><img src="/images/microfrontend/Untitled%204.png" alt="Untitled"></p><p>我们构造了一整套体系化的方案： 从<code>规范</code>到<code>开发基础库</code>、从<code>权限管理系统</code>到<code>微前端基座</code>、从<code>开发调试</code>到<code>部署运维</code>。</p><ol><li><strong>基础库：</strong>我们将每个应用都重复的工作提取出来，重新设计，并严格管理起来。使之能真正有效地服务业务开发，避免重复造轮子。</li><li><strong>开发规范</strong>：同时，我们期望提供更丰富的开发规范、指导、最佳实践作为支撑。让开发者走更少的弯路。</li><li><strong>权限管理平台</strong>：基座的<strong>菜单</strong>、<strong>权限信息</strong>来源于<code>权限管理平台</code>, 通过权限管理平台可以灵活地给不同业态、不同角色配置不同的菜单和权限。这是我们微前端方案的重要基础。</li><li><strong>基座:</strong> 基座是微前端应用集成的一个重要平台。同时也肩负着管理公共资源、依赖、规范的责任。主要有以下职责：<ul><li>子应用集成。给子应用提供渲染容器</li><li>路由/菜单管理</li><li>权限管理</li><li>主题管理</li><li>会话管理</li><li>多语言管理</li><li>共享依赖等</li></ul></li><li><p><strong>运行容器：<a href="https://wakeadmin.wakedata.com/mapp/deploy.html" target="_blank" rel="noopener">运行容器</a></strong>  是我们提供的一套微前端的运行和部署方案。相比传统纯粹的前端资源静态部署，我们希望在部署阶段可以做更多的事情：</p><ul><li>动态配置。比如域名配置、SEO 信息配置</li><li>主题管理。一键换肤能否实现？</li><li>子应用管理。自动发现子应用，而不是在微前端基座中硬编码？</li><li>语言包。能否实时配置语言包，而不需要重新编译代码、审核、发布…</li><li>开发环境、测试环境部署能否简化？</li></ul><p>得益于<code>运行容器</code>，我们可以实现<strong>前端部署的标准化</strong>，支持「<strong>一键部署」</strong>等能力。</p></li></ol><p><br><br><br><br><br><br><br></p><h1 id="基座"><a href="#基座" class="headerlink" title="基座"></a>基座</h1><p><img src="/images/microfrontend/Untitled%205.png" alt="基座主界面"></p><p>基座主界面</p><p>如上所示，基座为子应用提供了基础的运行环境， 蓝色区域为子应用的运行范围。</p><p><br></p><p><img src="/images/microfrontend/Untitled%206.png" alt="基座结构"></p><p>基座的大概结构如上。</p><p>首先是<code>会话管理</code>，基座会<code>拦截</code>应用的所有请求，如果监听到 401 状态码，则跳转到登录页面进行授权。登录/注册页面也是由子应用提供，我们尽量不让基座耦合具体的业务。</p><p><br></p><p>基座启动后，就会从<code>权限管理平台</code>拉取菜单、权限配置信息，渲染页面的菜单导航框架。同时也会对页面路由进行授权拦截，而细粒度的权限控制(比如按钮)，基座也会暴露 API 供子应用适配。</p><p><br></p><p>至于子应用信息，则是<strong>由<code>运行容器</code>自动发现并注入</strong>，避免在基座中硬编码了这些信息。基座底层基于 <a href="https://github.com/umijs/qiankun" target="_blank" rel="noopener">qiankun</a>，根据路由匹配渲染指定的子应用。</p><blockquote><p>💡 <code>运行容器</code>是啥? 这个我们会在下文介绍，简单来说，它就是一个 <code>NodeJS</code> 服务，会<strong>自动发现</strong>已经部署在服务器中的子应用，然后将这些信息注入到基座的启动代码中。</p></blockquote><p><br></p><p>基座还统一管理了<code>主题包</code>、<code>多语言</code>。从而保证子应用可以有较为统一的呈现。主题包也可以在部署时动态切换，这对于 POC 或者私有化部署比较方便。</p><blockquote><p>💡  主题包主要包含 CSS 变量、组件库样式、语言包、静态资源、甚至一些部署配置信息。</p></blockquote><p><br></p><p><img src="/images/microfrontend/Untitled%207.png" alt="API"></p><p>为了方便子应用使用基座的「<code>服务</code>」， 基座也向子应用暴露了一系列的组件库和 API。</p><p>组件库基于使用 <code>Web Component</code> 的形式，实现框架无关， 基于 Vue 3 创建。Vue 3 <a href="https://cn.vuejs.org/guide/extras/web-components.html" target="_blank" rel="noopener">构建自定义元素</a> 也很方便，所以就没必要引入其他框架专门来编写这块了</p><p>这些 API 可以直接挂载在全局 window 对象上，子应用可以直接访问。</p><blockquote><p>💡  实际上我们封装了一个套壳 npm 库，避免子应用直接访问 window 对象上的服务, 隐藏细节，另外可以提供类型提示。</p></blockquote><p><br><br><br><br><br><br><br></p><h1 id="子应用接入"><a href="#子应用接入" class="headerlink" title="子应用接入"></a>子应用接入</h1><p>简单、免侵入地改造子应用使我们要达成的主要目标。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>为此，我们也提供了相应的 <code>vue-cli</code> 插件, 支持快速集成，避免开发者关心 Webpack 底层的各种配置细节</p><blockquote><p>我们的微前端主要基于 <a href="https://github.com/umijs/qiankun" target="_blank" rel="noopener">qiankun</a>，官方目前并不支持 Vite，并且我们大量项目主要以 Vue CLI 为主。</p></blockquote><p>示例：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">'@vue/cli-service'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; defineMappChild &#125; = <span class="built_in">require</span>(<span class="string">'@wakeadmin/vue-cli-plugin-mapp-child'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  transpileDependencies: <span class="literal">false</span>,</span><br><span class="line">  pluginOptions: &#123;</span><br><span class="line">    <span class="comment">// 只需要简单的配置</span></span><br><span class="line">    ...defineMappChild(&#123;</span><br><span class="line">      mapp: &#123;</span><br><span class="line">        activeRule: <span class="string">'/dsp.html'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">  lintOnSave: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>多入口配置：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">'@vue/cli-service'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; defineMappChild &#125; = <span class="built_in">require</span>(<span class="string">'@wakeadmin/vue-cli-plugin-mapp-child'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  <span class="comment">// 多页应用</span></span><br><span class="line">  pages: &#123;</span><br><span class="line">    index: <span class="string">'src/main.ts'</span>,</span><br><span class="line">    another: <span class="string">'src/another.ts'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  pluginOptions: &#123;</span><br><span class="line">    <span class="comment">// 微前端集成配置</span></span><br><span class="line">    ...defineMappChild(&#123;</span><br><span class="line">      mapp: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// entry 必须为上面 pages 中定义的 key</span></span><br><span class="line">          entry: <span class="string">'index'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// entry 必须为上面 pages 中定义的 key</span></span><br><span class="line">          entry: <span class="string">'another'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>接着调整应用挂载程序：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp, App <span class="keyword">as</span> TApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHashHistory &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> Bay <span class="keyword">from</span> <span class="string">'@wakeadmin/bay'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; routes &#125; <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app: TApp</span><br><span class="line"></span><br><span class="line">Bay.createMicroApp(&#123;</span><br><span class="line">  <span class="keyword">async</span> bootstrap() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bootstrap vue3'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> mount(container, props) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'mount vue3'</span>, props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">      history: createWebHashHistory(),</span><br><span class="line">      routes,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    app = createApp(App).use(store).use(router).use(Bay)</span><br><span class="line"></span><br><span class="line">    app.mount(container?.querySelector(<span class="string">'#app'</span>) ?? <span class="string">'#app'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> unmount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'unmount vue3'</span>)</span><br><span class="line"></span><br><span class="line">    app.unmount()</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> update() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'update vue3'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="本地开发和调试"><a href="#本地开发和调试" class="headerlink" title="本地开发和调试"></a>本地开发和调试</h2><p>运行起来后， 我们会在终端打印出子应用的相关信息，如下图：</p><p><img src="/images/microfrontend/Untitled%208.png" alt="terminal"></p><p>接下来，只需要在<code>基座的调试页面</code>，注册这个子应用就可以运行起来的：</p><p><img src="/images/microfrontend/Untitled%209.png" alt="debug"></p><blockquote><p>💡  有了微前端之后，子应用的开发和调试也简化了很多，可以随时挂载到任意环境，不需要配置任何服务端代理。</p></blockquote><p><br><br><br><br><br></p><h1 id="部署和治理"><a href="#部署和治理" class="headerlink" title="部署和治理"></a>部署和治理</h1><p>网上很少关于微前端应用的部署和治理的介绍，下面介绍我们自己摸索出来一套方案， 这也是本文的重点。</p><p><br></p><h2 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h2><p>在此之前，我们的前端项目都是扔到一台静态资源服务器，很多开发者会手动操作，项目之前通过目录隔离，手动维护 Nginx 进行分流，手段原始且容易出错，场面十分混乱。</p><p>在 2021 年，我们就开始推行前端项目的容器化，来解决这种混乱的状态。</p><p>为了<code>标准化</code>、<code>自动化</code>每个项目的构建操作、部署流程，我们和后端对齐， 使用容器和 K8S 来实现发布产物的封装和部署。这样的好处是：</p><ul><li>实现测试环境和生产环境的统一。</li><li>简化部署流程， 采用统一的配置，无需更改 Nginx 配置</li><li>真正做到不同团队项目的隔离。</li><li>支持回滚</li><li>简化和标准化构建流程。同时也简化了运维的工作，前后端都是容器部署。</li><li>运行的环境更加灵活。我们可以使用最新的 nginx 版本，可以使用 HTTP2 等新的技术，前端自己就可以部署一套 NodeJS 环境，做一些更酷的事情。对运维的依赖性会更低。</li></ul><p><br></p><p>这对我们来说是一个比较重要的升级。我们的工作不再局限于静态资源的伺服，我们可以使用 NodeJS 开发 API、自动化工作流、可以进行服务端渲染等等，拓展了能力的边界。</p><p><br><br><br></p><p>然而，很多配置信息在构建时就固定下来了，比如 CDN 域名，接口请求路径等等。而不同环境通常会使用不同的配置信息。<strong>这样就无法实现构建一次镜像，在不同环境运行。</strong></p><p>后端程序的解决办法是将配置信息外置，比如通过<code>环境变量</code>配置或者从<code>配置中心</code>(比如 Nacos)获取。</p><p>这在前端行不通，所以我们引入了<code>运行容器</code>的概念。</p><p><br><br><br></p><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p><code>运行容器</code>，顾名思义就是整套<code>微前端</code> 的<code>运行时</code>，以 「<code>Docker 容器</code>」的形式部署。我们尽量复用 K8S 提供的基础设施(比如 PVC、配置映射、Sidecar 等) 来实现。</p><p>运行容器的主要结构：</p><p><img src="/images/microfrontend/Untitled%2010.png" alt="container"></p><p><code>运行容器</code>主要包含两大部分：</p><ul><li><code>Nginx</code> ：毫无疑问，Nginx 是<code>静态资源伺服</code>的最佳能手，同时它作为内部服务<code>反向代理</code>。</li><li><code>transpiler</code> (我们称为<code>转换器</code>): 这是一个「搬运工」，主要负责配置的收集、代码转换。并将转换后的静态资源交给  <code>nginx</code>  伺服。</li></ul><p>下面会详细介绍它的能力。</p><p><br><br><br></p><h2 id="如果实现子应用的自动发现？"><a href="#如果实现子应用的自动发现？" class="headerlink" title="如果实现子应用的自动发现？"></a>如果实现子应用的自动发现？</h2><p>答案是<strong>”约定“</strong>。</p><p>运行容器约定了以下目录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/data/</span><br><span class="line">  /<span class="built_in">source</span>/                   <span class="comment"># 源目录</span></span><br><span class="line">    /__public__/             <span class="comment"># 公共资源, 外部可以直接访问，不需要 __public__ 前缀</span></span><br><span class="line">    /__config__/             <span class="comment"># 配置目录</span></span><br><span class="line">      config.yml</span><br><span class="line">      any-sub-dir/</span><br><span class="line">        my-config.yml</span><br><span class="line"></span><br><span class="line">    /__entry__/              <span class="comment"># 基座目录</span></span><br><span class="line">      js/</span><br><span class="line">      index.html</span><br><span class="line"></span><br><span class="line">    /__apps__/               <span class="comment"># 子应用目录</span></span><br><span class="line">      wkb/</span><br><span class="line">      dsp/</span><br><span class="line">      dmp/</span><br><span class="line">        js/</span><br><span class="line">        mapp.json</span><br><span class="line">        index.html</span><br><span class="line"></span><br><span class="line">    /__i18n__/               <span class="comment"># 语言包目录</span></span><br><span class="line">      zh.tr</span><br><span class="line">      en.tr</span><br><span class="line">      any-sub-dir/</span><br><span class="line">        zh.tr</span><br><span class="line">        en.tr</span><br><span class="line"></span><br><span class="line">    /__theme__/              <span class="comment"># 主题目录</span></span><br><span class="line">      config.yml</span><br><span class="line">      element-ui.css</span><br><span class="line">      element-plus.css</span><br><span class="line">      fonts/</span><br><span class="line">      i18n/</span><br><span class="line">        zh.tr</span><br><span class="line">        en.tr</span><br><span class="line"></span><br><span class="line">  /public/                    <span class="comment"># nginx 伺服目录</span></span><br></pre></td></tr></table></figure><p>目录结构解析：</p><ul><li><code>/data/source</code>。没错，<code>transpiler</code>  就是<code>转译</code>和搬运这里的静态资源。</li><li><code>/data/public</code>。 <code>transpiler</code>  就是将资源转译后搬运到这里，<code>nginx</code>  对外伺服这个目录。</li></ul><p><br></p><blockquote><p>转译？<code>transpiler</code> 可以认为就是一个模板引擎，它会替换代码里面的动态变量。</p></blockquote><p><br></p><p>再来看  <code>/data/source</code>：</p><ul><li><code>__entry__</code>: 基座编译之后的代码就部署这里。</li><li><code>__apps__</code>: 子应用编译之后的代码就部署这里，子应用之间， 按照唯一的  <code>name</code>  区分目录。</li><li><code>__i18n__</code>: 扩展语言包，文件按照  <code>&lt;language&gt;.tr</code>  命名， 子目录的 .tr 文件也会被扫描到。</li><li><code>__config__</code>: 配置目录。配置文件使用  <code>.yml</code>  或  <code>.yaml</code>  命名，也可以放在子目录下。</li><li><code>__theme__</code>: 主题包目录。可以手动维护，也可以使用  <code>npmTheme</code>  配置项, 让  <code>transpiler</code>  从 npm 拉取。</li><li><code>__public__</code>: 公共资源目录。这些资源可以直接访问，而不需要  <code>__public__</code>  前缀。举个例子:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">__theme__/</span><br><span class="line">  index.css  *<span class="comment"># -&gt; 访问链接 example.com/__theme__/index.css*</span></span><br><span class="line">__public__/</span><br><span class="line">  hello.html *<span class="comment"># -&gt; 访问链接 example.com/hello.html*</span></span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><p>那  <code>transpiler</code>  的工作过程应该比较清晰了：</p><ul><li>扫描  <code>__apps__</code>  下的<code>子应用</code>。开发者也可以在<em>子应用目录下</em>使用  <code>mapp.json</code>  显式定义子应用描述信息。扫描后的子应用信息将放在  <code>microApps</code>  变量下。</li><li>扫描  <code>__config__</code>  下的配置文件。解析出配置信息。</li><li>扫描  <code>__i18n__</code>  下的  <code>.tr</code>, 解析结果放在  <code>i18n</code>  变量下。</li><li>扫描  <code>__theme__</code>  目录。<code>__theme__</code>  主题包也支持携带配置文件、语言包，所以这些信息也会合并到配置信息中。另外 CSS 文件、JavaScript 文件将被收集到  <code>theme</code>  变量中。</li></ul><p><br></p><p>扫描完毕之后，<code>transpiler</code>  拿着配置信息进行<code>模板转译</code>，将  <code>/data/source</code>  下的静态资源转换被拷贝到  <code>/data/public</code>  目录下。</p><p>来看个实际的模板例子:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"[%= description %]"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"[%= keywords %]"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"[%= assets.IMG_BAY_FAVICON || entryPath + '/favicon.png' %]"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"version"</span> <span class="attr">content</span>=<span class="string">"[%= version %]"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"update-time"</span> <span class="attr">content</span>=<span class="string">"[%= `$&#123;year&#125;-$&#123;month&#125;-$&#123;date&#125;` %]"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>[%= title %]<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--! [%- theme.stylesheets.map(i =&gt; `&lt;link rel="stylesheet" href="$&#123;i + '?' + hash &#125;" /&gt;`).join('\n') %] --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--! [%- theme.scripts.map(i =&gt; `&lt;script async="true" src="$&#123;i + '?' + hash&#125;"&gt;&lt;/script&gt;`).join('\n') %] --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--! [% if (microApps.length) &#123; %] --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--! [%- </span></span><br><span class="line"><span class="comment">      `&lt;script&gt;</span></span><br><span class="line"><span class="comment">        // 微应用注入</span></span><br><span class="line"><span class="comment">        (window.__MAPPS__ = (window.__MAPPS__ || [])).push($&#123;microApps.map(i =&gt; JSON.stringify(i)).join(', ')&#125;);</span></span><br><span class="line"><span class="comment">      &lt;/script&gt;`</span></span><br><span class="line"><span class="comment">    %] --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--! [% &#125; %]--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--! [%- `&lt;script&gt;</span></span><br><span class="line"><span class="comment">      // 静态资源注入</span></span><br><span class="line"><span class="comment">      (window.__MAPP_ASSETS__ = (window.__MAPP_ASSETS__ || [])).push($&#123;JSON.stringify(assets)&#125;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      // 全局共享的语言包</span></span><br><span class="line"><span class="comment">      window.__I18N_BUNDLES__ = $&#123;JSON.stringify(i18n)&#125;;</span></span><br><span class="line"><span class="comment">    &lt;/script&gt;` %] --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">      <span class="attr">defer</span>=<span class="string">"defer"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">"[%= cdnDomain ? '//' + cdnDomain : '' %][%= removeTrailingSlash(base) %]/__entry__/js/chunk-vendors.582ba02c.js?[%= hash %]"</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">      <span class="attr">defer</span>=<span class="string">"defer"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">"[%= cdnDomain ? '//' + cdnDomain : '' %][%= removeTrailingSlash(base) %]/__entry__/js/app.01bd68bb.js?[%= hash %]"</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">      <span class="attr">href</span>=<span class="string">"[%= cdnDomain ? '//' + cdnDomain : '' %][%= removeTrailingSlash(base) %]/__entry__/css/app.d835cada.css?[%= hash %]"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">rel</span>=<span class="string">"stylesheet"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span></span></span><br><span class="line"><span class="tag">      &gt;</span><span class="tag">&lt;<span class="name">strong</span></span></span><br><span class="line"><span class="tag">        &gt;</span>We're sorry but [%= title %] doesn't work properly without JavaScript enabled. Please</span><br><span class="line">        enable it to continue.</span><br><span class="line">      <span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">noscript</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><p>上面是基座的  <code>index.html</code>  模板。<code>transpiler</code>  基于  <strong><a href="https://ejs.bootcss.com/" target="_blank" rel="noopener">ejs</a></strong>  模板引擎，会解析替换文本文件中  <code>[% 模板 %]</code>  语法。</p><p><br></p><p>还有很多用法值得去挖掘。 比如:</p><ul><li>全局埋点脚本注入</li><li>全局监控脚本注入</li><li>…</li></ul><p>原理就是这么简单，只要子应用部署到 <code>__apps__</code> 目录下，我们就可以监听到，收集到必要的信息后，对 <code>source</code> 目录下的静态文件进行转译，输出到 <code>public</code> 目录下，最终由 Nginx 负责将文件传递给浏览器。</p><p><br><br><br><br><br></p><h2 id="部署和运维"><a href="#部署和运维" class="headerlink" title="部署和运维"></a>部署和运维</h2><p>那么子应用具体如何部署和运维呢？</p><p>子应用构建、生成和发布容器的过程这里就不展开说了，可以自行搜索 Docker 的相关教程，我们这里主要简单介绍一下在 K8S 平台如何部署和运维。</p><p>将基座和子应用聚合在一起，我们需要用到 <code>PVC</code> (PersistentVolumeClaim, 即持久化卷), 你可以认为 PVC 就是一个「网络硬盘」，而每个子应用、基座都是独立运行的「主机」(<code>Pod</code> 或 容器 , <em>Kubernetes</em>  中可部署的最小、最基本对象), 这个 PVC 可以被每个子应用共享访问，只要按照约定将子应用的静态文件拷贝到 PVC 对应位置就行了。如下图所示：</p><p><img src="/images/microfrontend/Untitled%2011.png" alt="PVC"></p><p><br><br><br><br><br></p><p>至于子应用和运行容器在 K8S 下如何组织，可以非常灵活，取决于需求和环境。笔者实践过以下几种方式：</p><ol><li><p>全部部署在一个 Pod 下。子应用作为 <code>Init Sidecar</code>（初始化边车）。这种部署方式比较简单，缺点就是任意一个应用需要更新，整个 Pod 都要重启，包括运行容器。</p><p><img src="/images/microfrontend/Untitled%2012.png" alt="方法1"></p><p>示例图：</p><p><img src="/images/microfrontend/Untitled%2013.png" alt="Sidecar"></p></li><li><p>分离运行容器和子应用。为了避免子应用更新导致整个 Pod 重启（包括运行容器），我们可以将子应用单独拎出去，子应用更新只会重启所在的 Pod，从而避免运行容器停机。</p><p><img src="/images/microfrontend/Untitled%2014.png" alt="方法2"></p></li><li><p>每个子应用都是独立的 Pod。好处就是每个子应用可以真正做到独立部署、启动，坏处就是管理起来稍显麻烦。</p><p><img src="/images/microfrontend/Untitled%2015.png" alt="方法3"></p></li></ol><p>开发者可以根据自己的运行环境选择不同的组织方式。</p><p><br><br><br><br><br></p><h2 id="那么配置呢？"><a href="#那么配置呢？" class="headerlink" title="那么配置呢？"></a>那么配置呢？</h2><p>首先简单的配置可以通过<code>环境变量</code>来实现，因为在 K8S 中，配置环境变量相对简单很多:</p><p><img src="/images/microfrontend/Untitled%2016.png" alt="环境变量配置"></p><p>对于稍微复杂的配置，可以使用<code>配置映射</code>(Config-Maps), 配置映射的每个键值对就相当于一个文件，我们可以挂载到容器的任何位置上：</p><p>定义配置映射：</p><p><img src="/images/microfrontend/Untitled%2017.png" alt="定义配置映射"></p><p>挂载配置映射：</p><p><img src="/images/microfrontend/Untitled%2018.png" alt="挂载配置映射"></p><p>配置映射可以挂载到任意的路径或文件上，它还有一个更赞的能力<strong>是：我们可以直接修改配置映射，这些变动会同步到容器内，从而实现实时变更</strong>。</p><p>小结。我们尽量复用了 K8S 本身的能力，这些能力足以实现较为复杂功能，避免重复造轮子。</p><p><br><br><br><br><br></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>限于篇幅很多细节无法展开，这里点到为止：</p><ul><li><strong>如何实现一键部署？</strong>因为使用的是容器化部署，可以将所有部署声明在 <a href="https://www.notion.so/b590284a71934f97a1db71ef967fbc5a?pvs=21" target="_blank" rel="noopener">yaml 文件</a>中维护, 新环境部署时直接导入就行。我们也开发过一个<a href="https://wakeadmin.wakedata.com/k8s-deploy/index.html#/micro" target="_blank" rel="noopener">可视化生成 yaml 的简易应用</a></li><li><strong>自动化部署？</strong>实现自动化部署有很多手段，如果你的公司有 DevOps 平台(比如我们使用 Zadig) , 这些平台本身就提供了自动化部署的能力，你可以查看相关文档。另外在 Jenkins 中也有相关的插件来实现部署推送。再不济，<a href="https://www.notion.so/a2b1fb632eb44b68b161a38f256756db?pvs=21" target="_blank" rel="noopener">可以使用 rancher 的 CLI 等等</a>。</li><li><strong>子应用如何共享依赖？</strong>可以使用 <a href="https://webpack.js.org/configuration/externals/#externals" target="_blank" rel="noopener">externals</a>, 或者 Webpack 5 的 *<strong>*<a href="https://webpack.js.org/concepts/module-federation/#motivation" target="_blank" rel="noopener">Module Federation</a>,</strong> 我们也探索过类似 <a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">jsDelivr</a> 的方案， 详见<a href="https://wakeadmin.wakedata.com/mapp/advanced/vendors.html#%E9%85%8D%E7%BD%AE%E9%A1%B9" target="_blank" rel="noopener">这里</a></li><li><strong>接口服务</strong>。运行容器除了上文讲到的各种功能，还可以提供一些造福前端的<a href="https://wakeadmin.wakedata.com/mapp/advanced/services.html" target="_blank" rel="noopener">接口服务</a>，比如接口代理、polyfill 服务、vendor 依赖。</li><li><strong><em>安全配置</em></strong>。在运行容器中统一配置 CSP、跨域等安全配置</li><li>…</li></ul><p><br><br><br><br><br></p><h2 id="有哪些最佳实践"><a href="#有哪些最佳实践" class="headerlink" title="有哪些最佳实践?"></a>有哪些最佳实践?</h2><ul><li><strong>保持基座业务无关性</strong>。我们尽量保证基座不耦合业务，为了避免子应用的业务侵入到基座，我们严格管控基座仓库的开发权限，以及向下暴露接口的截面。</li><li><strong>保持子应用之间的独立性</strong>。基座除了 <code>EventBus</code> ，没有提供其他应用通信的手段。对我们来说，微前端只不过是多页应用的延续。 设计良好的应用，不应该耦合其他应用。就算是一些共享状态，也可以从后端读取。</li><li><strong>避免硬编码配置信息</strong>。因为<code>运行容器</code>有动态替换变量的能力，因此应该避免在代码中硬编码配置信息，比如域名信息、企业文案、服务器链接。而是预留模板, 在部署时通过<strong><a href="https://wakeadmin.wakedata.com/mapp/deploy.html" target="_blank" rel="noopener">运行容器</a></strong>来配置。</li><li><strong>按照业务聚合子应用</strong>。即按照业务边界来拆分子应用，而不是按照‘菜单’， 具体来说子应用应该对应后端的微服务，尽管很多时候做不到。</li></ul><p><br><br><br><br><br></p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>我们整套方案并没有‘自造’复杂的技术，而是基于已有的工具整合起来的能力。这也是笔者一直坚持的观念，简单至上。</p><p>这个方案未来会如何迭代呢？</p><ul><li>可视化方式，简化部署的流程。毕竟不是所有开发者都熟悉 K8S 这套概念</li><li>发布流程审核。生产环境部署审核。</li><li>基座插件。支持扩展一些除子应用之外的场景，比如一些全局通用的业务 SDK、组件库。常规的子应用只会在路由匹配到时激活，而插件会在基座启动后加载并持久存在。</li><li>支持子应用扩展服务端的能力。当前的子应用都是 CSR，后续运行容器可以支持子应用扩展服务端接口。</li><li>灰度发布。</li><li>支持 Vite</li><li>…</li></ul><p><br><br><br><br><br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文大概介绍了我们落地和治理微前端应用的大概思路。这套体系中主要包含了三个主要部件：</p><p><img src="/images/microfrontend/Untitled%2019.png" alt="微前端"></p><ul><li>基座：<code>集中式</code>的微前端方案，基座是整个微前端的核心，负责管理子应用，并为子应用的开发提供必要的支撑</li><li>子应用：负责具体业务实现，按照业务聚合和拆分。</li><li>运行容器：为微前端应用架构提供了部署和治理方案</li></ul><p>因为文章篇幅原因，这里面很多细节无法展开。感兴趣的可以移步我们<a href="https://wakeadmin.wakedata.com/mapp/index.html" target="_blank" rel="noopener">公开的文档</a>（暂未开源）。</p><p><br><br><br></p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://wakeadmin.wakedata.com/mapp/index.html" target="_blank" rel="noopener">Wakeadmin</a></li><li><a href="https://github.com/umijs/qiankun" target="_blank" rel="noopener">qiankun</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/microfrontend/Untitled.png&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;微前端实现原理、框架选型之类的文章比较泛滥，我不打算讲这些玩意，本文主要来源于笔者过去一年落地微前端的一手经验，尽量不讲技术细节，而是讲
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue 开发的正确姿势：响应式编程思维</title>
    <link href="https://bobi.ink/2023/07/09/vue-with-rx/"/>
    <id>https://bobi.ink/2023/07/09/vue-with-rx/</id>
    <published>2023-07-08T16:00:00.000Z</published>
    <updated>2023-07-13T02:01:44.044Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vue-with-rx/Untitled.png" alt="Untitled"></p><p>写这篇文章的动机可以追溯到 3 年前， 我发现很多身边开发者并没有正确地使用 React Hooks, 所以我觉得应该把我的开发经验和思维整理下来。</p><p>尽管本文主要从 Vue 的角度出发，但是很多思维也可以用在 React Hooks 上。</p><p>从广义的的“<a href="https://en.wikipedia.org/wiki/Reactive_programming" target="_blank" rel="noopener">响应式编程(Reactive Programing)</a>” 上看，Vue、React、Rxjs 等框架都属于这个范畴。而狭义的响应式编程通常指的是 rxjs 这类 “面向数据<a href="https://zh.wikipedia.org/wiki/%E4%B8%B2%E6%B5%81" target="_blank" rel="noopener">串流</a>和变化传播的<a href="https://zh.wikipedia.org/wiki/%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">声明式</a><a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F" target="_blank" rel="noopener">编程范式</a>”</p><p>虽然 Vue 也是‘响应式编程’， 但是和 RxJS 是完全不一样的概念，至少RxJS 是有范式约束的，不管是编码上还是思维上面，我们都可以感受到它的强力约束，这和我们惯用的命令式编程差别很大。这也导致了它的学习门槛比较高。</p><p>为什么要牵扯到 RxJS 呢？因为它的思维对我们写好 Vue 代码很有帮助！</p><p><br><br><br></p><h1 id="简述-rxjs"><a href="#简述-rxjs" class="headerlink" title="简述 RxJS"></a>简述 RxJS</h1><p>先祭上<a href="https://zhuanlan.zhihu.com/p/25383159" target="_blank" rel="noopener">徐飞的买房的例子</a>，感受一下 RxJS 的魅力：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//           工资周期  ———&gt;  工资</span></span><br><span class="line"><span class="comment">//                            ↓</span></span><br><span class="line"><span class="comment">// 房租周期  ———&gt;  租金  ———&gt;  收入  ———&gt;  现金 </span></span><br><span class="line"><span class="comment">//                ↑           ↓ </span></span><br><span class="line"><span class="comment">//             房子数量 &lt;——— 新购房</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 挣钱是为了买房，买房是为了赚钱</span></span><br><span class="line"><span class="keyword">const</span> house$ = <span class="keyword">new</span> Subject()</span><br><span class="line"><span class="keyword">const</span> houseCount$ = house$.scan(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> acc + num, <span class="number">0</span>).startWith(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工资始终不涨</span></span><br><span class="line"><span class="keyword">const</span> salary$ = Observable.interval(<span class="number">100</span>).mapTo(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> rent$ = Observable.interval(<span class="number">3000</span>)</span><br><span class="line">  .withLatestFrom(houseCount$)</span><br><span class="line">  .map(<span class="function"><span class="params">arr</span> =&gt;</span> arr[<span class="number">1</span>] * <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一买了房，就没现金了……</span></span><br><span class="line"><span class="keyword">const</span> income$ = Observable.merge(salary$, rent$)</span><br><span class="line"><span class="keyword">const</span> cash$ = income$</span><br><span class="line">  .scan(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newSum = acc + num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newHouse = <span class="built_in">Math</span>.floor(newSum / <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">if</span> (newHouse &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      house$.next(newHouse)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newSum % <span class="number">100</span></span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// houseCount$.subscribe(num =&gt; console.log(`houseCount: $&#123;num&#125;`))</span></span><br></pre></td></tr></table></figure><p><br></p><p>如果用几个关键字来描述 RxJS 的话，我想应该是：</p><ul><li>事件：观察者模式</li><li>序列：迭代器模式</li><li>流：管道模式</li></ul><p>这几个模式我们分开去理解都没啥特别，比如 Vue 的 reactivity 数据就是观察者模式；JavaScript 的 for…of/generator 就是迭代器模式；数组的map/filter/reduce, shell 命令都符合管道模式。</p><p>RxJS  的牛逼之处就是把这三个模式优雅地组合起来了。它把事件抽象成为类似’数组’一样的序列，然后提供了丰富的操作符来变换这个序列，就像操作数组一样自然，最后通过管道将这些操作符组合起来实现复杂的功能变换。</p><p><br><br><br></p><h1 id="为什么建议你去学习-rxjs？"><a href="#为什么建议你去学习-rxjs？" class="headerlink" title="为什么建议你去学习 rxjs？"></a>为什么建议你去学习 rxjs？</h1><p>至少它可以帮助你写好 Vue 代码。它可以帮你写出更简洁、结构更清晰、低耦合、更容易测试的代码，这些代码更能体现原本的交互逻辑或业务流程。</p><p>相信我，尝试换个思路，可能原本复杂的实现，会变得更加简单。</p><p><br></p><h1 id="rxjs-和-vue-reactivity-data-有什么关联？"><a href="#rxjs-和-vue-reactivity-data-有什么关联？" class="headerlink" title="RxJS 和 Vue Reactivity Data 有什么关联？"></a>RxJS 和 Vue Reactivity Data 有什么关联？</h1><p>一些和 RxJS 相似的概念</p><ul><li><p>响应式数据。我们用 ref 或reactive 创建的数据，可以等似于 RxJS 的 Observable。只不过响应式数据并不像 rxjs 有显式的事件发布和订阅过程，也不存在事件流(序列)。</p><p>  <strong>我们可以认为Vue 数据的每次变更就相当于 RxJS 发出每次事件</strong>。</p></li><li><p>衍生数据。我们会使用 computed 来衍生新的数据，等似于 RxJS 用操作符衍生出新的 Observable。<strong>即 Vue 数据衍生数据，RxJS 事件衍生事件</strong></p></li><li>副作用。在 Vue 中， watch/watcheffects/render 相当于 RxJS 的 subscribe，RxJS 的数据流的终点通常也是副作用处理，比如将数据渲染到页面上。</li></ul><p><br></p><p>RxJS 的很多东西并不能直接套用过来，但思想和原则是可以复用的。</p><p>其中一个重要的思想就是：管道变换。这是一种思维方式的转变，在以往的编程设计中，我们更多操心的是类、模块、数据结构和算法。而管道变换我们会把程序视作从输入到输出的一个变换去构思:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># “列出目录树中最长的五个文”</span></span><br><span class="line">find . -<span class="built_in">type</span> f | xargs wc -l | sort -n | tail -5</span><br></pre></td></tr></table></figure><p>不要把数据看作是遍布整个系统的小数据池，而要把数据看作是一条浩浩荡荡的河流。</p><p>另一方面，编写 RxJS 代码一些原则，对我们编写 Vue 代码也大有裨益：</p><ul><li>避免副作用。RxJS 的操作符应该是没有副作用的函数，只关注输入的数据，然后对数据进行变换，传递给下一个。</li><li><p>避免外部状态/缓存状态。外部状态也是副作用的一种，单独拎出来讲，是因为我们在 Vue 中创建外部状态太容易了，而 RxJS 则相对来说麻烦一些，毕竟外部状态和事件流显得格格不入。</p><p>  在 RxJS 中管道是自包含的， 所有的状态从一个操作器流向下一个操作器，而不需要外部变量：</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Observable.from([1, 2, 3, 4, 5, 6, 7, 8])</span><br><span class="line">  .filter(val =&gt; val % 2)</span><br><span class="line">  .map(val =&gt; val * 10);</span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><h1 id="看看你代码中的坏味道"><a href="#看看你代码中的坏味道" class="headerlink" title="看看你代码中的坏味道"></a>看看你代码中的坏味道</h1><p>看看你的 Vue 代码有没有这些现象，如果存在这些坏味道，说明你并没有正确使用 Vue 的 Reactivity API。</p><ul><li>创建了大量的缓存状态。比如 sum，avg，temp…</li><li>使用了很多 <code>watch</code> / <code>watchEffect</code>…</li><li>冗长的 <code>setup</code> 方法或者组件代码</li><li>状态被随意修改，修改不属于管辖范围内的状态</li><li>…</li></ul><p><br><br><br></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>先从简单的场景开始: 分页请求。</p><p>❌ 常规的做法：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = reactive(&#123;&#125;) <span class="comment">// 查询参数</span></span><br><span class="line"><span class="keyword">const</span> pagination = reactive(&#123;<span class="attr">pageNo</span>: <span class="number">1</span>, <span class="attr">pageSize</span>: <span class="number">10</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> total = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> list = ref([])</span><br><span class="line"><span class="keyword">const</span> loading = ref(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">const</span> error = ref()</span><br><span class="line"></span><br><span class="line">watch([query, pagination], <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    error.value = <span class="literal">undefined</span></span><br><span class="line">    loading.value = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> request(<span class="string">`/something?<span class="subst">$&#123;qs(&#123;...query, ...pagination&#125;</span>)&#125;`</span>)</span><br><span class="line">    total.value = data.total</span><br><span class="line">    list.value = data.list</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err)&#123;</span><br><span class="line">    error.value = err</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    loading.value = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;<span class="attr">immediate</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p>✅ 推荐做法：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = reactive(&#123;&#125;) <span class="comment">// 查询参数</span></span><br><span class="line"><span class="keyword">const</span> pagination = reactive(&#123;<span class="attr">pageNo</span>: <span class="number">1</span>, <span class="attr">pageSize</span>: <span class="number">10</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// data 包含了 list、loading、error、total 等信息</span></span><br><span class="line"><span class="keyword">const</span> data = useRequest(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`/something?<span class="subst">$&#123;qs(&#123;...query, ...pagination&#125;</span>)&#125;`</span>)</span><br></pre></td></tr></table></figure><ul><li><p>自然地表达 query/pagination → data 的数据流。useRequest 更像 computed 的语义，从一个数据衍生出新的数据，不管它是同步的还是异步的。</p><p>  而使用 watch 会中断数据的流动，并且我们需要创建冗余缓存状态，代码看起来会比较混乱。想象一下复杂的页面，我们可能会有很多复杂、联动的异步请求，情况就会慢慢失控。</p></li><li><p><code>useRequest</code> 是啥？它封装了网络请求， useRequest 可以基于 <a href="https://docs-swrv.netlify.app/guide.html" target="_blank" rel="noopener">swrv</a>(swr 在 Vue 下的实现, 非官方)、或者VueUse 里面的 <a href="https://vueuse.org/core/computedAsync/" target="_blank" rel="noopener">computedAsync</a>、<a href="https://vueuse.org/core/useFetch/" target="_blank" rel="noopener">useFetch</a> 来封装。</p><p>  useRequest 类似于 RxJS 的 switchMap，当新的发起新的请求时，应该将旧的请求抛弃。</p><p>  笔者推荐使用 swr 这类库去处理网络请求，相比直接用 watch, 这类库支持数据缓存、Stale-while-revalidate 更新、还有并发竞态的处理等等。</p></li></ul><p><br><br><br></p><h2 id="实时搜索"><a href="#实时搜索" class="headerlink" title="实时搜索"></a>实时搜索</h2><p>第二个例子也比较简单，用户输入文本，我们debounce 发起数据请求</p><p>⚠️ 常规的实现：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = ref(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法一：在事件处理器加 debounce</span></span><br><span class="line"><span class="comment">// 如果这么实现，双向绑定到表单可能有卡顿问题</span></span><br><span class="line"><span class="keyword">const</span> handleQueryChange = debounce(<span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">  query.value = evt.target.value</span><br><span class="line">&#125;, <span class="number">800</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = ref()</span><br><span class="line"></span><br><span class="line">watch(query, <span class="keyword">async</span> (q) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetchData(q)</span><br><span class="line">  <span class="comment">// <span class="doctag">FIXME:</span> 需要处理竞态问题</span></span><br><span class="line">  data.value = res</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 法二，在 watch 回调或者 fetchData 加上 debounce</span></span><br><span class="line"><span class="keyword">const</span> handleQueryChange = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">  query.value = evt.target.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">watch(query, debounce(<span class="keyword">async</span> (q) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetchData(q)</span><br><span class="line">  data.value = res</span><br><span class="line">&#125;, <span class="number">800</span>))</span><br></pre></td></tr></table></figure><p>RxJS  实现:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> searchInput$ = fromEvent(searchInput, <span class="string">'input'</span>).pipe(</span><br><span class="line">  <span class="comment">// 使用 debounceTime 进行防抖处理</span></span><br><span class="line">  debounceTime(<span class="number">800</span>),</span><br><span class="line">  <span class="comment">// 使用 map 将事件转换为输入框的值</span></span><br><span class="line">  map(<span class="function"><span class="params">event</span> =&gt;</span> event.target.value),</span><br><span class="line">  <span class="comment">// 使用 distinctUntilChanged 进行去重处理</span></span><br><span class="line">  distinctUntilChanged(),</span><br><span class="line">  <span class="comment">// 使用 switchMap 进行请求并转换为列表数据</span></span><br><span class="line">  switchMap(<span class="function"><span class="params">keyword</span> =&gt;</span> <span class="keyword">from</span>(searchList(keyword)))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们使用 Vue 也可以表达类似的流程：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = ref(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">const</span> debouncedQuery = refDebounced(input, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = useRequest(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`/something?<span class="subst">$&#123;qs(&#123;query: query.value&#125;</span>)&#125;`</span>)</span><br></pre></td></tr></table></figure><p>refDebounce 来源于 VueUse，可以 “Debounce” 指定输入 ref 值的变动。</p><p><br><br><br></p><h2 id="定时刷新"><a href="#定时刷新" class="headerlink" title="定时刷新"></a>定时刷新</h2><p>假设我们要在上面的分页基础上实现定时轮询的功能：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = reactive(&#123;&#125;) <span class="comment">// 查询参数</span></span><br><span class="line"><span class="keyword">const</span> tick = useInterval(<span class="number">5000</span>)</span><br><span class="line"><span class="keyword">const</span> pagination = reactive(&#123;<span class="attr">pageNo</span>: <span class="number">1</span>, <span class="attr">pageSize</span>: <span class="number">10</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// data 包含了 list、loading、error、total 等信息</span></span><br><span class="line"><span class="keyword">const</span> data = useRequest(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`/something?<span class="subst">$&#123;qs(&#123;...query, ...pagination, _t: tick.value&#125;</span>)&#125;`</span>)</span><br></pre></td></tr></table></figure><p>我们看到上面的流程很自然。</p><p>现在加大难度，如果要在特定条件下终止呢？</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = reactive(&#123;&#125;) <span class="comment">// 查询参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认关闭</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">counter</span>: tick, pause, resume&#125; = useInterval(<span class="number">5000</span>, &#123;<span class="attr">controls</span>: <span class="literal">true</span>, <span class="attr">immediate</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> pagination = reactive(&#123;<span class="attr">pageNo</span>: <span class="number">1</span>, <span class="attr">pageSize</span>: <span class="number">10</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// data 包含了 list、loading、error、total 等信息</span></span><br><span class="line"><span class="keyword">const</span> data = useRequest(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`/something?<span class="subst">$&#123;qs(&#123;...query, ...pagination, _t: tick.value&#125;</span>)&#125;`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否轮询</span></span><br><span class="line"><span class="keyword">const</span> shouldPoll = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> data.data?.some(<span class="function"><span class="params">i</span> =&gt;</span> i.expired &gt; <span class="built_in">Date</span>.now())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按条件开启轮训</span></span><br><span class="line">watch(shoudPoll, (p) =&gt; p ? resume() : pause())</span><br></pre></td></tr></table></figure><p>如果用 RxJS 来实现的话，代码大概如下：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> interval$ = interval(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> poll$ = interval$.pipe(</span><br><span class="line">  <span class="comment">// 查询</span></span><br><span class="line">  switchMap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">from</span>(fetchData())),</span><br><span class="line">  share()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stop$ = poll$.pipe(</span><br><span class="line">  <span class="comment">// 终止轮询条件</span></span><br><span class="line">  filter(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i.every(<span class="function"><span class="params">i</span> =&gt;</span> i.expired &lt;= <span class="built_in">Date</span>.now())</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 poll$ 和 stop$ 组合在一起</span></span><br><span class="line">poll$</span><br><span class="line">  .pipe(</span><br><span class="line">    <span class="comment">// 使用 takeUntil 在 stop$ 发送事件后停止轮询</span></span><br><span class="line">    takeUntil(stop$)</span><br><span class="line">  )</span><br><span class="line">  .subscribe(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>因为 RxJS 的 Observable 是惰性的，只有被 subscribe 时才会开始执行，同理停止订阅就会中断执行。</p><p>中断执行后，如果要重新发起请求，重新订阅就好了。有点异曲同工之妙吧</p><p><br><br><br></p><h2 id="省市区选择器"><a href="#省市区选择器" class="headerlink" title="省市区选择器"></a>省市区选择器</h2><p>再来看一个稍微复杂一点的例子，常见的省市区选择器，这是一个典型的数据联动的场景。</p><p>我们先来看一个反例吧，我们的选择器需要先选择国家或地区，然后根据它来确定行政区域的划分，接着渲染各级行政区域选择器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default defineComponent(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    modelValue: &#123;</span><br><span class="line">      type: Array as () =&gt; number[],</span><br><span class="line">      default: () =&gt; [],</span><br><span class="line">    &#125;,</span><br><span class="line">    onChange: &#123;</span><br><span class="line">      type: Function,</span><br><span class="line">      default: () =&gt; &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    const isEchoingData = ref(false);</span><br><span class="line">    const regionList = ref&lt;RegionInfoDTO[][]&gt;([]);</span><br><span class="line">    const regionUrl = ref(&apos;&apos;);</span><br><span class="line">    const queryParams = ref(&#123;&#125; as IQueryParams);</span><br><span class="line"></span><br><span class="line">    const selectedRegion = computed&lt;number[]&gt;(&#123;</span><br><span class="line">      get: () =&gt; props.modelValue,</span><br><span class="line">      set: value =&gt; emit(&apos;update:modelValue&apos;, [...value]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const &#123; data: countryList &#125; = useRequest&lt;CountryInfoDTO&gt;(</span><br><span class="line">      () =&gt; `请求国家列表`</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 请求区域列表</span><br><span class="line">    const &#123; data: regionItems &#125; = useRequest&lt;RegionInfoDTO&gt;(() =&gt; regionUrl.value);</span><br><span class="line"></span><br><span class="line">    watch(regionItems, () =&gt; &#123;</span><br><span class="line">      regionList.value[queryParams.value.level] = regionItems.value?.data!;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const countryOptions = computed(() =&gt; &#123;</span><br><span class="line">      return countryList.value?.data.map(i =&gt; &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          label: i.name,</span><br><span class="line">          value: i.id,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    watch(queryParams, async newValue =&gt; &#123;</span><br><span class="line">      if (!Object.keys(newValue).length) return;</span><br><span class="line"></span><br><span class="line">      const query = `&amp;countryId=$&#123;newValue.level ? &apos;&apos; : newValue.value&#125;&amp;parentId=$&#123;</span><br><span class="line">        newValue.level ? newValue.value : &apos;&apos;</span><br><span class="line">      &#125;&amp;level=$&#123;newValue.level + 1&#125;`;</span><br><span class="line">      regionUrl.value = `区域请求路径$&#123;query&#125;`;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    watch(</span><br><span class="line">      props.modelValue,</span><br><span class="line">      async (newValue, oldValue) =&gt; &#123;</span><br><span class="line">        const newLen = newValue.length;</span><br><span class="line">        const oldLen = oldValue?.length ?? 0;</span><br><span class="line"></span><br><span class="line">        if (newLen &amp;&amp; newLen !== oldLen) &#123;</span><br><span class="line">          const index = 0;</span><br><span class="line"></span><br><span class="line">          queryParams.value = &#123; value: newValue[index], level: index &#125;;</span><br><span class="line">          isEchoingData.value = true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; immediate: true &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    watch(</span><br><span class="line">      regionList,</span><br><span class="line">      newVal =&gt; &#123;</span><br><span class="line">        const len = newVal.length;</span><br><span class="line">        const selectedLen = selectedRegion.value.length;</span><br><span class="line"></span><br><span class="line">        if (isEchoingData.value &amp;&amp; selectedLen &gt; len) &#123;</span><br><span class="line">          if (len === selectedLen - 1) return (isEchoingData.value = false);</span><br><span class="line"></span><br><span class="line">          queryParams.value = &#123; value: selectedRegion.value[len], level: len &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; deep: true &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    const onRegionChange = (value: number, level: number) =&gt; &#123;</span><br><span class="line">      selectedRegion.value.splice(level);</span><br><span class="line">      regionList.value.splice(level);</span><br><span class="line">      selectedRegion.value.push(value);</span><br><span class="line"></span><br><span class="line">      const currentRegion = regionList.value[level - 1]?.find(region =&gt; region.id === value);</span><br><span class="line"></span><br><span class="line">      if (!currentRegion?.isLeaf) &#123;</span><br><span class="line">        queryParams.value = &#123; value, level &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      props.onChange?.([...selectedRegion.value], [...selectedRegionNames.value]);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const currentRegionPlaceholder = (index: number) =&gt; &#123;</span><br><span class="line">      return `$&#123;selectedCountry.value?.regionLevelInfos[index]?.name ?? &apos;区域&apos;&#125;`;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const selectedCountry = computed(() =&gt; &#123;</span><br><span class="line">      const selectedCountryId = selectedRegion.value[0];</span><br><span class="line">      const selectedCountry = countryList.value?.data.find(country =&gt; country.id === selectedCountryId);</span><br><span class="line"></span><br><span class="line">      return selectedCountry;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const selectedRegionNames = computed(() =&gt; &#123;</span><br><span class="line">      const names = [];</span><br><span class="line"></span><br><span class="line">      if (selectedCountry.value) &#123;</span><br><span class="line">        names.push(selectedCountry.value.name);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      selectedRegion.value.slice(1).forEach((id, index) =&gt; &#123;</span><br><span class="line">        const region = regionList.value[index]?.find(region =&gt; region.id === id);</span><br><span class="line">        if (region) &#123;</span><br><span class="line">          names.push(region.name);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      return names;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return () =&gt; (</span><br><span class="line">      &lt;FatSpace&gt;</span><br><span class="line">        &lt;ElSelect</span><br><span class="line">          modelValue=&#123;selectedRegion.value[0]&#125;</span><br><span class="line">          placeholder=&quot;请选择国家&quot;</span><br><span class="line">          onChange=&#123;val =&gt; onRegionChange(val, 0)&#125;</span><br><span class="line">          filterable</span><br><span class="line">        &gt;</span><br><span class="line">          &#123;countryOptions.value?.map(country =&gt; (</span><br><span class="line">            &lt;ElOption key=&#123;country.value&#125; label=&#123;country.label&#125; value=&#123;country.value&#125; /&gt;</span><br><span class="line">          ))&#125;</span><br><span class="line">        &lt;/ElSelect&gt;</span><br><span class="line"></span><br><span class="line">        &#123;regionList.value.map((regions, index) =&gt; (</span><br><span class="line">          &lt;ElSelect</span><br><span class="line">            key=&#123;index&#125;</span><br><span class="line">            modelValue=&#123;selectedRegion.value[index + 1]&#125;</span><br><span class="line">            placeholder=&#123;`请选择$&#123;currentRegionPlaceholder(index)&#125;`&#125;</span><br><span class="line">            onChange=&#123;val =&gt; onRegionChange(val, index + 1)&#125;</span><br><span class="line">            filterable</span><br><span class="line">          &gt;</span><br><span class="line">            &#123;regions.map(region =&gt; (</span><br><span class="line">              &lt;ElOption key=&#123;region.id&#125; label=&#123;region.name&#125; value=&#123;region.id&#125; /&gt;</span><br><span class="line">            ))&#125;</span><br><span class="line">          &lt;/ElSelect&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/FatSpace&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>也就 150 行左右的代码，实现的是 <code>国家-国家各种区域</code> 的选择器，比如选择了中国就会有 <code>中国-省-市-区</code> 这样的分级。</p><p>读者也没必要读懂这些代码，我看到也头大，你只需要记住，这个充斥着我们上文提到的各种坏味道：过渡依赖 watch、数据流混乱…</p><p><img src="/images/vue-with-rx/Untitled%201.png" alt="Untitled"></p><p>让我们回归到业务本身，我们为什么需要不恪守这样的联动关系去组织代码呢？</p><p>可以的，一个比较重要的技巧就是自顶而下地去分析流程/数据流变换的过程。</p><p>首先从国家开始，只有用户选择了指定国家之后，我们才能获取到区域的结构信息(是省/市/区, 还是州/城市，anyway):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const AreaSelect2 = defineComponent(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    // 表单值是数组格式，每一项保存的是区域的 id</span><br><span class="line">    modelValue: Array as PropType&lt;number[]&gt;,</span><br><span class="line">  &#125;,</span><br><span class="line">  emits: [&apos;update:modelValue&apos;],</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    // 🔴 获取国家列表</span><br><span class="line">    const country = useCountryList();</span><br><span class="line"></span><br><span class="line">    // 🔴 计算当前选中的国家，我们从这里拿到行政区域结构</span><br><span class="line">    const currentCountry = computed(() =&gt; &#123;</span><br><span class="line">      return country.data.value?.data?.find(i =&gt; i.id === props.modelValue?.[0]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const handleCountryChange = (value: number) =&gt; &#123;</span><br><span class="line">      if (value !== props.modelValue?.[0]) &#123;</span><br><span class="line">        // 🛑 国家变动后，重置掉后续的数据</span><br><span class="line">        emit(&apos;update:modelValue&apos;, [value]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;ElSelect</span><br><span class="line">            modelValue=&#123;props.modelValue?.[0]&#125;</span><br><span class="line">            placeholder=&quot;请选择国家&quot;</span><br><span class="line">            onUpdate:modelValue=&#123;handleCountryChange&#125;</span><br><span class="line">            filterable</span><br><span class="line">            fitInputWidth</span><br><span class="line">            loading=&#123;country.isValidating.value&#125;</span><br><span class="line">          &gt;</span><br><span class="line">            &#123;country.data.value?.data?.map(i =&gt; &#123;</span><br><span class="line">              return &lt;ElOption key=&#123;i.id&#125; label=&#123;i.name&#125; value=&#123;i.id&#125;&gt;&lt;/ElOption&gt;;</span><br><span class="line">            &#125;)&#125;</span><br><span class="line">          &lt;/ElSelect&gt;</span><br><span class="line">          &#123;/* 此处暂时忽略 */&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>Composition API 的好处是，它让组合和封装变得非常便利。如上面的代码，我们将获取国家的相关逻辑封装成 useCountryList，代码变得更加简洁易读。</li><li>避免中间变量。恪守 v-model 单向数据流</li></ul><p><br></p><hr><p><br></p><p>接着我们根据选中的国家来渲染后续的区域联动。</p><p>这里提醒一下读者：“不要吝啬创建组件”</p><p>我在  <a href="https://juejin.cn/post/6844903844711759880#heading-2" target="_blank" rel="noopener">React组件设计实践总结04 - 组件的思维</a> 中讲过：</p><blockquote><p>大部分情况下, 组件表示是一个 UI 对象. 其实组件不单单可以表示 UI, 也可以用来抽象业务对象, 有时候抽象为组件可以巧妙地解决一些问题</p></blockquote><p>组件这个设计实在太好用了，笔者觉得它体现的更重要的思想是分治，而不是复用。组件一些比较重要的特性是：</p><ul><li>和函数一样，它是一个封闭的、自包含的单元。父组件不应该操心它，而应该让他自我组织。</li><li>组件有状态。这个是和函数不一样的地方</li><li><p>组件有生命周期。这就意味着组件可以自己管理和销毁自己的资源，不会泄露出去。</p><p>  这是组件和 Hooks 是有本质区别的！我们使用 Hooks 也可以实现一个自我组织的、封闭的、自包含的单元，但是它的生命周期不是它决定的，而是由使用它的宿主组件决定的</p></li></ul><blockquote><p>关于这块的详细阐述可以看笔者的<a href="https://juejin.cn/post/6844903844711759880#heading-2" target="_blank" rel="noopener">旧文章</a>。</p></blockquote><p>所以说，我们可以创建组件来封装区域选择的逻辑，将复杂度分流出去。或者说通过 props 将数据流往下传递给子组件… </p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">export const AreaSelect2 = defineComponent(&#123;</span><br><span class="line">  // 省略</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    // 省略</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;ElSelect</span><br><span class="line">           // 省略</span><br><span class="line">          &gt;</span><br><span class="line">            &#123;country.data.value?.data?.map(i =&gt; &#123;</span><br><span class="line">              return &lt;ElOption key=&#123;i.id&#125; label=&#123;i.name&#125; value=&#123;i.id&#125;&gt;&lt;/ElOption&gt;;</span><br><span class="line">            &#125;)&#125;</span><br><span class="line">          &lt;/ElSelect&gt;</span><br><span class="line">     </span><br><span class="line"><span class="addition">+          &#123;!!currentCountry.value &amp;&amp;</span></span><br><span class="line"><span class="addition">+            currentCountry.value?.regionLevelInfos?.map((i, index) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+              // 父区域 id</span></span><br><span class="line"><span class="addition">+              const parentValue = props.modelValue?.[index];</span></span><br><span class="line"><span class="addition">+              // 当前区域</span></span><br><span class="line"><span class="addition">+              const value = props.modelValue?.[index + 1];</span></span><br><span class="line"><span class="addition">+              // 父区域信息</span></span><br><span class="line"><span class="addition">+              const parentRegion: RegionLevelDTO =</span></span><br><span class="line"><span class="addition">+                index === 0</span></span><br><span class="line"><span class="addition">+                  ? &#123; code: currentCountry.value?.code!, name: currentCountry.value?.name! &#125;</span></span><br><span class="line"><span class="addition">+                  : currentCountry.value?.regionLevelInfos?.[index - 1]!;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+              const handleChange = (nextValue: number) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+                if (value === nextValue) &#123;</span></span><br><span class="line"><span class="addition">+                  return;</span></span><br><span class="line"><span class="addition">+                &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+                assert(Array.isArray(props.modelValue), 'modelValue is required');</span></span><br><span class="line"><span class="addition">+                // 裁剪掉当前区域后面的区域数据</span></span><br><span class="line"><span class="addition">+                const clone = [...props.modelValue].slice(0, index + 2);</span></span><br><span class="line"><span class="addition">+                clone[index + 1] = nextValue;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+                emit('update:modelValue', clone);</span></span><br><span class="line"><span class="addition">+              &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+              return (</span></span><br><span class="line"><span class="addition">+                &lt;Section</span></span><br><span class="line"><span class="addition">+                  index=&#123;index&#125;</span></span><br><span class="line"><span class="addition">+                  parentValue=&#123;parentValue&#125;</span></span><br><span class="line"><span class="addition">+                  modelValue=&#123;value&#125;</span></span><br><span class="line"><span class="addition">+                  region=&#123;i&#125;</span></span><br><span class="line"><span class="addition">+                  parentRegion=&#123;parentRegion&#125;</span></span><br><span class="line"><span class="addition">+                  country=&#123;currentCountry.value!&#125;</span></span><br><span class="line"><span class="addition">+                  onUpdate:modelValue=&#123;handleChange&#125;</span></span><br><span class="line"><span class="addition">+                /&gt;</span></span><br><span class="line"><span class="addition">+              );</span></span><br><span class="line"><span class="addition">+            &#125;)&#125;</span></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p>继续分流, 看看 Section 组件的实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Section = defineComponent(&#123;</span><br><span class="line">  name: &apos;AreaSelectSection&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 当前索引</span><br><span class="line">     */</span><br><span class="line">    index: &#123; type: Number, required: true &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 区域信息</span><br><span class="line">     */</span><br><span class="line">    region: &#123; type: Object as PropType&lt;RegionLevelDTO&gt;, required: true &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当前国家</span><br><span class="line">     */</span><br><span class="line">    country: &#123; type: Object as PropType&lt;CountryInfoDTO&gt;, required: true &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 父级</span><br><span class="line">     */</span><br><span class="line">    parentRegion: &#123; type: Object as PropType&lt;RegionLevelDTO&gt;, required: true &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 父级的值</span><br><span class="line">     */</span><br><span class="line">    parentValue: Number,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当前值</span><br><span class="line">     */</span><br><span class="line">    modelValue: Number,</span><br><span class="line">  &#125;,</span><br><span class="line">  emits: [&apos;update:modelValue&apos;],</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    // 获取区域列表</span><br><span class="line">    const region = useRegion(</span><br><span class="line">      computed(() =&gt; &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          countryId: props.country.id,</span><br><span class="line">          level: props.index + 1,</span><br><span class="line">          parentId: props.parentValue,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    const handleChange = (value: number) =&gt; &#123;</span><br><span class="line">      emit(&apos;update:modelValue&apos;, value);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;ElSelect</span><br><span class="line">          modelValue=&#123;props.modelValue&#125;</span><br><span class="line">          placeholder=&#123;`请选择$&#123;props.region.name&#125;`&#125;</span><br><span class="line">          filterable</span><br><span class="line">          fitInputWidth</span><br><span class="line">          disabled=&#123;!props.parentValue&#125;</span><br><span class="line">          onUpdate:modelValue=&#123;handleChange&#125;</span><br><span class="line">          loading=&#123;region.isValidating.value&#125;</span><br><span class="line">          class=&#123;s.select&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          &#123;region.data.value?.data?.map(i =&gt; &#123;</span><br><span class="line">            return &lt;ElOption key=&#123;i.id&#125; label=&#123;i.name&#125; value=&#123;i.id&#125;&gt;&lt;/ElOption&gt;;</span><br><span class="line">          &#125;)&#125;</span><br><span class="line">        &lt;/ElSelect&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可见，Section 的实现也再简单不过了。到这里，我相信很多读者已经感受到“响应式”编程的魅力了吧</p><p><br><br><br><br><br></p><h1 id="原则和建议"><a href="#原则和建议" class="headerlink" title="原则和建议"></a>原则和建议</h1><ol><li>优先使用 <code>computed</code>，警惕 <code>watch</code>/<code>watchEffect</code> 等 API 的使用。转换思维先从克制使用 watch 开始。</li><li>适当使用 <code>readonly</code>, 禁止状态被坏人修改</li><li>最小化状态。避免创建‘缓存’状态，让数据自然流动，不要阻断。</li><li>自顶而下，将细节/副作用分流到 hooks 或子组件中，起一个好一点的名字， 让流程看起来更清晰</li><li>将 watch 转换为 computed 的语义。外观上的差别是 watch 有 callback， 而 computed 是「管道」，会衍生新的数据。比如上面 useRequest 的例子</li><li>推荐使用 VueUse</li><li>封装 hooks， 让各种外部的状态或副作用优雅地集成进来</li><li>单向数据流，对这个有两层理解<ul><li>表示是一种数据流动的方向，通常和 CQRS 模式配合，比如 Redux、Vuex，只能单向的修改和查询</li><li>表示一种数据管辖的范围。 通常应用只有数据的拥有者才有权限变更。进一步地讲，我们应该以组件为边界，来限定数据的管辖范围。需要变更时，通过‘事件’ 来通知拥有者。比如 严格遵循 v-model 协议。</li></ul></li><li><p>使用响应式开发思维，构造单向的数据流</p><ul><li>尽量管道化的方式去设计你的程序</li><li>声明式，不要命令式</li><li>拆分组件或hooks来分治数据流</li><li>组件之间 props 传递也属于数据流。</li></ul><ol start="10"><li>使用 ref/reactive → computed → watch → handler → render 这样的顺序组织代码</li></ol></li></ol><p>🌹本文完，你的点赞是我写作的最大动力，欢迎留言转发（备注原文作者和链接）。</p><p><br><br><br></p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://juejin.cn/post/6844903844711759880#heading-4" target="_blank" rel="noopener">React组件设计实践总结04 - 组件的思维</a></li><li><a href="https://rxjs.dev/" target="_blank" rel="noopener">RxJS</a></li><li><a href="https://dev.to/lloyds-digital/comparing-reactivity-models-react-vs-vue-vs-svelte-vs-mobx-vs-solid-29m8" target="_blank" rel="noopener">Comparing reactivity models - React vs Vue vs Svelte vs MobX vs Solid vs Redux</a></li><li><a href="https://zhuanlan.zhihu.com/p/25383159" target="_blank" rel="noopener">RxJS 入门指引和初步应用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vue-with-rx/Untitled.png&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;写这篇文章的动机可以追溯到 3 年前， 我发现很多身边开发者并没有正确地使用 React Hooks, 所以我觉得应该把我的开发经验和思维整
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>次世代前端视图框架都在卷啥？</title>
    <link href="https://bobi.ink/2023/07/02/fe-view-future/"/>
    <id>https://bobi.ink/2023/07/02/fe-view-future/</id>
    <published>2023-07-01T16:00:00.000Z</published>
    <updated>2023-07-04T01:19:01.665Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/fe-view-future/Untitled.png" alt="state of JavaScript 2022 满意度排名"></p><p>state of JavaScript 2022 满意度排名</p><p>上图是 <a href="https://2022.stateofjs.com/zh-Hans/libraries/front-end-frameworks/" target="_blank" rel="noopener">State of JavaScript</a> 2022 前端框架满意度排名。前三名分别是 <code>Solid</code>、<code>Svelte</code>、<code>Qwik</code>。我们可以称他们为次世代前端框架的三大代表，前辈是 <code>React</code>/<code>Angular</code>/<code>Vue</code>。<br>目前 React/Augular/Vue 还占据的主流的市场地位， 现在我们还不知道下一个五年、十年谁会成为主流，有可能前辈会被后浪拍死在沙滩上， 也有可能你大爷还是你大爷。</p><p>就像编程语言一样，尽管每年都有新的语言诞生，但是撼动主流编程语言的地位谈何容易。在企业级项目中，我们的态度会趋于保守，选型会偏向稳定、可靠、生态完善的技术，因此留给新技术的生存空间并不多。除非是革命性的技术，或者有大厂支撑，否则这些技术或框架只会停留小众圈子内。</p><blockquote><p>比如有一点革命性、又有大厂支撑的 Flutter。</p></blockquote><p><br></p><p>那么从更高的角度看，这些次时代的前端视图框架在卷哪些方向呢？有哪些是革命性的呢?</p><p>先说一下本文的结论：</p><ul><li>整体上视图编程范式已经固化</li><li>局部上体验上内卷</li></ul><p><br><br><br></p><h1 id="视图编程范式固化"><a href="#视图编程范式固化" class="headerlink" title="视图编程范式固化"></a>视图编程范式固化</h1><p>从 JQuery 退出历史舞台，再到 React 等占据主流市场。视图的编程范式基本已经稳定下来，不管你在学习什么视图框架，我们接触的概念模型是趋同的，无非是实现的手段、开发体验上各有特色：</p><ul><li><strong>数据驱动视图</strong>。数据是现代前端框架的核心，视图是数据的映射， <code>View=f(State)</code> 这个公式基本成立。</li><li><strong>声明式视图</strong>。相较于上一代的 jQuery，现代前端框架使用声明式描述视图的结构，即描述结果而不是描述过程。</li><li><strong>组件化视图</strong>。组件是现代前端框架的第一公民。组件涉及的概念无非是 props、slots、events、ref、Context…</li></ul><p><br><br><br></p><h1 id="局部体验内卷"><a href="#局部体验内卷" class="headerlink" title="局部体验内卷"></a>局部体验内卷</h1><p>回顾一下 4 年前写的 <strong><a href="https://juejin.cn/post/6844903865926549511" target="_blank" rel="noopener">浅谈 React 性能优化的方向</a></strong>，现在看来依旧不过时，各大框架无非也是围绕着这些「方向」来改善。</p><p>当然，在「框架内卷」、「既要又要还要」时代，新的框架要脱颖而出并不容易，它既要服务好开发者(<code>开发体验</code>)，又要服务好客户(<code>用户体验</code>) ， 性能不再是我们选择框架的首要因素。</p><p><br></p><p>以下是笔者总结的，次世代视图框架的内卷方向:</p><ul><li><strong>用户体验</strong><ul><li>性能优化<ul><li>精细化渲染：这是次世代框架内卷的主要战场，它们的首要目的基本是实现低成本的精细化渲染<ul><li>预编译方案：代表有 Svelte、Solid</li><li>响应式数据：代表有 Svelte、Solid、Vue、Signal(不是框架)</li><li>动静分离</li></ul></li></ul></li><li>并发(Concurrent)：React 在这个方向独枳一树。</li><li>去 JavaScript：为了获得更好的首屏体验，各大框架开始「抛弃」JavaScript，都在比拼谁能更快到达用户的眼前，并且是完整可交互的形态。</li></ul></li><li><strong>开发体验</strong><ul><li>Typescript 友好：不支持 Typescript 基本就是 ca</li><li>开发工具链/构建体验: Vite、Turbopack… 开发的工具链直接决定了开发体验</li><li>开发者工具：框架少不了开发者工具，从 Vue Devtools 再到 <a href="https://devtools.nuxtjs.org/" target="_blank" rel="noopener">Nuxt Devtools</a>，酷炫的开发者工具未来可能都是标配</li><li>元框架: 毛坯房不再流行，从前到后、大而全的元框架称为新欢，内卷时代我们只应该关注业务本身。代表有 Nextjs、Nuxtjs</li></ul></li></ul><p><br><br><br><br><br></p><h2 id="精细化渲染"><a href="#精细化渲染" class="headerlink" title="精细化渲染"></a>精细化渲染</h2><p><br><br><br></p><h3 id="预编译方案"><a href="#预编译方案" class="headerlink" title="预编译方案"></a>预编译方案</h3><p>React、Vue 这些以 Virtual DOM 为主的渲染方式，通常只能做到组件级别的精细化渲染。<strong>而次世代的 Svelte、Solidjs 不约而同地抛弃了 Virtual DOM，采用静态编译的手段，将「声明式」的视图定义，转译为「命令式」的 DOM 操作</strong>。</p><p>Svelte</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> count = <span class="number">0</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    count += 1</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">on:click</span>=<span class="string">"&#123;handleClick&#125;"</span>&gt;</span>Clicked &#123;count&#125; &#123;count === 1 ? 'time' : 'times'&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编译结果：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ....</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_fragment</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> button</span><br><span class="line">  <span class="keyword">let</span> t0</span><br><span class="line">  <span class="keyword">let</span> t1</span><br><span class="line">  <span class="keyword">let</span> t2</span><br><span class="line">  <span class="keyword">let</span> t3_value = <span class="comment">/*count*/</span> (ctx[<span class="number">0</span>] === <span class="number">1</span> ? <span class="string">'time'</span> : <span class="string">'times'</span>) + <span class="string">''</span></span><br><span class="line">  <span class="keyword">let</span> t3</span><br><span class="line">  <span class="keyword">let</span> mounted</span><br><span class="line">  <span class="keyword">let</span> dispose</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    c() &#123;</span><br><span class="line">      button = element(<span class="string">'button'</span>)</span><br><span class="line">      t0 = text(<span class="string">'Clicked '</span>)</span><br><span class="line">      t1 = text(<span class="comment">/*count*/</span> ctx[<span class="number">0</span>])</span><br><span class="line">      t2 = space()</span><br><span class="line">      t3 = text(t3_value)</span><br><span class="line">    &#125;,</span><br><span class="line">    m(target, anchor) &#123;</span><br><span class="line">      insert(target, button, anchor)</span><br><span class="line">      append(button, t0)</span><br><span class="line">      append(button, t1)</span><br><span class="line">      append(button, t2)</span><br><span class="line">      append(button, t3)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!mounted) &#123;</span><br><span class="line">        dispose = listen(button, <span class="string">'click'</span>, <span class="comment">/*handleClick*/</span> ctx[<span class="number">1</span>])</span><br><span class="line">        mounted = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    p(ctx, [dirty]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dirty &amp; <span class="comment">/*count*/</span> <span class="number">1</span>) set_data(t1, <span class="comment">/*count*/</span> ctx[<span class="number">0</span>])</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        dirty &amp; <span class="comment">/*count*/</span> <span class="number">1</span> &amp;&amp;</span><br><span class="line">        t3_value !== (t3_value = <span class="comment">/*count*/</span> (ctx[<span class="number">0</span>] === <span class="number">1</span> ? <span class="string">'time'</span> : <span class="string">'times'</span>) + <span class="string">''</span>)</span><br><span class="line">      )</span><br><span class="line">        set_data(t3, t3_value)</span><br><span class="line">    &#125;,</span><br><span class="line">    i: noop,</span><br><span class="line">    o: noop,</span><br><span class="line">    d(detaching) &#123;</span><br><span class="line">      <span class="keyword">if</span> (detaching) &#123;</span><br><span class="line">        detach(button)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mounted = <span class="literal">false</span></span><br><span class="line">      dispose()</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance</span>(<span class="params">$$self, $$props, $$invalidate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $$invalidate(<span class="number">0</span>, (count += <span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [count, handleClick]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">SvelteComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    init(<span class="keyword">this</span>, options, instance, create_fragment, safe_not_equal, &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><p>我们看到，简洁的模板最终被转移成了底层 DOM 操作的命令序列。</p><p>我写文章比较喜欢比喻，这种场景让我想到，编程语言对内存的操作，DOM 就是浏览器里面的「内存」：</p><ul><li>Virtual DOM 就是那些那些带 GC 的语言，使用运行时的方案来屏蔽 DOM 的操作细节，这个抽象是有代价的</li><li>预编译方案则更像 Rust，没有引入运行时 GC, 使用了一套严格的所有权和对象生命周期管理机制，让编译器帮你转换出安全的内存操作代码。</li><li>手动操作 DOM, 就像 C、C++ 这类底层语言，需要开发者手动管理内存</li></ul><p>使用 Svelte/SolidJS 这些方案，可以做到修改某个数据，精细定位并修改 DOM 节点，犹如我们当年手动操作 DOM 这么精细。而 Virtual DOM 方案，只能到组件这一层级，除非你的组件粒度非常细。</p><p><br><br><br><br><br></p><h3 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h3><p>和精细化渲染脱不开身的还有<code>响应式数据</code>。</p><p>React 一直被诟病的一点是当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树，如果要避免不必要的子组件的重渲染，需要开发者手动进行优化(比如 <code>shouldComponentUpdate</code>、<code>PureComponent</code>、<code>memo</code>、<code>useMemo</code>/<code>useCallback</code>)  。同时你可能会需要使用不可变的数据结构来使得你的组件更容易被优化。</p><p>在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。</p><p>近期比较火热的 signal (信号，Angular、Preact、Qwik、Solid 等框架都引入了该概念)，如果读者是 Vue 或者 MobX 之类的用户， Signal 并不是新的概念。</p><p>按 Vue 官方文档的话说：<em>从根本上说，信号是与 Vue 中的 ref 相同的响应性基础类型。它是一个在访问时跟踪依赖、在变更时触发副作用的值容器。</em></p><p>不管怎样，响应式数据不过是<code>观察者模式</code>的一种实现。相比 React 主导的通过不可变数据的比对来标记重新渲染的范围，响应式数据可以实现更细粒度的绑定；而且响应式的另一项优势是它的可传递性(有些地方称为 <code>Props 下钻</code>(Props Drilling))。</p><p><br><br><br></p><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>Vue 3 就是动静结合的典型代表。在我看来 Vue 深谙中庸之道，在它身上我们很难找出短板。</p><p>Vue 的模板是需要静态编译的，这使得它可以像 Svelte 等框架一样，有较大的优化空间；同时保留了 Virtual DOM 和运行时 Reactivity，让它兼顾了灵活和普适性。</p><p>基于静态的模板，Vue 3 做了很多优化，笔者将它总结为<code>动静分离</code>吧。比如静态提升、更新类型标记、树结构打平，无非都是将模板中的静态部分和动态部分作一些分离，避免一些无意义的更新操作。</p><p>更长远的看，受 SolidJS 的启发， Vue 未来可能也会退出 Vapor 模式，不依赖 Virtual DOM 来实现更加精细的渲染。</p><p><br><br><br><br><br></p><h2 id="再谈编译时和运行时"><a href="#再谈编译时和运行时" class="headerlink" title="再谈编译时和运行时"></a>再谈编译时和运行时</h2><p>编译时和运行时没有优劣之分， 也不能说纯编译的方案就必定是未来的趋势。</p><p>这几年除了新的编译时的方案冒出来，宣传自己是未来；也有从编译时的焦油坑里爬出来， 转到运行时方案的，这里面的典型代表就是 Taro。</p><p>Taro 2.0 之前采用的是静态编译的方案，即将 ’React‘ 组件转译为小程序原生的代码:</p><p><img src="/images/fe-view-future/Untitled%201.png" alt="Untitled"></p><p>但是这个转译工作量非常庞大，JSX 的写法千变万化，非常灵活。Taro 只能采用 <code>穷举</code> 的方式对 JSX 可能的写法进行了一 一适配，这一部分工作量很大，实际上 Taro 有大量的 Commit 都是为了更完善的支持 JSX 的各种写法。这也是 Taro 官方放弃这种架构的原因。</p><p>也就是说 <strong>Taro 也只能覆盖我们常见的 JSX 用法，而且我们必须严格遵循 Taro 规范才能正常通过。</strong></p><p>有非常多的局限：</p><ul><li>静态的 JSX</li><li>不支持高阶组件</li><li>不支持动态组件</li><li>不支持操作 JSX 的结果</li><li>不支持 render function</li><li>不能重新导出组件</li><li>需要遵循 on<em>、render</em> 约束</li><li>不支持 Context、Fragment、props 展开、forwardRef</li><li>….</li></ul><p><a href="https://www.notion.so/Taro-React-65161e2a09f648c0ad1c69f314ff3cea?pvs=21" target="_blank" rel="noopener">有太多太多的约束</a>，这已经不是带着镣铐跳舞了，是被五花大绑了。</p><p><br></p><p>使用编译的方案不可避免的和实际运行的代码有较大的 <code>Gap</code>，源码和实际运行的代码存在较大的差别会导致什么？</p><ul><li>比较差的 Debug 体验。</li><li>比较黑盒。</li></ul><p>我们在歌颂编译式的方案，能给我们带来多大的性能提升、带来多么简洁的语法的同时。另一方面，一旦我们进行调试/优化，我们不得不跨越这层 Gap，去了解它转换的逻辑和底层实现。</p><p>这是一件挺矛盾的事情，当我们「精通」这些框架的时候，估计我们已经是一个<code>人肉编译器</code>了。</p><p>Taro 2.x 配合小程序， 这对卧龙凤雏, 可以将整个开发体验拉到地平线以下。</p><p><br></p><p>回到这些『次世代』框架。React/Vue/Angular 这些框架先入为主， 在它们的教育下，我们对前端视图开发的概念和编程范式的认知已经固化。</p><p><img src="/images/fe-view-future/Untitled%202.png" alt="Untitled"></p><p>比如在笔者看来 Svelte 是违法直觉的。因为 JavaScript 本身并不支持这种语义。Svelte 要支持这种语义需要一个编译器，而作为一个 JavaScript 开发者，我也需要进行心智上的转换。</p><p>而 SolidJS 则好很多，目之所及都是我们熟知的东西。尽管编译后可能是一个完全不一样的东西。</p><blockquote><p>💡 Vue 曾经也过一个名为<strong><a href="https://cn.vuejs.org/guide/extras/reactivity-transform.html" target="_blank" rel="noopener">响应性语法糖</a></strong>的实验性功能来探索这个方向，但最后由于<strong><a href="https://github.com/vuejs/rfcs/discussions/369#discussioncomment-5059028" target="_blank" rel="noopener">这个原因</a></strong>，废弃了。这是一次明智的决定</p></blockquote><p>当然，年轻的次世代的前端开发者可能不这么认为，他们毕竟没有经过旧世代框架的先入为主和洗礼，他们更能接受新的开发范式，然后扛起这些旗帜，让它们成为未来主流。</p><p>总结。纯编译的方能可以带来更简洁的语法、更多性能优化的空间，甚至也可以隐藏一些跨平台/兼容性的细节。另一方面，源码和实际编译结果之间的 Gap，可能会逼迫开发者成为人肉编译器，尤其在复杂的场景，对开发者的心智负担可能是翻倍的。</p><p>对于框架开发者来说，纯编译的方案实现复杂度会更高，这也意味着，会有较高贡献门槛，间接也会影响生态。</p><p><br><br><br><br><br></p><h2 id="去-javascript"><a href="#去-javascript" class="headerlink" title="去 JavaScript"></a>去 JavaScript</h2><p>除了精细化渲染，Web 应用的首屏体验也是框架内卷的重要方向，这个主要的发展脉络，笔者在 <a href="https://juejin.cn/post/7241027834490437669" target="_blank" rel="noopener">现代前端框架的渲染模式</a> 一文已经详细介绍，推荐大家读一下：</p><p><img src="/images/fe-view-future/Untitled%203.png" alt="Untitled"></p><p>这个方向的强有力的代表主要有 Astro(Island Architecture 岛屿架构)、Next.js(React Server Component)、Qwik(Resumable 去 Hydration)。</p><p>这些框架基本都是秉承 SSR 优先，在首屏的场景，JavaScript 是「有害」的，为了尽量更少地向浏览器传递 JavaScript，他们绞尽脑汁 ：</p><ul><li>Astro：’静态 HTML‘优先，如果想要 SPA 一样实现复杂的交互，可以申请开启一个岛屿，这个岛屿支持在客户端进行水合和渲染。你可以把岛屿想象成一个 iframe 一样的玩意。</li><li>React Server Component: 划分服务端组件和客户端组件，服务端组件仅在服务端运行，客户端只会看到它的渲染结果，JavaScript 执行代码自然也仅存于服务端。</li><li>Qwik：我要直接革了水合(Hydration)的命，我不需要水合，需要交互的时候，我惰性从服务端拉取事件处理器不就可以了…</li></ul><p>不得不说，「去 JavaScript」的各种脑洞要有意思多了。</p><p><br><br><br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要讲了次世代前端框架的内卷方向，目前来看还处于量变的阶段，并没有脱离现在主流框架的心智模型，因此我们上手起来基本不会有障碍。</p><p>作为普通开发者，我们可以站在更高的角度去审视这些框架的发展，避免随波逐流和无意义的内卷。</p><p><br><br><br></p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/597473358" target="_blank" rel="noopener">新时代的 SSR 框架破局者：<em>qwik</em></a></li><li><a href="https://cn.vuejs.org/guide/extras/rendering-mechanism.html" target="_blank" rel="noopener">Vue 渲染机制</a></li><li><a href="https://cn.vuejs.org/guide/extras/reactivity-in-depth.html" target="_blank" rel="noopener">Vue 深入响应式系统</a></li><li><a href="https://2022.stateofjs.com/zh-Hans/libraries/front-end-frameworks/" target="_blank" rel="noopener">State of JavaScript</a></li><li><a href="https://juejin.cn/post/6844903865926549511" target="_blank" rel="noopener">浅谈 React 性能优化的方向</a></li><li><a href="https://zhuanlan.zhihu.com/p/350507037" target="_blank" rel="noopener">新兴前端框架 Svelte 从入门到原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/fe-view-future/Untitled.png&quot; alt=&quot;state of JavaScript 2022 满意度排名&quot;&gt;&lt;/p&gt;
&lt;p&gt;state of JavaScript 2022 满意度排名&lt;/p&gt;
&lt;p&gt;上图是 &lt;a 
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>全新 JavaScript 装饰器实战下篇：实现依赖注入</title>
    <link href="https://bobi.ink/2023/06/30/decorator-2/"/>
    <id>https://bobi.ink/2023/06/30/decorator-2/</id>
    <published>2023-06-29T16:00:00.000Z</published>
    <updated>2023-06-30T08:43:56.329Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/decorator-2/Untitled.jpeg" alt="cover"></p><p><br></p><p>系列文章：</p><ul><li><a href="https://www.notion.so/Javascript-MobX-Vue-5e1c633167094d9784e602d66a5877f8?pvs=21" target="_blank" rel="noopener">全新 Javascript 装饰器实战上篇：用 MobX 的方式打开 Vue </a></li><li><a href="https://www.notion.so/JavaScript-0729df8081ec44b48f6f2e6ec7835120?pvs=21" target="_blank" rel="noopener">全新 JavaScript 装饰器实战下篇：实现依赖注入</a></li></ul><p>上一篇<a href="https://www.notion.so/Javascript-MobX-Vue-5e1c633167094d9784e602d66a5877f8?pvs=21" target="_blank" rel="noopener">文章</a>我们介绍了 JavaScript 最新的装饰器提案，以及它和旧版的区别。这篇文章我们将继续深入装饰器，尝试实现一个简易的依赖注入库。</p><p><br></p><p>谈到装饰器我们总会听到 <code>reflect-metadata</code>, 尤其是社区上的依赖注入库，比如 <a href="https://github.com/inversify/InversifyJS" target="_blank" rel="noopener">inversify.js</a></p><p><br></p><p><img src="/images/decorator-2/Untitled.png" alt="inversify.js"></p><p><br></p><p><strong>我们在上一篇文章的装饰器实现中，会直接去转换或者修改类的结构，大部分场景这并不是最佳实践。</strong></p><p><strong>大部分情况下我们应该利用装饰器来收集一些标注信息</strong>，比如 MobX 用装饰器来标注哪些是 observable、哪些是 computed；Inversify.js 用 inject 标注哪些属性需要进行注入；Angular.js 使用 Input/Output 标记属性….</p><p>如果我们要通过装饰器来标记类的原信息，那就得来认识一下：装饰器的好搭子 <code>reflect-metadata</code> 。</p><p><br><br><br><br><br></p><h2 id="di-库经常提及的-reflect-metadata-到底是什么？"><a href="#di-库经常提及的-reflect-metadata-到底是什么？" class="headerlink" title="DI 库经常提及的 reflect-metadata 到底是什么？"></a>DI 库经常提及的 reflect-metadata 到底是什么？</h2><p>这是一个 JavaScript 提案，但是作者并没有<a href="https://github.com/rbuckton/reflect-metadata/issues/96" target="_blank" rel="noopener">将其提交到 TC39</a>。它的继任者现在是 <a href="https://github.com/tc39/proposal-decorator-metadata" target="_blank" rel="noopener">Decorator Metadata</a>，现在已经进入了 Stage 3 阶段，Typescript 也将在 5.2 中实现这个提案。</p><p>Decorator Metadata 会在下文详细介绍，我们先来看看 reflect-metadata。</p><p>先来看看使用它能用来干啥：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test(&apos;reflect-metadata&apos;, () =&gt; &#123;</span><br><span class="line">  const key = &apos;myKey&apos;</span><br><span class="line"></span><br><span class="line">  // 🔴 装饰器语法</span><br><span class="line">  @Reflect.metadata(key, &apos;inClass&apos;)</span><br><span class="line">  class Foo &#123;</span><br><span class="line">    @Reflect.metadata(key, &apos;inStaticMember&apos;)</span><br><span class="line">    static staticMember = 1</span><br><span class="line"></span><br><span class="line">    @Reflect.metadata(key, &apos;inMember&apos;)</span><br><span class="line">    member = 2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 🔴 上述装饰器等价于</span><br><span class="line">  Reflect.defineMetadata(key, &apos;inClass&apos;, Foo)</span><br><span class="line">  Reflect.defineMetadata(key, &apos;inStaticMember&apos;, Foo, &apos;staticMember&apos;)</span><br><span class="line">  Reflect.defineMetadata(key, &apos;inMember&apos;, Foo.prototype, &apos;member&apos;)</span><br><span class="line"></span><br><span class="line">  // 🔴 静态成员</span><br><span class="line">  expect(Reflect.getMetadata(key, Foo)).toBe(&apos;inClass&apos;)</span><br><span class="line">  expect(Reflect.getMetadata(key, Foo, &apos;staticMember&apos;)).toBe(&apos;inStaticMember&apos;)</span><br><span class="line"></span><br><span class="line">  // 🔴 实例成员，**需要通过实例获取**</span><br><span class="line">  expect(Reflect.getMetadata(key, Foo, &apos;member&apos;)).toBeUndefined()</span><br><span class="line">  const foo = new Foo()</span><br><span class="line">  expect(Reflect.getMetadata(key, foo, &apos;member&apos;)).toBe(&apos;inMember&apos;)</span><br><span class="line">  // 或者通过原型对象获取</span><br><span class="line">  expect(Reflect.getMetadata(key, Foo.prototype, &apos;member&apos;)).toBe(&apos;inMember&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>通过上面的 「hello world」 我们可以发现：</p><ol><li>可以作为<code>装饰器</code>使用。这个表示这个提案和装饰器有不解的渊源，所以当我们谈及装饰器的时候，总会看到它的身影。</li><li>元数据? 没那么高大上，就是一些 key/value 存储</li><li>扩展了 Reflect API？为什么是 Reflect API?</li><li>关于存储位置，类和静态成员存储在类上，实例成员存储在类的原型上(prototype)</li></ol><p><br></p><p>通过上面的皮毛，我们 GET 不到它要解决痛点是啥。不就是存储一些元数据嘛，我们不需要这个 API 也可以做到，比如 MobX 的装饰器就是放在原型上的一个隐藏自定义属性上：</p><p><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function storeAnnotation(prototype: any, key: PropertyKey, annotation: Annotation) &#123;</span><br><span class="line">  if (!hasProp(prototype, storedAnnotationsSymbol)) &#123;</span><br><span class="line">    addHiddenProp(prototype, storedAnnotationsSymbol, &#123;</span><br><span class="line">      // Inherit annotations</span><br><span class="line">      ...prototype[storedAnnotationsSymbol],</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><p>实际上这个概念是从其他语言借鉴的，比如下面 Java Spring 依赖注入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 中，可以通过它的 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html" target="_blank" rel="noopener">Reflect API</a> 可以获取到类的<code>类型信息</code>，比如方法、方法的参数、返回值等类型信息。</p><p>然而，JavaScript 是一门弱类型语言，没有这类信息。所以我们在实现<code>依赖注入</code>时，并不能做到像 Java 那么强大：</p><p><br></p><p>Java:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> Engine engine;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      engine.turnOn();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vs Typescript</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Engine &#123;&#125;</span><br><span class="line"></span><br><span class="line">@injectable()</span><br><span class="line">class Car &#123;</span><br><span class="line">  @inject(&apos;EngineKey&apos;)</span><br><span class="line">  private engine: Engine</span><br><span class="line">  start() &#123;</span><br><span class="line">    this.engine.turnOn()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Java Spring 可以自动推断类型来进行注入</strong>，这个类型可以是接口、具体的类、抽象类等等。而现在 JavaScript 下的 DI 库，我们通常需要显式指定一个标识符，或者只能是一个具体的类(不支持接口)， 一点也不够优雅。</p><p>既然现在有了 <code>Typescript</code> ，能不能做到呢？Typescript 最终也是转换为 JavaScript ，默认情况下<code>类型信息</code>都会被裁减掉。</p><p>而 reflect-metadata 的初衷还是想将 Java/C# 这类语言的 Reflect 能力带到 JavaScript。<strong>因此就拟定了这样一个协议， 让 Typescript 或者其他转译到 JavaScript 强类型语言，可以通过它将类型信息保留下来。</strong></p><p><br></p><p>所以我们看到 Typescript 是它的主要推动者。我们在 Typescript 中可以通过开启 <code>emitDecoratorMetadata</code> 实现装饰器类型信息的保留:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Bar &#123;&#125;</span><br><span class="line"></span><br><span class="line">@d</span><br><span class="line">class Foo &#123;</span><br><span class="line">  @d</span><br><span class="line">  static staticMember = 1</span><br><span class="line"></span><br><span class="line">  @d</span><br><span class="line">  member = 2</span><br><span class="line"></span><br><span class="line">  @d</span><br><span class="line">  method(foo: number, bar: Bar, baz: Foo): string &#123;&#125;</span><br><span class="line"></span><br><span class="line">  constructor(a: Bar) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var __metadata =</span><br><span class="line">  (this &amp;&amp; this.__metadata) ||</span><br><span class="line">  function (k, v) &#123;</span><br><span class="line">    if (typeof Reflect === &apos;object&apos; &amp;&amp; typeof Reflect.metadata === &apos;function&apos;)</span><br><span class="line">      return Reflect.metadata(k, v)</span><br><span class="line">  &#125;</span><br><span class="line">// 省略部分代码</span><br><span class="line">__decorate([d, __metadata(&apos;design:type&apos;, Object)], Foo.prototype, &apos;member&apos;, void 0)</span><br><span class="line">__decorate(</span><br><span class="line">  [</span><br><span class="line">    d,</span><br><span class="line">    __metadata(&apos;design:type&apos;, Function),</span><br><span class="line">    __metadata(&apos;design:paramtypes&apos;, [Number, Object, Foo]),</span><br><span class="line">    __metadata(&apos;design:returntype&apos;, String),</span><br><span class="line">  ],</span><br><span class="line">  Foo.prototype,</span><br><span class="line">  &apos;method&apos;,</span><br><span class="line">  null</span><br><span class="line">)</span><br><span class="line">__decorate([d, __metadata(&apos;design:type&apos;, Object)], Foo, &apos;staticMember&apos;, void 0)</span><br><span class="line">Foo = __decorate([d, __metadata(&apos;design:paramtypes&apos;, [Object])], Foo)</span><br></pre></td></tr></table></figure><p>我们看到大部分的类型信息都保留下来了，比如成员类型、方法的参数/返回值类型。</p><p>但是它也有局限性，比如接口等自定义类型依旧无法保留，毕竟 JavaScript 并没有这些概念。这也直接决定了依旧无法和 Java 这种「原生」强类型语言比肩。</p><p><br></p><blockquote><p>reflect-metadata 可能代表的是 JavaScript 作为一个新汇编语言的觉悟，但是目前的事实也证明了这条路比较难。就拿 Typescript 来说，保留的信息比较有限，而且这会让开发者的技术栈严重依赖 Typescript，另外像 esbuild、swc、babel 这些转译器也很难跟进这种特性。<br><br><br>实际上，现在流行的 DI 库，如 <code>inversify</code>、<code>tsyringe</code> 对 Typescript <code>emitDecoratorMetadata</code> 的依赖也很小，去掉基本上不影响其有效运行。</p></blockquote><blockquote></blockquote><p><br></p><p>总结, reflect-metadata 视图提供一个类(class)元信息的存储标准。在笔者开来，主要的愿景是为上层更高级的语言(比如 Typescript)保留静态类型信息提供一种方式。其次，普通开发者也能使用这个标准化的 API 来给类标注信息。</p><p><br><br><br><br><br></p><h2 id="decorator-metadata"><a href="#decorator-metadata" class="headerlink" title="Decorator Metadata"></a>Decorator Metadata</h2><p>如今的 Metadata 提案已经从装饰器中分离出来，目前也进入了 Stage 3 阶段。经过重新设计的 Metadata 和 reflect-metadata 不是同一个玩意。</p><p>这个提案非常简单，就是新增了一个内置 Symbol —— <code>Symbol.metadata</code>。在装饰器的配合将元数据存储在类的 Symbol.metadata 下面:</p><p><br><br><br></p><p>针对装饰器协议的扩展:</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">type Decorator = (value: Input, context: &#123;</span><br><span class="line">  kind: string;</span><br><span class="line">  name: string | symbol;</span><br><span class="line">  access: &#123;</span><br><span class="line">    get?(): unknown;</span><br><span class="line">    set?(value: unknown): void;</span><br><span class="line">  &#125;;</span><br><span class="line">  isPrivate?: boolean;</span><br><span class="line">  isStatic?: boolean;</span><br><span class="line">  addInitializer?(initializer: () =&gt; void): void;</span><br><span class="line"><span class="addition">+ metadata?: Record&lt;string | number | symbol, unknown&gt;;</span></span><br><span class="line">&#125;) =&gt; Output | void;</span><br></pre></td></tr></table></figure><p><br></p><p>所有装饰器的 context 对象新增了 metadata 对象。 metadata 只是一个普通的对象，没什么特别：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function meta(key: string) &#123;</span><br><span class="line">  return (value: unknown, context: DecoratorContext) =&gt; &#123;</span><br><span class="line">    context.metadata![key] = true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@meta(&apos;inClass&apos;)</span><br><span class="line">class Foo &#123;</span><br><span class="line">  @meta(&apos;inStaticMember&apos;)</span><br><span class="line">  static staticMember = 1</span><br><span class="line"></span><br><span class="line">  @meta(&apos;inMember&apos;)</span><br><span class="line">  member = 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 类的所有装饰器共享</span><br><span class="line">expect(Foo[Symbol.metadata]).toEqual(&#123;</span><br><span class="line">  inStaticMember: true,</span><br><span class="line">  inMember: true,</span><br><span class="line">  inClass: true,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>就是这么朴实且无华。因为<strong>所有装饰器都是共享一个对象空间</strong>，避免冲突的职责就交给开发者了。</p><p>大概有两种方式：</p><ul><li>命名空间。比如单纯用字符串 key <code>库名称.{是否静态}.{装饰器位置}.{属性名}</code>，或者创建一个私有 Symbol 按嵌套的结构存储。</li><li><p>私有空间。以下是 MetaData 提案中的例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const PRIVATE_METADATA = new WeakMap();</span><br><span class="line"></span><br><span class="line">function meta(key, value) &#123;</span><br><span class="line">  return (_, context) =&gt; &#123;</span><br><span class="line">    let metadata = PRIVATE_METADATA.get(context.metadata);</span><br><span class="line"></span><br><span class="line">    if (!metadata) &#123;</span><br><span class="line">      metadata = &#123;&#125;;</span><br><span class="line">      PRIVATE_METADATA.set(context.metadata, metadata);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    metadata[key] = value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@meta(&apos;a&apos; &apos;x&apos;)</span><br><span class="line">class C &#123;</span><br><span class="line">  @meta(&apos;b&apos;, &apos;y&apos;)</span><br><span class="line">  m() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PRIVATE_METADATA.get(C[Symbol.metadata]).a; // &apos;x&apos;</span><br><span class="line">PRIVATE_METADATA.get(C[Symbol.metadata]).b; // &apos;y&apos;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><p>Anyway，解决命名冲突有无数的办法。</p><blockquote><p>🙋  那 <code>Typescript</code> 的 <code>emitDecoratorMetadata</code> 还支持吗？暂时看到相关的计划</p></blockquote><p><br><br><br><br><br></p><h2 id="简单理解依赖注入"><a href="#简单理解依赖注入" class="headerlink" title="简单理解依赖注入"></a>简单理解依赖注入</h2><p>现在开始实战部分，首先我们需要了解一下什么是依赖注入：</p><p><img src="/images/decorator-2/Untitled%201.png" alt="di"></p><p>理解依赖注入，需要搞清楚以下几个概念：</p><ul><li><strong>接口(interface)。</strong>接口是一个协议，或者是一个需求。这个由’甲方‘提出来，比如我们要一个手机，那么能“打电话”、”发短信”, 就是需求。接口是一个抽象的东西，并不是具体的实现。对于消费者来说它并不关心的内部细节、是怎么制造出来的。</li><li><strong>实现(implements)</strong>。满足接口需求的具体实现，比如“手机”这个接口的实现，可以是 iphone、小米手机、华为手机等等。</li><li><strong>依赖注入</strong>。依赖注入的意思就是<code>需求者</code>描述好自己的<code>需求</code>，然后由<code>经销商</code>来查找<strong>符合需求</strong>的<code>实现</code>，给到需求者。需求者从头到尾，不会去关心这个需求是怎么去实现的，它只关心它自己要干的事情。</li><li><strong>三种角色</strong>:<ul><li><code>需求者</code>。或者说<code>消费者</code></li><li><code>经销商</code>(容器)。我们也称为容器，他负责协调需求和实现。</li><li><code>供应商</code>。需求的具体实现者。</li></ul></li></ul><p><br><br><br></p><p>可以通过一个例子(来源<a href="https://www.notion.so/wakeapp-framework-b08cb3cb5f8e49f597aa90bbb89a1641?pvs=21" target="_blank" rel="noopener">这里</a>)来理解一下：</p><p><br></p><ol><li><p>定义需求(协议)</p><p>首先定义需求，描述我们期望得到一个怎样的东西。</p><p>需求通常使用 <code>interface</code> 来描述，当然，这并没有限制。你要一个类也可以、字符串、数字也可以，取决你的需求。</p><p>比如我想要一个手机:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface IPhone &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 打电话</span><br><span class="line">   */</span><br><span class="line">  call(num: string): void</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 发短信</span><br><span class="line">   */</span><br><span class="line">  sendMessage(num: string, message: string): void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册你的需求和标识符的绑定关系：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare global &#123;</span><br><span class="line">  interface DIMapper &#123;</span><br><span class="line">    &apos;DI.IPhone&apos;: IPhone</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>请求注入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class WeChat &#123;</span><br><span class="line">  // 注入请求</span><br><span class="line">  @inject(&apos;DI.IPhone&apos;)</span><br><span class="line">  myPhone: IPhone</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 打电话老妈</span><br><span class="line">   */</span><br><span class="line">  callMom() &#123;</span><br><span class="line">    this.myPhone.call(&apos;137****110&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现需求</p><p>接下来就是供应商来实现需求了。通常使用类来实现需求：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">@injectable()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TheIPhone</span> <span class="title">implements</span> <span class="title">IPhone</span> </span>&#123;</span><br><span class="line">  call(num: string) &#123;</span><br><span class="line">    <span class="comment">// 拨打电话流程</span></span><br><span class="line">  &#125;</span><br><span class="line">  sendMessage(num: string, <span class="attr">message</span>: string) &#123;</span><br><span class="line">    <span class="comment">// 发送短信流程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注册实现</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">configureDI((registerSingletonClass) =&gt; &#123;</span><br><span class="line">  registerSingletonClass(&apos;DI.IPhone&apos;, TheIPhone)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p><br><br><br></p><p>如果你理解了上面的例子，那么你已经懂依赖注入了。不过，当你接触到依赖注入的相关实现库时，还有听到这些概念：</p><ul><li><code>容器(Container)</code>。 就是上文提到的<code>经销商</code>，用最简单技术术语来描述的话，他就是一个<code>对象池</code>。他负责协调<code>消费者</code>需求和<code>提供商</code>的实现。</li><li><code>作用域(Scope)</code>。就是对象的存活时间和活动范围<ul><li>存活时间：比较典型的有 singleton(单例)、request(请求， 这个一句话说不清楚，你可以类比为 「HTTP 请求」，这些对象仅在这一次 HTTP 的请求周期内有效)、transient(临时，即每次 inject 请求都创建一个新的对象)。当然，根据实际的场景还可以扩展，比如在 React 组件生命周期</li><li>活动范围： 很多依赖注入库中，容器不是一个单一的对象，而是一个树状的结构，如果要限制某些对象的活动范围，或者覆盖对象的实现，可以通过 Fork 子容器的形式来实现隔离。</li></ul></li><li><code>绑定(binding)</code>。即协议的绑定，比如上面的例子中我们使用 <code>DI.IPhone</code> 字符串来绑定协议和实现。其他编程语言可以做得更加灵活，只需要声明类型，容器会根据类型的兼容性来协调注入。</li></ul><p><br></p><p>当然，一个生产级别的依赖注入实现还会涉及很多技术细节和概念，比如循环依赖、对象构造和析构、工厂、异步加载、对象生命周期管理、中间件、标签(Tagged)等等。</p><p><br></p><p>不过上面我们掌握的知识已经足够覆盖正常的开发场景了。</p><p><br><br><br></p><p><strong>依赖注入的好处就不多说了：</strong></p><ul><li>解耦。面向接口编程。</li><li>可扩展性。每个依赖注入的点就是一个扩展点。</li><li>可测试性。可以让程序职责更加单一，关注真正需要关注的内容。屏蔽干扰，让核心逻辑更容易被测试。</li></ul><p><br><br><br><br><br></p><h2 id="继续探索-typescript-装饰器的能力边界"><a href="#继续探索-typescript-装饰器的能力边界" class="headerlink" title="继续探索 Typescript 装饰器的能力边界"></a>继续探索 Typescript 装饰器的能力边界</h2><p>在上篇<a href="https://www.notion.so/Javascript-MobX-Vue-5e1c633167094d9784e602d66a5877f8?pvs=21" target="_blank" rel="noopener">文章</a>中，我们提到 Typescript 对新版的装饰器有了更严格的检查。</p><p><br></p><p>它可以约束装饰器的位置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare function injectable&lt;T, Class extends abstract new (...args: any) =&gt; T&gt;(): (</span><br><span class="line">  value: Class,</span><br><span class="line">  context: ClassDecoratorContext&lt;Class&gt;</span><br><span class="line">) =&gt; void</span><br><span class="line"></span><br><span class="line">@injectable()</span><br><span class="line">class Foo &#123;</span><br><span class="line">  // @ts-expect-error ❌ 只能装饰类</span><br><span class="line">  @injectable()</span><br><span class="line">  member = 1</span><br><span class="line"></span><br><span class="line">  // @ts-expect-error ❌ 只能装饰类</span><br><span class="line">  @injectable()</span><br><span class="line">  method() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>这还不止，我们还可以对被装饰的目标值进行约束。以依赖注入的场景来看, 旧版的装饰器很难做到根据注入的标识符来约束<code>实现</code>和<code>注入</code>。现在我们很容易做到：</p><p>先来构造<code>注入标识符</code>的类型(灵感来源于 <code>Vue</code> 的 <code>provide/inject</code>)：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface InjectionKey&lt;T&gt; extends Symbol &#123;&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>现在可以这样定义标识符：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 定义注入的协议，鸟类</span><br><span class="line">interface Bird &#123;</span><br><span class="line">  fly(): void</span><br><span class="line">  searchForFood(): void</span><br><span class="line">  breed(): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将接口和标识符实现绑定</span><br><span class="line">const BIRD_BINDING: InjectionKey&lt;Bird&gt; = Symbol(&apos;Bird&apos;)</span><br></pre></td></tr></table></figure><p><br></p><p>我们再来定义 <code>injectable</code> 装饰器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare function injectable&lt;T, Class extends abstract new (...args: any) =&gt; T&gt;(</span><br><span class="line">  // 传入 InjectionKey 类型，推断出 T 来约束 class</span><br><span class="line">  key: InjectionKey&lt;T&gt;</span><br><span class="line">): (value: Class, context: ClassDecoratorContext&lt;Class&gt;) =&gt; void</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// @ts-expect-error ❌ 没有履行 Bird 协议</span><br><span class="line">@injectable(BIRD_BINDING)</span><br><span class="line">class Eagle &#123;&#125;</span><br><span class="line"></span><br><span class="line">// ✅ 履行了 Bird 协议</span><br><span class="line">@injectable(BIRD_BINDING)</span><br><span class="line">class Pigeon implements Bird &#123;</span><br><span class="line">  fly() &#123;&#125;</span><br><span class="line">  searchForFood() &#123;&#125;</span><br><span class="line">  breed() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在可以对<code>实现者</code>的<code>协议履行</code>进行严格检查。</p><p><br><br><br></p><p>同理我们可以检查注入侧：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare function inject&lt;T&gt;(</span><br><span class="line">  key: InjectionKey&lt;T&gt;</span><br><span class="line">): (value: undefined, context: ClassFieldDecoratorContext&lt;unknown, T | undefined&gt;) =&gt; void</span><br><span class="line"></span><br><span class="line">declare function injectAll&lt;T&gt;(</span><br><span class="line">  key: InjectionKey&lt;T&gt;</span><br><span class="line">): (value: undefined, context: ClassFieldDecoratorContext&lt;unknown, T[] | undefined&gt;) =&gt; void</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Zoo &#123;</span><br><span class="line">  // @ts-expect-error ❌ 类型不匹配</span><br><span class="line">  @inject(BIRD_BINDING)</span><br><span class="line">  private unknown?: number</span><br><span class="line"></span><br><span class="line">  // ✅</span><br><span class="line">  @inject(BIRD_BINDING)</span><br><span class="line">  private bird?: Bird</span><br><span class="line"></span><br><span class="line">  // @ts-expect-error ❌ 类型不匹配</span><br><span class="line">  @injectAll(BIRD_BINDING)</span><br><span class="line">  private allBirds?: Bird</span><br><span class="line"></span><br><span class="line">  // ✅</span><br><span class="line">  @injectAll(BIRD_BINDING)</span><br><span class="line">  private birds?: Bird[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很酷?！</p><p><br><br><br><br><br></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>接下来我们把上面讲到的知识点运用起来，实现一个简易的依赖注入库。</p><p>🔴  运行环境：由于使用了较新的特性，其他构建平台暂未跟进(包括 Babel、Vite)。下面代码基于 Typescript 5.2(next) + <code>jest</code> + <code>ts-jest</code> 运行。</p><p>为了确保运行， 需要添加以下 polyfill：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// typescript polyfill</span><br><span class="line">declare global &#123;</span><br><span class="line">  interface SymbolConstructor &#123;</span><br><span class="line">    readonly metadata: unique symbol</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  interface Function &#123;</span><br><span class="line">    [Symbol.metadata]?: DecoratorMetadata</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// runtime polyfill</span><br><span class="line">if (typeof Symbol.metadata === &apos;undefined&apos;) &#123;</span><br><span class="line">  // @ts-expect-error</span><br><span class="line">  Symbol.metadata = Symbol(&apos;Symbol.metadata&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>💡  在新版的装饰器中，实现依赖注入不一定要用到 Decorator Metadata, 可以看装饰器提案中的<a href="https://github.com/tc39/proposal-decorators#access-and-metadata-sidechanneling" target="_blank" rel="noopener">例子</a>。</p></blockquote><p><br><br><br><br><br><br><br></p><h3 id="装饰器-api"><a href="#装饰器-api" class="headerlink" title="装饰器 API"></a>装饰器 API</h3><p>首先，我们把关键的装饰器 API 定义出来:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 🔴 InjectionKey 用于定义依赖注入的标识符, 可是实现标志服和协议的绑定，我们在上文介绍过了</span><br><span class="line">export interface InjectionKey&lt;T&gt; extends Symbol &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 作用域类型, 作为简单示例，我们就支持两种作用域类型</span><br><span class="line">export enum Scope &#123;</span><br><span class="line">  Singleton,</span><br><span class="line">  Transient,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 类装饰器，支持被注入的类都需要使用它来装饰</span><br><span class="line">// 可以接受一个 scope，默认为 单例</span><br><span class="line">export function injectable&lt;T, Class extends abstract new (...args: any) =&gt; T&gt;(</span><br><span class="line">  key: InjectionKey&lt;T&gt;,</span><br><span class="line">  scope?: Scope</span><br><span class="line">) &#123;</span><br><span class="line">  return (value: Class, context: ClassDecoratorContext&lt;Class&gt;) =&gt; &#123;</span><br><span class="line">    const metadata = getOrCreateMetadata(context.metadata)</span><br><span class="line"></span><br><span class="line">    if (metadata.injectable) &#123;</span><br><span class="line">      throw new Error(&apos;injectable is already defined&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    metadata.injectable = key</span><br><span class="line">    metadata.scope = scope</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 属性装饰器, 声明注入</span><br><span class="line">export function inject&lt;T&gt;(key: InjectionKey&lt;T&gt;) &#123;</span><br><span class="line">  return (value: undefined, context: ClassFieldDecoratorContext&lt;unknown, T | undefined&gt;) =&gt; &#123;</span><br><span class="line">    injectToField(&#123; key, context &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 属性装饰器, 声明注入所有绑定</span><br><span class="line">export function injectAll&lt;T&gt;(key: InjectionKey&lt;T&gt;) &#123;</span><br><span class="line">  return (value: undefined, context: ClassFieldDecoratorContext&lt;unknown, T[] | undefined&gt;) =&gt; &#123;</span><br><span class="line">    injectToField(&#123; key, multiple: true, context &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述装饰器不会对类进行改造，只是利用 Decorator Metadata 进行一些标注：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 🔴 我们存储在类 Decorator Metadata 的数据</span><br><span class="line">interface InjectionMetadata &#123;</span><br><span class="line">  // 类是否装饰了 @injectable</span><br><span class="line">  injectable?: InjectionKey&lt;unknown&gt;</span><br><span class="line">  // 作用域</span><br><span class="line">  scope?: Scope</span><br><span class="line">  // 类需要进行注入的属性</span><br><span class="line">  injections?: Map&lt;PropertyKey, Injection&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 类属性注入信息</span><br><span class="line">interface Injection &#123;</span><br><span class="line">  // 属性名</span><br><span class="line">  key: InjectionKey&lt;unknown&gt;</span><br><span class="line">  // 是否获取多个实例</span><br><span class="line">  multiple?: boolean</span><br><span class="line">  // 装饰器的上下文</span><br><span class="line">  context: ClassFieldDecoratorContext</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 Decorator Metadata 的 KEY, 使用 Symbol，避免和其他库冲突</span><br><span class="line">const METADATA_KEY: unique symbol = Symbol(&apos;METADATA_KEY&apos;)</span><br><span class="line"></span><br><span class="line">// 初始化 metadata</span><br><span class="line">function getOrCreateMetadata&lt;T&gt;(metadata: DecoratorMetadata): InjectionMetadata &#123;</span><br><span class="line">  if (metadata == null) &#123;</span><br><span class="line">    throw new Error(&apos;Decorator metadata is not defined&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return metadata[METADATA_KEY] ?? (metadata[METADATA_KEY] = &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 标记属性注入</span><br><span class="line">function injectToField(injection: Injection) &#123;</span><br><span class="line">  const &#123; context &#125; = injection</span><br><span class="line"></span><br><span class="line">  if (context.static === true) &#123;</span><br><span class="line">    throw new Error(&apos;inject cannot be used on static fields&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const metadata = getOrCreateMetadata(context.metadata)</span><br><span class="line"></span><br><span class="line">  if (metadata.injections == null) &#123;</span><br><span class="line">    metadata.injections = new Map()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (metadata.injections.has(context.name)) &#123;</span><br><span class="line">    throw new Error(`inject is already defined for $&#123;context.name.toString()&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  metadata.injections.set(context.name, injection)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试驱动开发，我们先把测试用例写了，也方便读者对我们 API 的用法有基本的了解：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 定义协议</span><br><span class="line">interface Bird &#123;</span><br><span class="line">  fly(): void</span><br><span class="line">  searchForFood(): void</span><br><span class="line">  breed(): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IZoo &#123;</span><br><span class="line">  getAllBirds(): Bird[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义标识符，并绑定协议</span><br><span class="line">const BIRD_BINDING: InjectionKey&lt;Bird&gt; = Symbol.for(&apos;Bird&apos;)</span><br><span class="line">const ZOO_KEY: InjectionKey&lt;IZoo&gt; = Symbol.for(&apos;Zoo&apos;)</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">test(&apos;property inject&apos;, () =&gt; &#123;</span><br><span class="line">  // 🔴 使用 @injectable 标注支持注入的类</span><br><span class="line">  @injectable(BIRD_BINDING)</span><br><span class="line">  class MyBird &#123;</span><br><span class="line">    fly() &#123;&#125;</span><br><span class="line">    searchForFood() &#123;&#125;</span><br><span class="line">    breed() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @injectable(BIRD_BINDING)</span><br><span class="line">  class MyBird2 &#123;</span><br><span class="line">    fly() &#123;&#125;</span><br><span class="line">    searchForFood() &#123;&#125;</span><br><span class="line">    breed() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @injectable(ZOO_KEY)</span><br><span class="line">  class Zoo implements IZoo &#123;</span><br><span class="line">    // 🔴 获取所有 Bird 实例</span><br><span class="line">    @injectAll(BIRD_BINDING)</span><br><span class="line">    birds?: Bird[]</span><br><span class="line"></span><br><span class="line">    getAllBirds() &#123;</span><br><span class="line">      return this.birds!</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 🔴 注册到容器</span><br><span class="line">  const container = new Container()</span><br><span class="line">  container.bind(BIRD_BINDING, MyBird)</span><br><span class="line">  container.bind(BIRD_BINDING, MyBird2)</span><br><span class="line">  container.bind(ZOO_KEY, Zoo)</span><br><span class="line"></span><br><span class="line">  // 测试</span><br><span class="line">  const zoo = container.get(ZOO_KEY)</span><br><span class="line"></span><br><span class="line">  expect(zoo).toBeInstanceOf(Zoo)</span><br><span class="line">  expect(zoo.getAllBirds().length).toBe(2)</span><br><span class="line">  expect(zoo.getAllBirds()[0]).toBeInstanceOf(MyBird)</span><br><span class="line">  expect(zoo.getAllBirds()[1]).toBeInstanceOf(MyBird2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="容器实现"><a href="#容器实现" class="headerlink" title="容器实现"></a>容器实现</h3><p>接下来就是实现容器了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Ctor&lt;T = unknown&gt; = new (...args: any) =&gt; T</span><br><span class="line"></span><br><span class="line">export class Container &#123;</span><br><span class="line">  // 存储绑定关系</span><br><span class="line">  private bindings: Map&lt;InjectionKey&lt;unknown&gt;, Ctor[]&gt; = new Map()</span><br><span class="line">  // 单例对象池</span><br><span class="line">  private pools: Map&lt;Ctor, unknown&gt; = new Map()</span><br><span class="line"></span><br><span class="line">  // 🔴 绑定，传入 InjectionKey 和 类实现</span><br><span class="line">  bind&lt;T&gt;(key: InjectionKey&lt;T&gt;, impl: new (...args: any) =&gt; T) &#123;</span><br><span class="line">    // 装饰器信息检查</span><br><span class="line">    if (impl[Symbol.metadata] == null) &#123;</span><br><span class="line">      throw new Error(`No metadata found for $&#123;impl.name&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const metadata = impl[Symbol.metadata]![METADATA_KEY] as InjectionMetadata | undefined</span><br><span class="line"></span><br><span class="line">    if (metadata == null || metadata.injectable == null) &#123;</span><br><span class="line">      throw new Error(`No injectable found for $&#123;impl.name&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 存储</span><br><span class="line">    if (this.bindings.has(key)) &#123;</span><br><span class="line">      this.bindings.get(key)!.push(impl)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.bindings.set(key, [impl])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 🔴 获取实例</span><br><span class="line">  get&lt;T&gt;(key: InjectionKey&lt;T&gt;): T &#123;</span><br><span class="line">    return this.resolve(key, false) as T</span><br><span class="line">  &#125;</span><br><span class="line">  // 🔴 获取所有实例</span><br><span class="line">  getAll&lt;T&gt;(key: InjectionKey&lt;T&gt;): T[] &#123;</span><br><span class="line">    return this.resolve(key, true) as T[]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 🔴 对象查找</span><br><span class="line">   */</span><br><span class="line">  private resolve(key: InjectionKey&lt;unknown&gt;, multiple: boolean): unknown &#123;</span><br><span class="line">    const binding = this.bindings.get(key)</span><br><span class="line"></span><br><span class="line">    if (binding == null) &#123;</span><br><span class="line">      throw new Error(`No binding found for $&#123;key.toString()&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!multiple &amp;&amp; binding.length &gt; 1) &#123;</span><br><span class="line">      throw new Error(`Multiple bindings found for $&#123;key.toString()&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return multiple</span><br><span class="line">      ? binding.map((impl) =&gt; this.createInstance(impl))</span><br><span class="line">      : this.createInstance(binding[0])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 🔴 对象实例化</span><br><span class="line">   */</span><br><span class="line">  private createInstance(impl: Ctor): unknown &#123;</span><br><span class="line">    const metadata = impl[Symbol.metadata]![METADATA_KEY] as InjectionMetadata</span><br><span class="line">    const &#123; scope = Scope.Singleton, injections &#125; = metadata</span><br><span class="line"></span><br><span class="line">    // 单例</span><br><span class="line">    if (scope === Scope.Singleton &amp;&amp; this.pools.has(impl)) &#123;</span><br><span class="line">      return this.pools.get(impl)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实例化</span><br><span class="line">    const instance = new impl()</span><br><span class="line"></span><br><span class="line">    // 依赖注入，递归调用</span><br><span class="line">    if (injections != null) &#123;</span><br><span class="line">      for (const injection of injections.values()) &#123;</span><br><span class="line">        const &#123; key, context, multiple &#125; = injection</span><br><span class="line">        const value = multiple ? this.getAll(key) : this.get(key)</span><br><span class="line">        // 🔴 利用新版装饰器的 access 实现注入</span><br><span class="line">        context.access.set(instance, value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (scope === Scope.Singleton) &#123;</span><br><span class="line">      this.pools.set(impl, instance)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>整个代码非常简单，这里对新版装饰器的妙用在于 <code>context.access.set(instance, value)</code> , 用起来非常方便，我们不需要关心属性的存储过程，比如<code>私有属性</code>。</p><p><br></p><p>上面的代码有一个问题没有解决，就是<code>循环依赖</code>。我们写一个测试来复现一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test(&apos;cycle dependency&apos;, () =&gt; &#123;</span><br><span class="line">  const container = new Container()</span><br><span class="line"></span><br><span class="line">  const A_KEY: InjectionKey&lt;A&gt; = Symbol(&apos;A&apos;)</span><br><span class="line">  const B_KEY: InjectionKey&lt;B&gt; = Symbol(&apos;B&apos;)</span><br><span class="line"></span><br><span class="line">  @injectable(A_KEY)</span><br><span class="line">  class A &#123;</span><br><span class="line">    @inject(B_KEY)</span><br><span class="line">    b?: B</span><br><span class="line"></span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @injectable(B_KEY)</span><br><span class="line">  class B &#123;</span><br><span class="line">    @inject(A_KEY)</span><br><span class="line">    a?: A</span><br><span class="line"></span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  container.bind(A_KEY, A)</span><br><span class="line">  container.bind(B_KEY, B)</span><br><span class="line"></span><br><span class="line">  const a = container.get(A_KEY)</span><br><span class="line">  expect(a).toBeInstanceOf(A)</span><br><span class="line">  const b = container.get(B_KEY)</span><br><span class="line">  expect(b).toBeInstanceOf(B)</span><br><span class="line">  expect(a.b).toBe(b)</span><br><span class="line">  expect(b.a).toBe(a)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的测试用例会出现<code>调用栈溢出</code>。因为 A → B 之间出现了循环依赖。这个也好办，我们新增一个缓存属性，存储正在实例化的对象，可以简单解决问题：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">export class Container &#123;</span><br><span class="line"><span class="addition">+ // 正在创建的对象</span></span><br><span class="line"><span class="addition">+ private creating: Map&lt;Ctor, unknown&gt; = new Map()</span></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 对象实例化</span><br><span class="line">   */</span><br><span class="line">  private createInstance(impl: Ctor): unknown &#123;</span><br><span class="line"><span class="addition">+   if (this.creating.has(impl)) &#123;</span></span><br><span class="line"><span class="addition">+     return this.creating.get(impl)</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line">    // ...</span><br><span class="line"><span class="addition">+   // 实例化</span></span><br><span class="line"><span class="addition">+   const instance = new impl()</span></span><br><span class="line"><span class="addition">+   // 缓存</span></span><br><span class="line"><span class="addition">+   this.creating.set(impl, instance)</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   try &#123;</span></span><br><span class="line">      // 依赖注入</span><br><span class="line">      if (injections != null) &#123;</span><br><span class="line">        for (const injection of injections.values()) &#123;</span><br><span class="line">          const &#123; key, context, multiple &#125; = injection</span><br><span class="line">          const value = multiple ? this.getAll(key) : this.get(key)</span><br><span class="line">          context.access.set(instance, value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (scope <span class="comment">=== Scope.Singleton) &#123;</span></span><br><span class="line">        this.pools.set(impl, instance)</span><br><span class="line">      &#125;</span><br><span class="line"><span class="addition">+   &#125; finally &#123;</span></span><br><span class="line"><span class="addition">+     this.creating.delete(impl)</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line"></span><br><span class="line">    return instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是装饰器的核心逻辑了。如果你对生产级别 DI 库感兴趣，可以深入看下扩展阅读提及的开源实现。</p><p>上面相关源码可以在<a href="https://github.com/ivan-94/decoractor-in-action/tree/new-di/src/di" target="_blank" rel="noopener">这里</a>找到。</p><p><br><br><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文回顾了装饰器的老搭档 <code>reflect-metadata</code> 的历史，它的愿景给装饰器提供标准化的元数据存储服务，更长远来愿景是给 JavaScript 的上层语言提供保留静态信息的接口。</p><p>但它最终没有提交给 tc39, 现在随着新的装饰器标准的发展，已经被 <code>Decorator Metadata</code> 提案取代。<code>Decorator Metadata</code> 相比 reflect-metadata 简化很多，就是新增了 <code>Symbol.metadata</code>, 配合装饰器 context.metadata，开发者可以存储任意元数据。</p><p>接着我们继续探索了 Typescript 对装饰器类型检查的增强，可以让我们写出更安全的代码。尤其在 DI 这个场景。</p><p>最后我们将上面学到的知识融会贯通，开发了一个简易的依赖注入实现。</p><p><br><br><br><br><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li>Decorator<br><a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noopener">https://github.com/tc39/proposal-decorators</a></li><li>Decorator Metadata<br><a href="https://github.com/tc39/proposal-decorator-metadata" target="_blank" rel="noopener">https://github.com/tc39/proposal-decorator-metadata</a></li><li>reflect-metadata<br><a href="https://github.com/rbuckton/reflect-metadata" target="_blank" rel="noopener">https://github.com/rbuckton/reflect-metadata</a><ul><li><a href="https://dev.to/svehla/why-reflect-metadata-suc-s-5fal" target="_blank" rel="noopener">Why reflect-metadata suc*s</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/decorators.html" target="_blank" rel="noopener">Typescript Experimental Decorator</a></li><li><a href="https://medium.com/jspoint/introduction-to-reflect-metadata-package-and-its-ecmascript-proposal-8798405d7d88" target="_blank" rel="noopener">Introduction to “reflect-metadata” package and its ECMAScript proposal</a></li></ul></li><li>DI 实现<br><a href="https://github.com/inversify/InversifyJS" target="_blank" rel="noopener">https://github.com/inversify/InversifyJS</a><br><a href="https://github.com/microsoft/tsyringe" target="_blank" rel="noopener">https://github.com/microsoft/tsyringe</a><br><a href="https://github.com/midwayjs/injection" target="_blank" rel="noopener">https://github.com/midwayjs/injection</a><br><a href="https://github.com/jeffijoe/awilix" target="_blank" rel="noopener">https://github.com/jeffijoe/awilix</a><br><a href="https://github.com/typestack/typedi" target="_blank" rel="noopener">https://github.com/typestack/typedi</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/decorator-2/Untitled.jpeg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.notion.so/Javascript
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>全新 Javascript 装饰器实战上篇：用 MobX 的方式打开 Vue</title>
    <link href="https://bobi.ink/2023/06/26/decorator/"/>
    <id>https://bobi.ink/2023/06/26/decorator/</id>
    <published>2023-06-25T16:00:00.000Z</published>
    <updated>2023-06-30T08:35:21.851Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/decorator/Untitled.jpeg" alt="cover"></p><p>去年三月份<a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noopener">装饰器提案</a>进入了 Stage 3 阶段，而今年三月份 Typescript 在 5.0 也正式支持了 <a href="https://github.com/tc39/proposal-decorators/tree/8ca65c046dd5e9aa3846a1fe5df343a6f7efd9f8" target="_blank" rel="noopener"></a>。装饰器提案距离正式的语言标准，只差临门一脚。</p><p>这也意味着旧版的装饰器(Stage 1) 将逐渐退出历史舞台。然而旧版的装饰器已经被广泛的使用，比如 MobX、Angular、NestJS… 未来较长的一段时间内，都会是新旧并存的局面。</p><p><br></p><p>本文将把装饰器语法带到 <code>Vue Reactivity API</code> 中，让我们可以像 MobX 一样，使用类来定义数据模型, 例如:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Counter &#123;</span><br><span class="line">  @observable</span><br><span class="line">  count = 1</span><br><span class="line"></span><br><span class="line">  @computed</span><br><span class="line">  get double() &#123;</span><br><span class="line">    return this.count * 2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add = () =&gt; &#123;</span><br><span class="line">    this.count++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>在这个过程中，我们可以体会到新旧装饰器版本之间的差异和实践中的各种陷阱。</p><p><br><br><br></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="/images/decorator/Untitled.png" alt="思维导图"></p><p>关于装饰器的主要 API 都在上述思维导图中，除此之外，读者可以通过下文「扩展阅读」中提及的链接来深入了解它们。</p><p><br><br><br></p><h2 id="legacy"><a href="#legacy" class="headerlink" title="Legacy"></a>Legacy</h2><p>首先，我们使用旧的装饰器来实现相关的功能。</p><p>在 Typescript 下，需要通过 <code>experimentalDecorators</code> 来启用装饰器语法:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;experimentalDecorators&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用 Babel 7 ，配置大概如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    [&quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;version&quot;: &quot;legacy&quot; &#125;]</span><br><span class="line">    [&quot;@babel/plugin-transform-class-properties&quot;, &#123;&quot;loose&quot;: true &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="observable"><a href="#observable" class="headerlink" title="@observable"></a>@observable</h3><p>我们先来实现 <code>@observable</code> 装饰器，它只能作用于「<code>类属性成员</code>」，比如:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Counter &#123;</span><br><span class="line">  @observable</span><br><span class="line">  count = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const counter = new Counter()</span><br><span class="line">expect(counter.count).toBe(1)</span><br></pre></td></tr></table></figure><p>属性值可以是<code>原始类型</code>或者<code>对象类型</code>，没有限制。</p><p>为了让 Vue 的视图可以响应它的变化，我们可以使用 <code>ref</code> 来包装它。<code>ref</code> 刚好符合我们的需求，可以放置原始类型，也可以是对象, <code>ref</code> 会将其包装为 <code>reactive</code> 。</p><p><br></p><p>初步实现如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const observable: PropertyDecorator = function (target, propertyKey) &#123;</span><br><span class="line">  if (typeof target === &apos;function&apos;) &#123;</span><br><span class="line">    throw new Error(&apos;Observable cannot be used on static properties&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (arguments.length &gt; 2 &amp;&amp; arguments[2] != null) &#123;</span><br><span class="line">    throw new Error(&apos;Observable cannot be used on methods&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const accessor: Initializer = (self) =&gt; &#123;</span><br><span class="line">    const value = ref()</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        return unref(value)</span><br><span class="line">      &#125;,</span><br><span class="line">      set(val) &#123;</span><br><span class="line">        value.value = val</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 定义getter /setter 长远</span><br><span class="line">  Object.defineProperty(target, propertyKey, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get: function () &#123;</span><br><span class="line">      // 惰性初始化</span><br><span class="line">      return initialIfNeed(this, propertyKey, accessor).get()</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function (value) &#123;</span><br><span class="line">      initialIfNeed(this, propertyKey, accessor).set(value)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下上面的代码：</p><ul><li>将装饰器的类型设置为 <code>PropertyDecorator</code>。<blockquote><p>📢 对应的类型还有： ClassDecorator、MethodDecorator、ParameterDecorator<br><br></p><p>⚠️ 旧版<em>装饰器使用位置上 Typescript 并没作类型检查，装饰器可以随意用在类、方法、属性各种位置上</em>。<br><br></p></blockquote></li><li>可以通过 <code>target</code> 的类型，来判断装饰器作用于<code>静态成员</code>上还是<code>实例成员</code>上。如果是静态成员，target 是类本身；如果是实例成员，target 为类的<code>原型对象(prototype)</code></li><li><p><code>属性装饰器</code>只会接收两个参数：类和属性名。因为属性在构造函数中创建, 在类定义阶段，获取不到更多信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  foo = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// transpile to</span><br><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.foo = 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们定义了一个新的 <code>getter</code>/<code>setter</code> 成员, 这样外部才能透明地使用 ref, 不需要加上 <code>.value</code> 后缀</p></li><li><p><code>惰性初始化</code> ref。旧版的装饰器并没有提供 <code>addInitializer</code> 这样的初始化钩子，我们曲线救国，使用惰性初始化的方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const REACTIVE_CACHE = Symbol(&apos;reactive_cache&apos;)</span><br><span class="line">export interface ReactiveAccessor &#123;</span><br><span class="line">  get(): any</span><br><span class="line">  set(value: any): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getReactiveCache(target: any): Record&lt;string | symbol, any&gt; &#123;</span><br><span class="line">  if (!hasProp(target, REACTIVE_CACHE)) &#123;</span><br><span class="line">    addHiddenProp(target, REACTIVE_CACHE, &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return target[REACTIVE_CACHE]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export type Initializer = (target: any) =&gt; ReactiveAccessor</span><br><span class="line"></span><br><span class="line">export function initialIfNeed(target: any, key: string | symbol, initializer: Initializer) &#123;</span><br><span class="line">  const cache = getReactiveCache(target)</span><br><span class="line">  // 如果属性未定义，就执行初始化</span><br><span class="line">  if (!hasProp(cache, key)) &#123;</span><br><span class="line">    cache[key] = initializer(target)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return cache[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>这里我们将信息缓存在 REACTIVE_CACHE 字段中，实现惰性初始化。</code></pre></li></ul><p><br><br><br><br><br></p><p>写个单元测试看看:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test(&apos;base type&apos;, () =&gt; &#123;</span><br><span class="line">  class A &#123;</span><br><span class="line">    @observable</span><br><span class="line">    str = &apos;str&apos;</span><br><span class="line"></span><br><span class="line">    @observable</span><br><span class="line">    num = 1</span><br><span class="line"></span><br><span class="line">    @observable</span><br><span class="line">    withoutInitialValue: any</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const a = new A()</span><br><span class="line"></span><br><span class="line">  let str</span><br><span class="line">  let num</span><br><span class="line">  let withoutInitialValue</span><br><span class="line">  // 🔴 初始值应该正常被设置</span><br><span class="line">  expect(a.str).toBe(&apos;str&apos;)</span><br><span class="line">  expect(a.num).toBe(1)</span><br><span class="line">  expect(a.withoutInitialValue).toBe(undefined)</span><br><span class="line"></span><br><span class="line">  // 🔴 属性的变动应该被检测</span><br><span class="line">  watchSyncEffect(() =&gt; &#123;</span><br><span class="line">    str = a.str</span><br><span class="line">  &#125;)</span><br><span class="line">  watchSyncEffect(() =&gt; &#123;</span><br><span class="line">    num = a.num</span><br><span class="line">  &#125;)</span><br><span class="line">  watchSyncEffect(() =&gt; &#123;</span><br><span class="line">    withoutInitialValue = a.withoutInitialValue</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  a.str = &apos;new str&apos;</span><br><span class="line">  a.num = 2</span><br><span class="line">  a.withoutInitialValue = &apos;withoutInitialValue&apos;</span><br><span class="line"></span><br><span class="line">  expect(str).toBe(&apos;new str&apos;)</span><br><span class="line">  expect(num).toBe(2)</span><br><span class="line">  expect(withoutInitialValue).toBe(&apos;withoutInitialValue&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>💥 在较新的构建工具中(比如 vite)，上述的测试大概率无法通过！为什么？</p><p><br></p><p><strong>经过调试会发现我们在 observable 中的 <code>defineProperty</code> 并没有生效？</strong></p><p><br><br><br></p><p>通过阅读 Vite 的文档可以找到一些线索，即 Typescript 的 <code>[useDefineForClassFields](https://cn.vitejs.dev/guide/features.html#usedefineforclassfields)</code>:</p><blockquote><p>从 Vite v2.5.0 开始，如果 TypeScript 的 target 是  <code>ESNext</code>  或  <code>ES2022</code>  及更新版本，此选项默认值则为  <code>true</code>。这与  <strong><code>[tsc</code> v4.3.2 及以后版本的行为](<a href="https://github.com/microsoft/TypeScript/pull/42663" target="_blank" rel="noopener">https://github.com/microsoft/TypeScript/pull/42663</a>)</strong>  一致。这也是标准的 ECMAScript 的运行时行为</p></blockquote><p><br></p><p><code>useDefineForClassFields</code> 会改变<code>类实例属性</code>的定义方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  foo = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 旧</span><br><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.foo = 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 新：useDefineForClassFields</span><br><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    Object.defineProperty(this, &apos;foo&apos;, &#123;</span><br><span class="line">      enumerable: true,</span><br><span class="line">      configurable: true,</span><br><span class="line">      writable: true,</span><br><span class="line">      value: 1,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是为什么我们装饰器内的 <code>defineProperty</code> 无法生效的原因。</p><p><br><br><br></p><p>解决办法：</p><p>方法 1： 显式关闭掉 useDefineForClassFields。如果是 Babel 需要配置 <code>@babel/plugin-transform-class-properties</code> 的 <code>loose</code> 为 true：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    [&quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;version&quot;: &quot;legacy&quot; &#125;]</span><br><span class="line">    [&quot;@babel/plugin-transform-class-properties&quot;, &#123;&quot;loose&quot;: true &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>方法 2： 或者模仿 <a href="https://www.mobxjs.com/enabling-decorators" target="_blank" rel="noopener">MobX V6</a> 的 API:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TodoList &#123;</span><br><span class="line">  @observable todos = []</span><br><span class="line"></span><br><span class="line">  @computed</span><br><span class="line">  get unfinishedTodoCount() &#123;</span><br><span class="line">    return this.todos.filter((todo) =&gt; !todo.finished).length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    makeObservable(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MobX 的 observable、computed 等装饰器只是收集了一些<strong><code>标记信息</code>，</strong> 本身不会对类进行转换，真正进行转换是在 <code>makeObservable</code> 中进行的， 而 <code>makeObservable</code> 的执行时机是在所有属性都初始化完毕之后。</p><p>由于本文只关注装饰器的能力，这里就不展开了，有兴趣的读者可以看下 MobX 的源码。</p><p><br><br><br><br><br></p><h3 id="computed"><a href="#computed" class="headerlink" title="@computed"></a>@computed</h3><p>按照同样的方法，我们来实现一下 <code>@computed</code> 装饰器，MobX 的 computed 和 Vue 的 computed 概念基本一致，就是用来做衍生数据的计算。</p><p><br></p><p>@computed 只能应用在 <code>getter</code> 上面:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const computed: MethodDecorator = function (target, propertyKey, descriptor) &#123;</span><br><span class="line">  // 不支持 static</span><br><span class="line">  if (typeof target === &apos;function&apos;) &#123;</span><br><span class="line">    throw new Error(&apos;computed cannot be used on static member&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 必须是 getter</span><br><span class="line">  if (</span><br><span class="line">    descriptor == null ||</span><br><span class="line">    typeof descriptor !== &apos;object&apos; ||</span><br><span class="line">    typeof descriptor.get !== &apos;function&apos;</span><br><span class="line">  ) &#123;</span><br><span class="line">    throw new Error(&apos;computed can only be used on getter&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const initialGetter = descriptor.get</span><br><span class="line">  const accessor: Initializer = (self) =&gt; &#123;</span><br><span class="line">    const value = vueComputed(() =&gt; initialGetter.call(self))</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        return unref(value)</span><br><span class="line">      &#125;,</span><br><span class="line">      set() &#123;</span><br><span class="line">        // readonly</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  descriptor.get = function () &#123;</span><br><span class="line">    // 惰性初始化</span><br><span class="line">    return initialIfNeed(this, propertyKey, accessor).get()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>getter/setter/method 装饰器的用法一致。会接收 <code>descriptor</code> 作为第三个参数，我们可以对 <code>descriptor</code> 进行修改，或者返回一个新的 <code>descriptor</code>。</li><li>我们使用 vue 的 computed API 对 getter 函数进行简单包装。</li></ul><p><br><br><br></p><p>测试一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test(&apos;computed&apos;, () =&gt; &#123;</span><br><span class="line">  const count = ref(0)</span><br><span class="line">  class A &#123;</span><br><span class="line">    @computed</span><br><span class="line">    get double() &#123;</span><br><span class="line">      return count.value * 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const a = new A()</span><br><span class="line">  let value</span><br><span class="line">  watchSyncEffect(() =&gt; &#123;</span><br><span class="line">    value = a.double</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  expect(value).toBe(0)</span><br><span class="line">  count.value++</span><br><span class="line">  expect(value).toBe(2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Ok, 没问题，可以正常运行。我们配合组件的实际场景再测试看看：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test(&apos;render&apos;, () =&gt; &#123;</span><br><span class="line">  class A &#123;</span><br><span class="line">    @observable</span><br><span class="line">    count = 1</span><br><span class="line"></span><br><span class="line">    @computed</span><br><span class="line">    get double() &#123;</span><br><span class="line">      return this.count * 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let count</span><br><span class="line">  const a = new A()</span><br><span class="line"></span><br><span class="line">  const Comp = defineComponent(&#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">      watchSyncEffect(() =&gt; &#123;</span><br><span class="line">        count = a.double</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      return () =&gt; &#123;</span><br><span class="line">        /* ignore */</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  const &#123; unmount &#125; = render(Comp)</span><br><span class="line"></span><br><span class="line">  let count2</span><br><span class="line">  watchSyncEffect(() =&gt; &#123;</span><br><span class="line">    count2 = a.double</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  expect(count).toBe(2)</span><br><span class="line">  expect(count2).toBe(2)</span><br><span class="line"></span><br><span class="line">  a.count++</span><br><span class="line">  expect(count).toBe(4)</span><br><span class="line">  expect(count2).toBe(4)</span><br><span class="line"></span><br><span class="line">  // 🔴 卸载</span><br><span class="line">  unmount()</span><br><span class="line"></span><br><span class="line">  a.count++</span><br><span class="line">  expect(count).toBe(4)</span><br><span class="line">  // 💥 received 4</span><br><span class="line">  expect(count2).toBe(6)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>上面的用例没有通过，<strong>在组件卸载之后，@computed 装饰的 double 就失去了响应性</strong>。Why?</p><p><br><br><br></p><p>解决这个问题之前，我们需要了解一下 <code>[effectScope](https://cn.vuejs.org/api/reactivity-advanced.html#effectscope)</code>, <code>effectScope</code> 创建一个 <code>effect 作用域</code>，可以捕获其中所创建的响应式副作用 (即计算属性和侦听器)，这样捕获到的副作用可以一起处理和销毁。</p><p><br></p><p><strong>Vue <code>setup</code> 就是包装在 effectScope 之下，如果我们的 computed 在 setup 下被初始化，就会被 setup 捕获，当组件卸载时就会被随之清理掉</strong>。</p><p><br></p><p>我们的 <code>@computed</code> 是为全局作用域设计的，不能因为某个组件卸载而被销毁掉。为了解决这个问题，我们需要自己构造一个独立的 <code>悬挂 effectScope</code> (<code>Detached effectScope</code> )：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">const accessor: Initializer = (self) =&gt; &#123;</span><br><span class="line"><span class="addition">+   // true 标记为 detached</span></span><br><span class="line"><span class="addition">+   const scope = effectScope(true)</span></span><br><span class="line"><span class="deletion">-   const value = vueComputed(() =&gt; initialGetter.call(self))</span></span><br><span class="line"><span class="addition">+   const value = scope.run(() =&gt; vueComputed(() =&gt; initialGetter.call(self)))</span></span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        return unref(value)</span><br><span class="line">      &#125;,</span><br><span class="line">      set() &#123;</span><br><span class="line">        // readonly</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>💡 watch 也会有相同的问题，读者可以自行尝试一下</p></blockquote><p><br></p><p>💥 <strong>会不会内存泄露？</strong>理论上会泄露，取决于被 computed 订阅的数据源。如果该订阅源长期未释放，可能会出现内存泄露。<br><br></p><p>解决办法是将对应的<code>类实例</code>和<code>组件</code>的生命周期绑定。当组件释放时，调用类实例的释放方法，例如：</p><p><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const providerStore = &lt;T,&gt;(store: new () =&gt; T): T =&gt; &#123;</span><br><span class="line">  const instance = new store()</span><br><span class="line">  // 将组件的 effectScope 传入实例中进行绑定</span><br><span class="line">  instance.__effect_scope__ = getCurrentScope()</span><br><span class="line">  return instance</span><br><span class="line">&#125;</span><br><span class="line">// computed 实现调整</span><br><span class="line">const scope = target.__effect_scope__ ?? effectScope(true)</span><br><span class="line">// 在 setup 中调用</span><br><span class="line">const store = providerStore(Store)</span><br></pre></td></tr></table></figure><p><br><br>比如 <code>全局Store</code> 可以和 <code>Vue App</code> 绑定，<code>页面 Store</code> 可以和<code>页面组件</code>绑定。<br><br><br>🔴 <strong>MobX computed 并没有该问题，MobX 的 computed 在<code>订阅者</code>清空时，会「<code>挂起</code>(suspend)」，清空自己的<code>订阅</code>(除非显式设置了 keepAlive)，从而可以规避这种内存泄露。详见<a href="https://github.com/mobxjs/mobx/blob/27efa3cc637e3195589874990c23d4de82c12072/packages/mobx/src/core/observable.ts%23L124" target="_blank" rel="noopener">这里</a>。<br>只能看后续 Vue 官方是否也作类似的支持了。</strong></p><p><br><br><br></p><hr><p><br><br><br></p><h2 id="new"><a href="#new" class="headerlink" title="New"></a>New</h2><p>2022/3 装饰器议案正式进入 Stage 3 阶段，按照惯例，Typescript 也在 5.0 版本加入了该功能。</p><p>新版装饰器外形如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Decorator = (</span><br><span class="line">  value: Input,</span><br><span class="line">  context: &#123;</span><br><span class="line">    kind: string</span><br><span class="line">    name: string | symbol</span><br><span class="line">    access: &#123;</span><br><span class="line">      get?(): unknown</span><br><span class="line">      set?(value: unknown): void</span><br><span class="line">    &#125;</span><br><span class="line">    private?: boolean</span><br><span class="line">    static?: boolean</span><br><span class="line">    addInitializer?(initializer: () =&gt; void): void</span><br><span class="line">  &#125;</span><br><span class="line">) =&gt; Output | void</span><br></pre></td></tr></table></figure><p><br></p><p>相比旧版的装饰器，新版的 API 形式上更加统一了，并且提供了一些上下文信息，对于开发者来说更加便利。</p><p><br><br><br></p><p>核心的变化如下：</p><ul><li><p>形式上更加统一，不管是什么位置，都遵循 <code>(value, context) ⇒ output | void</code>， 这个心智上更接近<code>管道(pipe)</code>, 接收一个 Value , 可以返回一个新的 Value 来<strong>替换旧的 Value</strong>。<br><img src="/images/decorator/Untitled%201.png" alt="linux 管道"><br>linux 管道</p><p><br></p></li><li><p><code>context</code> 提供了必要的上下文信息，对开发者来说更加便利，可以快速判断装饰器的类型、是否为静态属性、私有属性等等。</p></li><li><p>更倾向于将装饰器当做一个纯函数(管道、转换器)来使用，尽量不包含副作用(比如修改类的结构)。</p><p><br></p><p><strong>为了限制副作用，装饰器基本上屏蔽了一些底层细节，比如 descriptor，构造函数、原型对象，这些在新的装饰器中基本拿不到。</strong></p><p><br></p><p>副作用只能在 <code>context.addInitializer</code> 中调用，但是能力也非常有限。就拿<code>属性装饰器</code>来举例，initializer 通常在 class 内置的 defineProperty 之前调用，如果你在 <code>initializer</code> 中使用了 <code>defineProperty</code>，那么将被覆盖:</p><p>以 Typescript 的编译结果为例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Bar &#123;</span><br><span class="line">  @d</span><br><span class="line">  foo = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 编译结果：</span><br><span class="line">let Bar = (() =&gt; &#123;</span><br><span class="line">    var _a;</span><br><span class="line">    let _instanceExtraInitializers_1 = [];</span><br><span class="line">    let _foo_decorators;</span><br><span class="line">    let _foo_initializers = [];</span><br><span class="line">    return _a = class Bar &#123;</span><br><span class="line">            constructor() &#123;</span><br><span class="line">                // 🔴 ③ 定义属性</span><br><span class="line">                Object.defineProperty(this, &quot;foo&quot;, &#123;</span><br><span class="line">                    enumerable: true,</span><br><span class="line">                    configurable: true,</span><br><span class="line">                    writable: true,</span><br><span class="line">                    value:</span><br><span class="line">                      // 🔴 ① 先执行其他装饰器的 addInitializer 回调</span><br><span class="line">                      (__runInitializers(this, _instanceExtraInitializers_1),</span><br><span class="line">                        // 🔴 ② 属性装饰器的 initializer</span><br><span class="line">                        __runInitializers(this, _foo_initializers, 1))</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        (() =&gt; &#123;</span><br><span class="line">            _foo_decorators = [d];</span><br><span class="line">            __esDecorate(null, null, _foo_decorators, &#123; kind: &quot;field&quot;, name: &quot;foo&quot;, static: false, private: false, access: &#123; has: obj =&gt; &quot;foo&quot; in obj, get: obj =&gt; obj.foo, set: (obj, value) =&gt; &#123; obj.foo = value; &#125; &#125; &#125;, _foo_initializers, _instanceExtraInitializers_1);</span><br><span class="line">        &#125;)(),</span><br><span class="line">        _a;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><p>这样做的好处，笔者认为主要有以下几点:</p><ul><li>性能优化：旧版的装饰器可以对 class 进行魔改，这就导致了引擎在解析完 Class 体后再去执行装饰器时，最终的 Class 结构可能发生较大的改变，导致引擎的优化无法生效（来源：<a href="https://developer.aliyun.com/article/892441" target="_blank" rel="noopener">ECMAScript 双月报告：装饰器提案进入 Stage 3</a>）。</li><li>因为旧版可能会对类的结构进行破坏性魔改，这种副作用可能导致多个装饰器组合时，有难以预期的问题。</li><li>更容易测试</li></ul><p><br></p><p><strong>另外 Typescript 针对新的装饰器也提供了更严格的类型检查，比如可以约束装饰器使用的位置，旧版可以使用在任意位置，只能通过运行时进行检查</strong>。</p><p><img src="/images/decorator/Untitled%202.png" alt="Typescript 为新版装饰器提供了更严格的类型检查"></p><p>Typescript 为新版装饰器提供了更严格的类型检查</p><p><br></p><blockquote><p>💡  目前装饰器还未成为正式的语言特性，不排除后面还有特性变更。</p></blockquote><p><br></p><blockquote><p>💡  截止至文章发布的时间，Vite 使用新版装饰器还有一些问题。本文使用 Babel + Jest 来测试相关代码。</p></blockquote><p><br><br><br><br><br></p><h3 id="observable-1"><a href="#observable-1" class="headerlink" title="@observable"></a>@observable</h3><p>新版的<code>属性装饰器</code> API 如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type ClassFieldDecorator = (</span><br><span class="line">  value: undefined,</span><br><span class="line">  context: &#123;</span><br><span class="line">    kind: &apos;field&apos;</span><br><span class="line">    name: string | symbol</span><br><span class="line">    access: &#123; get(): unknown; set(value: unknown): void &#125;</span><br><span class="line">    static: boolean</span><br><span class="line">    private: boolean</span><br><span class="line">  &#125;</span><br><span class="line">) =&gt; (initialValue: unknown) =&gt; unknown | void</span><br></pre></td></tr></table></figure><ul><li>value 始终为 undefined，因为属性在类定义时不存在，无法获取到初始值</li><li>context 没有 <code>addInitializer</code> 。属性装饰器的返回值是一个函数，这个实际上就是一个 <code>initializer</code></li><li>访问不到类和类的原型</li><li>在 initializer 中也不能调用 defineProperty。原因见上文</li></ul><p>也就是说，<strong>属性装饰器基本上堵死了我们去改造属性的机会</strong>…</p><p><br><br><br></p><hr><p><br></p><p>且慢，跟随装饰器发布的还有一个<code>自动访问器</code>(Auto Accessor)的特性(🙂  越来越像 Java、C# 了）</p><p>自动访问器使用 <code>accessor</code> 关键字定义：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">  accessor x = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">  #x = 1</span><br><span class="line"></span><br><span class="line">  get x() &#123;</span><br><span class="line">    return this.#x</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set x(val) &#123;</span><br><span class="line">    this.#x = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这有啥用？稍安勿躁，它在装饰器场景有大用，先来看下它的 API:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type ClassAutoAccessorDecorator = (</span><br><span class="line">  value: &#123;</span><br><span class="line">    get: () =&gt; unknown;</span><br><span class="line">    set(value: unknown) =&gt; void;</span><br><span class="line">  &#125;,</span><br><span class="line">  context: &#123;</span><br><span class="line">    kind: &quot;accessor&quot;;</span><br><span class="line">    name: string | symbol;</span><br><span class="line">    access: &#123; get(): unknown, set(value: unknown): void &#125;;</span><br><span class="line">    static: boolean;</span><br><span class="line">    private: boolean;</span><br><span class="line">    addInitializer(initializer: () =&gt; void): void;</span><br><span class="line">  &#125;</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  get?: () =&gt; unknown;</span><br><span class="line">  set?: (value: unknown) =&gt; void;</span><br><span class="line">  init?: (initialValue: unknown) =&gt; unknown;</span><br><span class="line">&#125; | void;</span><br></pre></td></tr></table></figure><ul><li>value 接收 getter 和 setter</li><li>可以返回新的 getter 和 setter</li><li>init 可以对初始值进行<strong>_转换_</strong>。</li></ul><p><br><br><br></p><p>它的妙用在于，我们可以「兵不血刃」(不改变结构或者新增属性)地实现拦截，看看我们 observable 的实现就知道了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function observable&lt;This, Value&gt;(</span><br><span class="line">  value: ClassAccessorDecoratorTarget&lt;This, Value&gt;,</span><br><span class="line">  context: ClassAccessorDecoratorContext&lt;This, Value&gt;</span><br><span class="line">): ClassAccessorDecoratorResult&lt;This, Value&gt; | void &#123;</span><br><span class="line">  if (context.kind !== &apos;accessor&apos;) &#123;</span><br><span class="line">    throw new Error(&apos;observable can only be used on accessor&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (context.static) &#123;</span><br><span class="line">    throw new Error(&apos;observable can not be used on static accessor&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    init(val) &#123;</span><br><span class="line">      return ref(val)</span><br><span class="line">    &#125;</span><br><span class="line">    get() &#123;</span><br><span class="line">      return (value.get.call(this) as Ref&lt;Value&gt;).value</span><br><span class="line">    &#125;,</span><br><span class="line">    set(val) &#123;</span><br><span class="line">      const ref = value.get.call(this) as Ref&lt;Value&gt;</span><br><span class="line"></span><br><span class="line">      ref.value = val</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>通过 <code>context</code>，我们可以更方便地判断是否是静态成员、是否装饰在预期的位置</li><li>上述代码我们没有修改任何类的结构、新增任何属性。我们直接在 init 中将初始值转换为 ref, 相对应的 getter/setter 也作简单的改造。</li></ul><p><br></p><p>很简单是不是？只不过，这个对已有的代码倾入性太大了，所有相关的属性都需要修改为 <code>accessor</code>, 但对于 API 使用者来说没什么区别：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  @observable</span><br><span class="line">  accessor obj = &#123;</span><br><span class="line">    count: 1,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="computed-1"><a href="#computed-1" class="headerlink" title="@computed"></a>@computed</h3><p>Getter 装饰器和 Setter、Method 装饰器类型基本一致：</p><p><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type ClassGetterDecorator = (</span><br><span class="line">  value: Function,</span><br><span class="line">  context: &#123;</span><br><span class="line">    kind: &apos;getter&apos;</span><br><span class="line">    name: string | symbol</span><br><span class="line">    access: &#123; get(): unknown &#125;</span><br><span class="line">    static: boolean</span><br><span class="line">    private: boolean</span><br><span class="line">    addInitializer(initializer: () =&gt; void): void</span><br><span class="line">  &#125;</span><br><span class="line">) =&gt; Function | void</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>直接来看 computed 实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function computed&lt;This, Return, Value extends () =&gt; Return&gt;(</span><br><span class="line">  value: Value,</span><br><span class="line">  context: ClassGetterDecoratorContext&lt;This, Return&gt;</span><br><span class="line">): Value | void &#123;</span><br><span class="line">  if (context.static) &#123;</span><br><span class="line">    throw new Error(&apos;computed cannot be used on static member&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (context.kind !== &apos;getter&apos;) &#123;</span><br><span class="line">    throw new Error(&apos;computed can only be used on getter&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  context.addInitializer(function (this: unknown) &#123;</span><br><span class="line">    const scope = effectScope(true)</span><br><span class="line"></span><br><span class="line">    const val = scope.run(() =&gt; vueComputed(() =&gt; value.call(this)))</span><br><span class="line"></span><br><span class="line">    Object.defineProperty(this, context.name, &#123;</span><br><span class="line">      configurable: true,</span><br><span class="line">      enumerable: false,</span><br><span class="line">      get() &#123;</span><br><span class="line">        return unref(val)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>通过 <code>addInitializer</code> 来添加初始化逻辑(副作用)， this 为当前类的实例。旧版的装饰器并没有提供类似的时机，我们只能通过<code>惰性初始化</code>去模拟这种效果。</p><p><br></p><p>不过上面的程序也有个潜在的 BUG, 我们在新建一个 log 装饰器，组合在一起看看：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function log(value: Function, context: ClassGetterDecoratorContext) &#123;</span><br><span class="line">  return function (this: unknown) &#123;</span><br><span class="line">    console.log(&apos;start calling...&apos;)</span><br><span class="line">    return value.apply(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">  @observable</span><br><span class="line">  accessor count = 1</span><br><span class="line"></span><br><span class="line">  @log</span><br><span class="line">  @computed</span><br><span class="line">  get double() &#123;</span><br><span class="line">    return this.count * 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，我们会发现并没有打印 <code>start calling...</code> 邪恶的副作用…</p><p><br><br><br></p><p>主要原因是上述代码我们在 <code>addInitializer</code> 中引用的 ‘value’ 是类原始的 getter 值，而我们又重新用 defineProperty 覆盖了属性，导致 @log 装饰的值丢失了。</p><p><br></p><p>实际上在新版的装饰器中，更符合规范的用法是：<strong>返回新的值来替换旧的值</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const COMPUTED_CACHE: unique symbol = Symbol(&apos;computed_cache&apos;)</span><br><span class="line"></span><br><span class="line">export function computed&lt;This, Return, Value extends () =&gt; Return&gt;(</span><br><span class="line">  value: Value,</span><br><span class="line">  context: ClassGetterDecoratorContext&lt;This, Return&gt;</span><br><span class="line">): Value | void &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  // 🔴 初始化缓存对象</span><br><span class="line">  context.addInitializer(function (this: unknown) &#123;</span><br><span class="line">    if (!Object.prototype.hasOwnProperty.call(this, COMPUTED_CACHE)) &#123;</span><br><span class="line">      Object.defineProperty(this, COMPUTED_CACHE, &#123;</span><br><span class="line">        configurable: true,</span><br><span class="line">        enumerable: false,</span><br><span class="line">        value: new Map(),</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return function (this: Object) &#123;</span><br><span class="line">    const cache = this[COMPUTED_CACHE] as Map&lt;string | symbol, Ref&lt;Return&gt;&gt;</span><br><span class="line">    if (!cache.has(context.name)) &#123;</span><br><span class="line">      // 🔴 惰性初始化</span><br><span class="line">      const scope = effectScope(true)</span><br><span class="line"></span><br><span class="line">      const val = scope.run(() =&gt; vueComputed(() =&gt; value.call(this)))!</span><br><span class="line"></span><br><span class="line">      cache.set(context.name, val)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return unref(cache.get(context.name))</span><br><span class="line">  &#125; as Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>上面的代码中，我们返回的新的函数来取代原有的 <code>getter</code>，另外在 <code>addInitializer</code> 中初始化缓存属性。我们建议在 <code>addInitializer</code> 中一次性将需要的属性都初始化完毕，避免在 getter 中动态去添加新的属性，<a href="https://mathiasbynens.be/notes/shapes-ics" target="_blank" rel="noopener">利好 JavaScript 引擎的优化</a>。</p><p><br></p><p>这样做的好处是更符合新版装饰器的心智和设计意图，也可以保证装饰器按照组合的顺序调用。</p><p><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要详细对比了新版和旧版的装饰器差异，通过实战将装饰器的能力和陷阱挖掘出来。</p><p><br></p><p>总得来说，新版的装饰器更加统一直观、更容易入手，在能力上也克制地收敛了。不过目前社区上大量的库和框架还停留在 Stage 1 装饰器，升级和改造需要较大的成本，我们可以暂时观望观望。</p><p><br></p><p>下一步：装饰器比较复杂的应用是依赖注入，当前的依赖注入库都深度依赖 <code>reflect-metadata</code> 来实现。而 <a href="https://github.com/tc39/proposal-decorator-metadata?spm=a2c6h.12873639.article-detail.8.68bd13c4Dt6Qt7" target="_blank" rel="noopener">Decorator Metadata</a> 目前也进入了 Stage 3 阶段，很快就会和我们见面(Typescript 5.2)，届时我们再聊聊如何实现依赖注入(🐶 看你们的点赞)。</p><p><br><br><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><strong><a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noopener">proposal-decorators</a></strong></li><li><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html" target="_blank" rel="noopener">Typescript 5.0</a> 发布日志</li><li><a href="https://mp.weixin.qq.com/s/QnWez2sEWuL8j8GVDmBNTA" target="_blank" rel="noopener">TypeScript 5.0 将支持全新的装饰器写法！</a></li><li><a href="https://developer.aliyun.com/article/892441" target="_blank" rel="noopener">ECMAScript 双月报告：装饰器提案进入 Stage 3</a></li><li><a href="https://cn.vitejs.dev/guide/features.html#usedefineforclassfields" target="_blank" rel="noopener">vite typescript <code>useDefineForClassFields</code></a></li><li><a href="https://babeljs.io/docs/babel-plugin-proposal-decorators" target="_blank" rel="noopener">@babel/plugin-proposal-decorators</a></li><li>Javascript 引擎优化机制:<ul><li><a href="https://mathiasbynens.be/notes/shapes-ics" target="_blank" rel="noopener">JavaScript engine fundamentals: Shapes and Inline Caches</a></li><li><a href="https://mathiasbynens.be/notes/prototypes" target="_blank" rel="noopener">JavaScript engine fundamentals: optimizing prototypes</a></li></ul></li><li><a href="https://cn.mobx.js.org/refguide/action.html" target="_blank" rel="noopener">MobX</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/decorator/Untitled.jpeg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;去年三月份&lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的快乐与苦恼</title>
    <link href="https://bobi.ink/2023/06/21/happiness/"/>
    <id>https://bobi.ink/2023/06/21/happiness/</id>
    <published>2023-06-20T16:00:00.000Z</published>
    <updated>2023-06-21T10:28:32.450Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/happiness/Untitled.jpeg" alt="Universe"></p><blockquote><p>“<strong>我们朝九晚五上班下班，就是为了有朝一日去探索宇宙的</strong>”<br>    —— 宇宙探索编辑部</p></blockquote><p>随着大环境的下行，互联网行业也受到一定的冲击，哀鸿遍野。</p><p>笔者也没有幸免，培养起来的人马陆续被优化，留下一丢光杆司令，我也回到的业务一线，心里很不是滋味。留下来的人，也不知道这艘船什么时候会沉没… 为了活命而拼命挣扎（内卷）</p><p>负面情绪和焦虑不停侵扰，以至于怀疑，当初选的这条路是不是正确的。</p><p>捡起买了多年，但是一直没看的<code>《人月神话》</code>,  开篇就讲了程序员这个职业的乐趣和苦恼，颇有共鸣，所以拿出来给大家分享</p><p>不管过去多少年，不管你的程序载体是纸带、还是 JavaScript，不管程序跑在高对比(high contract)的终端、还是 iPhone，程序员的快乐和烦恼并没有变化。</p><p>尽管国内软件行业看起来不是那么健康。我相信很多人真正热爱的是编程，而不仅仅是一份工作，就是那种纯粹的热爱。你有没有：</p><ul><li>为了修改一个 Bug，茶饭不思</li><li>为了一个 idea，可以凌晨爬起来，决战到天亮</li><li>我们享受没有人打扰的午后</li><li>梦想着参与到一个伟大的开源项目</li><li>有强烈的分享欲，希望我们的作品可以帮助到更多人, 希望能得到用户的反馈，即使是一个点赞</li><li>…</li></ul><p><br><br><br></p><h2 id="我们的快乐"><a href="#我们的快乐" class="headerlink" title="我们的快乐"></a>我们的快乐</h2><blockquote><p>《人月神话》：</p><p>首先，<strong>这种快乐是一种创建事物的纯粹快乐</strong>。如同小孩在玩泥巴时感到快乐一样，成年人喜欢创建事物，特别是自己进行设计。我想这种快乐是上帝创造世界的折射，一种呈现在每片独特的、崭新的树叶和雪花上的喜悦。<br><br><br>其次，<strong>这种快乐来自于开发对他人有用的东西</strong>。内心深处，我们期望我们的劳动成果能够被他人使用，并能对他们有所帮助。从这一角度而言，这同小孩用粘士为“爸爸的办公室”捏制铅笔盒没有任何本质的区别。<br><br><br>第三，<strong>快乐来自于整个过程体现出的一股强大的魅力——将相互啮合的零部件组装在一起，看到它们以精妙的方式运行着，并收到了预期的效果。</strong>比起弹球游戏机或自动电唱机所具有的迷人魅力，程序化的计算机毫不逊色。<br><br><br>第四，<strong>这种快乐是持续学习的快乐，它来自于这项工作的非重复特性</strong>。人们所面临的问题总有这样那样的不同，因而解决问题的人可以从中学习新的事物，有时是实践上的，有时是理论上的，或者兼而有之。<br><br><br>最后，<strong>这种快乐还来自于在易于驾驭的介质上工作</strong>。程序员，就像诗人一样，几乎仅仅在单纯的思考中工作。程序员凭空地运用自己的想象，来建造自己的“城堡”。很少有创造介质如此灵活，如此易于精炼和重建，如此容易实现概念上的设想(不过我们将会看到，容易驾驭的特性也有它自己的问题)。<br><br><br>然而程序毕竞同诗歌不同，它是实实在在的东西;它可以移动和运行，能独立产生可见的输出;它能打印结果，绘制图形，发出声音，移动支架。神话和传说中的魔术在我们的时代已变成现实。在键盘上键入正确的咒语，屏幕会活动、变幻，显示出前所未有的也不可能存在的事物。</p></blockquote><p><br></p><p>编程就是一种纯粹创造的快乐，而且它的成本很低，我们只需要一台电脑，一个趁手的编辑器，一段不被人打扰的整块时间，然后进入心流状态，脑海中的想法转换成屏幕上闪烁的字符。<br>这是多巴胺带给我们的快乐。</p><p><img src="/images/happiness/Untitled.png" alt="飞机引擎"></p><p><br><br><br></p><p>我们也有「<code>机械崇拜</code>」，软件不亚于传统的机械的复杂构造。 它远比外界想象的要复杂和苛刻，而我们享受将无数零部件有机组合起来，点击——成功运行的快感。</p><p>我们享受复杂的问题，被抽象、拆解成一个个简单的问题， 认真描绘分层的弧线以及每个模块轮廓，谨慎设计它的每个锯齿和接口。</p><p>我们崇尚有序，赞赏清晰的边界， 为的就是我们创造的世界能够稳定发展。</p><p><br></p><p>我们认为懒惰是我们的优点，我们也崇拜自动化，享受我们数据通过我们建设的管道在不同模块、系统或者机器中传递和加工；享受程序像多米诺骨牌一样，自动构建、测试、发布、部署、分发到每个用户的手中，优雅地跑起来。</p><p>因为懒，我们时常追求创造出能够取代自己的工具，让我们能腾出时间在新的世界探索。比如可以制造出我们的 <a href="https://baike.baidu.com/item/MOSS/23288071?fr=aladdin" target="_blank" rel="noopener">Moss</a>，帮我们治理让每个程序的生命周期，让它们优雅地死去又重生。</p><p><br></p><p>我们是一群乐于分享和学习的群体，有繁荣的技术社区、各种技术大会、技术群…</p><p>不管是分享还是编程本身，其实都是希望我们的作品能被其他人用到，能产生价值：</p><ul><li>我们都有开源梦，多少人梦想着能参与那些广为人知开源项目。很少有哪个行业，有这么一群人,  能够自我组织，用爱发电、完全透明地做出一个个伟大的作品。</li><li>我们总会怀揣着乐观的设想，基于这种设想，我们会趋向打造更完美的作品，想象未来各种高并发、极端的场景，我们的程序能够游刃有余。</li><li>我们总是不满足于现有的东西，乐于不停地改进，造出更多的轮子，甚至不惜代价推翻重来</li><li>我们更会懊恼，自己投入大量精力的项目，无人问津，甚至胎死腹中。</li></ul><p><br></p><p>看着它们，从简单到繁杂，这是一种迭代的快乐。</p><p><br><br><br><br><br></p><h2 id="我们的苦恼"><a href="#我们的苦恼" class="headerlink" title="我们的苦恼"></a>我们的苦恼</h2><blockquote><p>《人月神话》<br>然而这个过程并不全都是快乐的。我们只有事先了解一些编程固有的苦恼，这样，当它们真的出现时，才能更加坦然地面对。<br><br><br>首先，<strong>苦恼来自追求完美</strong>。因为计算机是以这样的方式来变戏法的: 如果咒语中的一个字符、一个停顿，没有与正确的形式一致，魔术就不会出现(现实中，很少有人类活动会要求如此完美，所以人类对它本来就不习惯)。实际上，我认为，学习编程最困难的部分，是将做事的方式向追求完美的方向调整”。</p><p><br><br>其次，<strong>苦恼来自由他人来设定目标、供给资源和提供信息</strong>。编程人员很少能控制工作环境和工作目标。用管理的术语来说，个人的权威和他所承担的责任是不相配的。不过，似乎在所有的领域中，对要完成的工作，很少能提供与责任相一致的正式权威。而现实情况中，实际(相对于形式)的权威来自于每次任务的完成。</p><p><strong>对于系统编程人员而言，对其他人的依赖是一件非常痛苦的事情</strong>。他依靠其他人的程序，而这些程序往往设计得并不合理、实现拙劣、发布不完整(没有源代码或测试用例)或者文档记录得很糟。所以，系统编程人员不得不花费时间去研究和修改，而它们在理想情况下本应该是可拿的、完整的。</p><p><br><br>下一个苦恼 —— <strong>概念性设计是有趣的，但寻找琐碎的bug却是一项重复性的活动</strong>。伴随着创造性活动的，往往是枯燥沉闷的时间和艰苦的劳动。程序编制工作也不例外。</p><p><br><br>另<strong>外，人们发现调试和查错往往是线性收敛的，或者更糟糕的是，具有二次方的复杂度</strong>。结果，测试一拖再拖，寻找最后一个错误比第一个错误将花费更多的时间。</p><p><br><br>最后一个苦恼，有时也是一种无奈 —— <strong>当投入了大量辛苦的劳动，产品在即将完成或者终于完成的时候，却己显得陈旧过时</strong>。可能是同事和竞争对手己在追逐新的、更好的构思;也许替代方案不仅仅是在构思，而且己经在安排了。<br><br></p></blockquote><p>前阵子读到了 @<a href="https://www.zhihu.com/people/doodlewind" target="_blank" rel="noopener">doodlewind</a> 的 <a href="https://zhuanlan.zhihu.com/p/595759878" target="_blank" rel="noopener">全职开源，出海创业：我的 2022</a>，说的是他 all in 去做 AFFiNE 。我眼里只有羡慕啊，能够找到 all in 的事业…</p><p><br><br><br></p><p>这些年 OKR 也很火，我们公司也跟风了一年; 后面又回到了 KPI，轰轰烈烈搞全员KPI, 抓着每个人,  要定自己的全年KPI;  后年裁员，KPI 就不再提起了…</p><p>这三个阶段的演变很有意思，第一个阶段，期望通过 OKR 上下打通，将目标捆在一起，让团队自己驱动自己。实际上实施起来很难，让团队和个人自我驱动起来并不是一件容易的事情，虽然用的是 OKR，但内核还是 KPI，或者说 OKR 变成了领导的 OKR。<br>后面就变成了 KPI, 限定团队要承担多少销售额，交付多少项目；<br>再后来 KPI 都没有了，换成要求每个人设定自己工作日历，不能空转，哪里项目缺资源，就调配到哪里，彻底沦为了人矿…</p><p>能让我们 all in 的事情，首先得是我们认同的事情，其次我们能在这件事情上深度参与和发挥价值，并获得预期的回报。这才能实现「自我驱动」</p><p>对于大部分人来说，很少有这种工作机会，唯一值得 all in的，恐怕就只有自己了。</p><p><br><br><br></p><p>所以程序员的苦恼很多，虽然编程是一个创造性的工作，但是我们的工作是由其他人来设定目标和提供资源的。</p><p>也就是说我们只不过是困在敏捷循环里面的一颗螺丝钉，每天在早会上机械复读着：昨天干了什么，今天要干什么。<br>企业总会想法设法量化我们的工作，最好是像流水线一样透明、可预测。</p><p><br></p><p>培训机构四个月就能将高中生打造成可以上岗敲代码的程序员。我们这个行业已经不存在我们想象中高门槛。程序员可能就是新时代的蓝领工人，如果我们的工作是重复的、可预见的，那本质上就没什么区别了。</p><hr><p><br></p><p>追求完美是好事，也是坏事。苛刻的编译器会提高开发的门槛，但同样可以降低我们犯错的概率。</p><p>计算机几乎不会犯错的，只是我们不懂它，而人经常会犯错。相比苛刻的计算机，人更加可怕：</p><ul><li>应付领导或产品拍脑袋的需求</li><li>接手屎山代码</li><li>浪费时间的会议</li><li>狼性文化</li><li>…</li></ul><p><br><br><br></p><hr><p><br></p><p>还有一个苦恼是技术的发展实在太快了，时尚的项目生命周期太短，而程序员又是一群喜新厌旧的群体。</p><p>比如在前端，可能两三年前的项目就可以被定义为”老古董”了，上下文切换到这种项目会比较痛苦。不幸的是，这些老古董可能会因为某些程序员的偏见，出现破窗效应，慢慢沦为屎山。</p><p>我们虽然苦恼于项目的腐败，而大多数情况我们也是推手。</p><p><br></p><p>我们还有很多苦恼：</p><ul><li>35 岁危机，继续做技术还是转管理</li><li>面试的八股文</li><li>内卷</li><li>被 AI 取代</li><li>…</li></ul><p><br><br><br></p><p>对于读者来说，是快乐多一些呢？还是苦恼多一些呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/happiness/Untitled.jpeg&quot; alt=&quot;Universe&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“&lt;strong&gt;我们朝九晚五上班下班，就是为了有朝一日去探索宇宙的&lt;/strong&gt;”&lt;br&gt;    —— 宇宙探
      
    
    </summary>
    
      <category term="程序人生" scheme="https://bobi.ink/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>前端如何破解 CRUD 的循环</title>
    <link href="https://bobi.ink/2023/06/16/crud/"/>
    <id>https://bobi.ink/2023/06/16/crud/</id>
    <published>2023-06-15T16:00:00.000Z</published>
    <updated>2023-06-16T02:05:00.408Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/crud/Untitled.jpeg" alt="Untitled"></p><p>据说，西西弗斯是一个非常聪明的国王，但他也非常自负和狂妄。他甚至敢欺骗神灵，并把死者带回人间。为此，他被宙斯（Zeus）惩罚，被迫每天推着一块巨石上山，但在接近山顶时，巨石总是会滚落下来，他不得不重新开始推石头，永远困在这个循环中…</p><p>很多开发工作也如此单调而乏味，比如今天要讲的中后台开发的场景。中后台业务基本上就是一些数据的增删改查、图表，技术含量不高，比较容易范式化。</p><p>前端如何破除 CRUD 的单调循环呢？</p><p><br><br><br><br><br></p><h2 id="低代码"><a href="#低代码" class="headerlink" title="低代码"></a>低代码</h2><p>过去几年前端的低代码很火，这些<code>低代码平台</code>通常支持创建<code>数据模型</code>后，一键生成对应的增删改查页面：</p><p><br></p><p><img src="/images/crud/Untitled.png" alt="Untitled"></p><p><br></p><aside><br>💡 本文提及的低代码是<code>狭义</code>的<code>低代码</code>，你可以认为就是<code>可视化搭建平台</code>。<br><br></aside><p><br></p><p>低代码在过去几年就是 「雷声大，雨点小」，跟现在的 AI 颇为相似。</p><p>不管是大厂还是小厂都在搞低代码，包括笔者也参与过几个低代码项目，但是小厂支撑不起来这样的资源投入，最后都胎死腹中。我相信很多读者也经历过这种情况。<br>大部分公司只是尾随市场营销噱头，盲目跟风，压根就没有做这种低代码平台资源准备和沉淀。</p><p>作为前端，能参与到低代码项目的开发是一件非常兴奋的事情，毕竟是少数前端能主导的项目，架构、组件设计、编辑器的实现可玩性很高，可以跟同行吹很久。</p><p>作为用户(开发者)呢？可能会<a href="https://www.zhihu.com/question/561025857" target="_blank" rel="noopener">排斥和质疑</a>，不管怎么说，它并没有发挥市场所期望的价值。</p><p><br></p><p>最主要的原因是：<strong>它解决不了复杂的问题</strong>。</p><p><br></p><p>低代码直观、门槛低， 前期开发确实很爽，可视化数据建模、拖拉拽生成页面、流程编排，很快就可以把一些简单的业务开发出来。</p><p>然而软件编码本身占用研发流程的比例，据 <code>ChatGPT</code> 估算大约只有 20% ~ 30%。而且业务持续变化，代码也需要持续迭代。试想一下如何在这些低代码平台上进行重构和检索？</p><p><br><br><br></p><p>总的来说，有一些缺点：</p><ul><li><p><strong>复杂的业务逻辑用低代码可能会更加复杂。</strong>低代码应该是特定领域问题的简化和抽象，如果只是单纯将原有的编码工作转换为 GUI 的模式，并没有多大意义。</p><p>  例如流程编排，若要用它从零搭建一个复杂的流程，如果照搬<code>技术语言</code>去表达它，那有可能是个地狱：</p><p>  <img src="/images/crud/Untitled%201.png" alt="Untitled"></p><p>  理想的<strong>流程编排的节点应该是抽象程度更高的、内聚的<code>业务节点</code>，来表达<code>业务流程</code>的流转。然而</strong>这些节点的设计和开发其实是一件非常有挑战性的事情。</p></li><li><p><strong>软件工程是持续演进的，在可维护性方面，目前市面上的低代码平台并不能提供可靠的辅助和验证。</strong>因此企业很难将核心的稳态业务交给这些平台。</p></li><li>还有很多… 平台锁定，缺乏标准，性能问题、复用、扩展性、安全问题、黑盒，可迁移性，研发成本高，可预测性/可调试性差，高可用，版本管理，不能自动化…</li></ul><p><br><br><br></p><p>当然，低代码有低代码的适用场景，比如解决特定领域问题(营销活动页面，海报，数据大屏，表单引擎、商城装修、主页)，POC 验证。<strong>即一些临时的/非核心的敏态业务</strong>。</p><aside><br>💡 目前有些低代码平台也有「出码能力」，让二开有了一定的可行性。<br><br></aside><aside><br>💡 AI 增强后的低代码可能会更加强大。但笔者依旧保持观望的态度，毕竟准确地描述软件需求，本身就是就是软件研发的难题之一，不然我们也不需要 DDD中的各种方法论，开各种拉通会，或许也不需要需求分析师，产品…<br><br>非专业用户直接描述需求来产出软件，大多是不切实际的臆想<br></aside><p><br><br><br><br><br></p><h2 id="中间形态"><a href="#中间形态" class="headerlink" title="中间形态"></a>中间形态</h2><p>有没有介于可视化低代码平台和专业代码之间的中间形态？既能保持像低代码平台易用性，同时维持代码的灵活性和可维护性。</p><p>我想那就是 DSL(<code>domain-specific language</code>) 吧? <strong>DSL 背后体现的是对特定领域问题的抽象，其形式和语法倒是次要的。</strong></p><aside><br>💡 DSL 的形式有很多，可以创建一门新的微语言(比如 SQL, GraphQL)；可以是一个 JSON 或者 YAML 形式；也可以基于一门现有的<code>元语言</code>(比如 Ruby、Groovy，Rust…)来创建，这些元语言，提供的元编程能力，可以简洁优雅地表达领域问题，同时能够复用<code>元语言</code> 本身的语言能力和基础设施。<br><br></aside><p><strong>严格上可视化低代码平台也是一种‘可视化’ 的 DSL，笔者认为它的局限性更多还是来源‘可视化’，相对的，它优点也大多来源’可视化‘</strong>。</p><blockquote><p>这又牵扯到了持续了半个多世纪的： GUI vs CLI（程序化/文本化） 之争。这个在《UNIX 编程艺术》中有深入的探讨。命令行和命令语言比起可视化接口来说，更具表达力，尤其是针对复杂的任务。另外命令行接口具有高度脚本化的能力。缺点就是需要费劲地记忆，易用性差，透明度低。当问题规模变大、程序的行为日趋单一、过程化和重复时， CLI 也常能发挥作用。<br><br><br>如果按照<code>友好度</code>和问题域的<code>复杂度/规模</code>两个维度来划分，可以拉出以下曲线：<br><br><br><img src="/images/crud/Untitled%202.png" alt="Untitled"></p><p>中间会出现一个交叉点，在这个交叉点之后，命令行的简要行和表达力变得要比避免记忆负担更有价值。</p><p>《反 Mac 接口》一书中也进行了总结：可视化接口在处理小数量物体简单行为的情况下，工作的很好，但是当行为或物体的数量增加是，直接操作很快就编程机械重复的苦差…</p></blockquote><p><strong>也就是说，DSL 的形式会约束 DSL 本身的表达能力。</strong></p><p><br></p><p>正如前文说的，如果‘低代码’仅仅是将原本的编码工作转换为 GUI 形式，其实并没有多大意义，因为没有抽象。</p><p>反例：</p><p><img src="/images/crud/Untitled%203.png" alt="JSON GUI vs  JSON"></p><p>JSON GUI vs JSON</p><p><br><br><br></p><p>正例： VSCode 案例</p><p><img src="/images/crud/Untitled%204.png" alt="Untitled"></p><p><img src="/images/crud/Untitled%205.png" alt="Untitled"></p><p>充分利用 GUI 的优势，提供更好的目录组织、文本提示、数据录入的约束和校验。</p><p><br><br><br></p><p>我们可能会说 GUI 形式用户体验更好，门槛低更低，不用关心底层的细节。<strong>其实并不一定是 GUI 带来的，而是抽象后的结果。GUI 只不过是一种接口形式</strong>。</p><p><br></p><p>回到正题，为了摆脱管理后台 CRUD 的 「西西弗斯之石」： 我们可以创建一个 DSL，这个 DSL 抽象了管理端的各种场景，将繁琐的实现细节、重复的工作封装起来，暴露简洁而优雅的用户接口(User Interface)。</p><aside><br>💡 小结。DSL 是可视化低代码与 pro code 之间的中间中间形态，权衡了易用性/灵活性和实现成本。DSL 的形式会直接影响它的表达能力，但比形式更重要的是 DSL 对特定问题域的抽象。<br><br>我们不必重新发明一门语言，而是复用元语言的能力和生态，这基本上是零成本。<br></aside><p><br><br><br><br><br><br><br></p><h2 id="抽象过程"><a href="#抽象过程" class="headerlink" title="抽象过程"></a>抽象过程</h2><p>典型的增删改查页面：</p><p><img src="/images/crud/Untitled%206.png" alt="Untitled"></p><p>分析过程：</p><ol><li>后端增删改查主要由两大组件组成: <code>表单</code>和<code>表格</code>。</li><li>而表单和表格又由更原子的’<code>字段</code>’组成。字段的类型决定了存储类型、录入方式、和展示方式</li><li>字段有两种形态：<code>编辑态</code>和<code>预览态</code>。表格列、详情页通常是预览态，而表单和表格筛选则使用编辑态。</li></ol><p><br></p><p><img src="/images/crud/Untitled%207.png" alt="Untitled"></p><p>借鉴低代码平台的<code>组件库</code>/<code>节点库</code>，我们可以将这些‘字段’ 提取出来， 作为表单和表格的‘原子’单位， 这里我们给它取个名字，就叫<code>原件</code>(<code>Atomic</code>)吧。</p><p><img src="/images/crud/Untitled%208.png" alt="Untitled"></p><p><code>原件</code>将取代组件库里面的<code>表单组件</code>，作为我们 <code>CRUD</code> 页面的<strong>最小组成单位</strong>。它有且只有职责：</p><p><img src="/images/crud/Untitled%209.png" alt="Untitled"></p><ul><li>数据类型和校验。原件代表的是一种数据类型，可以是<code>基础类型</code>，比如数字、字符串、布尔值、枚举；也可以是基础类型上加了一些约束和交互，比如邮件、手机号码、链接；甚至可能有<code>业务属性</code>，比如用户，商品，订单，二维码。</li><li>数据的预览。</li><li>数据的录入，严格约束为 <code>value</code>/<code>onChange</code> 协议。好处是方便进行状态管理，可能保证原件实现的统一性。</li></ul><p><br><br><br></p><p>接着组合原件来实现表单和表格组件，满足 CRUD 场景：</p><p><img src="/images/crud/Untitled%2010.png" alt="Untitled"></p><p>理想状态下，我们仅需声明式地指定表格的列和原件类型，其余的技术细节应该隐藏起来。表格伪代码示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建包含 名称、创建时间、状态三列的表格，其中可以搜索名称和创建时间</span></span><br><span class="line">Table(</span><br><span class="line">  columns(</span><br><span class="line">    column(名称，name, queryable=<span class="literal">true</span>)</span><br><span class="line">    column(创建时间, created, data-range, queryable=<span class="literal">true</span>)</span><br><span class="line">    column(状态, status, select, options=[&#123;label: 启用，value: 1, &#123;label: 禁用， value: 0&#125;&#125;])</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br></p><p>表单伪代码示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建包含 名称、状态、地址的表单</span></span><br><span class="line">Form(</span><br><span class="line">  item(名称，name, required=<span class="literal">true</span>)</span><br><span class="line">  item(状态，status, select, options=[&#123;label: 启用，value: 1, &#123;label: 禁用， value: 0&#125;&#125;])</span><br><span class="line">  item(地址, address, address)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br></p><p>如上所示，本质上，开发者就应该只关注业务数据本身，而应该忽略掉前端技术实现的噪音(比如状态管理、展示风格、分页、异常处理等等)。</p><p><br><br><br></p><p>表格和表单为了适应不同的需求，还会衍生出不同的展现形式：</p><p><img src="/images/crud/Untitled%2011.png" alt="Untitled"></p><p><code>原件</code> + <code>核心的表单/表格能力</code> + <code>场景/展示形式</code>，一套「组合拳」下来，基本就可以满足常见的后台 CRUD 需求了。</p><p><br><br><br><br><br></p><h2 id="约定大于配置"><a href="#约定大于配置" class="headerlink" title="约定大于配置"></a>约定大于配置</h2><p>前端的在研发流程中相对下游，如果上游的产品定义，UI 设计，后端协议没有保持一致性，就会苦于应付各种混乱的差异，复用性将无从谈起。</p><p>为了最小化样板代码和沟通成本，实现开箱即用的效果。我们最好拉通上下游，将相关的规范确定下来，前端开发者应该扮演好串联的角色。</p><p><br></p><p>这些规范包含但不限于：</p><ul><li>页面的布局</li><li>UI 风格</li><li>提示语</li><li>验证规则</li><li>数据的存储格式</li><li>通用的接口(比如文件上传，导入导出)</li><li>…</li></ul><p><img src="/images/crud/Untitled%2012.png" alt="Untitled"></p><p>组件库可以内置这些约定，或者提供全局的配置方式。这些规范固化后，我们就享受开箱即用的快感了。</p><p><br><br><br><br><br></p><h2 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h2><p>基于上述思想，我们开发了一套<a href="https://wakeadmin.wakedata.com/components-doc/" target="_blank" rel="noopener">组件库</a>(基于 Vue 和 element-ui)，配合一套简洁的 DSL，来快速开发 CRUD 页面。</p><p><br></p><aside><br>💡 <strong><em>这套组件库耦合了我们自己的约定</em></strong>。因此可能不适用于外部通用的场景。本文的意义更多是想启发读者，去构建适合自己的一套解决方案。<br><br></aside><p><strong>列表页定义：</strong></p><p><img src="/images/crud/Untitled%2013.png" alt="Untitled"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; defineFatTable &#125; from &apos;@wakeadmin/components&apos;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 表格项类型</span><br><span class="line"> */</span><br><span class="line">export interface Item &#123;</span><br><span class="line">  id: number</span><br><span class="line">  name: string</span><br><span class="line">  createDate: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const MyTable = defineFatTable&lt;Item&gt;((&#123; column &#125;) =&gt; &#123;</span><br><span class="line">  // 可以在这里放置 Vue hooks</span><br><span class="line">  return () =&gt; (&#123;</span><br><span class="line">    async request(params) &#123;</span><br><span class="line">      /* 数据获取，自动处理异常和加载状态 */</span><br><span class="line">    &#125;,</span><br><span class="line">    // 删除操作</span><br><span class="line">    async remove(list, ids) &#123;</span><br><span class="line">      /*列删除*/</span><br><span class="line">    &#125;,</span><br><span class="line">    // 表格列</span><br><span class="line">    columns: [</span><br><span class="line">      // queryable 标记为查询字段</span><br><span class="line">      column(&#123; prop: &apos;name&apos;, label: &apos;名称&apos;, queryable: true &#125;),</span><br><span class="line">      column(&#123; prop: &apos;createDate&apos;, valueType: &apos;date-range&apos;, label: &apos;创建时间&apos;, queryable: true &#125;),</span><br><span class="line">      column(&#123;</span><br><span class="line">        type: &apos;actions&apos;,</span><br><span class="line">        label: &apos;操作&apos;,</span><br><span class="line">        actions: [&#123; name: &apos;编辑&apos; &#125;, &#123; name: &apos;删除&apos;, onClick: (table, row) =&gt; table.remove(row) &#125;],</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>语法类似于 Vue defineComponent，传入一个’setup’, 。这个 setup 中可以放置一些逻辑和状态或者 Vue hooks，就和 Vue defineComponent 定义一样灵活。</p><p>返回关于表格结构的”声明”。最优的情况下，开发者只需要定义表格结构和后端接口，其余的交由组件库处理。</p><p>当然复杂的定制场景也能满足，这里可以使用 JSX，监听事件，传递组件支持的任意 props 和 slots。</p><p><br><br><br></p><p><strong>表单页示例:</strong></p><p><img src="/images/crud/Untitled%2014.png" alt="Untitled"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; defineFatForm &#125; from &apos;@wakeadmin/components&apos;</span><br><span class="line">import &#123; ElMessageBox &#125; from &apos;element-plus&apos;</span><br><span class="line"></span><br><span class="line">export default defineFatForm&lt;&#123;</span><br><span class="line">  // 🔴 这里的泛型变量可以定义表单数据结构</span><br><span class="line">  name: string</span><br><span class="line">  nickName: string</span><br><span class="line">&#125;&gt;((&#123; item, form, consumer, group &#125;) =&gt; &#123;</span><br><span class="line">  // 🔴 这里可以放置 Vue Hooks</span><br><span class="line"></span><br><span class="line">  // 返回表单定义</span><br><span class="line">  return () =&gt; (&#123;</span><br><span class="line">    // FatForm props 定义</span><br><span class="line">    initialValue: &#123;</span><br><span class="line">      name: &apos;ivan&apos;,</span><br><span class="line">      nickName: &apos;狗蛋&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    submit: async (values) =&gt; &#123;</span><br><span class="line">      await ElMessageBox.confirm(&apos;确认保存&apos;)</span><br><span class="line">      console.log(&apos;保存成功&apos;, values)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // 🔴 子节点</span><br><span class="line">    children: [</span><br><span class="line">      item(&#123; prop: &apos;name&apos;, label: &apos;账号名&apos; &#125;),</span><br><span class="line">      item(&#123;</span><br><span class="line">        prop: &apos;nickName&apos;,</span><br><span class="line">        label: &apos;昵称&apos;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><aside><br>💡 和 tailwind 配合食用更香。我们假设整体的页面是符合UI规范的，细微的调整使用 tw 会很方便<br><br></aside><p><br><br><br></p><p><strong>全局配置：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; provideFatConfigurable &#125; from &apos;@wakeadmin/components&apos;</span><br><span class="line">import &#123; Message &#125; from &apos;element-ui&apos;</span><br><span class="line"></span><br><span class="line">export function injectFatConfigurations() &#123;</span><br><span class="line">  provideFatConfigurable(&#123;</span><br><span class="line">    // ...</span><br><span class="line">    // 统一处理 images 原件上传</span><br><span class="line">    aImagesProps: &#123;</span><br><span class="line">      action: &apos;/upload&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    // 统一 date-range 原件属性</span><br><span class="line">    aDateRangeProps: &#123;</span><br><span class="line">      rangeSeparator: &apos;至&apos;,</span><br><span class="line">      startPlaceholder: &apos;开始日期&apos;,</span><br><span class="line">      endPlaceholder: &apos;结束日期&apos;,</span><br><span class="line">      valueFormat: &apos;yyyy-MM-dd&apos;,</span><br><span class="line">      shortcuts: [</span><br><span class="line">        &#123;</span><br><span class="line">          text: &apos;最近一周&apos;,</span><br><span class="line">          onClick(picker: any) &#123;</span><br><span class="line">            picker.$emit(&apos;pick&apos;, getTime(7))</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          text: &apos;最近一个月&apos;,</span><br><span class="line">          onClick(picker: any) &#123;</span><br><span class="line">            picker.$emit(&apos;pick&apos;, getTime(30))</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          text: &apos;最近三个月&apos;,</span><br><span class="line">          onClick(picker: any) &#123;</span><br><span class="line">            picker.$emit(&apos;pick&apos;, getTime(90))</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>更多示例和深入讲解见<a href="https://wakeadmin.wakedata.com/components-doc/" target="_blank" rel="noopener">这里</a>。</p><p><br><br><br><br><br></p><h2 id="更多实现"><a href="#更多实现" class="headerlink" title="更多实现"></a>更多实现</h2><p>前端社区有很多类似的产品，比如：</p><ul><li><a href="https://xrender.fun/" target="_blank" rel="noopener">XRender</a>。中后台「表单/表格/图表」开箱即用解决方案</li><li><a href="https://procomponents.ant.design/docs/intro" target="_blank" rel="noopener">Antd ProComponents</a>。ProComponents 是基于 Ant Design 而开发的模板组件，提供了更高级别的抽象支持，开箱即用。可以显著的提升制作 CRUD 页面的效率，更加专注于页面</li><li><a href="https://github.com/baidu/amis" target="_blank" rel="noopener">百度 Amis</a> 。 用 JSON 作为 DSL，来描述界面</li></ul><p>读者不妨多参考参考。</p><p><br><br><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单来说，我们就是从提供「<strong>毛坯房</strong>」升级到了「<strong>精装房</strong>」，精装房的设计基于我们对市场需求的充分调研和预判。目的是对于 80% 的用户场景，可以实现拎包入住，当然也允许用户在约束的范围内改装。</p><p>本文主要阐述的观点：</p><ul><li>低代码平台的高效和易用大多来源于抽象，而不一定是 GUI，GUI ≠ 低代码。</li><li>摆脱「西西弗斯之石」 考验的是开发者的抽象能力，识别代码中固化/重复的逻辑。将模式提取出来，同时封装掉底层的实现细节。最终的目的是让开发者将注意力关注到业务本身，而不是技术实现细节。</li><li>用声明式、精简、高度抽象 DSL 描述业务 。DSL 的形式会约束他的表达能力，我们并不一定要创建一门新的语言，最简单的是复用元语言的生态和能力。</li><li>约定大于配置。设计风格、交互流程、数据存储等保持一致性，才能保证抽象收益的最大化。因此规范很重要。这需要我们和设计、产品、后端深入沟通，达成一致。</li><li>沉淀原件。低代码平台的效率取决于平台提供的组件能力、数量和粒度。比如前端的组件库，亦或者流程引擎的节点，都属于原件的范畴。</li><li>要求不要太高，这并不是一个万精油方案，我们期望能满足 80% 常见的场景，这已经是一个很好的成绩。至于那 20% 的个性需求，还是从毛坯房搞起吧。</li></ul><p><br><br><br><br><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://github.com/ascoders/weekly/issues/319" target="_blank" rel="noopener">精读《低代码逻辑编排》</a></li><li>UNIX 编程艺术</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/crud/Untitled.jpeg&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;据说，西西弗斯是一个非常聪明的国王，但他也非常自负和狂妄。他甚至敢欺骗神灵，并把死者带回人间。为此，他被宙斯（Zeus）惩罚，被迫每天推着一块巨石上山，
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>如何实现支持跨 Vue 2/3 的组件库</title>
    <link href="https://bobi.ink/2023/06/11/component-for-vue2-3/"/>
    <id>https://bobi.ink/2023/06/11/component-for-vue2-3/</id>
    <published>2023-06-10T16:00:00.000Z</published>
    <updated>2023-06-11T14:21:51.353Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><p><img src="/images/component-for-vue2-3/Untitled.jpeg" alt="Untitled"></p><p>Vue 3 已经<a href="https://vue-js.com/topic/5f65624c96b2cb0032c38550" target="_blank" rel="noopener">发布</a>三年，我们有较多项目还停留在 Vue 2。Vue 3 的升级是比较割裂的。</p><p>我们主要做的是 <code>2B</code> 业务，项目、模块、分支都非常多，升级的成本和风险都比较高。</p><p>我们目前的策略是 “新旧并存，渐进式升级”， 旧的项目就尽量不变了，新的项目强制使用新的技术栈。利用<code>微前端</code>架构，新旧应用可以灵活地组合起来。</p><p>因此我们的业务组件库、工具库之类需要考虑兼容旧的 Vue 2 项目。这篇文章，就向大家展示我们开发跨版本组件库，其中的决策和实现过程。</p><p><br><br><br></p><h2 id="方案决策"><a href="#方案决策" class="headerlink" title="方案决策"></a>方案决策</h2><p>实现跨版本的组件都多种方案，下面列举分析几种主要方案：</p><p><br></p><p><strong>方案一：使用 Vue SFC / 模板</strong></p><p>单纯从外观上看 Vue 2 / 3 在模板的语法上<a href="https://v3-migration.vuejs.org/zh/breaking-changes/v-model.html" target="_blank" rel="noopener">差别并不大</a>。在 <a href="https://blog.vuejs.org/posts/vue-2-7-naruto" target="_blank" rel="noopener">Vue 2.7</a> 开始内置了对 <code>script setup</code> 也有了较好的支持。</p><p>理论上，我们可以编写一份代码，然后分别针对 2 / 3 编译两份输出。</p><p><img src="/images/component-for-vue2-3/Untitled.png" alt="总体流程如上"></p><p>总体流程如上</p><p><strong>笔者提供了一个简单的 DEMO 来验证了这个方案的可行性，详见<a href="https://github.com/wakeadmin/cvv-sfc-demo" target="_blank" rel="noopener">这里</a>。</strong></p><ul><li>优点<ul><li>模板是 Vue 的第一公民，不需要为了兼容不同版本改变原有的开发习惯。学习成本比较低</li><li>支持静态编译，比如可以针对不同的版本进行条件编译，<strong>优化包体积</strong>。另外可以<strong>保留<a href="https://cn.vuejs.org/guide/extras/rendering-mechanism.html#compiler-informed-virtual-dom" target="_blank" rel="noopener">Vue 模板编译优化</a>机制</strong>。</li><li>使用公开标准语法，不需要 hack 或者关心太多框架底层的差异。</li></ul></li><li>缺点<ul><li>构建相对复杂，需要两份代码输出。</li><li>灵活性较差。模板语法差异很小，但不以为着没有差异，当需要处理某些跨版本差异时可能会比较棘手。比如<a href="https://v3-migration.vuejs.org/zh/breaking-changes/render-function-api.html" target="_blank" rel="noopener">向下透传事件、props 或者 slots</a> , <a href="https://v3-migration.vuejs.org/zh/breaking-changes/v-bind.html" target="_blank" rel="noopener">v-bind.sync 废弃了</a> 、<a href="https://v3-migration.vuejs.org/zh/breaking-changes/key-attribute.html" target="_blank" rel="noopener">template v-for key</a> <strong>、</strong>v-model 协议变化。</li><li>⚠️ 语法固化，为了兼容 Vue 2，template 语法需要停留在 Vue 3.0，这意味着后续发布的新特性可能无法使用，比如 <code>defineModel</code>，<code>defineOptions</code>。</li></ul></li></ul><p><br><br><br><br><br></p><p><strong>方案 2： 渲染函数</strong></p><p>Vue 2 和 Vue 3 都支持渲染函数，但是两者之间有非常大的差异。<strong>详细的差异对比可以看笔者整理的这篇文档： <a href="https://www.notion.so/Vue-2-3-302cbe0e37794345bbfbd89e32d617db?pvs=21" target="_blank" rel="noopener">Vue 2/3 渲染函数差异以及兼容方案</a></strong></p><p><br></p><p><strong>那 Vue 官方的 JSX 插件呢？</strong></p><p>Vue 2/3 JSX Babel (<strong><a href="https://github.com/vuejs/jsx-vue2" target="_blank" rel="noopener">jsx-vue2</a>、<a href="https://github.com/vuejs/babel-plugin-jsx" target="_blank" rel="noopener">babel-plugin-jsx</a></strong>)插件加了一些语法糖，来简化渲染函数的编写，但是这两个插件的语法完全是两个东西。</p><p>因此这个方案不在我们的考虑之列。</p><p><br><br><br><br><br></p><p><strong>方案 3：标准的 JSX</strong></p><p>那为什么不用标准的 <code>JSX</code> 呢？使用统一的 JSX 语法，转换为不同版本的渲染函数。</p><p><img src="/images/component-for-vue2-3/Untitled%201.png" alt="Untitled"></p><p>使用标准的 JSX 语法，意味着：</p><ul><li><p>不需要任何 <code>Babel</code> 插件，能够被市面上主流的编译器(如 tsc， swc，esbuild)直接处理。<br>例如 Typescript</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">/** tsconfig.json */</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"jsx"</span>: <span class="string">"react-jsx"</span>,</span><br><span class="line">    <span class="attr">"jsxImportSource"</span>: <span class="string">"JSX 运行时名称"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<strong>运行时</strong>转换到对应版本的渲染函数。</p></li><li>Typescript friendly。纯 TSX，不需要额外插件(比如 <code>Volar</code>)辅助。</li><li><p>使用习惯上接近 <code>React</code>。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">/** 🔴 1. 事件订阅  **/</span><br><span class="line">// 🤮</span><br><span class="line"><span class="deletion">- &lt;input vOn:click=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;input vOn:click_stop_prevent=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line">// 👍 使用 on* 注册时间</span><br><span class="line"><span class="addition">+ &lt;input onClick=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line"></span><br><span class="line">/** 🔴 2. 没有指令  **/</span><br><span class="line">// 🤮</span><br><span class="line"><span class="deletion">- &lt;input v-show=&#123;this.visible&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;input vModel=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;input vModel_trim=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;A v-model=&#123;[val, "argument", ["modifier"]]&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;a v-loading=&#123;val&#125; /&gt;;</span></span><br><span class="line"></span><br><span class="line">// 👍 没有语法糖</span><br><span class="line"><span class="addition">+ &lt;input modelValue=&#123;val&#125; onUpdate:modelValue=&#123;handleValChange&#125; /&gt;</span></span><br><span class="line"><span class="addition">+ &lt;input style=&#123;&#123;display: this.visible ? 'block' : 'none' &#125;&#125; /&gt;</span></span><br><span class="line"><span class="addition">+ &lt;a &#123;...withDirectives([[vLoading, val]])&#125;&gt;</span></span><br><span class="line"></span><br><span class="line">/** 🔴 3. slots  **/</span><br><span class="line">// 🤮</span><br><span class="line"><span class="deletion">- &lt;MyComponent&gt;</span></span><br><span class="line"><span class="deletion">-   &lt;header slot="header"&gt;header&lt;/header&gt;</span></span><br><span class="line"><span class="deletion">-   &lt;footer slot="footer"&gt;footer&lt;/footer&gt;</span></span><br><span class="line"><span class="deletion">- &lt;/MyComponent&gt;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">- const scopedSlots = &#123;</span></span><br><span class="line"><span class="deletion">-   header: () =&gt; &lt;header&gt;header&lt;/header&gt;,</span></span><br><span class="line"><span class="deletion">-   footer: () =&gt; &lt;footer&gt;footer&lt;/footer&gt;</span></span><br><span class="line"><span class="deletion">- &#125;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">- &lt;MyComponent scopedSlots=&#123;scopedSlots&#125; /&gt;</span></span><br><span class="line"></span><br><span class="line">// 👍 对齐 vue 3</span><br><span class="line"><span class="addition">+ const App = &#123;</span></span><br><span class="line"><span class="addition">+   setup() &#123;</span></span><br><span class="line"><span class="addition">+     const slots = &#123;</span></span><br><span class="line"><span class="addition">+       bar: () =&gt; &lt;span&gt;B&lt;/span&gt;,</span></span><br><span class="line"><span class="addition">+     &#125;;</span></span><br><span class="line"><span class="addition">+     return () =&gt; (</span></span><br><span class="line"><span class="addition">+       &lt;A v-slots=&#123;slots&#125;&gt;</span></span><br><span class="line"><span class="addition">+         &lt;div&gt;A&lt;/div&gt;</span></span><br><span class="line"><span class="addition">+       &lt;/A&gt;</span></span><br><span class="line"><span class="addition">+     );</span></span><br><span class="line"><span class="addition">+   &#125;,</span></span><br><span class="line"><span class="addition">+ &#125;;</span></span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><ul><li><p>优点</p><ul><li>构建很简单，使用标准的 JSX 只需构建一次。不需要引入特定的编译器，使用 <code>Typescript CLI</code>，<code>esbuild</code> 就可以直接编译。</li><li>Typescript Friendly, 另外相比 <code>vue-tsc</code> 编译结果会好一点。</li><li>灵活性。毋庸置疑，<code>JSX</code> 的灵活性，可操行性太强了。</li><li>相对模板编译来说，可控一点(Hackable)。</li><li>可以替换官方的 JSX 库，除了本文介绍的<code>跨版本组件库</code>场景，在日常 Vue 2/3 应用开发中也可以使用啊。</li></ul></li><li><p>缺点</p><ul><li>使用 <code>JSX</code> 则意味着放弃<a href="https://cn.vuejs.org/guide/extras/rendering-mechanism.html#compiler-informed-virtual-dom" target="_blank" rel="noopener">模板编译优化</a>的机会，比如动态节点标注，预字符串化，缓存，静态提升等等。</li><li>为了抹平版本之间的差异，多了一层抽象转换(主要是 Vue 2 上)，会有一些性能损耗。</li><li>实现上需要熟知两个版本之间的差异性。比较 hack</li><li>可读性较差，相比 <code>React</code> 简洁的 Api，Vue 上的一些特殊的框架特性，还是会让代码有些不太优雅，比如指令、Slot</li></ul></li></ul><p>后面我们选择了 <code>JSX</code> 方案，因为实现起来更简单，方案更加可控，尤其是应对后续的版本更新。</p><p><br><br><br><br><br></p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>构建跨版本的组件库，需要考虑的不仅仅是组件语法问题。Vue 2/3 从底层的 API 到渲染函数、再到应用层的组件库、路由、多语言等等，都出现了割裂。我们得兼顾这些变化。</p><p><br></p><ol><li><strong>分层策略</strong></li></ol><p><img src="/images/component-for-vue2-3/Untitled%202.png" alt="Untitled"></p><p>我们按照引用关系进行分层：</p><ul><li><strong><code>API 层</code></strong>。好在 Vue 3 大部分特性(主要是 <code>Composition API</code> 和 <code>defineComponent</code>) 已经下放到了 Vue 2，我们只需要使用 <a href="https://github.com/vueuse/vue-demi" target="_blank" rel="noopener">vue-demi</a> 就可以无缝使用这些核心的 API。<br>相对应的，上层的组件库、适配器代码禁止直接导入 ‘vue’</li><li><strong><code>视图语法层</code></strong>。就如上文说的，我们会封装一个 jsx-runtime, 抹平 Vue 2/3 在渲染函数上的差异。</li><li><strong><code>适配器层</code></strong>。应用层的各种类库的适配。比如我们公司主要使用 element-ui, 新旧版本的差异会在 element-adapter 中处理，并暴露统一接口。</li><li><strong><code>组件库层</code></strong>。最后我们的组件库基于下层提供的抽象能力，实现跨版本。</li><li><strong><code>应用</code></strong>。上层的 Vue 2 / 3 应用。下层的适配器，会根据应用使用的 Vue 版本，动态切换适配。</li></ul><p><br><br><br></p><p><strong>2) 新版本优先策略</strong></p><p>在封装适配器 或者 jsx-runtime 时，当新旧版本出现差异时，我们如何抉择？</p><p>这里采用的是“新版本优先”的策略，举一些例子：</p><ul><li>JSX 的语法对齐 Vue 3 的渲染函数。</li><li>只使用 Composition API</li><li>只使用 defineComponent</li></ul><p>换句话说，如果情况允许，我们始终以 Vue 3 为基准。</p><p><br><br><br></p><p><strong>3) 短板优先策略</strong></p><p>短板对齐是实现兼容的基础策略，主要分两个方面：</p><ul><li>削头: 并不是所有 Vue 3 的特性都能下放到 Vue 2, 比如 <code>Fragment</code>、<code>Teleport</code>、<code>Suspense</code>/<code>await setup</code>。我们只能放弃这些功能。</li><li>补尾：针对一些 Vue 2 的短板，需要一些额外的工作，比如 <a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">Vue 2 响应式系统的局限性</a>。</li></ul><p><br><br><br></p><p><strong>4) 回退策略</strong></p><p>对于一些无法抹平的差异，可以按照不同的版本特殊处理。可以使用 vue-demi 的 <code>isVue2</code> 来分条件处理。</p><p><br><br><br><br><br></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="api-兼容：vue-demi"><a href="#api-兼容：vue-demi" class="headerlink" title="API 兼容：vue demi"></a>API 兼容：vue demi</h3><p><a href="https://github.com/vueuse/vue-demi" target="_blank" rel="noopener">vue-demi</a> 为实现跨 Vue 版本的库提供基础的支持。它的主要策略：</p><ul><li><code>&lt;=2.6</code>: 导出  <code>vue</code> + <code>@vue/composition-api</code>.</li><li><code>2.7</code>: 导出  <code>vue</code> ( Vue 2.7 内置支持 Composition API).</li><li><code>&gt;=3.0</code>: 导出  <code>vue</code>, 模拟了 Vue 2 的<code>set</code> 、 <code>del</code> API.</li></ul><p>vue-demi 的实现很简单，就是在 npm 的 <code>postinstall</code> 钩子中，判断当前环境安装的 vue 库版本，决定导入的库。</p><p>在我们的场景中，除了 Composition API 和一些基础类型信息还不够，我们 Fork 了 vue-demi 来扩充了一些填充物，进一步抹平一些差异。</p><p><br><br><br><br><br></p><h3 id="渲染语法：jsx-runtime-的实现"><a href="#渲染语法：jsx-runtime-的实现" class="headerlink" title="渲染语法：JSX runtime 的实现"></a>渲染语法：JSX runtime 的实现</h3><p>JSX runtime 的实现并不涉及太复杂的技术，主要还是处理渲染函数的繁琐 API 差异。</p><p>文章篇幅有限，这里我就不展开讲细节了。<strong>⚠️ 完整的差异对比和应对方式可以看这里</strong>：</p><p><br></p><p><a href="https://www.notion.so/Vue-2-3-302cbe0e37794345bbfbd89e32d617db?pvs=21" target="_blank" rel="noopener">🎉Vue 2 / 3 渲染函数的差异 🎉</a></p><p><br></p><p>简单来说，我们的 JSX 语法以 Vue 3 为基准，主要涉及事件订阅、slots、指令的转换。</p><p><br></p><p><img src="/images/component-for-vue2-3/Untitled%203.png" alt="Untitled"></p><p>具体实现可以看<a href="https://github.com/wakeadmin/tools/tree/main/packages/h" target="_blank" rel="noopener">这里</a></p><p><br><br><br><br><br></p><h3 id="组件定义与-typescript-支持"><a href="#组件定义与-typescript-支持" class="headerlink" title="组件定义与 Typescript 支持"></a>组件定义与 Typescript 支持</h3><p>Typescript + Volar 就是一门玄学，类型‘体操’几乎占据了开发的三分之一时间。主要问题：</p><ul><li>Vue 2/3 类型定义和导出有细微的差别。我们的 jsx-runtime 要求一致的类型。</li><li>JSX 的 slots 不支持类型检查。渲染函数毕竟不是 Vue 的第一公民，slots 在 JSX 下无法类型检查。</li><li>为了兼容 options API, <code>defineComponent</code> 类型定义和推导比较<a href="https://github.com/vuejs/core/blob/a95e612b252ae59eaf56e0b8ddba66948d4ac20e/packages/runtime-core/src/apiDefineComponent.ts#L44" target="_blank" rel="noopener">复杂</a>。</li><li>泛型组件实现比较复杂，Volar 泛型的支持也比较玄学。</li></ul><p><br><br><br></p><p>为了能够更好地定义跨版本的组件，提供更好的类型支持，我们打算简化 <code>defineComponent</code>。为了避免命名冲突，尚且命名为 <code>declareComponent</code> 吧, 这个函数有以下职责：</p><ul><li>为实现跨版本支持提供必要约束。<code>declareComponent</code> 裁剪掉了 <code>Options API</code>, 只保留 setup、props、render 等属性。强制走 <code>Composition API</code>。</li><li>为 JSX (比如 v-slots 属性)提供更好类型检查支持</li><li>同时兼容 vue template 的类型检查 (<code>volar</code>)。</li><li>在运行时抹平一些跨版本的差异。绝大部分差异，Vue 2.7 在 <code>defineComponent</code> 方法内部已经抹平了。还有一些 <code>inheritAttrs</code> 带来的<a href="https://www.notion.so/Vue-2-3-302cbe0e37794345bbfbd89e32d617db?pvs=21" target="_blank" rel="noopener">隐式差异</a>，<strong>declareComponent 直接关闭了 <code>inheritAttrs</code></strong> 。</li><li>补全短板，并且向下保持兼容。Vue 2 已经不更新了，我们想要支持一些新的特性，比如泛型。</li></ul><p><br></p><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Counter = declareComponent(&#123;</span><br><span class="line">  name: &apos;Counter&apos;,</span><br><span class="line">  // 定义 props</span><br><span class="line">  props: declareProps&lt;&#123;</span><br><span class="line">    initialValue: number</span><br><span class="line">  &#125;&gt;(</span><br><span class="line">    // ⚠️ 和 defineComponent 一样，我们还是需要显式定义 props, 否则会被当做 attrs</span><br><span class="line">    [&apos;initialValue&apos;]</span><br><span class="line">  ),</span><br><span class="line"></span><br><span class="line">  // 定义事件</span><br><span class="line">  emits: declareEmits&lt;&#123; change: (value: number) =&gt; void &#125;&gt;(),</span><br><span class="line"></span><br><span class="line">  // 定义插槽</span><br><span class="line">  // slots: declareSlots&lt;&#123; foo: &#123; a: number &#125; &#125;&gt;(),</span><br><span class="line"></span><br><span class="line">  // setup</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    const count = ref(props.initialValue)</span><br><span class="line">    const handleClick = () =&gt; &#123;</span><br><span class="line">      count.value++</span><br><span class="line"></span><br><span class="line">      emit(&apos;change&apos;, count.value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return () =&gt; (</span><br><span class="line">      &lt;div title=&quot;count&quot; onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">        count: &#123;count.value&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>为了实现这个目标，我们先来看下 <code>Volar</code> 是如何推断组件的类型：</p><p><br></p><p>大致的推导过程如下, 其次可以参考 <code>vue-tsc</code> 的编译输出或者 Vue <code>defineComponent</code> 的类型声明。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// https://github.com/vuejs/language-tools/blob/71240c78f1a205605f4c079a299b2701250ef9be/packages/vue-component-type-helpers/index.d.ts#L5</span><br><span class="line">export type ComponentProps&lt;T&gt; = T extends new () =&gt; &#123; $props: infer P &#125;</span><br><span class="line">  ? NonNullable&lt;P&gt;</span><br><span class="line">  : T extends (props: infer P, ...args: any) =&gt; any</span><br><span class="line">  ? P</span><br><span class="line">  : &#123;&#125;</span><br><span class="line"></span><br><span class="line">export type ComponentSlots&lt;T&gt; = T extends new () =&gt; &#123; $slots: infer S &#125;</span><br><span class="line">  ? NonNullable&lt;S&gt;</span><br><span class="line">  : T extends (props: any, ctx: &#123; slots: infer S &#125;, ...args: any) =&gt; any</span><br><span class="line">  ? NonNullable&lt;S&gt;</span><br><span class="line">  : &#123;&#125;</span><br><span class="line"></span><br><span class="line">export type ComponentEmit&lt;T&gt; = T extends new () =&gt; &#123; $emit: infer E &#125;</span><br><span class="line">  ? NonNullable&lt;E&gt;</span><br><span class="line">  : T extends (props: any, ctx: &#123; emit: infer E &#125;, ...args: any) =&gt; any</span><br><span class="line">  ? NonNullable&lt;E&gt;</span><br><span class="line">  : &#123;&#125;</span><br><span class="line"></span><br><span class="line">export type ComponentExposed&lt;T&gt; = T extends new () =&gt; infer E</span><br><span class="line">  ? E</span><br><span class="line">  : T extends (props: any, ctx: &#123; expose(exposed: infer E): any &#125;, ...args: any) =&gt; any</span><br><span class="line">  ? NonNullable&lt;E&gt;</span><br><span class="line">  : &#123;&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Vue 2.x</span><br><span class="line"> */</span><br><span class="line">export type Vue2ComponentSlots&lt;T&gt; = T extends new () =&gt; &#123; $scopedSlots: infer S &#125;</span><br><span class="line">  ? NonNullable&lt;S&gt;</span><br><span class="line">  : T extends (props: any, ctx: &#123; slots: infer S &#125;, ...args: any) =&gt; any</span><br><span class="line">  ? NonNullable&lt;S&gt;</span><br><span class="line">  : &#123;&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>简单来说 <code>defineComponent</code> 方法最终输出的组件的类型外观长这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type YourComponent = new (...args: any[]): &#123;</span><br><span class="line">  $props: Props 类型</span><br><span class="line">  $emit: 事件类型</span><br><span class="line">  $slots: 插槽类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>💡 那 Typescript 的 JSX 怎么对组件进行类型检查呢？这个可以参考 Typescript 的 <a href="https://www.typescriptlang.org/docs/handbook/jsx.html" target="_blank" rel="noopener">JSX 文档</a>，还有 Vue 的 JSX <a href="https://github.com/vuejs/core/blob/a95e612b252ae59eaf56e0b8ddba66948d4ac20e/packages/vue/jsx.d.ts#L3" target="_blank" rel="noopener">类型定义</a>。简单说也是从上述的 <code>$props</code> 中推导的。</p></blockquote><p><br><br><br></p><p>我们的 <code>declareComponent</code> 只要保持和上面的类型兼容，就可以让 <code>volar</code> 在 vue template 下进行类型检查了。</p><p><br></p><p>因为刨除掉了不必要的 Options API, 相比 defineComponent, 类型定义可以简化很多:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function declareComponent&lt;</span><br><span class="line">  Props extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Emit extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Slots extends &#123;&#125; = &#123;&#125;</span><br><span class="line">&gt;(</span><br><span class="line">  options: SimpleComponentOptions&lt;Props, Emit, Expose, Slots&gt;</span><br><span class="line">): DefineComponent&lt;Props, Emit, Expose, Slots&gt; &#123;</span><br><span class="line">  /// .. 实现忽略，简单封装 defineComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 简化 defineComponent API, 只保留 Composition API</span><br><span class="line">export type SimpleComponentOptions&lt;</span><br><span class="line">  Props extends &#123;&#125;,</span><br><span class="line">  Emit extends &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125;,</span><br><span class="line">  Slots extends &#123;&#125;</span><br><span class="line">&gt; = &#123;</span><br><span class="line">  name?: string</span><br><span class="line">  props?: Props</span><br><span class="line">  emits?: Emit</span><br><span class="line">  slots?: Slots</span><br><span class="line">  expose?: Expose</span><br><span class="line">  setup: (</span><br><span class="line">    props: Props,</span><br><span class="line">    ctx: SetupContext&lt;Emit, DefaultSlots &amp; Slots, Expose, Data&gt;</span><br><span class="line">  ) =&gt; Promise&lt;RenderFunction | void&gt; | RenderFunction | void</span><br><span class="line">  inheritAttrs?: boolean</span><br><span class="line">  serverPrefetch?(): Promise&lt;any&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export interface ComponentInstance&lt;</span><br><span class="line">  Props extends &#123;&#125;,</span><br><span class="line">  Emit extends &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125;,</span><br><span class="line">  Slots extends &#123;&#125;</span><br><span class="line">&gt; &#123;</span><br><span class="line">  // props 定义</span><br><span class="line">  $props: Props &amp;</span><br><span class="line">    // 🔴 将 emit 转换为 on* 形式，方便 JSX 场景使用</span><br><span class="line">    EmitsToProps&lt;Emit&gt; &amp; &#123; &apos;v-slots&apos;?: Partial&lt;VSlotType&lt;Slots&gt;&gt; &#125; &amp; &#123;</span><br><span class="line">      // 🔴 扩展了 v-slots 的定义，方便 JSX 场景使用</span><br><span class="line">      &apos;v-children&apos;?: VChildrenType&lt;Slots&gt;</span><br><span class="line">    &#125; &amp; &#123;</span><br><span class="line">      ref?: RefType&lt;Expose | Expose[]&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  // 🔴 支持 volar 推断 slots</span><br><span class="line">  $slots: VSlotType&lt;Slots&gt;</span><br><span class="line">  // 🔴 支持 volar 推断 事件</span><br><span class="line">  $emit: EmitFn&lt;Emit&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以对比 Vue 的 DefineComponent 看看</span><br><span class="line">export interface DefineComponent&lt;</span><br><span class="line">  Props extends &#123;&#125;,</span><br><span class="line">  Emit extends &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125;,</span><br><span class="line">  Slots extends &#123;&#125;</span><br><span class="line">&gt; &#123;</span><br><span class="line">  new (...args: any[]): ComponentInstance&lt;Props, Emit, Expose, Slots&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>那怎么支持泛型组件吗？</strong></p><p><br><br><br><br><br></p><h3 id="泛型组件"><a href="#泛型组件" class="headerlink" title="泛型组件"></a><strong>泛型组件</strong></h3><blockquote><p>Volar 需要升级到最新版本。</p></blockquote><blockquote><p>Volar 的泛型支持比较玄学，我建议不要随意尝试！</p></blockquote><p>Vue 3.3 官方正式支持了<a href="https://blog.vuejs.org/posts/vue-3-3" target="_blank" rel="noopener">泛型 SFC</a> 和 defineComponent, 笔者实测 Volar 这块支持还有待改进。但是不妨碍我们进行初步的尝试。</p><p>上文的 <code>declareComponent</code> 写法是不支持泛型组件的。有两种方式可以实现泛型组件的声明，先来看一个比较简单的：</p><ol><li><p><strong>类型断言</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 🔴 使用泛型定义 props、emit 和 expose 等类型</span><br><span class="line">interface Props&lt;T&gt; &#123;</span><br><span class="line">  list: T[]</span><br><span class="line">  filter: (item: T) =&gt; boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 📢 这里要用 type</span><br><span class="line">type Emit&lt;T&gt; = &#123;</span><br><span class="line">  add: (item: T) =&gt; void</span><br><span class="line">  change: (list: T[]) =&gt; void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Expose&lt;T&gt; = &#123;</span><br><span class="line">  open: (item: T) =&gt; void</span><br><span class="line">  list: T[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Slots&lt;T&gt; = &#123;</span><br><span class="line">  foo: (list: T[]) =&gt; any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const GenericBar = declareComponent(&#123;</span><br><span class="line">  props: declareProps&lt;Props&lt;any&gt;&gt;([]),</span><br><span class="line">  emits: declareEmits&lt;Emit&lt;any&gt;&gt;(),</span><br><span class="line">  expose: declareExpose&lt;Expose&lt;any&gt;&gt;(),</span><br><span class="line">  slots: declareSlots&lt;Slots&lt;any&gt;&gt;(),</span><br><span class="line">  setup(props, ctx) &#123;</span><br><span class="line">    expectType&lt;any[]&gt;(props.list)</span><br><span class="line">    ctx.emit(&apos;change&apos;, [])</span><br><span class="line">    ctx.slots.foo?.([])</span><br><span class="line">    ctx.expose(&#123;</span><br><span class="line">      list: [],</span><br><span class="line">      open() &#123;</span><br><span class="line">        // ignore</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    return &#123;&#125; as any</span><br><span class="line">  &#125;,</span><br><span class="line">  // 🔴 重新断言，支持 泛型</span><br><span class="line">&#125;) as new &lt;T&gt;(...args: any[]) =&gt; ComponentInstance&lt;Props&lt;T&gt;, Emit&lt;T&gt;, Expose&lt;T&gt;, Slots&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">;&lt;GenericBar</span><br><span class="line">  list=&#123;[1, 2]&#125;</span><br><span class="line">  filter=&#123;(i) =&gt; &#123;</span><br><span class="line">    expectType&lt;number&gt;(i)</span><br><span class="line">    return true</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  onAdd=&#123;(i) =&gt; &#123;</span><br><span class="line">    expectType&lt;number&gt;(i)</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  onChange=&#123;(i) =&gt; &#123;</span><br><span class="line">    expectType&lt;number[]&gt;(i)</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  v-slots=&#123;&#123;</span><br><span class="line">    foo(i) &#123;</span><br><span class="line">      expectType&lt;number[]&gt;(i)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;&lt;/GenericBar&gt;</span><br></pre></td></tr></table></figure><p> <br></p><p>上面的方式在 JSX 表现正常，<strong>但是目前 Volar 在 vue template 并不支持。</strong></p><blockquote><p>💡 <strong>这里也有一些冷知识。</strong>假设 目标类型约束了 <code>Index Signature</code>, 比如 <code>{[key: string]: Function }</code>, 那么 <code>interface</code> 是无法赋值给它的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; interface Indexed &#123;</span><br><span class="line">&gt;   [key: string]: Function</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; interface Foo &#123;</span><br><span class="line">&gt;   hello: () =&gt; void</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; declare let a: Indexed</span><br><span class="line">&gt; declare let b: Foo</span><br><span class="line">&gt;</span><br><span class="line">&gt; a = b // 🚨 Index signature for type &apos;string&apos; is missing in type &apos;Foo&apos;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>如果使用 <code>type</code> 创建类型就可以:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; type Bar = &#123;</span><br><span class="line">&gt;   hello: () =&gt; void</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; declare let c: Bar</span><br><span class="line">&gt; a = c // it&apos;s work</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>笔者推测，应该<strong>是 interface 允许 <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces" target="_blank" rel="noopener">合并</a>，不是静态的，因此不能安全地满足 Index Signature 的约束</strong>。</p><p>了解更多：</p><p><a href="https://stackoverflow.com/questions/60697214/how-to-fix-index-signature-is-missing-in-type-error" target="_blank" rel="noopener">How to fix “Index signature is missing in type” error?</a></p></blockquote><p> <br><br> <br></p></li><li><p><strong>函数形式</strong></p><p>Vue 3.3 的 <code>defineComponent</code> 新增了一种<a href="https://cn.vuejs.org/api/general.html#definecomponent" target="_blank" rel="noopener">函数签名形式</a>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Comp = defineComponent(</span><br><span class="line">  &lt;T extends string | number&gt;(props: &#123; msg: T; list: T[] &#125;) =&gt; &#123;</span><br><span class="line">    // 就像在 &lt;script setup&gt; 中一样使用组合式 API</span><br><span class="line">    const count = ref(0)</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      // 渲染函数或 JSX</span><br><span class="line">      return &lt;div&gt;&#123;count.value&#125;&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 去掉注释，泛型会失效</span><br><span class="line">  // 目前仍然需要手动声明运行时的 props</span><br><span class="line">  // &#123;</span><br><span class="line">  //  props: [&apos;msg&apos;, &apos;list&apos;]</span><br><span class="line">  /// &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>尴尬的是，Vue 组件必须显式定义 props 参数，不然会被当做 attrs 处理。所以，当你将上面的<strong>props 参数注释去掉时，泛型就会失效了 😀</strong> 。</p><p>另外一件尴尬的事情是，截止目前为止，用上面语法创建的组件，在 Volar 上并不能得到很好的支持(只能正确推断 props)。</p><p><br></p><p>但使用 <a href="https://cn.vuejs.org/api/sfc-script-setup.html#generics" target="_blank" rel="noopener">SFC 泛型语法</a> 则会表现好一点。SFC 有什么特殊？</p><p>我使用 vue-tsc 将组件编译了一下，大概结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare const _default: &lt;T&gt;(</span><br><span class="line">  // 🔴 props 类型</span><br><span class="line">  __VLS_props: &#123;</span><br><span class="line">    list: T[]</span><br><span class="line">    filter: (item: T) =&gt; boolean</span><br><span class="line">  &#125; &amp; VNodeProps &amp;</span><br><span class="line">    AllowedComponentProps &amp;</span><br><span class="line">    ComponentCustomProps,</span><br><span class="line"></span><br><span class="line">  // 🔴 context 类型</span><br><span class="line">  __VLS_ctx?:</span><br><span class="line">    | Pick&lt;</span><br><span class="line">        &#123;</span><br><span class="line">          props: &#123;</span><br><span class="line">            list: T[]</span><br><span class="line">            filter: (item: T) =&gt; boolean</span><br><span class="line">          &#125;</span><br><span class="line">          expose(exposed: &#123; data: Ref&lt;T[] | null | undefined&gt; &#125;): void</span><br><span class="line">          attrs: any</span><br><span class="line">          slots: &#123;</span><br><span class="line">            foo: (scope: &#123; list: T[] &#125;) =&gt; any</span><br><span class="line">          &#125;</span><br><span class="line">          emit: &#123;</span><br><span class="line">            change: [T[]]</span><br><span class="line">            foo: [T, number]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;attrs&apos; | &apos;emit&apos; | &apos;slots&apos;</span><br><span class="line">      &gt;</span><br><span class="line">    | undefined</span><br><span class="line">) =&gt; // 🔴 返回值</span><br><span class="line">VNode &amp; &#123;</span><br><span class="line">  __ctx?:</span><br><span class="line">    | &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">          list: T[]</span><br><span class="line">          filter: (item: T) =&gt; boolean</span><br><span class="line">        &#125;</span><br><span class="line">        expose(exposed: &#123; data: Ref&lt;T[] | null | undefined&gt; &#125;): void</span><br><span class="line">        attrs: any</span><br><span class="line">        slots: &#123;</span><br><span class="line">          foo: (scope: &#123; list: T[] &#125;) =&gt; any</span><br><span class="line">        &#125;</span><br><span class="line">        emit: &#123;</span><br><span class="line">          change: [T[]]</span><br><span class="line">          foo: [T, number]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    | undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SFC 的编译结果多出了 <code>__ctx</code> 字段，实际上 Volar 就是从 __ctx 中提取了相关类型。</p><aside><br>💡 __ctx 应该是 volar 的内部实现细节，不排除后面会变动<br><br></aside><p>那我们现在就模仿它，重构一下 <code>declareComponent</code> 的签名:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface DefineComponentContext&lt;</span><br><span class="line">  Emit extends ObjectEmitsOptions = &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Slots extends &#123; [key: string]: Function &#125; = &#123;&#125;,</span><br><span class="line">  Attrs extends &#123;&#125; = &#123;&#125;</span><br><span class="line">&gt; &#123;</span><br><span class="line">  attrs: Attrs</span><br><span class="line">  slots: Slots</span><br><span class="line">  emit: EmitFn&lt;Emit&gt;</span><br><span class="line">  expose: ExposeFn&lt;Expose&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function declareComponent&lt;</span><br><span class="line">  Props extends &#123;&#125;,</span><br><span class="line">  Emit extends ObjectEmitsOptions = &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Slots extends &#123; [key: string]: Function &#125; = &#123;&#125;,</span><br><span class="line">  Attrs extends &#123;&#125; = &#123;&#125;</span><br><span class="line">&gt;(</span><br><span class="line">  setup: (</span><br><span class="line">    props: Props,</span><br><span class="line">    ctx: DefineComponentContext&lt;Emit, Expose, Slots, Attrs&gt;</span><br><span class="line">  ) =&gt; Promise&lt;RenderFunction | void&gt; | RenderFunction | void,</span><br><span class="line">  options?: &#123;</span><br><span class="line">    props?: Array&lt;keyof Props&gt; | ComponentObjectPropsOptions&lt;Partial&lt;Props&gt;&gt;</span><br><span class="line">    name?: string</span><br><span class="line">    inheritAttrs?: boolean</span><br><span class="line">    serverPrefetch?(): Promise&lt;any&gt;</span><br><span class="line">  &#125;</span><br><span class="line">): (</span><br><span class="line">  props: PropsType&lt;Props, Emit, Slots, Expose&gt;,</span><br><span class="line">  ctx: DefineComponentContext&lt;Emit, Expose, Slots, Attrs&gt;</span><br><span class="line">) =&gt; VNode &amp; &#123;</span><br><span class="line">  // 🛑</span><br><span class="line">  __ctx: &#123;</span><br><span class="line">    emit: EmitFn&lt;Emit&gt;</span><br><span class="line">    slots: Slots</span><br><span class="line">    expose: ExposeFn&lt;Expose&gt;</span><br><span class="line">    attrs: Attrs</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo&lt;T&gt;(</span><br><span class="line">  props: &#123; list: T[]; filter: (item: T) =&gt; boolean &#125;,</span><br><span class="line">  ctx: DefineComponentContext&lt;</span><br><span class="line">    &#123; change: (list: T[]) =&gt; void; add: (item: T) =&gt; void &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      open: (item: T) =&gt; void</span><br><span class="line">      list: T[]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      foo: (list: T[]) =&gt; any</span><br><span class="line">    &#125;</span><br><span class="line">  &gt;</span><br><span class="line">) &#123;</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    // render</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ⚠️ props 还是要定义</span><br><span class="line">Foo.props = [&apos;list&apos;, &apos;filter&apos;]</span><br><span class="line"></span><br><span class="line">export default declareComponent(Foo)</span><br></pre></td></tr></table></figure><p>目前 Volar 在泛型的支持上还有不少的坑。比如上面的示例中事件处理器的泛型变量会推断为 unknown。让子弹再飞一会吧。</p></li></ol><p><br><br><br><br><br> </p><h3 id="element-adapter"><a href="#element-adapter" class="headerlink" title="element-adapter"></a>element-adapter</h3><p>实现的原理和 vue-demi 类似，在 postinstall 时决定使用哪个版本。项目的结构如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scripts/             <span class="comment"># 和 vue-demi 一样，实现了 postinstall 和切换 CLI</span></span><br><span class="line">  postinstall.mjs</span><br><span class="line">  switch-cli.mjs</span><br><span class="line">src/</span><br><span class="line">  shared/</span><br><span class="line">  v2/                <span class="comment"># element-ui 导出</span></span><br><span class="line">    components/</span><br><span class="line">      Table.js</span><br><span class="line">      Slide.js</span><br><span class="line">      ...</span><br><span class="line">  v3/                <span class="comment"># element-plus 导出</span></span><br><span class="line">    components/</span><br><span class="line">      ...</span><br><span class="line">types/               <span class="comment"># 重新声明组件的类型信息。</span></span><br><span class="line">  alert.d.ts</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p><br> </p><p>大部分组件不需要特殊处理，重新导出就行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> &#123; Button &#125; from <span class="string">'element-ui'</span>;</span><br></pre></td></tr></table></figure><p><br> </p><p>有一些组件参数名称发生了变化，则以 element-plus 为基准做一下调整：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; TimePicker as ElTimePicker &#125; from &apos;element-ui&apos;</span><br><span class="line">import &#123; h &#125; from &apos;@wakeadmin/h&apos;</span><br><span class="line"></span><br><span class="line">import &#123; normalizeDateFormat &#125; from &apos;../../shared/date-format&apos;</span><br><span class="line"></span><br><span class="line">export const TimePicker = &#123;</span><br><span class="line">  functional: true,</span><br><span class="line">  render(_, context) &#123;</span><br><span class="line">    const &#123; format, selectableRange, valueFormat, ...other &#125; = context.props</span><br><span class="line"></span><br><span class="line">    // vue3 pickerOptions 提取到了全局</span><br><span class="line">    other.pickerOptions = &#123;</span><br><span class="line">      ...other.pickerOptions,</span><br><span class="line">      format: format &amp;&amp; normalizeDateFormat(format),</span><br><span class="line">      selectableRange,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (valueFormat) &#123;</span><br><span class="line">      other.valueFormat = normalizeDateFormat(valueFormat)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return h(</span><br><span class="line">      ElTimePicker,</span><br><span class="line">      Object.assign(&#123;&#125;, context.data, &#123; props: other, attrs: undefined &#125;),</span><br><span class="line">      context.slots()</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br> </p><p>另外，我们也会移植一些 element-plus 的新组件，比如 <code>TreeSelect</code>。</p><p>对于 icon 这类差异比较大，我们直接放弃了。可以使用外部图标库或者 SVG 组件库（参考这个<a href="https://github.com/wakeadmin/tools/tree/main/packages/icons" target="_blank" rel="noopener">实现</a>跨版本的 SVG 图标库）。</p><p><br><br><br><br><br> </p><h3 id="router-adapter"><a href="#router-adapter" class="headerlink" title="router-adapter"></a>router-adapter</h3><p>我们的组件库是可能会涉及到路由的订阅和操作。因为 vue-router API 差异并不大，处理起来会简单很多。</p><p>不管是 vue 2 还是 3，vue-router 都会在组件实例上挂载相关的 API, 我们直接获取就行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface RouteLike &#123;</span><br><span class="line">  query: Record&lt;string, any&gt;</span><br><span class="line">  params: Record&lt;string, any&gt;</span><br><span class="line">  hash: string</span><br><span class="line">  path: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export type RouteLocation =</span><br><span class="line">  | string</span><br><span class="line">  | &#123;</span><br><span class="line">      query?: Record&lt;string, any&gt;</span><br><span class="line">      hash?: string</span><br><span class="line">      path?: string</span><br><span class="line">      name?: string</span><br><span class="line">      params?: Record&lt;string, any&gt;</span><br><span class="line">      replace?: boolean</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">export interface RouterLike &#123;</span><br><span class="line">  push(to: RouteLocation): Promise&lt;any&gt;</span><br><span class="line">  replace(to: RouteLocation): Promise&lt;any&gt;</span><br><span class="line">  back(): void</span><br><span class="line">  forward(): void</span><br><span class="line">  go(delta: number): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function useRouter() &#123;</span><br><span class="line">  const instance = getCurrentInstance()</span><br><span class="line"></span><br><span class="line">  if (isVue2) &#123;</span><br><span class="line">    return (instance?.proxy?.$root as &#123; $router: RouterLike &#125; | undefined)?.$router</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return (instance?.root?.proxy as unknown as &#123; $router: RouterLike &#125;)?.$router</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ... useRoute 同理</span><br></pre></td></tr></table></figure><p><br> </p><p>其他的库可以采取类似的策略。</p><p><br><br><br><br><br> </p><h3 id="🎉-开源-🎉"><a href="#🎉-开源-🎉" class="headerlink" title="🎉 开源 🎉"></a>🎉 开源 🎉</h3><p>借着这篇文章，我们也将相关的<a href="https://github.com/wakeadmin" target="_blank" rel="noopener">程序开源了</a>! 希望能帮助到大家！</p><ul><li><a href="https://github.com/wakeadmin/tools/tree/main/packages/h" target="_blank" rel="noopener">jsx-runtime 实现</a></li><li><a href="https://github.com/wakeadmin/components" target="_blank" rel="noopener">组件库实现</a></li></ul><p>欢迎 Fork Star PR</p><p><br><br><br><br><br> </p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://www.notion.so/Vue-2-3-302cbe0e37794345bbfbd89e32d617db?pvs=21" target="_blank" rel="noopener">Vue 2/3 渲染函数差异以及兼容方案</a></li><li><a href="https://github.com/vuejs/core/pull/7963" target="_blank" rel="noopener">feat(types): <code>defineComponent()</code> with generics support</a></li><li><a href="https://cn.vitejs.dev/config/" target="_blank" rel="noopener">vitejs</a></li><li><a href="https://github.com/vitejs/vite-plugin-vue" target="_blank" rel="noopener">https://github.com/vitejs/vite-plugin-vue</a></li><li><a href="https://github.com/vitejs/vite-plugin-vue2" target="_blank" rel="noopener">https://github.com/vitejs/vite-plugin-vue2</a></li><li><a href="https://github.com/vuejs/babel-plugin-jsx" target="_blank" rel="noopener">https://github.com/vuejs/babel-plugin-jsx</a></li><li><a href="https://github.com/vuejs/jsx-vue2" target="_blank" rel="noopener">https://github.com/vuejs/jsx-vue2</a></li><li><a href="https://github.com/vuejs/language-tools" target="_blank" rel="noopener">https://github.com/vuejs/language-tools</a></li><li><a href="https://github.com/vuejs/vue-loader/" target="_blank" rel="noopener">https://github.com/vuejs/vue-loader/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/component-for-vue2-3/Untitled.jpeg&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;Vue 3 已经&lt;a href=&quot;https://vue-js.com/topic/5f6562
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>现代前端框架的渲染模式</title>
    <link href="https://bobi.ink/2023/06/05/render-patterns/"/>
    <id>https://bobi.ink/2023/06/05/render-patterns/</id>
    <published>2023-06-04T16:00:00.000Z</published>
    <updated>2023-06-05T03:25:04.885Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要参考的内容来源是<a href="https://www.patterns.dev/" target="_blank" rel="noopener">patterns.dev</a>。这个网站收录了许多实用的前端设计模式，大家赶紧收藏起来！</p></blockquote><p><br></p><p>React 发布已经十年了，笔者接触前端差不多也有十年时间了。说实话，如果没有 <a href="https://search.douban.com/book/subject_search?search_text=head+first&amp;cat=1001" target="_blank" rel="noopener">Head First 系列图书</a>，我可能都没有走上编程这条道路。</p><p><br></p><p><img src="/images/render-patterns/Untitled.png" alt="Head first"><br>Head first</p><p><br></p><p>尽管现在看来这系列图书内容可能过时了。</p><p>Head First 系列图书让我知道，原来编程也可以这么通俗易懂的，对于刚接触这个领域的同学来说，从这里可以获得很多信心和成就感。<br>这种风格也一直影响着我，学习和工作、传道授业过程中，我会努力把复杂的事情简化、通俗化，提炼本质。</p><p><br><br><br></p><p>这十年，前端渲染方式一直在演进，我觉得大概可以分为以下三个阶段：</p><p><img src="/images/render-patterns/Untitled%201.png" alt="Untitled"></p><ul><li>传统 SSR: 那时候前端还没有分离，在 JSP、ASP、Ruby on Rails、Django 这些 MVC 框架下，通过模板来渲染页面。jQuery 是这个阶段的主角</li><li>前后端分离：从 Node.js 发布，到目前为止，是前端发展最迅速的 10 年。<br>前后端分离的典型代表是 Angular 和 React、Vue 等框架，我觉得，促进前后端分离的主要原因还是<strong>随着需求的复杂化，分工精细化了</strong>。 前端可以专注于 UI 的设计和交互逻辑。后端只需要提供 API，不需要关心前端的具体实现。</li><li>同构前端：这几年前端框架的发展进入的深水区，随着云原生、容器技术、Serverless、边缘计算等底层技术设施的普及，也让‘前端’生存范围延展到服务端。前端开始寻求 <code>UX</code> 和 <code>DX</code> 的平衡点</li></ul><p><br><br><br><br><br></p><p>通过这篇文章，你就可以知道近些年前端渲染模式的演变。</p><p>废话不多说，直接开始吧。</p><p><br><br><br><br><br></p><h2 id="csr-客户端渲染"><a href="#csr-客户端渲染" class="headerlink" title="CSR - 客户端渲染"></a>CSR - 客户端渲染</h2><p><img src="/images/render-patterns/Untitled%202.png" alt="Untitled"></p><p>这个我们再熟悉不过了， 即前端页面在浏览器中渲染，服务端仅仅是静态资源服务器(比如 nginx)。</p><p>初始的 HTML 文件只是一个空壳，我们需要等待 JavaScript 包加载和执行完毕，才能进行交互，白屏时间比较长。</p><ul><li>优点<ul><li>部署简单</li><li>页面过渡、功能交互友好</li><li>适合复杂交互型应用程序开发</li></ul></li><li>缺点<ul><li><code>SEO</code> 不友好</li><li>白屏时间长</li><li>可能需要复杂的状态管理。时至今日，状态管理方面的轮子还在不停地造</li></ul></li></ul><p><br><br><br><br><br></p><h2 id="ssr-服务端渲染"><a href="#ssr-服务端渲染" class="headerlink" title="SSR - 服务端渲染"></a>SSR - 服务端渲染</h2><p><img src="/images/render-patterns/Untitled%203.png" alt="Untitled"></p><p>为了解决 SEO 和白屏问题，各大框架开始支持在服务端渲染 HTML 字符串。</p><p>SSR 把数据拉取放到了服务端，因为离数据源比较近，数据拉取的速度会快一点。但这也不是完全没有副作用，因为需要在服务端等待数据就绪, <code>TTFB(Time to First Byte)</code> 相比 CSR 会长一点。</p><p>SSR 只是给我们准备好了初始的数据和 HTML, 实际上和 CSR 一样，我们还是需要加载完整的<code>客户端程序</code>，然后在浏览器端重新渲染一遍(更专业的说是 <code>Hydration  水合/注水</code>)，才能让 DOM 有交互能力。</p><p><strong>也就说， <code>FCP(First Contentful Paint)</code> 相比 CSR 提前了, 但是 <code>TTI(Time to Interactive)</code> 并没有太多差别。只是用户可以更快地看到内容了。</strong></p><blockquote><p>hydration 的主要目的是挂载事件处理器、触发副作用等等</p></blockquote><p>优点</p><ul><li>SEO 友好</li><li>用户可以更快看到内容了</li></ul><p>缺点</p><ul><li>部署环境要求。需要 Nodejs 等 JavaScript 服务端运行环境</li><li>需要包含完整的 JavaScript 客户端渲染程序，<code>TTI</code> 还有改善空间</li></ul><p><br><br><br><br><br><br><br></p><h2 id="ssg-静态生成"><a href="#ssg-静态生成" class="headerlink" title="SSG - 静态生成"></a>SSG - 静态生成</h2><p><img src="/images/render-patterns/Untitled%204.png" alt="Untitled"></p><p>对于完全静态的页面，比如博客，公司主页等等，也可以使用 SSG 静态渲染。</p><p>和 SSR 的区别是，SSG 是在<code>构建时</code>渲染的。</p><p>和 CSR 一样，因为是静态的，所以在服务端不需要渲染运行时，部署在静态服务器就行了。</p><p>VuePress、VitePress、Gatsby、Docusaurus 这些框架都属于 SSG 的范畴。</p><p><br><br><br></p><p>优点</p><ul><li>相比 SSR, 因为不需要服务端运行时、数据拉取，TTFB/FCP 等都会提前。</li></ul><p>缺点</p><ul><li>和 SSR 一样，也有客户端渲染程序、需要进行 Hydrate。<br>对于<code>内容为中心</code>的站点来说，实际上并不需要太多交互，客户端程序还有较大压缩的空间。</li><li>在构建时渲染，如果内容变更，需要重新构建，比较麻烦</li></ul><p><br><br><br><br><br><br><br></p><h2 id="isg-增量静态生成"><a href="#isg-增量静态生成" class="headerlink" title="ISG - 增量静态生成"></a>ISG - 增量静态生成</h2><p><img src="/images/render-patterns/Untitled%205.png" alt="Untitled"></p><p>ISG 是 SSG 的升级版。解决 SSG 内容变更繁琐问题。</p><p>ISG 依旧会在构建时预渲染页面，但是这里多出了一个<code>服务端运行时</code>，这个运行时会按照一定的过期/刷新策略(通常会使用 <strong><a href="https://web.dev/stale-while-revalidate/" target="_blank" rel="noopener">stale-while-revalidate</a></strong> )来重新生成页面。</p><p><br><br><br><br><br><br><br></p><h2 id="progressive-hydration-渐进水合"><a href="#progressive-hydration-渐进水合" class="headerlink" title="Progressive Hydration - 渐进水合"></a>Progressive Hydration - 渐进水合</h2><p><img src="/images/render-patterns/Untitled%206.png" alt="Untitled"></p><p>上文提到，常规的 SSR 通常需要完整加载客户端程序(上图的 bundle.js)，水合之后才能得到可交互页面，这就导致 <code>TTI</code> 会偏晚。</p><p>最直接的解决办法就是压缩客户端程序的体积。那么自然会想到使用<code>代码分割</code>(code splitting)技术。<br><code>渐进式水合 （Progressive Hydration ）</code> 就是这么来的。</p><p>如上图，我们使用<code>代码分割</code>的方式，将 Foo、Bar 抽取为<code>异步组件</code>，抽取后<code>主包</code>的体积下降了，<code>TTI</code> 就可以提前了。</p><p>而 Foo、Bar 可以按照一定的策略来按需加载和水合，比如在视口可见时、浏览器空闲时，或者交给 <code>React Concurrent Mode</code> 根据交互的优先级来加载。</p><p>React 18 官方支持了渐进式水合（官方叫 <code>Selective Hydration</code>）。</p><p>要深入了解 Progress Hydration, 可以看这个<a href="https://www.youtube.com/watch?v=k-A2VfuUROg&amp;t=960s" target="_blank" rel="noopener">视频</a>。</p><p><br><br><br><br><br></p><h2 id="ssr-with-streaming-流式-ssr"><a href="#ssr-with-streaming-流式-ssr" class="headerlink" title="SSR with streaming - 流式 SSR"></a>SSR with streaming - 流式 SSR</h2><p><img src="/images/render-patterns/Untitled%207.png" alt="Untitled"></p><p>这个很好理解。尤其是在最近 <code>ChatGPT</code> 这么火。ChatGPT API 有两种响应模式：普通响应、流式响应</p><ul><li><a href="https://react.dev/reference/react-dom/server/renderToString" target="_blank" rel="noopener">renderToString</a> → 普通响应。即 SSR 会等待完整的 HTML 渲染完毕后，才给客户端发送第一个字节。</li><li><a href="https://react.dev/reference/react-dom/server/renderToNodeStream" target="_blank" rel="noopener">renderToNodeStream</a> → 流式响应。渲染多少，就发送多少。就像 ChatGPT 聊天消息一样，一个字一个字的蹦，尽管接收完整消息的时间可能差不多，用户体验却相差甚远。</li></ul><p>浏览器能够很好地处理 HTML 流，快速地将内容呈现给用户，而不是白屏干等。</p><p>下面这张图可以更直观感受两者区别：</p><p><img src="/images/render-patterns/Untitled%208.png" alt="来源：[https://mxstbr.com/thoughts/streaming-ssr/](https://mxstbr.com/thoughts/streaming-ssr/)"></p><p>来源：<a href="https://mxstbr.com/thoughts/streaming-ssr/" target="_blank" rel="noopener">https://mxstbr.com/thoughts/streaming-ssr/</a></p><p>对于常规的流式 SSR，优化效果可能没有我们想象的那么明显。<strong>因为框架还是得等数据拉取完成之后才能开始渲染</strong>。因此，除非是比较复杂、长序列的 HTML 树，至上而下需要较长时间的渲染，否则效果并不明显。</p><p><br><br><br></p><p>优点</p><ul><li>相比普通响应，流式响应可以提前 TTFB 和 FCP, 浏览器不用空转等待，可以连续绘制。</li></ul><p>缺点</p><ul><li><strong>数据拉取是 TTFB/FCP 的主要阻塞原因。为了解决这个问题，下文的 <code>Selective Hydration</code> 如何巧妙地解决这个问题。</strong></li></ul><p><br><br><br><br><br></p><h2 id="selective-hydration-选择性水合"><a href="#selective-hydration-选择性水合" class="headerlink" title="Selective Hydration - 选择性水合"></a>Selective Hydration - 选择性水合</h2><p><img src="/images/render-patterns/Untitled%209.png" alt="Untitled"></p><p><code>选择性水合（Progressive Hydration）</code> 是 <code>渐进式水合(Progressive Hydration)</code> 和 <code>流式SSR(SSR with Streaming)</code> 的升级版。<strong>主要通过选择性地跳过‘<code>慢组件</code>’，避免阻塞，来实现更快的 HTML 输出， 从而让流式响应发挥应有的作用。</strong></p><blockquote><p><code>慢组件</code>通常指的是：需要异步获取数据、体积较大、或者是计算量比较复杂的组件。</p></blockquote><p>比较典型的<code>慢组件</code>是异步数据获取的组件, 如下图，未开启 Selective Hydration 的情况，会等待所有异步任务完成后才开始输出，而 Selective Hydration 可以跳过这些组件，等待它们就绪后，继续输出。</p><p><img src="/images/render-patterns/Untitled%2010.png" alt="Untitled"></p><p>我们可以在最新的 Next.js(当前是 13.4) 演示一下。</p><details><br> <summary>没有开启 Selective Hydration 的 Demo:</summary><br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function delay(time: number) &#123;</span><br><span class="line">  return new Promise((resolve) =&gt; setTimeout(resolve, time))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取关键数据</span><br><span class="line"> */</span><br><span class="line">function getCrucialData() &#123;</span><br><span class="line">  return delay(1000).then(() =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      data: Math.random(),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getData(time: number) &#123;</span><br><span class="line">  return delay(time).then(() =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      data: Math.random(),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Foo = async () =&gt; &#123;</span><br><span class="line">  const data = await getData(1000)</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;foo: &#123;data.data&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Bar = async () =&gt; &#123;</span><br><span class="line">  const data = await getData(2000)</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;bar: &#123;data.data&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 页面 🔴</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">export default async function WithoutSelective() &#123;</span><br><span class="line">  // 获取关键数据</span><br><span class="line">  const crucialData = await getCrucialData()</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Without Selective&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;This page is rendered without Selective Hydration.&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;crucial data: &#123;crucialData.data&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Foo&gt;&lt;/Foo&gt;</span><br><span class="line">      &lt;Bar&gt;&lt;/Bar&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>运行结果：浏览器等待响应的时间为 3s<br><img src="/images/render-patterns/Untitled%2011.png" alt="Untitled"><br>即所有<code>服务端组件（Server Component）</code> 就绪后才会有实际的内容输出。<br><br></details><p><br><br><br></p><p>开启 Selective Hydration 很简单，我们只需要用 Suspend 包裹起来，提示 React 这可能是一个‘慢组件’，可以跳过他：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default async function WithoutSelective() &#123;</span><br><span class="line">  // 获取关键数据</span><br><span class="line">  const crucialData = await getCrucialData()</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Without Selective&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;This page is rendered without Selective Hydration.&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;crucial data: &#123;crucialData.data&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Suspense fallback=&quot;foo loading&quot;&gt;</span><br><span class="line">        &lt;Foo&gt;&lt;/Foo&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">      &lt;Suspense fallback=&quot;bar loading&quot;&gt;</span><br><span class="line">        &lt;Bar&gt;&lt;/Bar&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>现在来看运行结果：</p><p><img src="/images/render-patterns/Untitled%2012.png" alt="Untitled"></p><p>明显 TTFB 提前了！但是完整的请求时间没变。</p><p><br></p><p>当 Foo 和 Bar 就绪后，Next.js 会将渲染结果写入流中。怎么做到的？</p><p><br></p><p>看一眼 HTML 就知道了：</p><p><img src="/images/render-patterns/Untitled%2013.png" alt="Untitled"></p><p>对于<code>慢组件</code>，React 会先渲染 Suspend 的 fallback 内容，并留一个插槽。</p><p>继续往下看，可以看到 Foo、Bar 的渲染结果：</p><p><img src="/images/render-patterns/Untitled%2014.png" alt="Untitled"></p><p>接着将渲染结果替换掉插槽。用于后续的水合。</p><p><br><br><br><br><br></p><p>总之，在服务端，Selective Hydration 在 SSR With Streaming 的基础上，通过选择性地跳过一些低优先级的慢组件来优化了 TTFB(主要的，相对于 FCP 等指标也优化了)，更快地向用户呈现页面。</p><p>在客户端 Selective Hydration 的运行过程同 Progressive Hydration 。</p><p>关于 Selective Hydration 细节，可以阅读以下文章：</p><ul><li><a href="https://github.com/reactwg/react-18/discussions/130" target="_blank" rel="noopener">New in 18: Selective Hydration</a></li><li><a href="https://github.com/reactwg/react-18/discussions/37" target="_blank" rel="noopener">New Suspense SSR Architecture in React 18</a></li></ul><p><br><br><br><br><br><br><br></p><h2 id="islands-architecture-岛屿架构"><a href="#islands-architecture-岛屿架构" class="headerlink" title="Islands Architecture - 岛屿架构"></a>Islands Architecture - 岛屿架构</h2><p><img src="/images/render-patterns/Untitled%2015.png" alt="Untitled"></p><p>近两年，<strong>去 JavaScript 成为一波小趋势</strong>，这其中的典型代表是 <code>Islands Architecture</code> (岛屿架构)和 <code>React Server Component</code>(RSC, React 服务端组件)。</p><p>它们主张是：<strong>在服务端渲染，然后去掉不必要 JavaScript</strong></p><p>岛屿架构的主要代表是 <code>Astro</code>。如上图，Astro 在服务端渲染后，<strong>默认情况下，在客户端侧没有客户端程序和水合的过程。而对于需要 JavaScript 增强，实现动态交互的组件，需要显式标记为岛屿。</strong></p><p><br></p><p>这有点类似 Progressive Hydration 的意思。但是还是有很大的差别：</p><ul><li>岛屿是在<code>去 JavaScript</code> 这个背景下的交互增强手段。按 Astro 解释是： 你可以将‘岛屿’想象成在一片由<em>静态（不可交互）的 HTML</em> 页面中的<em>动态岛屿</em></li><li>每个岛屿都是独立加载、局部水合。而 Progressive Hydration 是整棵树水合的分支，只不过延后了。</li><li>岛屿可以框架无关。</li></ul><p><br></p><p>去 JavaScript 后，可以缓解典型的 SSR <code>TTI</code> 问题。<strong>但是岛屿架构并不能通吃所有的场景，最擅长的是”内容为中心“的站点，即当静态的页面比重远高于动态比重时，去 JavaScript 的收益才是显著的。</strong></p><p><br><br><br><br><br></p><h2 id="react-server-component-react-服务端组件"><a href="#react-server-component-react-服务端组件" class="headerlink" title="React Server Component - React 服务端组件"></a>React Server Component - React 服务端组件</h2><p><img src="/images/render-patterns/Untitled%2016.png" alt="Untitled"></p><p>在笔者看来，<code>React Server Component(RSC)</code> 本质上和岛屿架构的目的是一样的，都是去 JavaScript。只是实现的手段不同。</p><p><br></p><p>这是 Next.js 官方文档的示例图：和岛屿架构类似，对于静态的内容推荐使用 <code>Server Component (SC),</code> 而需要交互增强的，可以使用 <code>Client Component (CC)</code>。</p><p><img src="/images/render-patterns/Untitled%2017.png" alt="Untitled"></p><p><br></p><p>顾名思义，RSC <strong>就是只能在服务端运行的组件</strong>。下面简单对比一下两者的区别：</p><table><thead><tr><th></th><th>Server Component</th><th>Client Component</th></tr></thead><tbody><tr><td>运行环境</td><td>服务端</td><td>- 服务端 + 客户端</td></tr><tr><td>- 仅客户端</td></tr><tr><td>JavaScript</td><td>服务端组件依赖的相关程序对客户端不可见。</td></tr><tr><td>在这里实现了 ‘去 JavaScript’</td><td>需要打包分发给客户端</td></tr><tr><td>水合</td><td>不需要水合</td><td>需要水合</td></tr><tr><td>支持 async</td><td>Y</td><td>N</td></tr><tr><td>支持状态(state, context)</td><td>N</td><td>Y</td></tr><tr><td>支持事件、副作用</td><td>N</td><td>Y</td></tr></tbody></table><blockquote><p>RSC 优点类似 React Hooks 出来之前的<a href="https://web.archive.org/web/20170621181013/https://facebook.github.io/react/docs/components-and-props.html" target="_blank" rel="noopener">函数组件</a>: 就是一个普通的函数，不能使用 hooks，没有状态，只会被调用一次。</p></blockquote><p>你可以通过 <a href="https://nextjs.org/docs/getting-started/react-essentials" target="_blank" rel="noopener">Next.js 的文档</a>，深入学习 RSC。React 官方的<a href="https://github.com/reactwg/server-components/discussions" target="_blank" rel="noopener">讨论组</a>也是不错的一手学习场地。</p><p><br><br><br></p><p><strong>那么相比岛屿架构呢？</strong></p><p>优点</p><ul><li>Server Component 和 Client Component 都是 React 框架的组件，尽管有些区别，但是心智模型是统一的。</li><li>React Server Component 是 React 框架下一体化的原生解决方案，支持和 Selective Hydration 配合使用。岛屿架构只是一个架构模式。</li><li>可以进行更细粒度和更灵活的组合。</li></ul><p>缺点</p><ul><li>Server Component 和 Client Component 还是有较大差别，在组合、通信上也有较多限制，需要开发者规划好服务端和客户端的边界。初期有一定上手门槛。<br>当然，Islands 可能也有类似的问题。</li></ul><p><br><br><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文篇幅较长，我给大家整理了这些渲染模式的发展历程和关系脉络</p><p><img src="/images/render-patterns/Untitled%2018.png" alt="Untitled"></p><p>任何技术的迭代都是有其动机和脉络。不推荐大家面向热度编程，大部分情况下，做到‘知其然，也知其所以然’，就足够了。</p><p><br><br><br><br><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://www.patterns.dev/posts/react-selective-hydration" target="_blank" rel="noopener">Pattern dev</a></li><li><a href="https://nextjs.org/docs/getting-started/react-essentials" target="_blank" rel="noopener">Next.js</a></li><li><a href="https://nextjs.org/docs/pages/building-your-application/data-fetching/incremental-static-regeneration" target="_blank" rel="noopener">Next.js Incremental Static RegenerationExamples</a></li><li><a href="https://github.com/reactwg/server-components/discussions" target="_blank" rel="noopener">reactwg/<strong>server-components</strong></a></li><li><strong><a href="https://dev.to/this-is-learning/is-0kb-of-javascript-in-your-future-48og" target="_blank" rel="noopener">Is 0kb of JavaScript in your Future?</a></strong></li><li><a href="https://jasonformat.com/islands-architecture/" target="_blank" rel="noopener">Islands Architecture</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文主要参考的内容来源是&lt;a href=&quot;https://www.patterns.dev/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;patterns.dev&lt;/a&gt;。这个网站收录了许多实用的前端设计模式，大家赶紧收藏起来！
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>岛屿架构</title>
    <link href="https://bobi.ink/2023/06/01/island-pattern/"/>
    <id>https://bobi.ink/2023/06/01/island-pattern/</id>
    <published>2023-05-31T16:00:00.000Z</published>
    <updated>2023-06-01T10:07:58.113Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1516091877740-fde016699f2c?ixlib=rb-4.0.3&amp;q=85&amp;fm=jpg&amp;crop=entropy&amp;cs=srgb&amp;w=6000" alt="https://images.unsplash.com/photo-1516091877740-fde016699f2c?ixlib=rb-4.0.3&amp;q=85&amp;fm=jpg&amp;crop=entropy&amp;cs=srgb&amp;w=6000"></p><p>好久没跟大家见面了。这两三年一直专注于公司的开发工作，做了很多事情，但回头看看，感觉这两年一直在吃 ’老本‘，前端相关的技术也没怎么追了。</p><p>现在重新捡起笔吧！补补课，记录一些最近学到的新东西，以及过去几年总结。</p><p>首先从岛屿架构开始吧。</p><h2 id="岛屿架构"><a href="#岛屿架构" class="headerlink" title="岛屿架构"></a>岛屿架构</h2><p>岛屿架构(<a href="https://www.patterns.dev/posts/islands-architecture" target="_blank" rel="noopener">Islands Architecture</a>) 如今已经不是新鲜的概念了，社区上已经有了较多成熟的方案。</p><p>概览图：</p><p><img src="/images/island-pattern/Untitled.png" alt="Untitled"></p><p><br><br><br><br><br></p><p>这其中的典型代表是 <a href="https://docs.astro.build/zh-cn/concepts/islands/" target="_blank" rel="noopener">Astro</a>。Astro 对岛屿架构的解释，也非常直观：</p><blockquote><p>“Astro 群岛“指的是<code>静态 HTML</code> 中的<code>交互性的 UI 组件</code>。一个页面上可以有多个岛屿，并且每个岛屿都被<code>独立呈现</code>。<strong>你可以将它们想象成在一片由静态（不可交互）的 HTML 页面中的动态岛屿</strong>。</p></blockquote><p>从上面这句话的定义中可以提炼一些要点：</p><ul><li>静态 HTML。</li><li>交互性的 UI 组件。</li><li>多个岛屿，支持独立呈现。</li></ul><p><br><br><br></p><p>为了解析这些要点，我们还是得简单了解一下 Astro 这个框架的特性。</p><p>Astro 宣称自己是 ‘<strong><code>zero-JS frontend architecture</code></strong>’，即 Astro 在服务端渲染静态 HTML，客户端中不需要加载额外的 JS 就能完整呈现内容。</p><p><br><br><br><br><br><br><br></p><hr><p>写一个简单 DEMO 试试：</p><p>React 组件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; useState &#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">export const Counter = () =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0)</span><br><span class="line"></span><br><span class="line">  return &lt;div onClick=&#123;() =&gt; setCount((i) =&gt; i + 1)&#125;&gt;click me to increment: &#123;count&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Astro 文件：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">import Layout from '../layouts/Layout.astro';</span><br><span class="line">import Card from '../components/Card.astro';</span><br><span class="line">import &#123; Counter &#125; from '../components/Counter';</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Layout</span> <span class="attr">title</span>=<span class="string">"Welcome to Astro."</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">role</span>=<span class="string">"list"</span> <span class="attr">class</span>=<span class="string">"link-card-grid"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Card</span></span></span><br><span class="line"><span class="tag">        <span class="attr">href</span>=<span class="string">"https://docs.astro.build/"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">title</span>=<span class="string">"Documentation"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">body</span>=<span class="string">"Learn how Astro works and explore the official API docs."</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Card</span></span></span><br><span class="line"><span class="tag">        <span class="attr">href</span>=<span class="string">"https://astro.build/integrations/"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">title</span>=<span class="string">"Integrations"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">body</span>=<span class="string">"Supercharge your project with new frameworks and libraries."</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  ...;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这语法，astro 集大家之所长，吸取了 Vue SFC 和 React 的 JSX, 还有 MDX。</p><p><img src="/images/island-pattern/Untitled%201.png" alt="Untitled"></p><p>运行后， 服务端直出 HTML，除了 HMR ，没有引入额外的 JavaScript。真 Zero JS!</p><p><br><br><br><br><br></p><hr><p>然而，这个有别于典型的 SSR 框架。SSR 也是在服务端渲染完整 HTML 树，但是在客户端依然需要加载完整的视图框架代码，然后进行水合(Hydration)，才能让页面变得可交互:</p><p><img src="/images/island-pattern/Untitled%202.png" alt="Untitled"></p><p>那 Astro 没有 JS，显然是无法与用户进行动态交互的。Astro 的解决办法就是 <code>岛屿架构</code>, 我们只需将需要动态交互的页面模块声明为岛屿，如下图，页头和图片轮播就是可交互的岛屿。</p><p><img src="/images/island-pattern/Untitled%203.png" width="400px"></p><p>来源：astro 文档</p><p><br><br><br><br><br><br><br></p><hr><p>现在将 React 组件声明为岛屿：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">---</span></span><br><span class="line">import Layout from '../layouts/Layout.astro';</span><br><span class="line">import Card from '../components/Card.astro';</span><br><span class="line">import &#123; Counter &#125; from '../components/Counter';</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"></span><br><span class="line">&lt;Layout title="Welcome to Astro."&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line"><span class="deletion">-    &lt;Counter/&gt;</span></span><br><span class="line"><span class="addition">+    &lt;Counter client:load /&gt;</span></span><br><span class="line">    &lt;ul role="list" class="link-card-grid"&gt;</span><br><span class="line">      &lt;Card</span><br><span class="line">        href="https://docs.astro.build/"</span><br><span class="line">        title="Documentation"</span><br><span class="line">        body="Learn how Astro works and explore the official API docs."</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Card</span><br><span class="line">        href="https://astro.build/integrations/"</span><br><span class="line">        title="Integrations"</span><br><span class="line">        body="Supercharge your project with new frameworks and libraries."</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">&lt;/Layout&gt;</span><br></pre></td></tr></table></figure><p>我们只需将对应的 React 组件加上 <code>client:load</code> 指令，Astro 就是将其识别为岛屿，该 React 组件的代码及其相关依赖会被打包到一起，在客户端端加载和水合。</p><p><img src="/images/island-pattern/Untitled%204.png" alt="Untitled"></p><p>现在我们的 Counter 组件在客户端就是一个可交互的状态了。Astro 基本上没有什么上手门槛，建议读者自己玩一下。有机会再展开讲一下它的实现原理。</p><hr><p><br><br><br><br><br></p><p>有了‘岛屿’赋能的 Astro 架构：</p><p><img src="/images/island-pattern/Untitled%205.png" alt="Untitled"></p><p>Astro 在服务端渲染完整的 HTML 树，然后在客户端中按需加载岛屿代码，并进行水合。看起来有点像微前端、或者 iframe 这样的机制。</p><p>现在来回顾一下开头提到的 <code>‘要点’</code>：</p><table><thead><tr><th></th><th>岛屿架构</th><th>SSR + CSR</th><th>CSR</th></tr></thead><tbody><tr><td>静态 HTML</td><td>静态 HTML 优先，无 JavaScript</td><td>服务端渲染 HTML 初始内容, 包含完整的客户端副本</td><td>完全在客户端加载渲染</td></tr><tr><td>交互性的 UI 组件</td><td>默认完全静态，通过岛屿局部增强可交互性</td><td>全局可交互</td><td>全局可交互</td></tr><tr><td>多个岛屿，支持独立呈现</td><td>岛屿之间互相独立，可以独立加载和交互</td><td>完整加载。可以通过代码分块 + <a href="https://www.patterns.dev/posts/progressive-hydration" target="_blank" rel="noopener">https://www.patterns.dev/posts/progressive-hydration</a> 实现按需加载</td><td>完整加载。可以通过代码分块实现按需加载</td></tr></tbody></table><p><br><br><br><br><br></p><h2 id="岛屿架构的优势"><a href="#岛屿架构的优势" class="headerlink" title="岛屿架构的优势"></a>岛屿架构的优势</h2><p>岛屿架构非常适合<code>以内容为中心</code>的网站，比如博客，文档网站，新闻网站等等。在 Astro 的定位非常清晰，它把站点类型分为两种：</p><ul><li>内容为中心 → 也称为 网站 → Astro 擅长</li><li>交互为中心的 → 也称为 Web 应用程序 → 应该使用 Next.js 或者 Nuxt.js 这样的框架</li></ul><p>在岛屿架构擅长的场景中，Astro 给出了比较：</p><ul><li><a href="https://twitter.com/t3dotgg/status/1437195415439360003" target="_blank" rel="noopener">Astro vs. SPA (Next.js)</a> - 94% less JavaScript</li><li><a href="https://twitter.com/jlengstorf/status/1442707241627385860?lang=en" target="_blank" rel="noopener">Astro vs. SPA (Next.js)</a> - 34% 更快地加载</li><li><a href="https://vanntile.com/blog/next-to-astro" target="_blank" rel="noopener">Astro vs. SPA (Next.js)</a> – 65% 网络使用减少</li><li><a href="https://www.youtube.com/watch?v=2ZEMb_H-LYE&amp;t=8163s" target="_blank" rel="noopener">Astro vs. SPA (Remix, SvelteKit)</a> - “这令人置信的 Google Lighthouse 分数”</li><li><a href="https://www.youtube.com/watch?v=2ZEMb_H-LYE&amp;t=8504s" target="_blank" rel="noopener">Astro vs. Qwik</a> - 43% 更快的 TTI</li></ul><p><br><br><br><br><br></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>岛屿架构本身概念并不复杂，是前端框架和工程化发展的一个阶段性质变结果。</p><p>前后端分离(分工上)还是不变的趋势，相比传统的 MPA ，岛屿架构更加现代化，拥有更好的开发体验。</p><p>相比 SPA，岛屿架构在<code>以内容为中心</code>的场景下，优势也非常明显。</p><p><br><br><br><br><br></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.patterns.dev/posts/islands-architecture" target="_blank" rel="noopener">Islands Architecture</a></li><li><a href="https://jasonformat.com/islands-architecture/" target="_blank" rel="noopener">Islands Architecture</a></li><li><a href="https://www.youtube.com/watch?v=k-A2VfuUROg" target="_blank" rel="noopener">Rendering on the Web: Performance Implications of Application Architecture</a></li><li><a href="https://dev.to/this-is-learning/is-0kb-of-javascript-in-your-future-48og" target="_blank" rel="noopener">Is 0kb of JavaScript in your Future?</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1516091877740-fde016699f2c?ixlib=rb-4.0.3&amp;amp;q=85&amp;amp;fm=jpg&amp;amp;crop=entropy&amp;amp;cs=srgb&amp;am
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Electron 低延迟视频流播放方案探索</title>
    <link href="https://bobi.ink/2020/04/05/video-stream/"/>
    <id>https://bobi.ink/2020/04/05/video-stream/</id>
    <published>2020-04-04T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.331Z</updated>
    
    <content type="html"><![CDATA[<p>好久不见，接近四个月没更新博客了! </p><p>去年<a href="https://juejin.im/post/5e0010866fb9a015fd69c645#comment" target="_blank" rel="noopener">最后一篇</a>文章介绍了我们的 Electron 桌面客户端的一些优化措施，这篇文章也跟我们正在开发的 Electron 客户端有一定关系。最近我们正在预研在 Electron 页面中实时播放会议视频流的方案。</p><p><br></p><p><img src="/images/video-push/conf.jpeg" alt></p><p><br></p><p>视频会议界面是最后一块没有被 Web 取代的页面, 它完全用原生开发的，所以开发效率比较低，比如要做一些动画效果开发很痛苦，难以响应多变的产品需求。所以我们在想: <strong>能不能将 Web 页面端来播放底层库 WebRTC 接收到的视频流</strong>? <strong>或者为什么不直接通过浏览器的 WebRTC API 来进行通讯呢</strong>？</p><p>先回答后者，因为我们视频会议这块的逻辑处理、音视频处理已经被抽取成独立的、跨平台的模块，统一进行维护；另外浏览器的 WebRTC API 提供的接口非常高级，就像一个黑盒一样，无法定制化、扩展，遇到问题也很难诊断和处理, 受限于浏览器。最大的原因还是变动有点大，时间上不允许。</p><p>因此目前只能选前者，即底层库给 Electron 页面推送视频流，在页面实时播放。 再此之前，笔者几乎没有接触过音视频开发，我能想到的是通过类似直播的方式，底层库作为”主播端”, Web 页面作为”观众端”。</p><p><img src="/images/video-push/overall.png" alt></p><p><br></p><p>因为视频流只是在本地进行转发，所以我们不需要考虑各种复杂的网络情况、带宽限制。唯一的要求是低延迟，低资源消耗：</p><ul><li>我们视频会议语音和视频是分离的。 只有一路混合语音，通过 SIP 传输。而会议视频则可能存在多路，使用 WebRTC 进行传输。我们不需要处理语音(由底层库直接播放), 这就要求我们的视频播放延迟不能太高, 出现语音和视频不同步。</li><li>不需要考虑浏览器兼容性。Electron 浏览器版本为 Chrome 80</li><li>本地转发，不需要考虑网络情况、带宽限制</li></ul><p><br><br><br></p><p><strong>最近因为工作需要才有机会接触到音视频相关的知识，我知道的只是皮毛，所以文章肯定存在不少问题，敬请斧正</strong>。下面，跟着音视频小白的我，一起探索探索有哪些方案。</p><p><br><br><br></p><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#①-典型的web直播方案">① 典型的Web直播方案</a><ul><li><a href="#rtmp-推流">RTMP 推流</a></li><li><a href="#rtmp-拉流">RTMP 拉流</a></li><li><a href="#rtmp-低延迟优化">RTMP 低延迟优化</a></li></ul></li><li><a href="#②-jsmpeg--broadwayjs">② JSMpeg &amp; BroadwayJS</a><ul><li><a href="#relay-服务器">Relay 服务器</a></li><li><a href="#推送">推送</a></li><li><a href="#视频播放">视频播放</a></li><li><a href="#多进程优化">多进程优化</a></li><li><a href="#简单说一下-broadwayjs">简单说一下 Broadway.js</a></li></ul></li><li><a href="#③-直接渲染-yuv">③ 直接渲染 YUV</a></li><li><a href="#扩展阅读">扩展阅读</a></li></ul><!-- /TOC --><p><br><br><br></p><h2 id="①-典型的web直播方案"><a href="#①-典型的web直播方案" class="headerlink" title="① 典型的Web直播方案"></a>① 典型的Web直播方案</h2><p>Web 直播有很多方案(参考这篇文章：<a href="https://imweb.io/topic/5a542e43a192c3b460fce3a8" target="_blank" rel="noopener">《Web 直播，你需要先知道这些》</a>):</p><ul><li><strong>RTMP (Real Time Messaging Protocol)</strong> 属于 Adobe。延时低，实时性较好。不过浏览器需要借助 Flash 才能播放; 但是我们也可以转换成 HTTP/Websocket 流喂给 <a href="https://github.com/bilibili/flv.js/tree/master/docs" target="_blank" rel="noopener"><code>flv.js</code></a> 实现播放。</li><li><strong>RTP (Real-time Transport Protocol)</strong> <a href="https://www.jianshu.com/p/17997567d828" target="_blank" rel="noopener">WebRTC 底层就基于 RTP/RTCP</a>。实时性非常好，适用于视频监控、视频会议、IP 电话。</li><li><strong>HLS (Http Live Streaming)</strong> 苹果提出的基于 HTTP 的流媒体传输协议。Safari 支持较好，高版本 Chrome 也支持，也有一些比较成熟的第三方方案。</li></ul><p><br></p><p>HLS 延迟太高，不符合我们的要求，所以一开始就放弃了。搜了很多资料，很多都是介绍 RTMP 的，可见 RTMP 在国内采用有多广泛, 因此我们打算试试:</p><p><br></p><p>首先是搭建 RMTP 服务器，可以直接基于 <a href="https://github.com/illuspas/Node-Media-Server" target="_blank" rel="noopener">Node-Media-Server</a>，代码很简单:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NodeMediaServer = <span class="built_in">require</span>(<span class="string">'node-media-server'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// RMTP 服务器, 用于RTMP 推流和拉流</span></span><br><span class="line">  rtmp: &#123;</span><br><span class="line">    port: <span class="number">1935</span>, <span class="comment">// 1935 是RTMP的标准端口</span></span><br><span class="line">    chunk_size: <span class="number">0</span>,</span><br><span class="line">    gop_cache: <span class="literal">false</span>,</span><br><span class="line">    ping: <span class="number">30</span>,</span><br><span class="line">    ping_timeout: <span class="number">60</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// HTTP / WebSocket 流，暴露给 flv.js</span></span><br><span class="line">  http: &#123;</span><br><span class="line">    port: <span class="number">8000</span>,</span><br><span class="line">    allow_origin: <span class="string">'*'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nms = <span class="keyword">new</span> NodeMediaServer(config)</span><br><span class="line">nms.run()</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="rtmp-推流"><a href="#rtmp-推流" class="headerlink" title="RTMP 推流"></a>RTMP 推流</h3><p><a href="http://www.ffmpeg.org" target="_blank" rel="noopener"><code>ffmpeg</code></a> 是音视频开发的必备神器，本文将通过它来捕获摄像头，进行各种转换和处理，最后进行视频流推送。 下面看看怎么用 ffmpeg 进行 RTMP 推流。</p><p>首先进行视频采集，下面命令列举所有支持的设备类型：</p><blockquote><p>本文的所有命令都在 macOS 下面执行, 其他平台用法差不多，自行搜索</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -devices</span></span><br><span class="line">Devices:</span><br><span class="line"> D. = Demuxing supported</span><br><span class="line"> .E = Muxing supported</span><br><span class="line"> --</span><br><span class="line"> D  avfoundation    AVFoundation input device</span><br><span class="line"> D  lavfi           Libavfilter virtual input device</span><br><span class="line">  E sdl,sdl2        SDL2 output device</span><br></pre></td></tr></table></figure><p><br></p><p><code>macOS</code> 下通常使用 <code>avfoundation</code> 进行设备采集, 下面列举当前终端所有支持的输入设备:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> fmpeg -f avfoundation -list_devices <span class="literal">true</span> -i <span class="string">""</span></span></span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] AVFoundation video devices:</span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] [0] FaceTime HD Camera</span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] [1] Capture screen 0</span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] AVFoundation audio devices:</span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] [0] Built-in Microphone</span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] [1] Boom2Device</span><br></pre></td></tr></table></figure><p><br></p><p>我们将使用 <code>FaceTime HD Camera</code> 这个输入设备来采集视频，并推送 RTMP 流：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -r 30 -i <span class="string">"FaceTime HD Camera"</span> -c:v libx264 -preset superfast -tune zerolatency -an -f flv rtmp://localhost/live/<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p><br></p><p>稍微解释一下上面的命令:</p><ul><li><code>-f avfoundation -r 30 -i &quot;FaceTime HD Camera&quot;</code> 表示从 <code>FaceTime HD Camera</code> 中以 30 fps 的帧率采集视频</li><li><code>-c:v libx264</code> 输出视频的编码格式是 H.264,  RTMP 通常采用H.264 编码</li><li><code>-f flv</code> 指的视频的封包格式, RTMP 一般采用 flv 封包格式。</li><li><code>-an</code> 忽略音频流</li><li><code>-preset superfast -tune zerolatency</code> H.264 的转码预设参数和调优参数。会影响视频质量和压缩率</li></ul><p><br></p><blockquote><p><strong>封包格式(format)</strong>和<strong>编码(codec)</strong>是音视频开发中最基础的概念。<br><br><br><strong>封包格式</strong>: 相当于一种储存视频信息的容器，将编码好的音频、视频、或者是字幕、脚本之类的文件根据相应的规范组合在一起，从而生成一个封装格式的文件。常见的封包格式有 avi、mpeg、flv、mov 等<br><br><br><strong>编码格式</strong>: 编码主要的目的是为了压缩。从设备采集到的音视频流称为裸码流(rawvideo 格式, 即没有经过编码压缩处理的数据)。举例：一个 720p，30fps，60min 的电影，裸流大小为：12Bx1280x720x30x60x100 = 1.9T。这不管在文件系统上存储、还是在网络上传输，成本都太高了，所以我们需要编码压缩。 H264 是目前最常见的编码格式之一。</p></blockquote><p><br><br><br></p><h3 id="rtmp-拉流"><a href="#rtmp-拉流" class="headerlink" title="RTMP 拉流"></a>RTMP 拉流</h3><p>最简单的，我们可以使用 <a href="http://www.ffmpeg.org/ffplay.html" target="_blank" rel="noopener"><code>ffplay</code></a> (ffmpeg 提供的工具套件之一) 播放器来测试推流和拉流是否正常:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffplay rtmp://localhost/live/<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p><br></p><p>Flash 已经过时， 为了在 Web 页面中实现 RTMP 流播放，我们还要借助 <a href="https://github.com/bilibili/flv.js" target="_blank" rel="noopener"><code>flv.js</code></a>。 flvjs 估计大家都很熟悉(花边：如何看待哔哩哔哩的 flv.js 作者月薪不到 5000 元？)，它是 B 站开源的 flv 播放器。按照官方的介绍：</p><blockquote><p>flv.js works by transmuxing FLV file stream into ISO BMFF (Fragmented MP4) segments, followed by feeding mp4 segments into an HTML5 <code>&lt;video&gt;</code> element through <code>Media Source Extensions API</code>.</p></blockquote><p><br></p><p>上面提到，flv(Flash Video) 是一个视频封包格式，<code>flvjs</code> 做的就是<strong>把 flv 转换成 Fragmented MP4(ISO BMFF) 封包格式</strong>，然后喂给<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Media_Source_Extensions_API" target="_blank" rel="noopener">Media Source Extension API, MSE</a>, 接着我们将 MSE 挂载到 <code>&lt;video&gt;</code> 就可以直接播放了, 它的架构如下:</p><p><br></p><p><img src="/images/video-push/flv-arch.png" alt></p><p><br><br><br></p><p>flvjs 支持通过 HTTP Streaming、 WebSocket 或者自定义数据源等多种形式拉取二进制视频流。下面示例通过 flvjs 来拉取 <code>node-media-server</code> 的视频流:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/flv.js/1.5.0/flv.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;video id=<span class="string">"video"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span></span><br><span class="line">&lt;button id=<span class="string">"play"</span>&gt;play&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  if (flvjs.isSupported()) &#123;</span></span><br><span class="line"><span class="regexp">    const videoElement = document.getElementById('video');</span></span><br><span class="line"><span class="regexp">    const play = document.getElementById('play');</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    const flvPlayer = flvjs.createPlayer(</span></span><br><span class="line"><span class="regexp">      &#123;</span></span><br><span class="line"><span class="regexp">        type: 'flv',</span></span><br><span class="line"><span class="regexp">        isLive: true,</span></span><br><span class="line"><span class="regexp">        hasAudio: false,</span></span><br><span class="line"><span class="regexp">        url: 'ws:/</span><span class="regexp">/localhost:8000/</span>live/test.flv<span class="string">',</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        enableStashBuffer: true,</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    flvPlayer.attachMediaElement(videoElement);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    play.onclick = () =&gt; &#123;</span></span><br><span class="line"><span class="string">      flvPlayer.load();</span></span><br><span class="line"><span class="string">      flvPlayer.play();</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>完整示例代码在<a href="https://github.com/ivan-94/video-push/tree/master/rtmp" target="_blank" rel="noopener">这里</a></p></blockquote><p><br><br><br></p><h3 id="rtmp-低延迟优化"><a href="#rtmp-低延迟优化" class="headerlink" title="RTMP 低延迟优化"></a>RTMP 低延迟优化</h3><p><strong>推流端</strong></p><p><code>ffmpeg</code> 推流端可以通过一些控制参数来降低推流的延迟，主要优化方向是提高编码的效率、减少缓冲大小，当然有时候要牺牲一些代码质量和带宽。 这篇文章 <a href="https://blog.csdn.net/fireroll/article/details/51902018" target="_blank" rel="noopener">ffmpeg 的转码延时测试与设置优化</a> 总结了一些优化措施可以参考一下:</p><ul><li>关闭 sync-lookahead</li><li>降低 rc-lookahead，但别小于 10,默认是-1</li><li>降低 threads(比如从 12 降到 6)</li><li>禁用 rc-lookahead</li><li>禁用 b-frames</li><li>缩小 GOP</li><li>开启 x264 的 -preset fast/faster/verfast/superfast/ultrafast 参数</li><li>使用-tune zerolatency 参数</li></ul><p><br></p><p><strong>node-media-server</strong></p><p>NMS 也可以通过降低缓冲大小和<a href="https://github.com/ossrs/srs/wiki/v1_CN_LowLatency" target="_blank" rel="noopener">关闭 GOP Cache</a> 来优化延迟。</p><p><br></p><p><strong>flvjs 端</strong></p><p>flvjs 可以开启 <code>enableStashBuffer</code> 来提高实时性。 实际测试中，flvjs 可能会出现’累积延迟’现象，可以通过<a href="https://github.com/bilibili/flv.js/issues/258" target="_blank" rel="noopener">手动 seek</a>来纠正。</p><p><br><br><br></p><p>经过一番折腾，优化到最好的延迟是 400ms，往下就束手无策了(对这块熟悉的同学可以请教一下)。而且在对接到底层库实际推送时，播放效果并不理想，出现各种卡顿、延迟。由于时间和知识有限，我们很难定位到具体的问题在哪， 所以我们暂时放弃了这个方案。</p><p><br><br><br></p><h2 id="②-jsmpeg-amp-broadwayjs"><a href="#②-jsmpeg-amp-broadwayjs" class="headerlink" title="② JSMpeg &amp; BroadwayJS"></a>② JSMpeg &amp; BroadwayJS</h2><p>Jerry Qu 写得 <a href="https://imququ.com/post/html5-live-player-2.html" target="_blank" rel="noopener">《HTML5 视频直播（二）》</a> 给了我不少启发，得知了 <a href="https://github.com/phoboslab/jsmpeg" target="_blank" rel="noopener"><code>JSMpeg</code></a> 和 <a href="https://github.com/mbebenita/Broadway" target="_blank" rel="noopener"><code>Broadwayjs</code></a> 这些方案</p><p><strong>这两个库不依赖于浏览器的 video 的播放机制，使用纯 JS/WASM 实现视频解码器，然后直接通过 Canvas2d 或 WebGL 绘制出来</strong>。Broadwayjs 目前不支持语音，JSMpeg 支持语音(基于 WebAudio)。</p><p><br></p><p>经过简单的测试, 相比 RTMP， JSMpeg 和 BroadwayJS 延迟都非常低，基本符合我们的要求。下面简单介绍一下 JSMpeg 用法。Broadwayjs 用法差不多, 下文会简单带过。它们的基本处理过程如下：</p><p><br></p><p><img src="/images/video-push/jsmpeg.png" alt></p><p><br></p><h3 id="relay-服务器"><a href="#relay-服务器" class="headerlink" title="Relay 服务器"></a>Relay 服务器</h3><p>因为 ffmpeg 无法向 Web 直接推流，因此我们还是需要创建一个中转（relay）服务器来接收视频推流，再通过 WebSocket 转发给页面播放器。</p><p>ffmpeg 支持 HTTP、TCP、UDP 等各种推流方式。HTTP 推流更方便我们处理, 因为是本地环境，这些网络协议不会有明显的性能差别。</p><p>下面创建一个 HTTP 服务器来接收推流，推送路径是 <code>/push/:id</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.server = http</span><br><span class="line">  .createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = req.url || <span class="string">'/'</span></span><br><span class="line">    <span class="keyword">if</span> (!url.startsWith(<span class="string">'/push/'</span>)) &#123;</span><br><span class="line">      res.statusCode = <span class="number">404</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> id = url.slice(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止超时</span></span><br><span class="line">    res.connection.setTimeout(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转发出去</span></span><br><span class="line">    req.on(<span class="string">'data'</span>, (c) =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.broadcast(id, c)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    req.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(port)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>接着通过 <code>WebSocket</code> 将流转发出去, 页面可以通过 <code>ws://localhost:PORT/pull/{id}</code> 拉取视频流:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 webSocket 拉取流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">this</span>.wss = <span class="keyword">new</span> ws.Server(&#123;</span><br><span class="line">  server: <span class="keyword">this</span>.server,</span><br><span class="line">  <span class="comment">// 通过 /pull/&#123;id&#125; 拉流</span></span><br><span class="line">  verifyClient: <span class="function">(<span class="params">info, cb</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (info.req.url &amp;&amp; info.req.url.startsWith(<span class="string">'/pull'</span>)) &#123;</span><br><span class="line">      cb(<span class="literal">true</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cb(<span class="literal">false</span>, <span class="literal">undefined</span>, <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.wss.on(<span class="string">'connection'</span>, (client, req) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> url = req.url</span><br><span class="line">  <span class="keyword">const</span> id = url.slice(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;prefix&#125;</span>new player attached: <span class="subst">$&#123;id&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> buzy = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> listener = &#123;</span><br><span class="line">    id,</span><br><span class="line">    onMessage: <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 推送</span></span><br><span class="line">      <span class="keyword">if</span> (buzy) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      buzy = <span class="literal">true</span></span><br><span class="line">      client.send(data, &#123; <span class="attr">binary</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span> <span class="title">ack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        buzy = <span class="literal">false</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.attachListener(listener)</span><br><span class="line"></span><br><span class="line">  client.on(<span class="string">'close'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;prefix&#125;</span> player dettached: <span class="subst">$&#123;id&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">this</span>.detachListener(listener)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p>这里同样使用 ffmpeg 作为推送示例:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -r 30 -i <span class="string">"FaceTime HD Camera"</span> -f mpegts -codec:v mpeg1video -an  -bf 0 -b:v 1500k -maxrate 2500k http://localhost:9999/push/<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p>稍微解释一下 ffmpeg 命令</p><ul><li><code>-f mpegts -codec:v mpeg1video -an</code> 指定使用 MPEG-TS 封包格式， 并使用 mpeg1 视频编码，忽略音频</li><li><code>-bf 0</code> JSMpeg 解码器暂时不能正确地处理 B 帧。所以这些将 B 帧禁用。关于什么是 I/B/P 帧, 参考这篇<a href="https://www.jianshu.com/p/b3d1004229db" target="_blank" rel="noopener">文章</a></li><li><code>-b:v 1500k -maxrate 2500k</code> 设置推流的平均码率和最大码率。经过测试，JSMpeg 码率过高容易出现花屏和数组越界崩溃。</li></ul><p>另外 JSMpeg 还要求，视频的宽度必须是 2 的倍数。ffmpeg 可以通过滤镜(filter)或设置视频尺寸(-s)来解决这个问题, 不过多余转换都要消耗一定 CPU 资源的：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i in.mp4 -f mpeg1video -vf "crop=iw-mod(iw\,2):ih-mod(ih\,2)" -bf 0 out.mpg</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"video-canvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jsmpeg.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'video-canvas'</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> url = <span class="string">'ws://localhost:9999/pull/test'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> player = <span class="keyword">new</span> JSMpeg.Player(url, &#123;</span></span><br><span class="line"><span class="undefined">    canvas: canvas,</span></span><br><span class="line"><span class="javascript">    audio: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">    pauseWhenHidden: <span class="literal">false</span>,</span></span><br><span class="line"><span class="undefined">    videoBufferSize: 8 * 1024 * 1024,</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>API 很简单，上面我们传递一个画布给 JSMpeg，禁用了 Audio, 并设置了一个较大的缓冲区大小, 来应对一些码率波动。</p><p><br></p><blockquote><p>完整代码见<a href="https://github.com/ivan-94/video-push/tree/master/jsmpeg" target="_blank" rel="noopener">这里</a></p></blockquote><p><br><br><br></p><h3 id="多进程优化"><a href="#多进程优化" class="headerlink" title="多进程优化"></a>多进程优化</h3><p>实际测试下来，JSMpeg 视频延迟在 100ms - 200ms 之间。当然这还取决于视频的质量、终端的性能等因素。</p><p>受限于终端性能以及解码器效率, 对于平均码率(笔者粗略测试大概为 2000k)较高的视频流，JSMpeg 有很大概率会出现花屏或者内存访问越界问题(memory access out of bounds)。</p><p><img src="/images/video-push/jsmpeg-problems.png" alt></p><p><br></p><p>因此我们不得不通过压缩视频的质量、降低视频分辨率等手段来降低视频码率。然而这并不能根本解决问题，这是使用 JSMpeg 的痛点之一。详见<a href="https://github.com/phoboslab/jsmpeg#performance-considerations" target="_blank" rel="noopener">JSMpeg 的性能说明</a></p><p><br></p><p>因为解码本身是一个 CPU 密集型的操作，且由浏览器来执行，CPU 占用还是挺高的(笔者机器单个页面单个播放器, CPU 占用率在 16%左右)，而且 JSMpeg 播放器一旦异常崩溃会难以恢复。</p><p>在我们的实际应用场景中，一个页面可能会播放多路视频, 如果所有视频都在浏览器主进程中进行解码渲染，页面操作体验会很差。 所以最好是将 JSMpeg 分离到 Worker 中, <strong>一来保证主进程可以响应用户的交互，二来 JSMpeg 崩溃不会连累主进程</strong>。</p><p>好在将 JSMpeg 放在 Worker 中执行容易: Worker 中支持独立 WebSocket 请求，另外 Canvas 通过 <code>transferControlToOffscreen()</code> 方法创建 <code>OffscreenCanvas</code> 对象并传递给 Worker，实现 canvas 离屏渲染。</p><p>先来看看 <code>worker.js</code>, 和上面的代码差不多，主要是新增了 worker 通讯:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">importScripts(<span class="string">'./jsmpeg.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.window = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'message'</span>, (evt) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = evt.data</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (data.type) &#123;</span><br><span class="line">    <span class="comment">// 创建播放器</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'create'</span>:</span><br><span class="line">      <span class="keyword">const</span> &#123; url, canvas, ...config &#125; = data.data</span><br><span class="line">      <span class="keyword">this</span>.id = url</span><br><span class="line">      <span class="keyword">this</span>.player = <span class="keyword">new</span> JSMpeg.Player(url, &#123;</span><br><span class="line">        canvas,</span><br><span class="line">        audio: <span class="literal">false</span>,</span><br><span class="line">        pauseWhenHidden: <span class="literal">false</span>,</span><br><span class="line">        videoBufferSize: <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>,</span><br><span class="line">        ...config,</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁播放器</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'destroy'</span>:</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.player) &#123;</span><br><span class="line">          <span class="keyword">this</span>.player.destroy()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.postMessage(&#123; <span class="attr">type</span>: <span class="string">'destroyed'</span> &#125;)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(LOGGER_FREFIX + <span class="string">'销毁失败: '</span>, global.id, err)</span><br><span class="line">        <span class="keyword">this</span>.postMessage(&#123;</span><br><span class="line">          type: <span class="string">'fatal'</span>,</span><br><span class="line">          data: err,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就绪</span></span><br><span class="line"><span class="keyword">this</span>.postMessage(&#123; <span class="attr">type</span>: <span class="string">'ready'</span>, <span class="attr">data</span>: &#123;&#125; &#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>再来看看主进程, 通过 <code>transferControlToOffscreen()</code> 生成离屏渲染画布，让 JSMpeg 可以无缝迁移到 Worker:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.getElementById(<span class="string">'video'</span>)</span><br><span class="line"><span class="keyword">const</span> wk = <span class="keyword">new</span> Worker(<span class="string">'./jsmpeg.worker.js'</span>)</span><br><span class="line"></span><br><span class="line">wk.onmessage = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> data = evt.data</span><br><span class="line">  <span class="keyword">switch</span> (data.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ready'</span>:</span><br><span class="line">      <span class="comment">// 创建 OffscreenCanvas 对象</span></span><br><span class="line">      <span class="keyword">const</span> oc = video.transferControlToOffscreen()</span><br><span class="line"></span><br><span class="line">      wk.postMessage(</span><br><span class="line">        &#123;</span><br><span class="line">          type: <span class="string">'create'</span>,</span><br><span class="line">          data: &#123;</span><br><span class="line">            canvas: oc,</span><br><span class="line">            url: <span class="string">'ws://localhost:9999/pull/test'</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        [oc] <span class="comment">// 注意这里</span></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="简单说一下-broadway-js"><a href="#简单说一下-broadway-js" class="headerlink" title="简单说一下 Broadway.js"></a>简单说一下 Broadway.js</h3><p>还有一个类似 JSMpeg 的解决方案 ———— <a href="https://github.com/mbebenita/Broadway" target="_blank" rel="noopener">Broadwayjs</a>。 它是一个 <code>H.264</code> 解码器, 通过 <a href="https://github.com/emscripten-core/emscripten" target="_blank" rel="noopener"><code>Emscripten</code></a> 工具从 Android 的 H.264 解码器转化而成。它支持接收 H.264 裸流，不过也有一些限制：不支持 <a href="https://github.com/mbebenita/Broadway#encoding-video" target="_blank" rel="noopener"><code>weighted prediction for P-frames</code> &amp; <code>CABAC entropy encoding</code></a>。</p><p><br></p><p>推送示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation  -r 30 -i <span class="string">"FaceTime HD Camera"</span>  -f rawvideo -c:v libx264 -pix_fmt yuv420p -vprofile baseline -tune zerolatency -coder 0 -bf 0 -flags -loop -wpredp 0 -an  http://localhost:9999/push/<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p><br><br><br></p><p>客户端示例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.getElementById(<span class="string">'video'</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="string">`ws://localhost:9999/pull/test`</span></span><br><span class="line"><span class="keyword">const</span> player = <span class="keyword">new</span> Player(&#123;</span><br><span class="line">  canvas: video,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(url)</span><br><span class="line">ws.binaryType = <span class="string">'arraybuffer'</span></span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = evt.data</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data !== <span class="string">'string'</span>) &#123;</span><br><span class="line">    player.decode(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(data))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get command from server: '</span>, data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>完整代码看<a href="https://github.com/ivan-94/video-push/tree/master/broadway" target="_blank" rel="noopener">这里</a></p></blockquote><p>经过测试，同等质量和尺寸的视频流 JSMpeg 和 Broadway CPU 消耗差不多。但是 Broadway 视频流不受码率限制，没有花屏和崩溃现象。当然, 对于高质量视频, ffmpeg 转换和 Broadway 播放, 资源消耗都非常惊人。</p><p><br></p><p>其他类似的方案:</p><ul><li><a href="https://github.com/ChihChengYang/wfs.js" target="_blank" rel="noopener">wfs</a> html5 player for raw h.264 streams.</li></ul><p><br><br><br></p><h2 id="③-直接渲染-yuv"><a href="#③-直接渲染-yuv" class="headerlink" title="③ 直接渲染 YUV"></a>③ 直接渲染 YUV</h2><p><strong>回到文章开始，其实底层库从 WebRTC 中拿到的是 YUV 的原始视频流, 也就是没有经过编码压缩的一帧一帧的图像。上文介绍的方案都有额外的解封包、解编码的过程，最终输出的也是 YUV 格式的视频帧，它们的最后一步都是将这些 YUV 格式视频帧转换成 RGB 格式，渲染到 Canvas 中</strong>。</p><p><strong>那能不能将原始的 YUV 视频帧直接转发过来，直接在 Cavans 上渲染不就得了</strong>？ 将去掉中间的解编码过程, 效果怎样？试一试。</p><p><br></p><blockquote><p>此前已经有文章做过这方面的尝试: <a href="https://juejin.im/post/5de29d7be51d455f9b335efa" target="_blank" rel="noopener">《IVWEB 玩转 WASM 系列-WEBGL YUV 渲染图像实践》</a>。我们参考它搞一个。</p></blockquote><p>至于什么是 <code>YUV</code>，我就不科普, 自行搜索。 YUV 帧的大小可以根据这个公式计算出来： <code>(width * height * 3) &gt;&gt; 1</code>,<br><strong>即 <code>YUV420p</code> 的每个像素占用 1.5 bytes</strong>。</p><p>因此我们只需要知道视频的大小, 就可以切割视频流，将视频帧分离出来了。 下面新建一个中转服务器来接收推流, 在这里将 YUV 裸流切割成一帧一帧图像数据，下发给浏览器：</p><p><br></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> parsed = <span class="keyword">new</span> URL(<span class="string">'http://host'</span> + url)</span><br><span class="line">  <span class="keyword">let</span> id = parsed.searchParams.get(<span class="string">'id'</span>),</span><br><span class="line">    width = parsed.searchParams.get(<span class="string">'width'</span>),</span><br><span class="line">    height = parsed.searchParams.get(<span class="string">'height'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nwidth = <span class="built_in">parseInt</span>(width)</span><br><span class="line">  <span class="keyword">const</span> nheight = <span class="built_in">parseInt</span>(height)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> frameSize = (nwidth * nheight * <span class="number">3</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按照字节大小切割流</span></span><br><span class="line">  <span class="keyword">const</span> stream = req.pipe(<span class="keyword">new</span> Splitter(frameSize))</span><br><span class="line"></span><br><span class="line">  stream.on(<span class="string">'data'</span>, (c) =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.broadcast(id, c)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/ivan-94/video-push/blob/master/yuv/size-split.js" target="_blank" rel="noopener"><code>Splitter</code></a> 根据固定字节大小切割 Buffer。 </p><p><br></p><p>如果渲染 YUV ？ 可以参考 <a href="https://github.com/phoboslab/jsmpeg/blob/master/src/webgl.js" target="_blank" rel="noopener">JSMpeg WebGL 渲染器</a>, <a href="https://github.com/mbebenita/Broadway/blob/master/Player/YUVCanvas.js" target="_blank" rel="noopener">Broadway.js WebGL 渲染器</a>。 具体如何渲染就不展开了， 下面直接将 Broadway.js 的 <a href="https://github.com/mbebenita/Broadway/blob/master/Player/YUVCanvas.js" target="_blank" rel="noopener"><code>YUVCanvas.js</code></a> 直接拿过来用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> YUVCanvas(&#123;</span><br><span class="line">  canvas: video,</span><br><span class="line">  type: <span class="string">'yuv420'</span>,</span><br><span class="line">  width: width,</span><br><span class="line">  height: height,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 WebSocket 接收 YUV 帧. 并抽取出 YUV 分量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ylen = width * height</span><br><span class="line">  <span class="keyword">const</span> uvlen = (width / <span class="number">2</span>) * (height / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  renderer.render(</span><br><span class="line">    buff.subarray(<span class="number">0</span>, ylen),</span><br><span class="line">    buff.subarray(ylen, ylen + uvlen),</span><br><span class="line">    buff.subarray(ylen + uvlen, ylen + uvlen + uvlen),</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><blockquote><p>需要注意的是：JSMpeg 和 Broadway 的 Canvas 渲染都要求视频的宽度必须是 8 的倍数。不符合这个要求的会报错，<a href="https://juejin.im/post/5de29d7be51d455f9b335efa" target="_blank" rel="noopener">《IVWEB 玩转 WASM 系列-WEBGL YUV 渲染图像实践》</a> 处理了这个问题。</p></blockquote><p><br></p><p>最后看看 ffmpeg 推送示例:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -r 30 -i <span class="string">"FaceTime HD Camera"</span> -f rawvideo -c:v rawvideo -pix_fmt yuv420p <span class="string">"http://localhost:9999/push?id=test&amp;width=320&amp;height=240"</span></span></span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>完整代码看<a href="https://github.com/ivan-94/video-push/tree/master/yuv" target="_blank" rel="noopener">这里</a></p></blockquote><p><br><br><br></p><p>下面看看简单资源消耗对比。 笔者设备是 15 款 Macboook pro, 视频源采集自摄像头，分辨率 320x240、像素格式 uyvy422、帧率 30。</p><p><em>下表 <code>J</code> 表示 <code>JSMpeg</code>、<code>B</code> 表示 <code>Broadway</code>、<code>Y</code> 表示 <code>YUV</code></em></p><table><thead><tr><th></th><th>CPU (J/B/Y)</th><th>内存 (J/B/Y)</th><th>平均码率 (J/B/Y)</th></tr></thead><tbody><tr><td>ffmpeg</td><td>9% / 9% / 5%</td><td>12MB / 12MB / 9MB</td><td>1600k / 200k / 27000k</td></tr><tr><td>服务器</td><td>0.6% / 0.6% /1.4%</td><td>18MB / 18MB / 42MB</td><td>N/A</td></tr><tr><td>播放器</td><td>16% / 13% / 8%</td><td>70MB / 200MB / 50MB</td><td>N/A</td></tr></tbody></table><p><br></p><p>从结果来看，直接渲染 YUV 综合占用的资源最少。因为没有经过压缩，码率也是非常高的，不过本地环境不受带宽限制，这个问题也不大。我们还可以利用<code>requestAnimationFrame</code> 由浏览器来调度播放的速率，丢掉积累的帧，保持低延迟播放。</p><p><br><br><br></p><p>本文完</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://juejin.im/post/5ab851b6f265da23826df601" target="_blank" rel="noopener">直播原理与 web 直播实战</a></li><li><a href="https://juejin.im/post/5de29d7be51d455f9b335efa" target="_blank" rel="noopener">IVWEB 玩转 WASM 系列-WEBGL YUV 渲染图像实践</a></li><li><a href="https://github.com/ossrs/srs/wiki/v1_CN_LowLatency" target="_blank" rel="noopener">低延时直播应用</a></li><li><a href="https://zhuanlan.zhihu.com/p/100519553" target="_blank" rel="noopener">基于 H5 的直播协议和视频监控方案</a></li><li><a href="https://imququ.com/post/html5-live-player-2.html" target="_blank" rel="noopener">HTML5 视频直播（二）</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久不见，接近四个月没更新博客了! &lt;/p&gt;
&lt;p&gt;去年&lt;a href=&quot;https://juejin.im/post/5e0010866fb9a015fd69c645#comment&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最后一篇&lt;/a&gt;文章介绍
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>分享这半年的 Electron 应用开发和优化经验</title>
    <link href="https://bobi.ink/2019/12/16/electron/"/>
    <id>https://bobi.ink/2019/12/16/electron/</id>
    <published>2019-12-15T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>2019 年最后一发，谈谈这半年 Electron 应用开发和优化心得。干货也挺多，希望能给你带来一点启发。</p><p>下半年可以拿出来说一说的项目，估计就是我们用 Electron 重构了一个桌面端应用。这个应用类似于<code>钉钉</code>或者<code>企业微信</code>，主要功能有即时通信、语音/视频、会议，基本功能和交互体验和 PC 端微信差不多(其实就是模仿)，具体细节就不展开了, 这些对本文不重要。如下图</p><p><br></p><p><img src="/images/electron/mygzb.jpeg" alt></p><p><br></p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#为什么选择-electron">为什么选择 Electron?</a></li><li><a href="#进程模型">进程模型</a></li><li><a href="#技术选型与代码组织">技术选型与代码组织</a></li><li><a href="#性能优化硬货">性能优化(硬货)</a><ul><li><a href="#1-性能分析">1. 性能分析</a></li><li><a href="#2-优化策略">2. 优化策略</a><ul><li><a href="#21-继续和白屏作斗争">2.1 继续和白屏作斗争</a></li><li><a href="#22-追赶原生的交互体验">2.2 追赶原生的交互体验</a></li><li><a href="#23-优化进程通信">2.3 优化进程通信</a></li></ul></li></ul></li><li><a href="#坑还是会有的">坑还是会有的</a></li><li><a href="#扩展资料">扩展资料</a></li></ul><!-- /TOC --><p><br></p><h2 id="为什么选择-electron"><a href="#为什么选择-electron" class="headerlink" title="为什么选择 Electron?"></a>为什么选择 Electron?</h2><p>原因也很简单: <strong>我们的应用要兼容多个平台，原生开发效率低，我们没有资源</strong>。</p><p>说了跟白说一样，大部分选择 Electron 框架的动机都是差不多的，无非就是穷，尤其是在夹缝中生存的企业。</p><p>为了优化客户端开发资源，<strong>‘混合化’成为了我们今年客户端重构的主题</strong>。</p><p>先来看一下我们现在的客户端基本架构:</p><p><img src="/images/electron/client-arch.png" alt></p><p><br></p><p>混合化对我们来说有两层意思:</p><ol><li>我们的应用架构’混合’了多种技术。通用底层 C/C++, 平台原生(iOS, Android, PC, MacOS)，Web 技术</li><li>跨平台</li></ol><p><br></p><p>基于我们原有的客户端基础和情况，混合化重构自然而然分化为了两个方向:</p><ol><li><strong>业务下沉</strong>。将通用的、核心的业务下沉。例如消息处理、语音/视频、会议、数据存储等核心模块, 核心协议是 XMPP、SIP。这些模块变动频率较低、对性能要求也比较高，而且有跨平台需求，因此适合用 C/C++ 来实现。</li><li><strong>UI 混合</strong>。视图层混合化目前也有较多的解决方案，例如 Electron、React Native、Flutter、或者是 HTML Hybrid。我们选择先从 Electron 开始，因为它在桌面端开发中已经有非常成熟的表现，市场上也有很多大型的 Electron 应用，例如 VSCode、Atom、Slack。在移动端，我们对 React Native 和 Flutter 还比较保守，后续可能会进行尝试。</li></ol><p><br></p><p>理解了我们的动机，现在再看上面的图, 应该就好理解多了, 这是典型的三层结构, 和 MVC 非常相似：</p><ul><li><strong>M – 通用混合层</strong>。 C/C++ 封装核心、通用的业务模块以及业务数据存储。</li><li><strong>V – UI 层</strong>。视图层，使用跨平台视图解决方案，对于性能要求较高的部分使用原生实现。比如 Electron</li><li><strong>C – 平台桥接层</strong>。介于 M 和 V 之间，桥接<code>通用混合层</code>接口，同时也为 UI 层暴露一些<strong>平台相关</strong>的特性。比如在桌面端，这里会通过 Node 原生模块桥接通用混合层, 同时也补充一些 Electron 缺失或不完美的功能。</li></ul><p><br><br><br></p><h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><p>Electron 的主从进程模型是基本的常识。每个 Electron 应用有且只要一个主进程(Main Process)、以及一个或多个渲染进程(Renderer Process), 对应多个 Web 页面。除此之外还有 GPU 进程、扩展进程等等。可以通过 <a href="https://electronjs.org/docs/tutorial/application-architecture#main-and-renderer-processes" target="_blank" rel="noopener">Electron Application Architecture</a> 了解 Electron 的基本架构。</p><p>主进程负责创建页面窗口、协调进程间通信、事件分发。为了安全考虑，原生 GUI 相关的 API 是无法在渲染进程直接访问的，它们必须通过 IPC 调用主进程。<strong>这种主从进程模型缺点也非常明显，即主进程单点故障。主进程崩溃或者阻塞，会影响整个应用的响应</strong>。比如主进程跑长时间的 CPU 任务，将阻塞渲染进程的用户交互事件。</p><p><br></p><p>对我们的应用来说，目前有以下进程, 以及它们的职责:</p><p><strong>① 主进程</strong></p><ul><li>进程间通信、窗口管理</li><li>全局通用服务。</li><li>一些只能或适合在主进程做的事情。例如浏览器下载、全局快捷键处理、托盘、session。</li><li>维护一些必要的全局状态</li><li>上面说的<code>通用混合层</code>也跑在这个进程。通过 Node C++ 插件暴露接口。</li></ul><p><br></p><p><strong>② 渲染进程</strong></p><p>负责 Web 页面的渲染, 具体页面的业务处理。</p><p><br></p><p><strong>③ Service Worker</strong></p><p>负责静态资源缓存。缓存一些网络图片、音频。保证静态资源的稳定加载。</p><p><br><br><br></p><h2 id="技术选型与代码组织"><a href="#技术选型与代码组织" class="headerlink" title="技术选型与代码组织"></a>技术选型与代码组织</h2><p>说说我们的技术选型。</p><ul><li>UI 框架 - <code>React</code></li><li>状态管理 - <code>Mobx</code></li><li>国际化 - <code>i18next</code></li><li>打包 - <code>自研 CLI</code></li></ul><p><br></p><p>源码组织</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bridge/                  # 桥接层代码</span><br><span class="line">resources/               # 构建资源，以及第三方DLL</span><br><span class="line">src/</span><br><span class="line"></span><br><span class="line">  main/                  # 🔴主进程代码</span><br><span class="line">    services/            # 📡**通过 RPC 暴露给渲染进程的全局服务**</span><br><span class="line">      tray.ts            # 托盘状态管理</span><br><span class="line">      shortcut.ts        # 全局快捷键分发</span><br><span class="line">      preferences.ts     # 用户配置管理</span><br><span class="line">      windows.ts         # 窗口管理</span><br><span class="line">      screen-capture.ts  # 截屏</span><br><span class="line">      bridge.ts          # 桥接层接口封装</span><br><span class="line">      context-menu.ts    # 右键菜单</span><br><span class="line">      state.ts           # 全局状态管理, 保存一些必要的全局状态，例如主题、当前语言、当前用户</span><br><span class="line">      ...</span><br><span class="line">    lib/                 # 封装库</span><br><span class="line">      bridge.ts          # 桥接层API 分装</span><br><span class="line">      logger.ts          # 日志</span><br><span class="line">      ...</span><br><span class="line">    bootstrap.ts         # 启动程序</span><br><span class="line">    index.ts             # 🔴入口文件</span><br><span class="line"></span><br><span class="line">  renderer/              # 🔴渲染进程</span><br><span class="line">    services/            # 📡主进程的全局服务的客户端</span><br><span class="line">      windows.ts         # 窗口管理客户端</span><br><span class="line">      tray.ts</span><br><span class="line">      ...</span><br><span class="line">    assets/              # 静态资源</span><br><span class="line">    hooks/               # React Hooks</span><br><span class="line">    components/          # 通用组件</span><br><span class="line">      Webview</span><br><span class="line">      Editor</span><br><span class="line">      toast</span><br><span class="line">      ...</span><br><span class="line">    pages/               # 🔴页面</span><br><span class="line">      Home</span><br><span class="line">        ui/              # 🔴视图代码，由前端团队维护</span><br><span class="line">        store/           # 🔴状态代码，由客户端团队维护，前端Store的公开状态</span><br><span class="line">        translation/     # 国际化翻译文件</span><br><span class="line">        index.tsx        # 页面入口</span><br><span class="line">      Settings</span><br><span class="line">      Login</span><br><span class="line">    page.json            # 🔴声明所有页面及页面配置。类似小程序</span><br></pre></td></tr></table></figure><p><br></p><p>眼尖的读者会发现每个页面下有 <code>ui</code> 和 <code>store</code> 目录，分别对应视图和状态。为什么这么划分？</p><p>首先这是因为这个项目由两个团队共同来开发的，即原有的原生客户端团队和我们的前端团队。分离视图和状态有两个好处:</p><ul><li>前端前期不需要关心客户端底层业务，而客户端也不需要关心前端的页面实现。职责明确，各自干好自己事情。</li><li>降低学习成本。我们状态管理选用了 Mobx，对于客户端同学，只需要掌握少量的 Typescript 语言知识就可以马上上手。如果熟悉 Java、C# 那就更没什么问题了。每个 Store 只是一个简单的类：</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> CounterStore <span class="keyword">extends</span> MobxStore &#123;</span><br><span class="line">  <span class="meta">@observable</span></span><br><span class="line">  <span class="keyword">public</span> count: <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@action</span></span><br><span class="line">  <span class="keyword">public</span> incr = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.count++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> pageReady() &#123;</span><br><span class="line">    <span class="comment">// 页面就绪，可以在这里做一些准备工作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件监听</span></span><br><span class="line">    <span class="comment">// addDisposer 将释放函数添加到队列中，在页面退出时释放</span></span><br><span class="line">    <span class="keyword">this</span>.addDisposer(</span><br><span class="line">      addListener(<span class="string">'someevent'</span>, <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.dosomething(evt)</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.initial()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> pageWillClose() &#123;</span><br><span class="line">    <span class="comment">// 页面释放，可以在这里做一些资源释放</span></span><br><span class="line">    releaseSomeResource()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>使用 Mobx 作为状态管理，相比 Redux，面向对象思想对他们更好理解。在这种场景，简单才是真理；</p><p>分离了状态和业务逻辑，前端页面实现也简化了，视图只是状态的映射，这让我们的页面和组件更好被维护和复用。</p><p><br><br><br></p><h2 id="性能优化-硬货"><a href="#性能优化-硬货" class="headerlink" title="性能优化(硬货)"></a>性能优化(硬货)</h2><p>前戏完了，关于 Electron 的一些性能优化才是本篇文章的重头戏。</p><p>Electron 不是银弹，鱼和熊掌不可兼得。Electron 带来开发效率的提升，其本身也有很多硬伤，譬如常被人吐槽的内存占用高，和原生客户端性能差异等等。为了优化 Electron 应用，我们也做了很多工作。</p><p>性能优化一般都分两步走：</p><ul><li>① 分析、找出问题。参考<a href="https://juejin.im/post/5d06bf0a51882528194a9736" target="_blank" rel="noopener">《React 性能测量和分析》</a></li><li>② 针对问题解决问题。无外乎三个方向, 参考 <a href="https://juejin.im/post/5d045350f265da1b695d5bf2" target="_blank" rel="noopener">《浅谈 React 性能优化的方向》</a></li></ul><p><br></p><h3 id="1-性能分析"><a href="#1-性能分析" class="headerlink" title="1. 性能分析"></a>1. 性能分析</h3><p>最好的分析工具是 Chrome 开发者工具的 <code>Performance</code>。通过火焰图, JavaScript 执行过程的任何蛛丝马迹都可以直观的看到。</p><p><img src="/images/electron/chrome-perf.png" alt></p><p><br></p><p>对于主进程，开启调试后也可以通过 <code>Profile</code> 工具收集 JavaScript 执行信息。</p><p>如果你要分析某段代码的执行过程，也可以通过下面命令生成分析文件，然后导入到 Chrome Performance 中分析:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出 cpu 和 堆分析文件</span></span><br><span class="line">node --cpu-prof --heap-prof -e "require('request’)”“</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="2-优化策略"><a href="#2-优化策略" class="headerlink" title="2. 优化策略"></a>2. 优化策略</h3><h4 id="2-1-继续和白屏作斗争"><a href="#2-1-继续和白屏作斗争" class="headerlink" title="2.1 继续和白屏作斗争"></a>2.1 继续和白屏作斗争</h4><p>即使 Electron 通常从本地文件系统加载 JavaScript 代码，没有网络加载延迟，我们还是需要继续和页面白屏做斗争，因为 JavaScript 等资源的加载、解析和执行还是有相当大的代价(参考<a href="https://v8.dev/blog/cost-of-javascript-2019" target="_blank" rel="noopener">The cost of JavaScript in 2019</a>)。作为一个桌面端应用，细微的白屏延迟用户都可以感觉的到。我们要尽量让用户感觉不到这是一个 Web 页面。</p><p><strong>影响 Electron 白屏的主要因素有：页面窗口的创建、静态资源的加载、JavaScript 解析和执行</strong>。</p><p>见招拆招，针对页面白屏我们做了这些优化:</p><p><br></p><p><strong>① 骨架屏</strong></p><p>最简单的方式。在资源未加载完毕之前，先展示页面的骨架。避免用户看到白茫茫的屏幕。</p><p>另外需要设置背景色或者延迟显示窗口，来避免闪烁。</p><p><img src="/images/electron/shell.png" alt><br><em>VSCode骨架屏</em></p><p><br></p><p><strong>② 惰性加载</strong></p><p>优先加载核心的功能，保证初次加载效率，让用户可以尽快进行交互。</p><p><br></p><p><img src="/images/electron/load-order.gif" alt></p><p><br></p><ul><li><strong>代码分割 + 预加载</strong>： 代码分割是最常见优化方式。我们把隐藏的内容、或者次优先级的模块拆分出去，启动模块中只保留关键路径。我们也可以在浏览器空闲时预加载这些模块。</li><li><p><strong>延后加载 Node 模块</strong>： Nodejs 模块的加载和执行需要花费较大的代价, 例如模块查找、模块文件读取、接着才是模块解析和执行。这些操作都是同步了，别忘了，node_modules 黑洞，某块模块可能会引用大量的依赖….</p><p>Node 应用和 Electron 应用不太一样，通常 Node 服务器应用都会将模块放置在文件顶部, 然后同步加载进来。这个放到 Electron 用户界面上就无法忍受了。 用户界面的启动速度和交互阻塞, 用户是可以感知到的，而且忍耐程度会较低。</p><p>所以要充分评估模块的大小和依赖。或者可以选择使用打包工具优化和合并 Node 模块。</p></li><li><p><strong>划分加载优先级</strong>：既然我们没办法一开始将所有东西都加载出来，那就按照优先级渐进式地将在它们。举个例子，当我们使用 VSCode 打开一个文件时，VScode 会先展示代码面板、接着是目录树、侧边栏、代码高亮、问题面板、初始化各种插件…</p></li></ul><p><br></p><p><strong>③ 使用现代的 JavaScript/CSS 代码</strong></p><p>Electron 每个版本都会预装当时最新的 Chrome，对于前端来说，这是最爽的一件事情:</p><ul><li>没有负担地使用最新的 JavaScript 特性</li><li>没有 Polyfill、没有 runtime-helper。相比老旧浏览器，代码量更少，性能也更好</li><li>我们需要主动抛弃一些老旧的依赖。保持使用最新的库</li></ul><p><br></p><p><strong>④ 打包优化</strong></p><p>即使使用最新最牛逼的浏览器，打包工具还是很有用。</p><ul><li><strong>减少代码体积</strong>: 现代打包工具有非常多优化手段，例如 Webpack 支持作用域提升、摇树，还有代码压缩、预执行… 这可以合并代码、压缩代码体积，裁剪多余的代码, 减少运行时负担。</li><li><strong>优化I/O</strong>: 我们将模块合并之后，可以减少模块查找和加载的I/O往返。</li></ul><p><br></p><p><strong>⑤ <a href="https://v8project.blogspot.it/2015/09/custom-startup-snapshots.html" target="_blank" rel="noopener">v8 Snapshot</a> or <a href="https://v8.dev/blog/code-caching" target="_blank" rel="noopener">v8 Code Cache</a></strong></p><p>Atom 有很多优质的文章，分享了他们优化Atom的经历。例如它们使用了 <a href="https://blog.atom.io/2017/04/18/improving-startup-time.html" target="_blank" rel="noopener">V8 的snapshot 来优化启动时间</a>。</p><p>这是一种 <code>AOT</code> 优化策略，简单说 Snapshot 是堆快照，你可以认为它是 JavaScript 代码在V8中的内存表示形态。</p><p>它有两个好处: 一是相比普通 JavaScript 加载更快，二是它是二进制的，如果你为了‘安全’考虑，可以将模块转换成snapshot，这样更难被‘破解’。</p><p>不过它也有较多限制。对架构的影响比较大。比如要求在初始化的过程中不要有‘副作用’，例如DOM访问。因为在‘编译时‘这些东西不存在。</p><p>这篇文章详细介绍了如何在 Electron 中应用 v8 snapshot: <a href="https://flight-manual.atom.io/behind-atom/sections/how-atom-uses-chromium-snapshots/" target="_blank" rel="noopener">How Atom Uses Chromium Snapshots</a></p><p><br></p><p>还有一个更加广泛使用的方案是 <a href="https://v8.dev/blog/code-caching" target="_blank" rel="noopener">v8 Code Cache</a>。NodeJS 12 <a href="https://www.yuque.com/egg/nodejs/nodejs-12#2e3ceb28" target="_blank" rel="noopener">开始</a>在构建时提前为内置库生成代码缓存，从而提升 30% 的启动耗时。</p><p>通过这些文章，深入了解 Code Cache 扩展阅读:</p><ul><li><a href="https://v8.dev/blog/code-caching-for-devs" target="_blank" rel="noopener">Code caching for JavaScript developers</a></li><li><a href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201" target="_blank" rel="noopener">JavaScript Start-up Performance</a></li><li><a href="https://v8.dev/blog/improved-code-caching" target="_blank" rel="noopener">Improved code caching</a></li><li><a href="https://fed.taobao.org/blog/taofed/do71ct/speed-node-start-time/" target="_blank" rel="noopener">如何加快 Node.js 应用的启动速度</a></li></ul><p><br><br><br></p><p><strong>⑥ 窗口预热 与 窗口池、窗口常驻</strong></p><p>为了追赶原生窗口的打开和展示速度，我们运用了很多技巧，用空间来换取时间。</p><p>例如我们的应用首页，用户在打开登录页面时，我们就会在<strong>后台预热</strong>，将该加载的资源都准备好，在登录成功后，就可以立即渲染显示。窗口打开的延时很短，基本接近原生的窗口体验。</p><p>这里用到了一些 Hack 手段，我们将这些窗口放到了屏幕之外，并设置 <code>skipTaskBar</code> 来实现隐藏或者关闭的效果。</p><p><br></p><p>对于频繁开启/关闭的窗口，也可以使用<strong>窗口池</strong>来优化。比如 Webview 页面，打开的一个 Webview 页面时，会优先从窗口池中选取，当窗口池为空时才创建新的窗口, 后面页面关闭后会再放回窗口池中，方便后续复用。</p><p>另外，对于业务无关的、通用的窗口，也可以采用<strong>常驻模式</strong>，例如通知，图片查看器。这些窗口一旦创建就不会释放，打开效果会更好。</p><p><br></p><p><strong>⑦ 跟进 Electron 最新版本</strong></p><p>保持版本的更新。</p><p><br></p><h4 id="2-2-追赶原生的交互体验"><a href="#2-2-追赶原生的交互体验" class="headerlink" title="2.2 追赶原生的交互体验"></a>2.2 追赶原生的交互体验</h4><p>白屏时间的优化只是一个开始，应用使用过程中的交互体验也是一个非常重要的部分。下面讲讲我们的一些优化手段：</p><p><br></p><p><strong>① 静态资源缓存</strong></p><p>对于一些网络资源，我们采取了一些缓存手段，保证它们展示的速度。我们目前采用的是 Service-Worker + Workbox 的方式，利用 Service-Worker 可以拦截多个页面的网络请求，从而实现跨页面的静态资源缓存，这种方式实现比较简单。</p><p>除了 Service Worker，也可以通过协议拦截方式来实现。详见: <a href="https://electronjs.org/docs/api/protocol" target="_blank" rel="noopener">protocol</a>。后面有时间再尝试一下，看效果怎么样。</p><p><br></p><p><strong>② 预加载机制</strong></p><p>如果你看过我的 <a href="https://juejin.im/post/5dadc6045188255a270a0f85" target="_blank" rel="noopener">《这可能是最通俗的 React Fiber(时间分片) 打开方式》</a>, 应该见识到 <code>requestIdleCallback</code> 的强大，React 利用它来调度一些渲染任务，保证浏览器响应用户的交互。</p><p>这个 API 对于我们的应用优化也有重要的意义。通过它我们可以知道浏览器的资源利用情况，利用浏览器空闲时间来预执行一些低优先级的任务。比如：</p><ul><li>渲染隐藏的 Tab</li><li>延后加载的模块代码</li><li>惰性加载的图片</li><li>未激活的会话</li><li>执行低优先级的任务</li><li>…</li></ul><p><br></p><p>例如 React 代码分割：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">lazy</span>(<span class="params">factory, Fallback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Comp = l(factory)</span><br><span class="line">  <span class="comment">// 预加载调度</span></span><br><span class="line">  scheduleIdle(&#123;</span><br><span class="line">    name: <span class="string">'LazyComponent'</span>,</span><br><span class="line">    size: TaskSize.Heavy,</span><br><span class="line">    task: factory,</span><br><span class="line">    timeout: <span class="number">2000</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">LazyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Suspense fallback=&#123;Fallback ? <span class="xml"><span class="tag">&lt;<span class="name">Fallback</span> /&gt;</span> : null&#125;&gt;</span></span><br><span class="line">        &lt;Comp &#123;...props&#125; /&gt;</span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">    )</span></span><br><span class="line"><span class="xml">  &#125; as typeof Comp</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>使用:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> List = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./List'</span>))</span><br></pre></td></tr></table></figure><p><br></p><p><strong>③ 避免同步操作</strong></p><p>Electron 可以通过 NodeJS 进行 I/O 操作，但是我们一定要尽量避免同步 I/O。例如同步的文件操作、同步的进程间通信。它们会阻塞页面的渲染和事件交互。</p><p><br></p><p><strong>④ 减少主进程负荷</strong></p><p>Electron 的主进程非常重要。它是所有窗口的父进程，它负责调度各种资源。如果主进程被阻塞，将影响整个应用响应性能。</p><p>你可以做一个简单的实验，在主进程上打一个断点，你会发现所有的页面窗口都会失去响应，尽管它们在各自不同的进程。这是因为所有用户交互都是由主进程分发给渲染进程的，主进程阻塞了，渲染进程当然无法接收用户事件啦。</p><p>所以不要让主进程干脏活累活，能在渲染进程做的，就在渲染进程做。<strong>千万避免在主进程中跑计算密集任务和同步I/O</strong>。</p><p><br></p><p><strong>⑤ 分离CPU密集型操作到单独进程或Worker, 避免阻塞UI</strong></p><p><br></p><p><strong>⑥ React 优化</strong></p><p>见 <a href="https://juejin.im/post/5d045350f265da1b695d5bf2" target="_blank" rel="noopener">《React 性能优化的方向》</a></p><p><br></p><p><strong>⑦ 放弃CSS-in-js</strong></p><p>我们为了压缩运行时性能，能在编译时做的就在编译时做，放弃了 CSS-in-js 方案，使用纯 CSS + BEM 来编写样式。主要有两个原因:</p><ul><li>Electron 使用较新的 Chrome，现代 CSS 已经很强大</li><li>我们使用了窗口预热机制，可以率先解析这部分 CSS 代码。而 CSS-in-js 方案则是组件渲染时，动态生成的。</li></ul><p><br></p><p><strong>⑧ 没有退路了，那就只能上 Node 原生模块了</strong></p><p>真好，还有退路</p><p><br><br><br></p><h4 id="2-3-优化进程通信"><a href="#2-3-优化进程通信" class="headerlink" title="2.3 优化进程通信"></a>2.3 优化进程通信</h4><p>涉及到多页面/窗口的 Electron 应用，IPC 会非常频繁，搞不好会成为性能瓶颈。</p><p><br></p><p><strong>① 巨坑 remote</strong></p><p><a href="https://electronjs.org/docs/api/remote" target="_blank" rel="noopener">remote</a> 提供了一种简便的、无侵入的形式来访问主进程的API和数据。<strong>其底层基于同步的 IPC</strong>。你可以通过我<a href="https://juejin.im/post/5d4b79a3e51d4561b072dcb0" target="_blank" rel="noopener">这篇文章</a>来了解它的原理。</p><p>坑在哪里呢？</p><p>① 它是同步的<br>② 属性动态获取。为了确保你能够获取到最新的值，remote底层并不会进行缓存，而是每次获取一个属性就动态到主进程中取。</p><p>比如获取一个主进程中的对象:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主进程</span></span><br><span class="line">global.foo = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: &#123;</span><br><span class="line">    baz: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染进程访问:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;remote&#125; <span class="keyword">from</span> <span class="string">'electron'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(remote.getGlobal(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure><p>这里会触发 4 次 同步 IPC: getGlobal、foo、bar、bar.baz。对于复杂的数据，这个消耗就很难忍受了。</p><p>不要使用 remote，除非你知道你自己在干什么。</p><p><br><br><br></p><p><strong>② 封装IPC 库</strong></p><p>为了优化 IPC 通信，我们自己基于Electron 的IPC接口, 封装了自己的一套 RPC 库。主要特征有:</p><ul><li>异步的。没有同步的选项。避免干蠢事</li><li>消息合并。合并事件推送，批量传递</li><li>序列化。直接传递 JSON 字符串，不让 Electron 干涉序列化。Electron 内部序列化稍微有点复杂，比如会处理 Buffer 等特殊类型。</li><li>一致化的、简单易用的 API。使用一样在接口支持主进程与渲染进程，以及渲染进程与渲染进程之间双向通信。</li></ul><p>举个例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rpc <span class="keyword">from</span> <span class="string">'myrpc'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册方法</span></span><br><span class="line">rpc.registerHandler(<span class="string">'echo'</span>, <span class="keyword">async</span> data =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line">rpc.on(<span class="string">'some-event'</span>, (data, source) =&gt; &#123;</span><br><span class="line">  <span class="comment">// dosomething</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>客户端:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rpc <span class="keyword">from</span> <span class="string">'myrpc'</span></span><br><span class="line"></span><br><span class="line">rpc.emit(target, <span class="string">'some-event'</span>) <span class="comment">// target 为接收的窗口或者主进程。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法调用</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> rpc.callHandler(target, <span class="string">'echo'</span>, <span class="string">'hello-world'</span>)</span><br></pre></td></tr></table></figure><p><br></p><p>还不够，我们还在优化，后续再分享给大家。</p><p><br><br><br></p><h2 id="坑还是会有的"><a href="#坑还是会有的" class="headerlink" title="坑还是会有的"></a>坑还是会有的</h2><p>一路走来也遇到很多坑。痛并快乐着。</p><ul><li>窗口阴影、圆角</li><li>剪切板不够强大</li><li>remote 巨坑</li><li>一些兼容问题</li><li>主进程崩溃，渲染进程不会退出，导致进程‘溢出’</li><li>截屏。刚开始用 Electron 实现，效果不好，现在是原生实现</li><li>…</li></ul><p><br><br><br></p><h2 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/96041706" target="_blank" rel="noopener">从 VSCode 看大型 IDE 技术架构</a></li><li><a href="https://electronjs.org/docs/tutorial/performance" target="_blank" rel="noopener">Electron Performance</a></li><li><a href="https://www.youtube.com/watch?v=r0OeHRUCCb4" target="_blank" rel="noopener">CovalenceConf 2019: Visual Studio Code – The First Second</a></li><li><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/" target="_blank" rel="noopener">Get Started With Analyzing Runtime Performance</a></li><li><a href="https://github.com/atom/electron-link" target="_blank" rel="noopener">electron-link</a></li><li><a href="http://peterforgacs.github.io/2018/09/12/How-to-create-a-V8-snapshot-of-your-javascript-file/" target="_blank" rel="noopener">How to Create a V8 Heap Snapshot of a Javascript File and Use It in Electron</a></li><li><a href="https://blog.atom.io/2018/01/10/the-state-of-atoms-performance.html" target="_blank" rel="noopener">The State of Atom’s Performance</a></li><li><a href="https://blog.atom.io/2017/04/18/improving-startup-time.html" target="_blank" rel="noopener">Improving Startup Time</a></li></ul><p><br><br><br></p><p><img src="/images/group.jpeg" alt><br><em>回复: <code>ivan</code> 进群</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019 年最后一发，谈谈这半年 Electron 应用开发和优化心得。干货也挺多，希望能给你带来一点启发。&lt;/p&gt;
&lt;p&gt;下半年可以拿出来说一说的项目，估计就是我们用 Electron 重构了一个桌面端应用。这个应用类似于&lt;code&gt;钉钉&lt;/code&gt;或者&lt;code&gt;企业
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>if 我是前端Leader，谈谈前端框架体系建设</title>
    <link href="https://bobi.ink/2019/12/06/fe-framework/"/>
    <id>https://bobi.ink/2019/12/06/fe-framework/</id>
    <published>2019-12-05T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>这期来聊一聊前端框架。</p><p>“if 我是前端 Leader” 是我的一个文章系列，说说我人在其位，欲谋其职的一些点点滴滴感悟。跟前端 Leader 只有那么一丢丢关系，干货不多，但老少皆宜，不要被标题给唬住了。</p><p><br></p><p><strong>文章大纲</strong></p><p><br></p><!-- TOC --><ul><li><a href="#什么是框架">什么是框架?</a></li><li><a href="#前端框架的发展历程">前端‘框架’的发展历程</a><ul><li><a href="#前端框架启蒙阶段">前端框架启蒙阶段</a></li><li><a href="#野蛮生长期">野蛮生长期</a></li><li><a href="#前端框架整合期">前端框架整合期</a></li></ul></li><li><a href="#现有的框架都有什么">现有的框架都有什么？</a></li><li><a href="#谈谈前端团队框架体系的建设">谈谈前端团队框架体系的建设</a><ul><li><a href="#第一阶段-前端工程化--基础设施">第一阶段: 前端工程化 / 基础设施</a></li><li><a href="#第二阶段-应用开发方案整合">第二阶段: 应用开发方案整合</a></li><li><a href="#第三阶段-组件体系">第三阶段: 组件体系</a></li><li><a href="#第四阶段打通上下游">第四阶段：打通上下游</a></li><li><a href="#未来-ai">未来: AI?</a></li></ul></li><li><a href="#扩展资料">扩展资料</a></li></ul><!-- /TOC --><p><br><br><br></p><h2 id="什么是框架"><a href="#什么是框架" class="headerlink" title="什么是框架?"></a>什么是框架?</h2><p>这应该不是我第一次谈‘框架‘了。React 是一个框架吗？ Vue 是一个框架吗？ 严格来说不是，它们只是一个视图解决方案，这里面算得上是框架的估计只有 Angular。</p><p>如果说后端框架围绕着<code>数据存储</code>建立起来，那么前端框架的基础就是视图库，毕竟前端的本质工作就是视图。这是为什么前端生态圈一般是围绕着视图库展开的。所以说，<strong>前端框架的基础是‘视图’库</strong>。</p><p>如果跟后端框架比起来，成熟的前端框架其实不多。</p><p><br></p><p><strong>什么是框架？</strong></p><p><br></p><p>看个例子。打开 <a href="https://umijs.org" target="_blank" rel="noopener">UmiJS</a>, 它对自己的描述是:</p><blockquote><p><strong>可插拔的企业级 react 应用框架</strong></p></blockquote><p>关键字是<strong>企业级</strong>。什么是企业级，我自己也说不清楚。我只知道 React 没有说自己是企业级，Koa、Express 也没有，然而 <a href="https://eggjs.org" target="_blank" rel="noopener">Eggjs</a> 和 <a href="https://umijs.org" target="_blank" rel="noopener">Umijs</a> 都说它们是<strong>企业级框架</strong>；Angular 通常也常常跟企业级这个概念联系在一起；语言层面有 Java。</p><p>对比一下他们就知道了，我觉得企业级表示它是 <strong>面向企业生产，目的是提高企业的生产力</strong>。总结一下有以下特点：</p><p><br></p><ul><li>是高效 + 成熟方案的整合</li><li>关注生产的整个链路，而不是某个环节</li><li>有更强的约束和限制</li><li>更严苛的要求。性能、可扩展性(以应对不同的需求)、健壮性、稳定性、可用性、安全性</li><li>标准化</li><li>经过生产环境验证, 有较多用例保证</li></ul><p><br></p><p>归根到底还是成本问题，框架最本质的目的就是要减低各类成本。让更少的人可以做更多的事情、且能保证质量、降低维护成本，且能保证不断优化和演进。</p><p><br></p><p><strong>给个定义吧。</strong></p><p><br></p><p><strong>前端框架体系的建立离不开前端工程化成熟和‘最佳实践‘的沉淀’。你可以认为框架就是一个整合的方案，提供一个前端‘最佳‘的组合配置。开发者需要做的就是在这个框架约束下填充自己业务代码。</strong></p><p><br></p><p>好处：</p><ul><li>效率提升。让开发者关注业务开发</li><li>学习成本降低。框架封装了很多底层复杂性</li><li>更强的约束。所有动作必须按照框架规定的执行, 避免干坏事、蠢事。更强的约束也意味着框架集成度更高、框架内部可以做更多事情，但灵活性也更低。</li><li>产品质量。框架内部会自动处理很多事情，例如性能优化、安全性处理</li><li>可维护性。所有项目都按照一致的、标准化的规范开发，升级迭代方便。这一点对团队项目的可维护性很重要。</li></ul><p><br></p><p>坏处:</p><ul><li>灵活性。不能满足所有人的需求，最佳实践这种东西有点武断</li><li>滞后性。具体方案可能会滞后。</li><li>大而全。对于某些项目可能过重。</li></ul><p><br><br><br></p><h2 id="前端‘框架’的发展历程"><a href="#前端‘框架’的发展历程" class="headerlink" title="前端‘框架’的发展历程"></a>前端‘框架’的发展历程</h2><h3 id="前端框架启蒙阶段"><a href="#前端框架启蒙阶段" class="headerlink" title="前端框架启蒙阶段"></a>前端框架启蒙阶段</h3><p>在 React、Vue 流行之前已经有许多‘前端框架‘，例如 Angular、Ember、Backbone…</p><p>它们大部分都受到后端框架的启发，因为当年也正是后端框架最火的时候，例如 Rails。所以在它们身上会看到很多后端框架的影子。</p><p>但是很多后端的开发模式，在前端有点吃不开。更本质的原因是前端工程化还不成熟，基础相对薄弱，难以支撑上层建筑的发展。</p><p><br><br><br></p><h3 id="野蛮生长期"><a href="#野蛮生长期" class="headerlink" title="野蛮生长期"></a>野蛮生长期</h3><p>随着 NodeJS 的普及、JavaScript 语言日益强大，前端工程化逐步深化。 React 这类视图库出来后，很多东西被打碎重构, 正所谓百花齐放，欣欣向荣。</p><p>围绕着三大视图库各种各样的库百花齐放，前端也拓展到了浏览器以外的领域。人们都乐于造轮子，使用最新的技术。</p><p>由于发展得太快，所谓的框架/最佳实践很难被广泛接受，或者很容易就过时了，每个人每个团队更热衷于创造自己的组合方案，往往也只限于团队内部。</p><p><br><br><br></p><h3 id="前端框架整合期"><a href="#前端框架整合期" class="headerlink" title="前端框架整合期"></a>前端框架整合期</h3><p>几乎每个团队都会重复走这样的路子：<em>稳定技术栈、工程化建设、基础库/组件库建设、沉淀自己的最佳实践</em>。</p><p>团队没有一定的工程能力和资源其实是很难将这些零散的实践体系化、有机地粘合起来, 长期有效的维护更新更是一件难事, 半途而废的居多。</p><p>现在前端发展开始进入平稳阶段。所以大一统的前端‘框架’再一次进入人们的视野。就像 Umi 的作者 <a href="https://www.zhihu.com/people/chenchengpro/activities" target="_blank" rel="noopener">云谦</a> 说的: <em>现在是工业化时代, 框架像是一个魔法球，把各种技术栈吸到一起，加工后吐给用户，以此来支撑业务</em>。</p><p><img src="/images/fe-framework/bigfish.jpg" alt><br><em>上图来源于&lt;蚂蚁前端研发最佳实践&gt; PPT</em></p><p><br></p><p>框架就是将各种技术栈方案、基础设施整合起来, 暴露标准的、一致性的接口, 让开发者专注业务开发。</p><p><br><br><br></p><h2 id="现有的框架都有什么？"><a href="#现有的框架都有什么？" class="headerlink" title="现有的框架都有什么？"></a>现有的框架都有什么？</h2><p><strong>一个前端开发框架应该涵盖前端开发链路的各个环节。为约束和简化业务开发、提供有用的指导</strong>。</p><p>看看现有‘前端框架‘吧，现在社区上比较流行的‘框架’有 Angular、Next.js、Nuxt、Umi。我们横向对比一下它们的一些特性，发现基本上包含这些东西：</p><p><img src="/images/fe-framework/framework-content.png" alt></p><p><br></p><p>跟衣服的标准码一样。社区开源的都是通用类型框架，可以预知的是它们没有办法满足所有团队的要求。我们往往需要根据自己业务情况量身定制框架。</p><p>为了应对这些需求，不同的框架也有不同的应对策略:</p><ul><li><strong>更开放</strong>。框架只提供核心功能，附加几乎什么事情都能干的<strong>插件机制</strong>。插件可以干预框架的整个生命周期，不满足的需求可以自己定制自己的插件</li><li><strong>更决断</strong>。我给你提供的就是最好的，能满足你的尽量满足你，其他的你不要管太多，也没有必要管, 专注你的业务。</li></ul><p><br></p><p>我们也有自己的选择策略:</p><ul><li>自己搞。例如大厂团队，有资源、有丰富的实践经验。他们有能力将自己的‘最佳实践’体系化。他们会选择创建自己的框架。同时他们也乐于将经验分享出来，也可以利用社区完善自己的作品。个人，基于学习和折腾的目的, 也可以搞一套。</li><li>基于开源框架扩展。可以将开源框架作为基础，根据自己团队情况进行扩展开发。</li><li>完全使用开源框架。开源框架可以满足许多通用的需求, 适合简单的应用场景。<strong>我们选择一个框架主要有两个原因：① 我们要提高工作效率；② 我们需要一个标准</strong>。 为了标准，其实可妥协一些事情。更重要的是这些框架是在不断发展和演进的, 从而我们团队的技术也可以免费地跟随他们演进和发展。将开源框架的默认最佳实践开发视为标准。</li></ul><p><br></p><p>我一直坚信<strong>专业的人做专业的事。要善于将事情外包出去，腾空自己去做重要的事情</strong>。大厂有专门的团队在做工具、建设基础设施，社区上开源的框架也由一大帮牛人在维护，而且通常开发迭代很活跃。所以说社区已经有的方案，可以直接拿来用，不要自己去造轮子，因为你一般没那么多精力。</p><p><br><br><br></p><h2 id="谈谈前端团队框架体系的建设"><a href="#谈谈前端团队框架体系的建设" class="headerlink" title="谈谈前端团队框架体系的建设"></a>谈谈前端团队框架体系的建设</h2><p>前端开发的时间都花在了哪里?</p><p><img src="/images/fe-framework/time.jpg" alt><br><em>上图来源于&lt;蚂蚁前端研发最佳实践&gt; PPT</em></p><p><br></p><p>对于前端团队来说，开源前端框架只是一个基础，只是涉及前端开发的某个很小的部分，它就像一艘船。你要航线穿越大西洋，还有做很多工作、需要紧密高效的协作、可靠的后勤保障、目标和方向、坚定的领导… 路还很长。</p><p><strong>现在来聊聊‘广义的‘框架体系，它集成自身业务，涉及前端开发完整链路，关注点从前端应用上升到了前端团队研发体系</strong>。</p><p><br></p><p><img src="/images/fe-framework/framework-order.png" alt></p><p><br></p><p>九层之台，起于累土。 前端团队框架体系的建设是一个渐进式的过程，首先从基础设施开始、接着就是应用开发技术栈组合，再到组件体系，后面是上层的业务开发方案… 上层以下层为基础，共同构建出完整的框架体系。</p><p>我觉得前端团队可以按照这样的分层结构，分阶段来完成这些建设任务。</p><p><br></p><h3 id="第一阶段-前端工程化-基础设施"><a href="#第一阶段-前端工程化-基础设施" class="headerlink" title="第一阶段: 前端工程化 / 基础设施"></a>第一阶段: 前端工程化 / 基础设施</h3><p>最基础的阶段，关注前端的基础设施建设。这个阶段已经比较成熟，社区上有很多开箱即用的方案，例如 Umi、Next.js、Vue-CLI、Create-React-App 等等。主要内容有:</p><p><img src="/images/fe-framework/base.png" alt></p><p><br></p><h3 id="第二阶段-应用开发方案整合"><a href="#第二阶段-应用开发方案整合" class="headerlink" title="第二阶段: 应用开发方案整合"></a>第二阶段: 应用开发方案整合</h3><p>在完善基础设施的同时，团队的应用开发技术栈组合方案也应该稳定下来，成为框架的一部分。这些组合也非常重要，它会影响上层的组件建设和业务开发。主要内容有:</p><p><img src="/images/fe-framework/app-dev.png" alt></p><p><br></p><h3 id="第三阶段-组件体系"><a href="#第三阶段-组件体系" class="headerlink" title="第三阶段: 组件体系"></a>第三阶段: 组件体系</h3><p>组件化现在是前端主流开发模式，这里还有很多工作可以做，还有很大的提效空间。</p><p>整个组件体系也是一个分层式的结构：</p><p><img src="/images/fe-framework/component.png" alt></p><ul><li>基础组件。越底层，就说明可复用的程度越高、越通用。Ant-Design、Element-UI、iView、Material-UI 这些就属于基础组件库，有能力的团队也可以开发一套符合自己设计风格的组件库。</li><li>业务组件。在基础组件之上封装的、耦合自己业务的组件。它们一般从重复的业务场景中抽象出来。</li><li>区块。再往上，就很难用模块化的组件去组织了。于是有人(阿里前端)提出了‘区块’的概念，<strong>你可以认为‘区块’是：代码片段、代码示例、代码模板…</strong> 这么看来，这并不是一种新的概念? 还没完! <strong>区块还要配套‘区块市场’才能展现它的用处。区块市场是一个代码片段分享平台，维护着大量的区块，试图覆盖大部分常见的使用场景。对于开发者来说就是找到尽量匹配自己场景的区块，拷贝过来，稍微改改就行了。这是一种 ‘Ctrl+C，Ctrl+V’ 编程哲学的完美实践啊</strong>。</li><li>页面。和区块差不多，快速生成页面和路由。约定式的路由可以给页面自动化创建带来一些便利。</li><li>布局。例如后台的整体布局。</li><li>项目。项目的整体结构。可以通过‘脚手架‘ 来快速生成项目模板。</li></ul><p><br></p><p><img src="/images/fe-framework/icework.png" alt></p><p><br></p><p>像区块、页面生成这些操作需要一些工具辅助。例如：</p><ul><li>生成器。生成不同级别的元件<ul><li>项目(项目模板)。 俗称脚手架, 支持不同的项目类型：应用、组件库、程序库、 插件</li><li>页面/路由</li><li>区块</li><li>组件</li><li>数据模型</li></ul></li><li>可视化工具。可视化的项目编排工具, 如飞冰。</li></ul><p><br></p><h3 id="第四阶段：打通上下游"><a href="#第四阶段：打通上下游" class="headerlink" title="第四阶段：打通上下游"></a>第四阶段：打通上下游</h3><p>前端只是研发流程的一环，只是前端自嗨，上下游没有资源支持，是很难走远的。</p><p>对于前端来说，通常上游指的是 UI、下游指的是后端。</p><p>对于 UI。上面说的组件体系，其实是建立在稳定的、一致的、统一的 UI 设计语言之上的。否则一切都是空谈。所以我们要求 UI 设计团队要有良好的设计规范、能和前端组件体系绑定并良性迭代。</p><p>对于 后端。可以促进建立更标准的接口范式、封装通用的服务(有利于业务组件复用)、更深的有业务中台、BFF…</p><p>上下游的打通，对前端生产力的解放也有非常大的促进作用。</p><p><br></p><h3 id="未来-ai"><a href="#未来-ai" class="headerlink" title="未来: AI?"></a>未来: AI?</h3><p>AI 自动生成前端代码？ 太高大上了，还是把话筒交给它吧： <a href="https://mp.weixin.qq.com/s/EktHbvCnghkywZE8rOvMhw" target="_blank" rel="noopener">《双 11 模块 79.34% 的代码是怎样智能生成的？》</a>， 溜了</p><p><br><br><br></p><h2 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/94949118" target="_blank" rel="noopener">《蚂蚁前端研发最佳实践》文字稿</a> 好文</li><li><a href="https://mp.weixin.qq.com/s/EktHbvCnghkywZE8rOvMhw" target="_blank" rel="noopener">双 11 模块 79.34% 的代码是怎样智能生成的？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这期来聊一聊前端框架。&lt;/p&gt;
&lt;p&gt;“if 我是前端 Leader” 是我的一个文章系列，说说我人在其位，欲谋其职的一些点点滴滴感悟。跟前端 Leader 只有那么一丢丢关系，干货不多，但老少皆宜，不要被标题给唬住了。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>JSX AS DSL? 写个 Mock API 服务器看看</title>
    <link href="https://bobi.ink/2019/11/29/jsx-as-dsl/"/>
    <id>https://bobi.ink/2019/11/29/jsx-as-dsl/</id>
    <published>2019-11-28T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.329Z</updated>
    
    <content type="html"><![CDATA[<p>这几天打算写一个简单的 API Mock 服务器，老生常谈哈？其实我是想讲 JSX, Mock 服务器只是一个幌子。我在寻找一种更简洁、方便、同时又可以灵活扩展的、和别人不太一样的方式，来定义各种 Mock API。后来我发现了 JSX 在领域问题描述的优势和潜力，当然这可不是空谈，我们会实际写一个项目来证实这个判断。</p><p><br></p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#1-领域问题的描述">1. 领域问题的描述</a><ul><li><a href="#11-配置文件形式">1.1 配置文件形式</a></li><li><a href="#12-编程语言与内部-dsl">1.2 编程语言与内部 DSL</a></li></ul></li><li><a href="#2-javascript-内部-dsl">2. JavaScript 内部 DSL</a><ul><li><a href="#21-对象形式">2.1 对象形式</a></li><li><a href="#22-链式调用形式">2.2 链式调用形式</a></li><li><a href="#23-es2015-template-tag">2.3 ES2015 Template Tag</a></li><li><a href="#24-要不试试-jsx">2.4 要不试试 JSX？</a></li></ul></li><li><a href="#3-jsx-入门">3. JSX 入门</a><ul><li><a href="#31-自定义工厂">3.1 自定义工厂</a></li><li><a href="#32-host-component-vs-custom-component">3.2 Host Component vs Custom Component</a></li><li><a href="#33-简单实现-createelement-工厂方法">3.3 简单实现 createElement 工厂方法</a></li></ul></li><li><a href="#4-基础组件的设计">4. 基础组件的设计</a><ul><li><a href="#41-来源于-koa-的灵感">4.1 来源于 Koa 的灵感</a></li><li><a href="#42-use-基础组件">4.2 use 基础组件</a></li><li><a href="#43-高层组件的封装">4.3 高层组件的封装</a></li></ul></li><li><a href="#5-浅谈实现原理">5. 浅谈实现原理</a><ul><li><a href="#51-渲染">5.1 ‘渲染’</a></li><li><a href="#52-运行">5.2 运行</a></li></ul></li><li><a href="#6-总结终于完事了">6. 总结，终于完事了</a></li><li><a href="#7-扩展">7. 扩展</a></li></ul><!-- /TOC --><p><br></p><h2 id="1-领域问题的描述"><a href="#1-领域问题的描述" class="headerlink" title="1. 领域问题的描述"></a>1. 领域问题的描述</h2><p>一上来就说这么抽象的名词，’领域问题’ 是什么鬼？什么是领域，Wiki 上解释的非常好，<strong>领域就是指某一专业或事物方面范围的涵盖</strong>。那么所谓领域问题就可以理解为，我们需要通过程序或者其他方式去解决的需求。</p><p>比如提到 API Mock 服务器，我们需要解决的就是请求匹配和数据模拟这些问题；Nginx 解决的资源伺服和代理问题；HTML + CSS 解决的是页面 UI 展示问题…</p><p>我们这里重点关注’<strong>描述</strong>‘。<strong>这些描述是提供给领域专家的‘前端‘ 或者 用户界面(UI)</strong>。举个例子：</p><p><br></p><p><img src="/images/jsx-as-dsl/dq-fe.png" alt></p><p><br></p><p>描述的形式有很多，例如配置文件、编程语言、图形界面。 先来看看现在常见的工具是怎么做的：</p><p><br></p><h3 id="1-1-配置文件形式"><a href="#1-1-配置文件形式" class="headerlink" title="1.1 配置文件形式"></a>1.1 配置文件形式</h3><p><strong>JSON?</strong></p><p>JSON 是一种非常简单的数据表述, 没有任何学习成本，解析也非常方便。但是它有非常多致命的缺陷，比如不支持注释、冗余、数据结构单一。</p><p><strong>YAML?</strong></p><p>相比 JSON 语法要简洁很多、可读性也比较强。作为一个配置文件形式非常优秀</p><p><strong>还是其他配置文件形式…</strong></p><p>通常这些配置文件都是语言无关的，因此不会包含特定语言的元素。换句话说配置文件形式数据是相对静态的, 所以灵活性、扩展性比较差。只适合简单的配置场景。</p><p>举个例子，这些配置文件不支持函数。我们的 Mock 服务器可能需要通过一个函数来动态处理请求，所以配置文件在这里并不适用。</p><blockquote><p>当然你可以通过其他方式来取代‘函数’，例如模板、或者脚本支持</p></blockquote><p><br><br><br></p><h3 id="1-2-编程语言与内部-dsl"><a href="#1-2-编程语言与内部-dsl" class="headerlink" title="1.2 编程语言与内部 DSL"></a>1.2 编程语言与内部 DSL</h3><p>我们需要回到编程语言本身，利用它的编程能力，实现配置文件无法实现的更强大的功能。</p><p>不过单纯使用通用类型编程语言，命令式的过程描述可能过于繁琐。<strong>我们最好针对具体领域问题进行简化和抽象，给用户提供一个友好的用户界面，让他们声明式地描述他们的领域问题。我们要尽可能减少用户对底层细节的依赖，与此同时最好能保持灵活的扩展能力</strong>。</p><p>我说的可能就是<a href="https://zh.wikipedia.org/wiki/领域特定语言" target="_blank" rel="noopener"><strong>DSL(Domain-specific languages)</strong></a>:</p><blockquote><p>DSL 是一种用于描述特定应用领域的计算机语言。DSL 在计算机领域有非常广泛的应用，例如描述 Web 页面的 HTML、数据库查询语言 SQL、正则表达式。<br>相对应的是<strong>通用类型语言</strong>(GPL, General-Purpose Language)，例如 Java、C++、JavaScript。它们可以用于描述任意的领域逻辑，它们通常是<a href="https://en.wikipedia.org/wiki/Turing_completeness" target="_blank" rel="noopener">图灵完备</a>的。<br>可以这么认为，虽然不严谨：除了通用类型语言、其他语言都算是 DSL。</p></blockquote><p><br></p><p><strong>怎么创建 DSL？</strong></p><p>从头开发一门新语言？No! 成本太高了</p><p>一种更优雅的方式是在通用编程语言的基础上进行减法或者封装抽象。当然不是所有类型语言都有这个’能力’, 比如 Java、C/C++ 就不行，它们的语法太 Verbose 或者工具链太重了。但是 Groovy、Ruby、Scala、还有 Elixir 这些语言就可以方便地创建出‘DSL’, 而且它们大部分是动态语言。</p><p>它们有的借助宏、有的天生语法就非常适合作为 DSL、有的具备非常强的动态编程能力… 这些因素促就了它们适合作为 DSL 的母体(宿主)。</p><p><strong>我们通常也将这种 DSL 称为 <code>Embedded DSL(嵌入式 DSL)</code> 或者 <code>内部 DSL</code>，因为它们寄生在通用类型编程语言中。而独立的 DSL，如 JSON、HTML，称为<code>外部DSL</code></strong>。</p><p>内部 DSL 好处是省去了实现一门语言的复杂性(Parse-&gt;Transform-&gt;Generate)。</p><p><br></p><p>举两个非常典型的例子:</p><p>Java 开发者常用的 <a href="https://gradle.org" target="_blank" rel="noopener">Gradle</a>，基于 Groovy:</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'java-library'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    api <span class="string">'org.apache.commons:commons-math3:3.6.1'</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">'com.google.guava:guava:27.0.1-jre'</span></span><br><span class="line"></span><br><span class="line">    testImplementation <span class="string">'junit:junit:4.12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>还有 CocoaPods, 基于 Ruby:</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">source <span class="string">'http://source.git'</span></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">'8.0'</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'Demo'</span> <span class="keyword">do</span></span><br><span class="line">    pod <span class="string">'AFNetworking'</span></span><br><span class="line">    pod <span class="string">'SDWebImage'</span></span><br><span class="line">    pod <span class="string">'Masonry'</span></span><br><span class="line">    pod <span class="string">"Typeset"</span></span><br><span class="line">    pod <span class="string">'BlocksKit'</span></span><br><span class="line">    pod <span class="string">'Mantle'</span></span><br><span class="line">    pod <span class="string">'IQKeyboardManager'</span></span><br><span class="line">    pod <span class="string">'IQDropDownTextField'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><br></p><p>具体的实现细节不在本文的范围之内，还是聊回 JavaScript。</p><p><br></p><p><strong>我个人要求 DSL 应该具备这些特性</strong>：</p><ul><li><strong>专注于特定领域</strong>。也就是说它的目的非常明确，因此比通用类型语言要简单很多，但是它的边界有时候并不好把握。</li><li><strong>组织性</strong>。它应该方便组织和描述领域问题, <strong>或者说这是一种约束能力</strong>。配置文件组织性就非常好，比如 JSON，它可以很容易地描述数据结构，没有什么心智负担。另一个典型的例子是单元测试框架(例如 jest)，它们使用 describe、it、expect 这些元件，让单元测试更好的组织起来。</li><li><strong>可读性</strong>。它必须是人类可读的、容易理解的。</li><li><strong>声明式</strong>。声明式优于过程式、描述 What 而不是 How。</li><li><strong>扩展性</strong>。很多 DSL 一开始并不关注这一点，因为一开始问题可能并不复杂。<strong>问题的领域不是静态不变的，它可能会变大，这时候 DSL 的扩展能力就很关键了</strong>。 就比如 HTML，随着前端开发越来越复杂，原有的元素和功能集合已经无法满足需求，所以衍生除了很多组件或者自定义元素方案。如果原本的 DSL 无法扩展，可以在这个基础之上再套一层 DSL，CSS vs SASS、HTML vs React 就是这样的例子。</li></ul><p><br><br><br></p><h2 id="2-javascript-内部-dsl"><a href="#2-javascript-内部-dsl" class="headerlink" title="2. JavaScript 内部 DSL"></a>2. JavaScript 内部 DSL</h2><p>上节提到了 Groovy、Ruby ‘适合‘ 用作 DSL 母体，并不代表一定要用它们实现，这只是说明它们天生具备的一些语言特性让实现更加便捷，或者说外观更加简洁。</p><p>Google 一把 ‘JavaScript DSL‘ 匹配的有效资料很少。 如果你觉得困惑那就应该回到问题本身, 最重要的是解决领域问题，至于怎么组织和描述则是相对次要的。所以不要去纠结 JavaScript 适不适合。</p><p><br></p><p>那我们就针对 Mock Server 这个具体领域，聊一聊 JavaScript 内部 DSL 的典型组织方式:</p><p><br></p><h3 id="2-1-对象形式"><a href="#2-1-对象形式" class="headerlink" title="2.1 对象形式"></a>2.1 对象形式</h3><p>最简单的方式是直接基于对象或者数组进行声明，实现简单又保持组织性。例如 <a href="https://umijs.org/zh/guide/mock-data.html#使用-umi-的-mock-功能" target="_blank" rel="noopener">Umi Mock</a> 还有 <a href="https://ice.work" target="_blank" rel="noopener">飞冰</a> Mock, 就是基于对象组织的:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 支持值为 Object 和 Array</span></span><br><span class="line">  <span class="string">'GET /api/users'</span>: &#123; <span class="attr">users</span>: [<span class="number">1</span>, <span class="number">2</span>] &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// GET POST 可省略</span></span><br><span class="line">  <span class="string">'/api/users/1'</span>: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 支持自定义函数，API 参考 express@4</span></span><br><span class="line">  <span class="string">'POST /api/users/create'</span>: <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">'OK'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 mockjs 等三方库</span></span><br><span class="line">  <span class="string">'GET /api/tags'</span>: mockjs.mock(&#123;</span><br><span class="line">    <span class="string">'list|100'</span>: [&#123; <span class="attr">name</span>: <span class="string">'@city'</span>, <span class="string">'value|1-100'</span>: <span class="number">50</span>, <span class="string">'type|0-2'</span>: <span class="number">1</span> &#125;],</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>和配置文件差不多, 实现和使用都非常简单 ，简单的 API Mock 场景开箱即用，对于复杂的用法和 API 协议，也可以通过自定义函数进一步封装。<strong>但是有时候我们希望库可以承担多一点事情</strong>。</p><p><br><br><br></p><h3 id="2-2-链式调用形式"><a href="#2-2-链式调用形式" class="headerlink" title="2.2 链式调用形式"></a>2.2 链式调用形式</h3><p>JavaScript 作为内部 DSL 的另外一种典型的形式是链式调用。</p><p>其中最出名的是 JQuery, 它让链式调用这种模式广为人知。相比啰嗦的原生 DOM 操作代码，JQuery 确实让人眼前一亮, 它暴露精简的 API, 帮我们屏蔽了许多底层 DOM 操作细节，抚平平台差异，同时还能保持灵活性和扩展性。这才是它真正流行的原因，大众喜闻乐见的都是简单的东西。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'.awesome'</span>)</span><br><span class="line">  .addClass(<span class="string">'flash'</span>)</span><br><span class="line">  .draggable()</span><br><span class="line">  .css(<span class="string">'color'</span>, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><p><br></p><p>JQuery 这种 API 模式也影响到了其他领域，比如 Iot 领域的 <a href="https://ruff.io/zh-cn/docs/getting-started.html" target="_blank" rel="noopener"><code>Ruff</code></a>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ready(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点亮灯</span></span><br><span class="line">  $(<span class="string">'#led-r'</span>).turnOn()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>jest</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(z).not.toBeNull()</span><br><span class="line">expect(z).toBeDefined()</span><br><span class="line">expect(value).toBeGreaterThan(<span class="number">3</span>)</span><br><span class="line">expect(value).toBeGreaterThanOrEqual(<span class="number">3.5</span>)</span><br></pre></td></tr></table></figure><p><br></p><p>API Mock 服务器领域也有两个这样的例子:</p><p><a href="https://github.com/nock/nock" target="_blank" rel="noopener">Nock</a>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scope = nock(<span class="string">'http://myapp.iriscouch.com'</span>)</span><br><span class="line">  .get(<span class="string">'/users/1'</span>)</span><br><span class="line">  .reply(<span class="number">404</span>)</span><br><span class="line">  .post(<span class="string">'/users'</span>, &#123;</span><br><span class="line">    username: <span class="string">'pgte'</span>,</span><br><span class="line">    email: <span class="string">'pedro.teixeira@gmail.com'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .reply(<span class="number">201</span>, &#123;</span><br><span class="line">    ok: <span class="literal">true</span>,</span><br><span class="line">    id: <span class="string">'123ABC'</span>,</span><br><span class="line">    rev: <span class="string">'946B7D1C'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .get(<span class="string">'/users/123ABC'</span>)</span><br><span class="line">  .reply(<span class="number">200</span>, &#123;</span><br><span class="line">    _id: <span class="string">'123ABC'</span>,</span><br><span class="line">    _rev: <span class="string">'946B7D1C'</span>,</span><br><span class="line">    username: <span class="string">'pgte'</span>,</span><br><span class="line">    email: <span class="string">'pedro.teixeira@gmail.com'</span>,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>还有网易云团队的 <a href="https://docs.svrx.io/zh/guide/route.html" target="_blank" rel="noopener">Srvx</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span>('/handle(.*)').to.handle(ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'handle'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">get</span>('/blog(.*)').to.json(&#123; code: <span class="number">200</span> &#125;)</span><br><span class="line"><span class="keyword">get</span>('/code(.*)').to.send('code', 201)</span><br><span class="line"><span class="keyword">get</span>('/json(.*)').to.send(&#123; json: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="keyword">get</span>('/text(.*)').to.send('haha')</span><br><span class="line"><span class="keyword">get</span>('/html(.*)').to.send('&lt;html&gt;haha&lt;/html&gt;')</span><br><span class="line"><span class="keyword">get</span>('/rewrite:path(.*)').to.rewrite('/query&#123;path&#125;<span class="string">')</span></span><br><span class="line"><span class="string">get('</span>/redirect:path(.*)<span class="string">').to.redirect('</span>localhost:<span class="number">9002</span>/proxy&#123;path&#125;<span class="string">')</span></span><br><span class="line"><span class="string">get('</span>/api(.*)<span class="string">').to.proxy('</span>http:<span class="comment">//mock.server.com/')</span></span><br><span class="line"><span class="keyword">get</span>('/test(.*)').to.proxy('http://mock.server.com/', &#123;</span><br><span class="line">  secure: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">get</span>('/test/:id').to.proxy('http://&#123;id&#125;.dynamic.server.com/<span class="string">')</span></span><br><span class="line"><span class="string">get('</span>/query(.*)<span class="string">').to.handle(ctx =&gt; &#123;</span></span><br><span class="line"><span class="string">  ctx.body = ctx.query</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">get('</span>/header(.*)<span class="string">')</span></span><br><span class="line"><span class="string">  .to.header(&#123; '</span>X-From<span class="string">': '</span>svrx<span class="string">' &#125;)</span></span><br><span class="line"><span class="string">  .json(&#123; user: '</span>svrx<span class="string">' &#125;)</span></span><br><span class="line"><span class="string">get('</span>/user<span class="string">').to.json(&#123; user: '</span>svrx<span class="string">' &#125;)</span></span><br><span class="line"><span class="string">get('</span>/sendFile/:path(.*)<span class="string">').to.sendFile('</span>./&#123;path&#125;<span class="string">')</span></span><br></pre></td></tr></table></figure><p><br></p><p>链式调用模式目前是主流的 JavaScript 内部 DSL 形式。而且实现也比较简单，<strong>更重要的是它接近自然语言</strong>。</p><p><br><br><br></p><h3 id="2-3-es2015-template-tag"><a href="#2-3-es2015-template-tag" class="headerlink" title="2.3 ES2015 Template Tag"></a>2.3 ES2015 Template Tag</h3><p>近年基于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings" target="_blank" rel="noopener">ES6 Template Tag</a> 特性引入‘新语言‘到 JavaScript 的库层出不穷。</p><p><strong>不过因为 ES6 Template Tag 本质上是字符串，所以需要解析和转换，因此更像是外部 DSL。别忘了 Compiler as Framework! 通常我们可以利用 Babel 插件在编译时提前将它们转换为 JavaScript 代码。</strong></p><p><br></p><p>举几个流行的例子:</p><p><a href="https://github.com/modernserf/zebu" target="_blank" rel="noopener">Zebu</a>: 这是一个专门用于解析 Template Tag 的小型编译器, 看看它的一些内置例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 范围</span></span><br><span class="line">range<span class="string">`1,3 ... (10)`</span> <span class="comment">// [1, 3, 5, 7, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态机, 牛逼</span></span><br><span class="line"><span class="keyword">const</span> traffic = machine<span class="string">`</span></span><br><span class="line"><span class="string">  initState: #green</span></span><br><span class="line"><span class="string">  states: #green | #yellow | #red</span></span><br><span class="line"><span class="string">  events: #timer</span></span><br><span class="line"><span class="string">  onTransition: <span class="subst">$&#123;state =&gt; <span class="built_in">console</span>.log(state)&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  #green  @ #timer -&gt; #yellow</span></span><br><span class="line"><span class="string">  #yellow @ #timer -&gt; #red</span></span><br><span class="line"><span class="string">  #red    @ #timer -&gt; #green</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">traffic.start() <span class="comment">// log &#123; type: "green" &#125;</span></span><br><span class="line">traffic.send(&#123; <span class="attr">type</span>: <span class="string">'timer'</span> &#125;) <span class="comment">// log &#123; type: "yellow" &#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>Jest 表格测试:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe.each<span class="string">`</span></span><br><span class="line"><span class="string">  a    | b    | expected</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;<span class="number">1</span>&#125;</span> | <span class="subst">$&#123;<span class="number">1</span>&#125;</span> | <span class="subst">$&#123;<span class="number">2</span>&#125;</span></span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;<span class="number">1</span>&#125;</span> | <span class="subst">$&#123;<span class="number">2</span>&#125;</span> | <span class="subst">$&#123;<span class="number">3</span>&#125;</span></span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;<span class="number">2</span>&#125;</span> | <span class="subst">$&#123;<span class="number">1</span>&#125;</span> | <span class="subst">$&#123;<span class="number">3</span>&#125;</span></span></span><br><span class="line"><span class="string">`</span>(<span class="string">'$a + $b'</span>, (&#123; a, b, expected &#125;) =&gt; &#123;</span><br><span class="line">  test(<span class="string">`returns <span class="subst">$&#123;expected&#125;</span>`</span>, () =&gt; &#123;</span><br><span class="line">    expect(a + b).toBe(expected)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  test(<span class="string">`returned value not be greater than <span class="subst">$&#123;expected&#125;</span>`</span>, () =&gt; &#123;</span><br><span class="line">    expect(a + b).not.toBeGreaterThan(expected)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  test(<span class="string">`returned value not be less than <span class="subst">$&#123;expected&#125;</span>`</span>, () =&gt; &#123;</span><br><span class="line">    expect(a + b).not.toBeLessThan(expected)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>除此之外还有:</p><ul><li><a href="https://github.com/developit/htm" target="_blank" rel="noopener">htm</a></li><li><a href="https://github.com/apollographql/graphql-tag" target="_blank" rel="noopener">graphql-tag</a></li><li><a href="http://styled-components.com" target="_blank" rel="noopener">styled-components</a></li></ul><p><br></p><p>Template Tag 这些方案给我们开了很多脑洞。尽管如此，它也带来了一些复杂性，就像开头说的，它们是字符串，需要解析、语法检查和转换，且 JavaScript 本身的语言机制并没有给它们带来多少便利(如语法高亮、类型检查)。</p><p><br><br><br></p><h3 id="2-4-要不试试-jsx？"><a href="#2-4-要不试试-jsx？" class="headerlink" title="2.4 要不试试 JSX？"></a>2.4 要不试试 JSX？</h3><p>铺垫了这么多，只是前戏。上面提到这些方案，要么过于简单、要么过于复杂、要么平淡无奇。我将目光投向了 JSX，我发现它可以满足我的大部分需求。</p><p>先来看看一下我们的 Mock 服务器的原型设计:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Get, Post, mock &#125; <span class="keyword">from</span> <span class="string">'jsxmock'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (</span><br><span class="line">  &lt;server port=<span class="string">"4321"</span>&gt;</span><br><span class="line">    &#123;<span class="comment">/* 首页 */</span>&#125;</span><br><span class="line">    &lt;Get&gt;hello world&lt;<span class="regexp">/Get&gt;</span></span><br><span class="line"><span class="regexp">    &#123;/</span>* 登录 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">    &lt;Post path="/</span>login<span class="string">"&gt;login success&lt;/Post&gt;</span></span><br><span class="line"><span class="string">    &#123;/* 返回 JSON */&#125;</span></span><br><span class="line"><span class="string">    &lt;Get path="</span>/json<span class="string">"&gt;&#123;&#123; id: 1 &#125;&#125;&lt;/Get&gt;</span></span><br><span class="line"><span class="string">    &#123;/* mockjs */&#125;</span></span><br><span class="line"><span class="string">    &lt;Get path="</span>/mockjs<span class="string">"&gt;&#123;mock(&#123; 'id|+1': 1, name: '@name' &#125;)&#125;&lt;/Get&gt;</span></span><br><span class="line"><span class="string">    &#123;/*自定义逻辑*/&#125;</span></span><br><span class="line"><span class="string">    &lt;Get path="</span>/user/:id<span class="string">"&gt;&#123;(req, res) =&gt; res.send('hello')&#125;&lt;/Get&gt;</span></span><br><span class="line"><span class="string">  &lt;/server&gt;</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure><p><br></p><p>嵌套匹配场景</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (</span><br><span class="line">  &lt;server&gt;</span><br><span class="line">    &lt;Get path=<span class="string">"/api"</span>&gt;</span><br><span class="line">      &#123;<span class="comment">/* 匹配 /api?method=foo */</span>&#125;</span><br><span class="line">      &lt;MatchBySearch key=<span class="string">"method"</span> value=<span class="string">"foo"</span>&gt;</span><br><span class="line">        foo</span><br><span class="line">      &lt;<span class="regexp">/MatchBySearch&gt;</span></span><br><span class="line"><span class="regexp">      &#123;/</span>* 匹配 /api?method=bar *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">      &lt;MatchBySearch key="method" value="bar"&gt;</span></span><br><span class="line"><span class="regexp">        bar</span></span><br><span class="line"><span class="regexp">      &lt;/</span>MatchBySearch&gt;</span><br><span class="line">      &lt;BlackHole&gt;我会吃掉任何请求&lt;<span class="regexp">/BlackHole&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Get&gt;</span><br><span class="line">  &lt;<span class="regexp">/server&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p><br></p><p>有点 Verbose? 进一步封装组件:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyAwesomeAPI = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; path = <span class="string">'/api'</span>, children &#125; = props</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Get path=&#123;path&#125;&gt;</span><br><span class="line">      &#123;<span class="built_in">Object</span>.keys(children).map(<span class="function"><span class="params">name</span> =&gt;</span> (</span><br><span class="line">        &lt;MatchBySearch key=<span class="string">"method"</span> value=&#123;name&#125;&gt;</span><br><span class="line">          &#123;children[name]&#125;</span><br><span class="line">        &lt;<span class="regexp">/MatchBySearch&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Get&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (</span><br><span class="line">  &lt;server&gt;</span><br><span class="line">    &lt;MyAwesomeAPI&gt;&#123;&#123; <span class="attr">foo</span>: <span class="string">'foo'</span>, <span class="attr">bar</span>: <span class="string">'bar'</span> &#125;&#125;&lt;<span class="regexp">/MyAwesomeAPI&gt;</span></span><br><span class="line"><span class="regexp">    &lt;MyAwesomeAPI path="/</span>api<span class="number">-2</span><span class="string">"&gt;&#123;&#123; hello: 'foo', world: 'bar' &#125;&#125;&lt;/MyAwesomeAPI&gt;</span></span><br><span class="line"><span class="string">  &lt;/server&gt;</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure><p><br></p><p>看起来不错哈？我们看到了 JSX 作为 DSL 的潜力，也把 React 的组件思维搬到了 GUI 之外的领域。</p><p><br></p><hr><p><br></p><p>你知道我的风格，篇幅较长 ☕️ 休息一会，再往下看。</p><p><br><br><br></p><h2 id="3-jsx-入门"><a href="#3-jsx-入门" class="headerlink" title="3. JSX 入门"></a>3. JSX 入门</h2><p>如果你是 React 的开发者，JSX 应该再熟悉不过了。它不过是一个语法糖，但是它目前不是 JavaScript 标准的一部分。Babel、Typescript 都支持转译 JSX。</p><p>例如</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jsx = (</span><br><span class="line">  &lt;div foo=<span class="string">"bar"</span>&gt;</span><br><span class="line">    &lt;span&gt;<span class="number">1</span>&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span&gt;2&lt;/</span>span&gt;</span><br><span class="line">    &lt;Custom&gt;custom element&lt;<span class="regexp">/Custom&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>会转译为:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jsx = React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    foo: <span class="string">'bar'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  React.createElement(<span class="string">'span'</span>, <span class="literal">null</span>, <span class="string">'1'</span>),</span><br><span class="line">  React.createElement(<span class="string">'span'</span>, <span class="literal">null</span>, <span class="string">'2'</span>),</span><br><span class="line">  React.createElement(Custom, <span class="literal">null</span>, <span class="string">'custom element'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-1-自定义工厂"><a href="#3-1-自定义工厂" class="headerlink" title="3.1 自定义工厂"></a>3.1 自定义工厂</h3><p>JSX 需要一个<strong>工厂方法</strong>来创建创建’节点实例’。默认是 <code>React.createElement</code>。我们可以通过注释配置来提示转译插件。按照习惯，自定义工厂都命名为 <code>h</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* @jsx h */</span></span><br><span class="line"><span class="comment">/* @jsxFrag 'fragment' */</span></span><br><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">'somelib'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jsx = (</span><br><span class="line">  &lt;div foo=<span class="string">"bar"</span>&gt;</span><br><span class="line">    &lt;span&gt;<span class="number">1</span>&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span&gt;2&lt;/</span>span&gt;</span><br><span class="line">    &lt;&gt;fragement&lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>将转译为:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">'somelib'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jsx = h(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    foo: <span class="string">'bar'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  h(<span class="string">'span'</span>, <span class="literal">null</span>, <span class="string">'1'</span>),</span><br><span class="line">  h(<span class="string">'span'</span>, <span class="literal">null</span>, <span class="string">'2'</span>),</span><br><span class="line">  h(<span class="string">'fragment'</span>, <span class="literal">null</span>, <span class="string">'fragement'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-2-host-component-vs-custom-component"><a href="#3-2-host-component-vs-custom-component" class="headerlink" title="3.2 Host Component vs Custom Component"></a>3.2 Host Component vs Custom Component</h3><p>JSX 会区分两种组件类型。小写开头的为内置组件，它们以字符串的形式传入 createElement; 大写开头的表示自定义组件, 作用域内必须存在该变量, 否则会报错。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内置组件</span></span><br><span class="line">;<span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span></span><br><span class="line"><span class="xml">// 自定义组件</span></span><br><span class="line"><span class="xml">;<span class="tag">&lt;<span class="name">Custom</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-3-简单实现-createelement-工厂方法"><a href="#3-3-简单实现-createelement-工厂方法" class="headerlink" title="3.3 简单实现 createElement 工厂方法"></a>3.3 简单实现 createElement 工厂方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> copy = &#123; ...(props || EMPTY_OBJECT) &#125;</span><br><span class="line">  copy.children = copy.children || (children.length &gt; <span class="number">1</span> ? children : children[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    _vnode: <span class="literal">true</span>,</span><br><span class="line">    type,</span><br><span class="line">    props: copy,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="4-基础组件的设计"><a href="#4-基础组件的设计" class="headerlink" title="4. 基础组件的设计"></a>4. 基础组件的设计</h2><h3 id="4-1-来源于-koa-的灵感"><a href="#4-1-来源于-koa-的灵感" class="headerlink" title="4.1 来源于 Koa 的灵感"></a>4.1 来源于 Koa 的灵感</h3><p>大家应该比较熟悉 koa 中间件机制。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// logger</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  <span class="keyword">const</span> rt = ctx.response.get(<span class="string">'X-Response-Time'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;rt&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// x-response-time</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="built_in">Date</span>.now() - start</span><br><span class="line">  ctx.set(<span class="string">'X-Response-Time'</span>, <span class="string">`<span class="subst">$&#123;ms&#125;</span>ms`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// response</span></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'Hello World'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>形象的说，它就是一个洋葱模型:</p><p><img src="/images/jsx-as-dsl/koa.png" alt></p><p><br></p><p>中间件调用 next，就会进入下一级。 如果把函数的边界打破。它的样子确实像洋葱:</p><p><img src="/images/jsx-as-dsl/koa-2.png" alt></p><p><br></p><p>✨<strong>我发现使用 JSX 可以更直观地表示这种洋葱结构</strong></p><p><br></p><p><img src="/images/jsx-as-dsl/koa-3.png" alt></p><p><br><br><br></p><h3 id="4-2-use-基础组件"><a href="#4-2-use-基础组件" class="headerlink" title="4.2 use 基础组件"></a>4.2 use 基础组件</h3><p>于是乎，有了 <code>&lt;use /&gt;</code> 这个基础组件。它类似于 Koa 的 <code>app.use</code>, 用于拦截请求，可以进行响应, 也可以选择进入下一层。</p><p><strong>① 来看看整体设计</strong>。</p><p>use 正是基于上面说的，使用 JSX 来描述中间件包裹层次的基础组件。因为使用的是一种树状结构，所以要区分<strong>兄弟中间件</strong>和<strong>子中间件</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;server&gt;</span><br><span class="line">  &lt;use m=&#123;A&#125;&gt;</span><br><span class="line">    &lt;use m=&#123;Aa&#125; /&gt;</span><br><span class="line">    &lt;use m=&#123;Ab&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">  &lt;use m=&#123;B&#125; /</span>&gt;</span><br><span class="line">  &lt;use m=&#123;C&#125; /&gt;</span><br><span class="line">&lt;<span class="regexp">/server&gt;</span></span><br></pre></td></tr></table></figure><p>其中 <code>Aa</code>、<code>Ab</code> 就是 <code>A</code> 的<strong>子中间件</strong>。在 A 中可以调用类似 koa 的 <code>next</code> 函数，进入下级中间件。</p><p><code>A</code>、<code>B</code>、<code>C</code>之间就是<strong>兄弟中间件</strong>。当前继中间件未匹配时，就会执行下一个相邻中间件。</p><p>乍一看，这就是 koa 和 express 的结合啊!</p><p><br></p><p><strong>② 再看看 Props 设计</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface UseProps &#123;</span><br><span class="line">  m: <span class="function">(<span class="params">req, res, recurse: (</span>) =&gt;</span> <span class="built_in">Promise</span>&lt;boolean&gt;) =&gt; <span class="built_in">Promise</span>&lt;boolean&gt;;</span><br><span class="line">  skip?: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>m</code></p><ul><li><p><code>req</code>、<code>res</code>：Express 的请求对象和响应对象</p></li><li><p><code>recurse</code>：递归执行子级中间件, 类似 koa 的 next。返回一个<code>Promise&lt;boolean&gt;</code>, 它将在下级中间件执行完成后 resolve，boolean 表示下级中间件是否匹配拦截了请求。</p></li><li><p>返回值：返回一个 <code>Promise&lt;boolean&gt;</code> 表示当前中间件是否匹配(拦截请求)。如果匹配，后续的兄弟中间件将不会被执行。</p></li></ul></li><li><p><code>skip</code>：强制跳过，我们在开发时可能会临时跳过匹配请求，这个有点像单元测试中的 skip</p></li></ul><p><br></p><p><strong>③ 看一下运行实例</strong></p><p>假设代码为:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cb = <span class="function"><span class="params">name</span> =&gt;</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (</span><br><span class="line">  &lt;server&gt;</span><br><span class="line">    &lt;use</span><br><span class="line">      m=&#123;<span class="keyword">async</span> (req, res, rec) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'A'</span>)</span><br><span class="line">        <span class="keyword">if</span> (req.path === <span class="string">'/user'</span>) <span class="keyword">await</span> rec() <span class="comment">// 如果匹配，则放行，让其递归进入内部</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'end A'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;use m=&#123;cb(<span class="string">'A-1'</span>)&#125;&gt;如果父级匹配，则这里会被执行&lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">      &lt;use m=&#123;cb('A-2')&#125;&gt;...&lt;/u</span>se&gt;</span><br><span class="line">    &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">    &lt;use m=&#123;cb('B')&#125; /</span>&gt;</span><br><span class="line">    &lt;use m=&#123;cb(<span class="string">'C'</span>)&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/server&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>如果请求的是 ‘/‘，那么打印的是 <code>A -&gt; end A -&gt; B -&gt; C</code>；<br>如果请求为 ‘/user’, 那么打印的是 <code>A -&gt; A-1 -&gt; A-2 -&gt; end A -&gt; B -&gt; C</code></p><p><br></p><p>我们的基础组件和 Koa / Express 一样，核心保持非常小而简洁，当然它也比较低级，这样能够保证灵活性。</p><p><strong>这个简单的基础组件设计就是整个框架的‘基石’</strong>。 如果你了解 Koa 和 Express，这里没有新的东西。只是换了一种表现方式。</p><p><br><br><br></p><h3 id="4-3-高层组件的封装"><a href="#4-3-高层组件的封装" class="headerlink" title="4.3 高层组件的封装"></a>4.3 高层组件的封装</h3><p>Ok, 有了 <code>use</code> 这个基础原语, 我可以做很多有意思的事情，使用组件化的思维封装出更高级的 API。</p><p><br></p><p><strong>① <code>&lt;Log&gt;</code>：打日志</strong></p><p>封装一个最简单的组件:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Log: Component = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;use</span><br><span class="line">      m=&#123;<span class="keyword">async</span> (req, res, rec) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">        <span class="comment">// 进入下一级</span></span><br><span class="line">        <span class="keyword">const</span> rtn = <span class="keyword">await</span> rec()</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">          <span class="string">`<span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;req.path&#125;</span>: <span class="subst">$&#123;<span class="built_in">Date</span>.now() - start&#125;</span>ms`</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> rtn</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>用法:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;server&gt;</span><br><span class="line">  &lt;Log&gt;</span><br><span class="line">    &lt;Get&gt;hello world&lt;<span class="regexp">/Get&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Post path="/</span>login<span class="string">"&gt;login sucess&lt;/Post&gt;</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">  &lt;/Log&gt;</span></span><br><span class="line"><span class="string">&lt;/server&gt;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><p><strong>② <code>&lt;NotFound&gt;</code>: 404</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NotFound = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; children &#125; = props</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;use</span><br><span class="line">      m=&#123;<span class="keyword">async</span> (req, res, rec) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> found = <span class="keyword">await</span> rec()</span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">          <span class="comment">// 下级未匹配</span></span><br><span class="line">          res.status(<span class="number">404</span>)</span><br><span class="line">          res.send(<span class="string">'Not Found'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>用法和 Log 一样。<code>recurse</code> 返回 false 时，表示下级没有匹配到请求。</p><p><br><br><br></p><p><strong>③ <code>&lt;Catch&gt;</code>: 异常处理</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Catch: Component = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;use</span><br><span class="line">      m=&#123;<span class="keyword">async</span> (req, res, rec) =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">await</span> rec()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          res.status(<span class="number">500</span>)</span><br><span class="line">          res.send(err.message)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>用法和 Log 一样。捕获下级中间件的异常。</p><p><br><br><br></p><p><strong>④ <code>&lt;Match&gt;</code>: 请求匹配</strong></p><p>Match 组件也是一个非常基础的组件，其他高层组件都是基于它来实现。它用于匹配请求，并作出响应。先来看看 Props 设计：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type CustomResponder =</span><br><span class="line">  | MiddlewareMatcher</span><br><span class="line">  | MockType</span><br><span class="line">  | boolean</span><br><span class="line">  | string</span><br><span class="line">  | number</span><br><span class="line">  | object</span><br><span class="line">  | <span class="literal">null</span></span><br><span class="line">  | <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface MatchProps &#123;</span><br><span class="line">  match?: <span class="function">(<span class="params">req: Request, res: Response</span>) =&gt;</span> boolean <span class="comment">// 请求匹配</span></span><br><span class="line">  headers?: StringRecord <span class="comment">// 默认响应报头</span></span><br><span class="line">  code?: number | string <span class="comment">// 默认响应码</span></span><br><span class="line">  <span class="comment">// children 类型则比较复杂, 可以是原始类型、对象、Mock对象、自定义响应函数，以及下级中间件</span></span><br><span class="line">  children?: ComponentChildren | CustomResponder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>Match 组件主体:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Match = <span class="function">(<span class="params">props: MatchProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; match, skip, children &#125; = props</span><br><span class="line">  <span class="comment">// 对 children 进行转换</span></span><br><span class="line">  <span class="keyword">let</span> response = generateCustomResponder(children, props)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;use</span><br><span class="line">      skip=&#123;skip&#125;</span><br><span class="line">      m=&#123;<span class="keyword">async</span> (req, res, rec) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 检查是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (match ? match(req, res) : <span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (response) &#123;</span><br><span class="line">            <span class="keyword">return</span> response(req, res, rec)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果没有响应器，则将控制权交给下级组件</span></span><br><span class="line">          <span class="keyword">return</span> rec()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>限于篇幅，Match 的具体细节可以看<a href="https://github.com/ivan-94/jsxmock/blob/master/src/components/Match.tsx" target="_blank" rel="noopener">这里</a></p><p>前进，前进。 <code>Get</code>、<code>Post</code>、<code>Delete</code>、<code>MatchByJSON</code>、<code>MatchBySearch</code> 都是在 <code>Match</code> 基础上封装了，这里就不展开了。</p><p><br><br><br></p><p><strong>⑤ <code>&lt;Delay&gt;</code>: 延迟响应</strong></p><p>太兴奋了，一不小心又写得老长，我可以去写小册了。Ok, 最后一个例子, 在 Mock API 会有模拟延迟响应的场景, 实现很简单:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Delay = <span class="function">(<span class="params">props: DelayProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; timeout = <span class="number">3000</span>, ...other &#125; = props</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;use</span><br><span class="line">      m=&#123;<span class="keyword">async</span> (req, res, rec) =&gt; &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> setTimeout(res, timeout))</span><br><span class="line">        <span class="keyword">return</span> rec()</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;Match &#123;...other&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>用法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Get path=<span class="string">"/delay"</span>&gt;</span><br><span class="line">  &#123;<span class="comment">/* 延迟 5s 返回 */</span>&#125;</span><br><span class="line">  &lt;Delay timeout=&#123;<span class="number">5000</span>&#125;&gt;Delay Delay...&lt;<span class="regexp">/Delay&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Get&gt;</span><br></pre></td></tr></table></figure><p>更多使用案例，请看 <a href="https://github.com/ivan-94/jsxmock" target="_blank" rel="noopener">jsxmock 文档</a>)</p><p>坚持到这里不容易，你对它的原理可能感兴趣，那不妨继续看下去。</p><p><br><br><br></p><h2 id="5-浅谈实现原理"><a href="#5-浅谈实现原理" class="headerlink" title="5. 浅谈实现原理"></a>5. 浅谈实现原理</h2><p>简单看一下实现。如果了解过 React 或者 Virtual-DOM 的实现原理。这一切就很好理解了。</p><p><br></p><h3 id="5-1-‘渲染’"><a href="#5-1-‘渲染’" class="headerlink" title="5.1 ‘渲染’"></a>5.1 ‘渲染’</h3><p>这是打了引号的’渲染’。这只是一种习惯的称谓，并不是指它会渲染成 GUI。它用来展开整颗 JSX 树。对于我们来说很简单，我们没有所谓的更新或者 UI 渲染相关的东西。只需递归这个树、收集我们需要的东西即可。</p><p>我们的目的是收集到所有的中间件，以及它们的嵌套关系。我们用 MiddlewareNode 这个树形数据结构来存储它们：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type Middleware = (</span><br><span class="line">  req: Request,</span><br><span class="line">  res: Response,</span><br><span class="line">  <span class="comment">// 递归</span></span><br><span class="line">  recurse: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>&lt;boolean&gt;,</span><br><span class="line">) =&gt; <span class="built_in">Promise</span>&lt;boolean&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface MiddlewareNode &#123;</span><br><span class="line">  m: Middleware           <span class="comment">// 中间件函数</span></span><br><span class="line">  skip: boolean           <span class="comment">// 是否跳过</span></span><br><span class="line">  children: MiddlewareNode[] <span class="comment">// 子级中间件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染函数:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> currentMiddlewareNode</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 🔴 创建根中间件</span></span><br><span class="line">  <span class="keyword">const</span> middlewares = (currentMiddlewareNode = createMiddlewareNode())</span><br><span class="line">  <span class="comment">// 🔴 挂载</span></span><br><span class="line">  <span class="keyword">const</span> tree = mount(vnode)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>挂载是一个递归的过程，这个过程中，遇到<code>自定义组件</code>我们就展开，遇到 use 组件就将它们收集到 <code>currentMiddlewareNode</code> 中:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prevMiddlewareNode</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode.type === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 🔴自定义组件展开</span></span><br><span class="line">    <span class="keyword">const</span> rtn = vnode.type(vnode.props)</span><br><span class="line">    <span class="keyword">if</span> (rtn != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 递归挂载自定义组件的渲染结果</span></span><br><span class="line">      mount(rtn, inst)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode.type === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="comment">// 内置组件</span></span><br><span class="line">    <span class="keyword">if</span> (vnode.type === <span class="string">'use'</span>) &#123;</span><br><span class="line">      <span class="comment">// 🔴收集中间件</span></span><br><span class="line">      <span class="keyword">const</span> md = createMiddlewareNode(inst.props.m)</span><br><span class="line">      md.skip = !!inst.props.skip</span><br><span class="line">      currentMiddlewareNode.children.push(md)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 保存父级中间件</span></span><br><span class="line">      prevMiddlewareNode = currentMiddlewareNode</span><br><span class="line">      currentMiddlewareNode = md <span class="comment">// ⬇️推入栈，下级的中间件将加入这个列表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ... 其他内置组件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 🔴递归挂载子级节点</span></span><br><span class="line">    mountChilren(inst.props.children, inst)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vnode.type === <span class="string">'use'</span>) &#123;</span><br><span class="line">      currentMiddlewareNode = prevMiddlewareNode <span class="comment">// ⬆️弹出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🔴 子节点列表挂载</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountChilren</span>(<span class="params">children: any, parent: Instance</span>) </span>&#123;</span><br><span class="line">  childrenToArray(children).forEach(mount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="5-2-运行"><a href="#5-2-运行" class="headerlink" title="5.2 运行"></a>5.2 运行</h3><p>现在看看怎么运行起来。我们实现了一个简单的中间件机制，相对 Koa 好理解一点：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">runMiddlewares</span>(<span class="params">req, res, current</span>): <span class="title">Promise</span>&lt;<span class="title">boolean</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; m, skip, children &#125; = current</span><br><span class="line">  <span class="keyword">if</span> (skip) &#123;</span><br><span class="line">    <span class="comment">// 跳过, 直接返回 false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用中间件</span></span><br><span class="line">  <span class="keyword">return</span> m(req, res, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// recurse 回调</span></span><br><span class="line">    <span class="comment">// 🔴 如果有下级中间件，则递归调用子级中间件</span></span><br><span class="line">    <span class="keyword">if</span> (children &amp;&amp; children.length) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> child <span class="keyword">of</span> children) &#123;</span><br><span class="line">        <span class="keyword">const</span> matched = <span class="keyword">await</span> runMiddlewares(req, res, child)</span><br><span class="line">        <span class="keyword">if</span> (matched) &#123;</span><br><span class="line">          <span class="comment">// 🔴 如果其中一个兄弟中间件匹配，后续的中间件都不会被执行</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 🔴 没有下级中间件，或者没有任何下级中间件匹配</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>很简单哈？ 就是递归递归递归</p><p><br><br><br></p><h2 id="6-总结，终于完事了"><a href="#6-总结，终于完事了" class="headerlink" title="6. 总结，终于完事了"></a>6. 总结，终于完事了</h2><p>本文从配置文件讲到 DSL，又讲到了 JavaScript 内部 DSL 表达形式和能力。最后将焦点聚集在了 JSX 上面。</p><p>我通过一个实战的案例展示了 JSX 和 React 的组件化思维，它不仅仅适用于描述用户界面，我们也看到 JSX 作为一种 DSL 的潜力和灵活性。</p><p>最后总结一下优缺点。</p><p><br></p><p><strong>✅ 优点</strong></p><ul><li><strong>更好的类型推断和约束</strong>。 Typescript 友好</li><li><strong>可组合</strong>。具有组件封装和组合能力, 可以轻易封装高级、易于使用的接口</li><li><strong>Just Javascript</strong>。 本身就是 JavaScript 代码，很灵活</li><li><strong>更好的组织性、媲美配置文件</strong>。JSX 语法类似于 XML，有良好的组织性。</li><li><strong>习惯</strong>。 如果你习惯 React，Vue 这类前端框架，JSX 配置方式很容易被接受和上手</li><li><strong>实现简单</strong>。</li><li><strong>更能直观地表现层级结构</strong>。比如表示中间件的洋葱结构</li><li><strong>模块化</strong>。与生俱来，可以将接口分发到不同的文件中，然后可轻易地组合起来。</li></ul><p><br></p><p><strong>⚠️ 缺点</strong></p><ul><li>代码需要转译。需要 Babel 和 Typescript 转译。</li><li>有点 Verbose。</li></ul><p><br></p><p><strong>灵活却有组织性</strong>。灵活通常容易导致杂乱无章，组织性则可能意味着牺牲灵活性，两者在某种意义上面看是矛盾的。能够将两者平衡案例其实很少见，JSX 可能是一个。（我好像在吹 🐂）</p><p><br></p><p><strong>🎉🎉代码已经在 Github, 目前正处于原型阶段: <a href="https://github.com/ivan-94/jsxmock" target="_blank" rel="noopener">ivan-94/jsxmock</a> 欢迎 ⭐️ 和贡献。</strong></p><p><br><br><br></p><h2 id="7-扩展"><a href="#7-扩展" class="headerlink" title="7. 扩展"></a>7. 扩展</h2><ul><li><a href="https://www.yinwang.org/blog-cn/2017/05/25/dsl" target="_blank" rel="noopener">DSL 的误区</a></li><li><a href="https://draveness.me/dsl" target="_blank" rel="noopener">谈谈 DSL 以及 DSL 的应用（以 CocoaPods 为例）</a></li><li><a href="https://www.phodal.com/blog/javascript-dsl-example/" target="_blank" rel="noopener">JavaScript DSL 示例</a></li><li><a href="https://www.zhihu.com/question/35436669" target="_blank" rel="noopener">你是如何构建 Web 前端 Mock Server 的？</a></li><li><a href="https://docs.svrx.io/zh/blog/mock.html" target="_blank" rel="noopener">使用 svrx 实现更优雅的接口 Mock</a></li></ul><p><br></p><p>也学别人建个群(好多读者问过)，试试水吧…</p><p><img src="/images/group.png" alt></p><p><br></p><p><img src="/images/sponsor.jpg" alt></p><p><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天打算写一个简单的 API Mock 服务器，老生常谈哈？其实我是想讲 JSX, Mock 服务器只是一个幌子。我在寻找一种更简洁、方便、同时又可以灵活扩展的、和别人不太一样的方式，来定义各种 Mock API。后来我发现了 JSX 在领域问题描述的优势和潜力，当然这可
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
</feed>
