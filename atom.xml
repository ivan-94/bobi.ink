<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bobi.ink</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bobi.ink/"/>
  <updated>2023-07-13T02:11:54.631Z</updated>
  <id>https://bobi.ink/</id>
  
  <author>
    <name>Ivan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微前端的落地和治理实战</title>
    <link href="https://bobi.ink/2023/07/13/microfrontend/"/>
    <id>https://bobi.ink/2023/07/13/microfrontend/</id>
    <published>2023-07-12T16:00:00.000Z</published>
    <updated>2023-07-13T02:11:54.631Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/microfrontend/Untitled.png" alt="Untitled"></p><p>微前端实现原理、框架选型之类的文章比较泛滥，我不打算讲这些玩意，本文主要来源于笔者过去一年落地微前端的一手经验，尽量不讲技术细节，而是讲一个体系化的方案是怎么搭建起来。</p><p>文章较长，耐心看完保证会有收获。</p><h1 id="背景与痛点"><a href="#背景与痛点" class="headerlink" title="背景与痛点"></a>背景与痛点</h1><p>首先来看下业务背景，方便读者了解我们为什么选择微前端，以及其他相关技术选型的原因。</p><p>前端在架构上面的变化远落后于后端，后端的架构已经经历了微服务、中台化、DDD 改造的腥风血雨…</p><p>在改造成微前端之前, 我们也是一个巨型的<code>单体应用</code>，后面随着业务的复杂化，业务和团队进一步进行拆分， 我们的前端项目也根据<a href="https://zh.wikipedia.org/zh-hans/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener"><code>康威定律</code></a>，进化成为了‘<code>多页应用</code>’， 如下图所示：</p><p><img src="/images/microfrontend/Untitled%201.png" alt="多页"></p><p><br></p><p>我们主要做的是 2B 业务，做 <a href="https://zh.wikipedia.org/zh-hans/%E6%A6%82%E5%BF%B5%E9%AA%8C%E8%AF%81" target="_blank" rel="noopener">POC</a>(概念验证) 和<code>私有化部署</code>是家常便饭，在已有的架构下，我们需要应用某些配置可能会牵扯多个项目，比如主题、文案、接口配置等信息的修改，需要针对多个项目进行创建分支、修改代码、构建、发布、部署… 一系列繁琐的流程</p><p>主要原因是我们的业务系统经过长期、多团队、多业态的迭代，积累了大量的技术债。</p><ul><li>技术栈老旧，开发效率低，我们想要应用新的技术和规范，但碍于项目体量大、质量差，重构举步维艰。</li><li>子应用的拆分没有固定的范式。有些模块按照团队拆分出独立的仓库，有些仓库则采用 MonoRepo。前者仓库之间存在大量重复代码、缺乏管理；而后者 MonoRepo 则越来越臃肿, 职责不清晰，编译缓慢, 逐渐也演变成了<code>巨石应用</code>。</li><li>基于多页的子应用缺乏管理，规范/标准不统一。无法统一控制视觉呈现、共享的功能和依赖。造成重复工作</li><li>新旧项目、第三方应用集成都很复杂。</li><li>多行业、多团队的项目特性，导致工程管理复杂，扩展性差。</li><li>部署方式原始。</li><li>应用按照菜单聚合，而不是按照业务聚合</li><li>…</li></ul><p><br></p><blockquote><p>💡  怎么理解 “应用按照菜单聚合，而不是按照业务聚合” 呢？</p><p><img src="/images/microfrontend/Untitled%202.png" alt="菜单聚合"></p><p><strong>朴素的多页应用通常按照“菜单”来拆分应用，比如按照上图的顶级 Tab。</strong></p><p>后面来这一个这样的需求，a 应用的某些功能菜单需要在 b Tab 下展示，这时候就傻眼了：</p><ul><li>把 a 的相关代码搬运到 b？如果后面菜单又改了怎么办？再说，你能搬得动吗？</li><li>用 iframe 将 a 套在 b 应用下？</li></ul></blockquote><p><br><br><br></p><p>因此我们亟需一套新的架构，<strong>能统一管理不同团队业务线、同时能够保持原本的独立性和灵活性</strong>。这时候微前端架构就进入了我们的考察范围：</p><p><img src="/images/microfrontend/Untitled%203.png" alt="星状"></p><p>我们需要一个「底座」将不同的应用聚合起来，将原本<code>离散</code>的应用通过一个<code>基座</code>串联起来：</p><ul><li><strong>离散的应用结构，转换为星状结构。</strong>基座可以统一管理子应用。</li><li><strong>开发者可以更专注于业务的开发</strong>。基座会提供配套的登录会话管理、权限管理、菜单管理、路由管理、主题管理等方案，子应用只需关心业务功能本身的开发。</li><li><strong>更容易地集成应用</strong>。不管是自己的业务应用、老旧系统、还是外部第三方应用，都可以在极少改动的情况下集成进来。</li><li><strong>视觉统一</strong>。</li><li><strong>拆分巨石应用，让子应用可以按照“业务聚合”</strong>。<strong>不再耦合菜单</strong>， 让应用更轻量、内聚、更可维护</li></ul><blockquote><p>💡  使用微前端之后，子应用不再耦合菜单，菜单由基座来管理和组合，菜单可以被放在任意位置。</p></blockquote><p><br></p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><strong>由于我们原本就是<code>多页应用</code>的架构，所以基于<code>路由分发</code> + <code>基座形式</code>的微前端方案是一种比较自然的选择</strong>。整体项目架构如下：</p><p><img src="/images/microfrontend/Untitled%204.png" alt="Untitled"></p><p>我们构造了一整套体系化的方案： 从<code>规范</code>到<code>开发基础库</code>、从<code>权限管理系统</code>到<code>微前端基座</code>、从<code>开发调试</code>到<code>部署运维</code>。</p><ol><li><strong>基础库：</strong>我们将每个应用都重复的工作提取出来，重新设计，并严格管理起来。使之能真正有效地服务业务开发，避免重复造轮子。</li><li><strong>开发规范</strong>：同时，我们期望提供更丰富的开发规范、指导、最佳实践作为支撑。让开发者走更少的弯路。</li><li><strong>权限管理平台</strong>：基座的<strong>菜单</strong>、<strong>权限信息</strong>来源于<code>权限管理平台</code>, 通过权限管理平台可以灵活地给不同业态、不同角色配置不同的菜单和权限。这是我们微前端方案的重要基础。</li><li><strong>基座:</strong> 基座是微前端应用集成的一个重要平台。同时也肩负着管理公共资源、依赖、规范的责任。主要有以下职责：<ul><li>子应用集成。给子应用提供渲染容器</li><li>路由/菜单管理</li><li>权限管理</li><li>主题管理</li><li>会话管理</li><li>多语言管理</li><li>共享依赖等</li></ul></li><li><p><strong>运行容器：<a href="https://wakeadmin.wakedata.com/mapp/deploy.html" target="_blank" rel="noopener">运行容器</a></strong>  是我们提供的一套微前端的运行和部署方案。相比传统纯粹的前端资源静态部署，我们希望在部署阶段可以做更多的事情：</p><ul><li>动态配置。比如域名配置、SEO 信息配置</li><li>主题管理。一键换肤能否实现？</li><li>子应用管理。自动发现子应用，而不是在微前端基座中硬编码？</li><li>语言包。能否实时配置语言包，而不需要重新编译代码、审核、发布…</li><li>开发环境、测试环境部署能否简化？</li></ul><p>得益于<code>运行容器</code>，我们可以实现<strong>前端部署的标准化</strong>，支持「<strong>一键部署」</strong>等能力。</p></li></ol><p><br><br><br><br><br><br><br></p><h1 id="基座"><a href="#基座" class="headerlink" title="基座"></a>基座</h1><p><img src="/images/microfrontend/Untitled%205.png" alt="基座主界面"></p><p>基座主界面</p><p>如上所示，基座为子应用提供了基础的运行环境， 蓝色区域为子应用的运行范围。</p><p><br></p><p><img src="/images/microfrontend/Untitled%206.png" alt="基座结构"></p><p>基座的大概结构如上。</p><p>首先是<code>会话管理</code>，基座会<code>拦截</code>应用的所有请求，如果监听到 401 状态码，则跳转到登录页面进行授权。登录/注册页面也是由子应用提供，我们尽量不让基座耦合具体的业务。</p><p><br></p><p>基座启动后，就会从<code>权限管理平台</code>拉取菜单、权限配置信息，渲染页面的菜单导航框架。同时也会对页面路由进行授权拦截，而细粒度的权限控制(比如按钮)，基座也会暴露 API 供子应用适配。</p><p><br></p><p>至于子应用信息，则是<strong>由<code>运行容器</code>自动发现并注入</strong>，避免在基座中硬编码了这些信息。基座底层基于 <a href="https://github.com/umijs/qiankun" target="_blank" rel="noopener">qiankun</a>，根据路由匹配渲染指定的子应用。</p><blockquote><p>💡 <code>运行容器</code>是啥? 这个我们会在下文介绍，简单来说，它就是一个 <code>NodeJS</code> 服务，会<strong>自动发现</strong>已经部署在服务器中的子应用，然后将这些信息注入到基座的启动代码中。</p></blockquote><p><br></p><p>基座还统一管理了<code>主题包</code>、<code>多语言</code>。从而保证子应用可以有较为统一的呈现。主题包也可以在部署时动态切换，这对于 POC 或者私有化部署比较方便。</p><blockquote><p>💡  主题包主要包含 CSS 变量、组件库样式、语言包、静态资源、甚至一些部署配置信息。</p></blockquote><p><br></p><p><img src="/images/microfrontend/Untitled%207.png" alt="API"></p><p>为了方便子应用使用基座的「<code>服务</code>」， 基座也向子应用暴露了一系列的组件库和 API。</p><p>组件库基于使用 <code>Web Component</code> 的形式，实现框架无关， 基于 Vue 3 创建。Vue 3 <a href="https://cn.vuejs.org/guide/extras/web-components.html" target="_blank" rel="noopener">构建自定义元素</a> 也很方便，所以就没必要引入其他框架专门来编写这块了</p><p>这些 API 可以直接挂载在全局 window 对象上，子应用可以直接访问。</p><blockquote><p>💡  实际上我们封装了一个套壳 npm 库，避免子应用直接访问 window 对象上的服务, 隐藏细节，另外可以提供类型提示。</p></blockquote><p><br><br><br><br><br><br><br></p><h1 id="子应用接入"><a href="#子应用接入" class="headerlink" title="子应用接入"></a>子应用接入</h1><p>简单、免侵入地改造子应用使我们要达成的主要目标。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>为此，我们也提供了相应的 <code>vue-cli</code> 插件, 支持快速集成，避免开发者关心 Webpack 底层的各种配置细节</p><blockquote><p>我们的微前端主要基于 <a href="https://github.com/umijs/qiankun" target="_blank" rel="noopener">qiankun</a>，官方目前并不支持 Vite，并且我们大量项目主要以 Vue CLI 为主。</p></blockquote><p>示例：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">'@vue/cli-service'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; defineMappChild &#125; = <span class="built_in">require</span>(<span class="string">'@wakeadmin/vue-cli-plugin-mapp-child'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  transpileDependencies: <span class="literal">false</span>,</span><br><span class="line">  pluginOptions: &#123;</span><br><span class="line">    <span class="comment">// 只需要简单的配置</span></span><br><span class="line">    ...defineMappChild(&#123;</span><br><span class="line">      mapp: &#123;</span><br><span class="line">        activeRule: <span class="string">'/dsp.html'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">  lintOnSave: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>多入口配置：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">'@vue/cli-service'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; defineMappChild &#125; = <span class="built_in">require</span>(<span class="string">'@wakeadmin/vue-cli-plugin-mapp-child'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  <span class="comment">// 多页应用</span></span><br><span class="line">  pages: &#123;</span><br><span class="line">    index: <span class="string">'src/main.ts'</span>,</span><br><span class="line">    another: <span class="string">'src/another.ts'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  pluginOptions: &#123;</span><br><span class="line">    <span class="comment">// 微前端集成配置</span></span><br><span class="line">    ...defineMappChild(&#123;</span><br><span class="line">      mapp: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// entry 必须为上面 pages 中定义的 key</span></span><br><span class="line">          entry: <span class="string">'index'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// entry 必须为上面 pages 中定义的 key</span></span><br><span class="line">          entry: <span class="string">'another'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>接着调整应用挂载程序：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp, App <span class="keyword">as</span> TApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHashHistory &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> Bay <span class="keyword">from</span> <span class="string">'@wakeadmin/bay'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; routes &#125; <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app: TApp</span><br><span class="line"></span><br><span class="line">Bay.createMicroApp(&#123;</span><br><span class="line">  <span class="keyword">async</span> bootstrap() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bootstrap vue3'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> mount(container, props) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'mount vue3'</span>, props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">      history: createWebHashHistory(),</span><br><span class="line">      routes,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    app = createApp(App).use(store).use(router).use(Bay)</span><br><span class="line"></span><br><span class="line">    app.mount(container?.querySelector(<span class="string">'#app'</span>) ?? <span class="string">'#app'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> unmount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'unmount vue3'</span>)</span><br><span class="line"></span><br><span class="line">    app.unmount()</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> update() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'update vue3'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="本地开发和调试"><a href="#本地开发和调试" class="headerlink" title="本地开发和调试"></a>本地开发和调试</h2><p>运行起来后， 我们会在终端打印出子应用的相关信息，如下图：</p><p><img src="/images/microfrontend/Untitled%208.png" alt="terminal"></p><p>接下来，只需要在<code>基座的调试页面</code>，注册这个子应用就可以运行起来的：</p><p><img src="/images/microfrontend/Untitled%209.png" alt="debug"></p><blockquote><p>💡  有了微前端之后，子应用的开发和调试也简化了很多，可以随时挂载到任意环境，不需要配置任何服务端代理。</p></blockquote><p><br><br><br><br><br></p><h1 id="部署和治理"><a href="#部署和治理" class="headerlink" title="部署和治理"></a>部署和治理</h1><p>网上很少关于微前端应用的部署和治理的介绍，下面介绍我们自己摸索出来一套方案， 这也是本文的重点。</p><p><br></p><h2 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h2><p>在此之前，我们的前端项目都是扔到一台静态资源服务器，很多开发者会手动操作，项目之前通过目录隔离，手动维护 Nginx 进行分流，手段原始且容易出错，场面十分混乱。</p><p>在 2021 年，我们就开始推行前端项目的容器化，来解决这种混乱的状态。</p><p>为了<code>标准化</code>、<code>自动化</code>每个项目的构建操作、部署流程，我们和后端对齐， 使用容器和 K8S 来实现发布产物的封装和部署。这样的好处是：</p><ul><li>实现测试环境和生产环境的统一。</li><li>简化部署流程， 采用统一的配置，无需更改 Nginx 配置</li><li>真正做到不同团队项目的隔离。</li><li>支持回滚</li><li>简化和标准化构建流程。同时也简化了运维的工作，前后端都是容器部署。</li><li>运行的环境更加灵活。我们可以使用最新的 nginx 版本，可以使用 HTTP2 等新的技术，前端自己就可以部署一套 NodeJS 环境，做一些更酷的事情。对运维的依赖性会更低。</li></ul><p><br></p><p>这对我们来说是一个比较重要的升级。我们的工作不再局限于静态资源的伺服，我们可以使用 NodeJS 开发 API、自动化工作流、可以进行服务端渲染等等，拓展了能力的边界。</p><p><br><br><br></p><p>然而，很多配置信息在构建时就固定下来了，比如 CDN 域名，接口请求路径等等。而不同环境通常会使用不同的配置信息。<strong>这样就无法实现构建一次镜像，在不同环境运行。</strong></p><p>后端程序的解决办法是将配置信息外置，比如通过<code>环境变量</code>配置或者从<code>配置中心</code>(比如 Nacos)获取。</p><p>这在前端行不通，所以我们引入了<code>运行容器</code>的概念。</p><p><br><br><br></p><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p><code>运行容器</code>，顾名思义就是整套<code>微前端</code> 的<code>运行时</code>，以 「<code>Docker 容器</code>」的形式部署。我们尽量复用 K8S 提供的基础设施(比如 PVC、配置映射、Sidecar 等) 来实现。</p><p>运行容器的主要结构：</p><p><img src="/images/microfrontend/Untitled%2010.png" alt="container"></p><p><code>运行容器</code>主要包含两大部分：</p><ul><li><code>Nginx</code> ：毫无疑问，Nginx 是<code>静态资源伺服</code>的最佳能手，同时它作为内部服务<code>反向代理</code>。</li><li><code>transpiler</code> (我们称为<code>转换器</code>): 这是一个「搬运工」，主要负责配置的收集、代码转换。并将转换后的静态资源交给  <code>nginx</code>  伺服。</li></ul><p>下面会详细介绍它的能力。</p><p><br><br><br></p><h2 id="如果实现子应用的自动发现？"><a href="#如果实现子应用的自动发现？" class="headerlink" title="如果实现子应用的自动发现？"></a>如果实现子应用的自动发现？</h2><p>答案是<strong>”约定“</strong>。</p><p>运行容器约定了以下目录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/data/</span><br><span class="line">  /<span class="built_in">source</span>/                   <span class="comment"># 源目录</span></span><br><span class="line">    /__public__/             <span class="comment"># 公共资源, 外部可以直接访问，不需要 __public__ 前缀</span></span><br><span class="line">    /__config__/             <span class="comment"># 配置目录</span></span><br><span class="line">      config.yml</span><br><span class="line">      any-sub-dir/</span><br><span class="line">        my-config.yml</span><br><span class="line"></span><br><span class="line">    /__entry__/              <span class="comment"># 基座目录</span></span><br><span class="line">      js/</span><br><span class="line">      index.html</span><br><span class="line"></span><br><span class="line">    /__apps__/               <span class="comment"># 子应用目录</span></span><br><span class="line">      wkb/</span><br><span class="line">      dsp/</span><br><span class="line">      dmp/</span><br><span class="line">        js/</span><br><span class="line">        mapp.json</span><br><span class="line">        index.html</span><br><span class="line"></span><br><span class="line">    /__i18n__/               <span class="comment"># 语言包目录</span></span><br><span class="line">      zh.tr</span><br><span class="line">      en.tr</span><br><span class="line">      any-sub-dir/</span><br><span class="line">        zh.tr</span><br><span class="line">        en.tr</span><br><span class="line"></span><br><span class="line">    /__theme__/              <span class="comment"># 主题目录</span></span><br><span class="line">      config.yml</span><br><span class="line">      element-ui.css</span><br><span class="line">      element-plus.css</span><br><span class="line">      fonts/</span><br><span class="line">      i18n/</span><br><span class="line">        zh.tr</span><br><span class="line">        en.tr</span><br><span class="line"></span><br><span class="line">  /public/                    <span class="comment"># nginx 伺服目录</span></span><br></pre></td></tr></table></figure><p>目录结构解析：</p><ul><li><code>/data/source</code>。没错，<code>transpiler</code>  就是<code>转译</code>和搬运这里的静态资源。</li><li><code>/data/public</code>。 <code>transpiler</code>  就是将资源转译后搬运到这里，<code>nginx</code>  对外伺服这个目录。</li></ul><p><br></p><blockquote><p>转译？<code>transpiler</code> 可以认为就是一个模板引擎，它会替换代码里面的动态变量。</p></blockquote><p><br></p><p>再来看  <code>/data/source</code>：</p><ul><li><code>__entry__</code>: 基座编译之后的代码就部署这里。</li><li><code>__apps__</code>: 子应用编译之后的代码就部署这里，子应用之间， 按照唯一的  <code>name</code>  区分目录。</li><li><code>__i18n__</code>: 扩展语言包，文件按照  <code>&lt;language&gt;.tr</code>  命名， 子目录的 .tr 文件也会被扫描到。</li><li><code>__config__</code>: 配置目录。配置文件使用  <code>.yml</code>  或  <code>.yaml</code>  命名，也可以放在子目录下。</li><li><code>__theme__</code>: 主题包目录。可以手动维护，也可以使用  <code>npmTheme</code>  配置项, 让  <code>transpiler</code>  从 npm 拉取。</li><li><code>__public__</code>: 公共资源目录。这些资源可以直接访问，而不需要  <code>__public__</code>  前缀。举个例子:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">__theme__/</span><br><span class="line">  index.css  *<span class="comment"># -&gt; 访问链接 example.com/__theme__/index.css*</span></span><br><span class="line">__public__/</span><br><span class="line">  hello.html *<span class="comment"># -&gt; 访问链接 example.com/hello.html*</span></span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><p>那  <code>transpiler</code>  的工作过程应该比较清晰了：</p><ul><li>扫描  <code>__apps__</code>  下的<code>子应用</code>。开发者也可以在<em>子应用目录下</em>使用  <code>mapp.json</code>  显式定义子应用描述信息。扫描后的子应用信息将放在  <code>microApps</code>  变量下。</li><li>扫描  <code>__config__</code>  下的配置文件。解析出配置信息。</li><li>扫描  <code>__i18n__</code>  下的  <code>.tr</code>, 解析结果放在  <code>i18n</code>  变量下。</li><li>扫描  <code>__theme__</code>  目录。<code>__theme__</code>  主题包也支持携带配置文件、语言包，所以这些信息也会合并到配置信息中。另外 CSS 文件、JavaScript 文件将被收集到  <code>theme</code>  变量中。</li></ul><p><br></p><p>扫描完毕之后，<code>transpiler</code>  拿着配置信息进行<code>模板转译</code>，将  <code>/data/source</code>  下的静态资源转换被拷贝到  <code>/data/public</code>  目录下。</p><p>来看个实际的模板例子:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"[%= description %]"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"[%= keywords %]"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"[%= assets.IMG_BAY_FAVICON || entryPath + '/favicon.png' %]"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"version"</span> <span class="attr">content</span>=<span class="string">"[%= version %]"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"update-time"</span> <span class="attr">content</span>=<span class="string">"[%= `$&#123;year&#125;-$&#123;month&#125;-$&#123;date&#125;` %]"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>[%= title %]<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--! [%- theme.stylesheets.map(i =&gt; `&lt;link rel="stylesheet" href="$&#123;i + '?' + hash &#125;" /&gt;`).join('\n') %] --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--! [%- theme.scripts.map(i =&gt; `&lt;script async="true" src="$&#123;i + '?' + hash&#125;"&gt;&lt;/script&gt;`).join('\n') %] --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--! [% if (microApps.length) &#123; %] --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--! [%- </span></span><br><span class="line"><span class="comment">      `&lt;script&gt;</span></span><br><span class="line"><span class="comment">        // 微应用注入</span></span><br><span class="line"><span class="comment">        (window.__MAPPS__ = (window.__MAPPS__ || [])).push($&#123;microApps.map(i =&gt; JSON.stringify(i)).join(', ')&#125;);</span></span><br><span class="line"><span class="comment">      &lt;/script&gt;`</span></span><br><span class="line"><span class="comment">    %] --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--! [% &#125; %]--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--! [%- `&lt;script&gt;</span></span><br><span class="line"><span class="comment">      // 静态资源注入</span></span><br><span class="line"><span class="comment">      (window.__MAPP_ASSETS__ = (window.__MAPP_ASSETS__ || [])).push($&#123;JSON.stringify(assets)&#125;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      // 全局共享的语言包</span></span><br><span class="line"><span class="comment">      window.__I18N_BUNDLES__ = $&#123;JSON.stringify(i18n)&#125;;</span></span><br><span class="line"><span class="comment">    &lt;/script&gt;` %] --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">      <span class="attr">defer</span>=<span class="string">"defer"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">"[%= cdnDomain ? '//' + cdnDomain : '' %][%= removeTrailingSlash(base) %]/__entry__/js/chunk-vendors.582ba02c.js?[%= hash %]"</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">      <span class="attr">defer</span>=<span class="string">"defer"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">"[%= cdnDomain ? '//' + cdnDomain : '' %][%= removeTrailingSlash(base) %]/__entry__/js/app.01bd68bb.js?[%= hash %]"</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">      <span class="attr">href</span>=<span class="string">"[%= cdnDomain ? '//' + cdnDomain : '' %][%= removeTrailingSlash(base) %]/__entry__/css/app.d835cada.css?[%= hash %]"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">rel</span>=<span class="string">"stylesheet"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span></span></span><br><span class="line"><span class="tag">      &gt;</span><span class="tag">&lt;<span class="name">strong</span></span></span><br><span class="line"><span class="tag">        &gt;</span>We're sorry but [%= title %] doesn't work properly without JavaScript enabled. Please</span><br><span class="line">        enable it to continue.</span><br><span class="line">      <span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">noscript</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><p>上面是基座的  <code>index.html</code>  模板。<code>transpiler</code>  基于  <strong><a href="https://ejs.bootcss.com/" target="_blank" rel="noopener">ejs</a></strong>  模板引擎，会解析替换文本文件中  <code>[% 模板 %]</code>  语法。</p><p><br></p><p>还有很多用法值得去挖掘。 比如:</p><ul><li>全局埋点脚本注入</li><li>全局监控脚本注入</li><li>…</li></ul><p>原理就是这么简单，只要子应用部署到 <code>__apps__</code> 目录下，我们就可以监听到，收集到必要的信息后，对 <code>source</code> 目录下的静态文件进行转译，输出到 <code>public</code> 目录下，最终由 Nginx 负责将文件传递给浏览器。</p><p><br><br><br><br><br></p><h2 id="部署和运维"><a href="#部署和运维" class="headerlink" title="部署和运维"></a>部署和运维</h2><p>那么子应用具体如何部署和运维呢？</p><p>子应用构建、生成和发布容器的过程这里就不展开说了，可以自行搜索 Docker 的相关教程，我们这里主要简单介绍一下在 K8S 平台如何部署和运维。</p><p>将基座和子应用聚合在一起，我们需要用到 <code>PVC</code> (PersistentVolumeClaim, 即持久化卷), 你可以认为 PVC 就是一个「网络硬盘」，而每个子应用、基座都是独立运行的「主机」(<code>Pod</code> 或 容器 , <em>Kubernetes</em>  中可部署的最小、最基本对象), 这个 PVC 可以被每个子应用共享访问，只要按照约定将子应用的静态文件拷贝到 PVC 对应位置就行了。如下图所示：</p><p><img src="/images/microfrontend/Untitled%2011.png" alt="PVC"></p><p><br><br><br><br><br></p><p>至于子应用和运行容器在 K8S 下如何组织，可以非常灵活，取决于需求和环境。笔者实践过以下几种方式：</p><ol><li><p>全部部署在一个 Pod 下。子应用作为 <code>Init Sidecar</code>（初始化边车）。这种部署方式比较简单，缺点就是任意一个应用需要更新，整个 Pod 都要重启，包括运行容器。</p><p><img src="/images/microfrontend/Untitled%2012.png" alt="方法1"></p><p>示例图：</p><p><img src="/images/microfrontend/Untitled%2013.png" alt="Sidecar"></p></li><li><p>分离运行容器和子应用。为了避免子应用更新导致整个 Pod 重启（包括运行容器），我们可以将子应用单独拎出去，子应用更新只会重启所在的 Pod，从而避免运行容器停机。</p><p><img src="/images/microfrontend/Untitled%2014.png" alt="方法2"></p></li><li><p>每个子应用都是独立的 Pod。好处就是每个子应用可以真正做到独立部署、启动，坏处就是管理起来稍显麻烦。</p><p><img src="/images/microfrontend/Untitled%2015.png" alt="方法3"></p></li></ol><p>开发者可以根据自己的运行环境选择不同的组织方式。</p><p><br><br><br><br><br></p><h2 id="那么配置呢？"><a href="#那么配置呢？" class="headerlink" title="那么配置呢？"></a>那么配置呢？</h2><p>首先简单的配置可以通过<code>环境变量</code>来实现，因为在 K8S 中，配置环境变量相对简单很多:</p><p><img src="/images/microfrontend/Untitled%2016.png" alt="环境变量配置"></p><p>对于稍微复杂的配置，可以使用<code>配置映射</code>(Config-Maps), 配置映射的每个键值对就相当于一个文件，我们可以挂载到容器的任何位置上：</p><p>定义配置映射：</p><p><img src="/images/microfrontend/Untitled%2017.png" alt="定义配置映射"></p><p>挂载配置映射：</p><p><img src="/images/microfrontend/Untitled%2018.png" alt="挂载配置映射"></p><p>配置映射可以挂载到任意的路径或文件上，它还有一个更赞的能力<strong>是：我们可以直接修改配置映射，这些变动会同步到容器内，从而实现实时变更</strong>。</p><p>小结。我们尽量复用了 K8S 本身的能力，这些能力足以实现较为复杂功能，避免重复造轮子。</p><p><br><br><br><br><br></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>限于篇幅很多细节无法展开，这里点到为止：</p><ul><li><strong>如何实现一键部署？</strong>因为使用的是容器化部署，可以将所有部署声明在 <a href="https://www.notion.so/b590284a71934f97a1db71ef967fbc5a?pvs=21" target="_blank" rel="noopener">yaml 文件</a>中维护, 新环境部署时直接导入就行。我们也开发过一个<a href="https://wakeadmin.wakedata.com/k8s-deploy/index.html#/micro" target="_blank" rel="noopener">可视化生成 yaml 的简易应用</a></li><li><strong>自动化部署？</strong>实现自动化部署有很多手段，如果你的公司有 DevOps 平台(比如我们使用 Zadig) , 这些平台本身就提供了自动化部署的能力，你可以查看相关文档。另外在 Jenkins 中也有相关的插件来实现部署推送。再不济，<a href="https://www.notion.so/a2b1fb632eb44b68b161a38f256756db?pvs=21" target="_blank" rel="noopener">可以使用 rancher 的 CLI 等等</a>。</li><li><strong>子应用如何共享依赖？</strong>可以使用 <a href="https://webpack.js.org/configuration/externals/#externals" target="_blank" rel="noopener">externals</a>, 或者 Webpack 5 的 *<strong>*<a href="https://webpack.js.org/concepts/module-federation/#motivation" target="_blank" rel="noopener">Module Federation</a>,</strong> 我们也探索过类似 <a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">jsDelivr</a> 的方案， 详见<a href="https://wakeadmin.wakedata.com/mapp/advanced/vendors.html#%E9%85%8D%E7%BD%AE%E9%A1%B9" target="_blank" rel="noopener">这里</a></li><li><strong>接口服务</strong>。运行容器除了上文讲到的各种功能，还可以提供一些造福前端的<a href="https://wakeadmin.wakedata.com/mapp/advanced/services.html" target="_blank" rel="noopener">接口服务</a>，比如接口代理、polyfill 服务、vendor 依赖。</li><li><strong><em>安全配置</em></strong>。在运行容器中统一配置 CSP、跨域等安全配置</li><li>…</li></ul><p><br><br><br><br><br></p><h2 id="有哪些最佳实践"><a href="#有哪些最佳实践" class="headerlink" title="有哪些最佳实践?"></a>有哪些最佳实践?</h2><ul><li><strong>保持基座业务无关性</strong>。我们尽量保证基座不耦合业务，为了避免子应用的业务侵入到基座，我们严格管控基座仓库的开发权限，以及向下暴露接口的截面。</li><li><strong>保持子应用之间的独立性</strong>。基座除了 <code>EventBus</code> ，没有提供其他应用通信的手段。对我们来说，微前端只不过是多页应用的延续。 设计良好的应用，不应该耦合其他应用。就算是一些共享状态，也可以从后端读取。</li><li><strong>避免硬编码配置信息</strong>。因为<code>运行容器</code>有动态替换变量的能力，因此应该避免在代码中硬编码配置信息，比如域名信息、企业文案、服务器链接。而是预留模板, 在部署时通过<strong><a href="https://wakeadmin.wakedata.com/mapp/deploy.html" target="_blank" rel="noopener">运行容器</a></strong>来配置。</li><li><strong>按照业务聚合子应用</strong>。即按照业务边界来拆分子应用，而不是按照‘菜单’， 具体来说子应用应该对应后端的微服务，尽管很多时候做不到。</li></ul><p><br><br><br><br><br></p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>我们整套方案并没有‘自造’复杂的技术，而是基于已有的工具整合起来的能力。这也是笔者一直坚持的观念，简单至上。</p><p>这个方案未来会如何迭代呢？</p><ul><li>可视化方式，简化部署的流程。毕竟不是所有开发者都熟悉 K8S 这套概念</li><li>发布流程审核。生产环境部署审核。</li><li>基座插件。支持扩展一些除子应用之外的场景，比如一些全局通用的业务 SDK、组件库。常规的子应用只会在路由匹配到时激活，而插件会在基座启动后加载并持久存在。</li><li>支持子应用扩展服务端的能力。当前的子应用都是 CSR，后续运行容器可以支持子应用扩展服务端接口。</li><li>灰度发布。</li><li>支持 Vite</li><li>…</li></ul><p><br><br><br><br><br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文大概介绍了我们落地和治理微前端应用的大概思路。这套体系中主要包含了三个主要部件：</p><p><img src="/images/microfrontend/Untitled%2019.png" alt="微前端"></p><ul><li>基座：<code>集中式</code>的微前端方案，基座是整个微前端的核心，负责管理子应用，并为子应用的开发提供必要的支撑</li><li>子应用：负责具体业务实现，按照业务聚合和拆分。</li><li>运行容器：为微前端应用架构提供了部署和治理方案</li></ul><p>因为文章篇幅原因，这里面很多细节无法展开。感兴趣的可以移步我们<a href="https://wakeadmin.wakedata.com/mapp/index.html" target="_blank" rel="noopener">公开的文档</a>（暂未开源）。</p><p><br><br><br></p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://wakeadmin.wakedata.com/mapp/index.html" target="_blank" rel="noopener">Wakeadmin</a></li><li><a href="https://github.com/umijs/qiankun" target="_blank" rel="noopener">qiankun</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/microfrontend/Untitled.png&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;微前端实现原理、框架选型之类的文章比较泛滥，我不打算讲这些玩意，本文主要来源于笔者过去一年落地微前端的一手经验，尽量不讲技术细节，而是讲
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue 开发的正确姿势：响应式编程思维</title>
    <link href="https://bobi.ink/2023/07/09/vue-with-rx/"/>
    <id>https://bobi.ink/2023/07/09/vue-with-rx/</id>
    <published>2023-07-08T16:00:00.000Z</published>
    <updated>2023-07-13T02:01:44.044Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vue-with-rx/Untitled.png" alt="Untitled"></p><p>写这篇文章的动机可以追溯到 3 年前， 我发现很多身边开发者并没有正确地使用 React Hooks, 所以我觉得应该把我的开发经验和思维整理下来。</p><p>尽管本文主要从 Vue 的角度出发，但是很多思维也可以用在 React Hooks 上。</p><p>从广义的的“<a href="https://en.wikipedia.org/wiki/Reactive_programming" target="_blank" rel="noopener">响应式编程(Reactive Programing)</a>” 上看，Vue、React、Rxjs 等框架都属于这个范畴。而狭义的响应式编程通常指的是 rxjs 这类 “面向数据<a href="https://zh.wikipedia.org/wiki/%E4%B8%B2%E6%B5%81" target="_blank" rel="noopener">串流</a>和变化传播的<a href="https://zh.wikipedia.org/wiki/%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">声明式</a><a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F" target="_blank" rel="noopener">编程范式</a>”</p><p>虽然 Vue 也是‘响应式编程’， 但是和 RxJS 是完全不一样的概念，至少RxJS 是有范式约束的，不管是编码上还是思维上面，我们都可以感受到它的强力约束，这和我们惯用的命令式编程差别很大。这也导致了它的学习门槛比较高。</p><p>为什么要牵扯到 RxJS 呢？因为它的思维对我们写好 Vue 代码很有帮助！</p><p><br><br><br></p><h1 id="简述-rxjs"><a href="#简述-rxjs" class="headerlink" title="简述 RxJS"></a>简述 RxJS</h1><p>先祭上<a href="https://zhuanlan.zhihu.com/p/25383159" target="_blank" rel="noopener">徐飞的买房的例子</a>，感受一下 RxJS 的魅力：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//           工资周期  ———&gt;  工资</span></span><br><span class="line"><span class="comment">//                            ↓</span></span><br><span class="line"><span class="comment">// 房租周期  ———&gt;  租金  ———&gt;  收入  ———&gt;  现金 </span></span><br><span class="line"><span class="comment">//                ↑           ↓ </span></span><br><span class="line"><span class="comment">//             房子数量 &lt;——— 新购房</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 挣钱是为了买房，买房是为了赚钱</span></span><br><span class="line"><span class="keyword">const</span> house$ = <span class="keyword">new</span> Subject()</span><br><span class="line"><span class="keyword">const</span> houseCount$ = house$.scan(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> acc + num, <span class="number">0</span>).startWith(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工资始终不涨</span></span><br><span class="line"><span class="keyword">const</span> salary$ = Observable.interval(<span class="number">100</span>).mapTo(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> rent$ = Observable.interval(<span class="number">3000</span>)</span><br><span class="line">  .withLatestFrom(houseCount$)</span><br><span class="line">  .map(<span class="function"><span class="params">arr</span> =&gt;</span> arr[<span class="number">1</span>] * <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一买了房，就没现金了……</span></span><br><span class="line"><span class="keyword">const</span> income$ = Observable.merge(salary$, rent$)</span><br><span class="line"><span class="keyword">const</span> cash$ = income$</span><br><span class="line">  .scan(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newSum = acc + num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newHouse = <span class="built_in">Math</span>.floor(newSum / <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">if</span> (newHouse &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      house$.next(newHouse)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newSum % <span class="number">100</span></span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// houseCount$.subscribe(num =&gt; console.log(`houseCount: $&#123;num&#125;`))</span></span><br></pre></td></tr></table></figure><p><br></p><p>如果用几个关键字来描述 RxJS 的话，我想应该是：</p><ul><li>事件：观察者模式</li><li>序列：迭代器模式</li><li>流：管道模式</li></ul><p>这几个模式我们分开去理解都没啥特别，比如 Vue 的 reactivity 数据就是观察者模式；JavaScript 的 for…of/generator 就是迭代器模式；数组的map/filter/reduce, shell 命令都符合管道模式。</p><p>RxJS  的牛逼之处就是把这三个模式优雅地组合起来了。它把事件抽象成为类似’数组’一样的序列，然后提供了丰富的操作符来变换这个序列，就像操作数组一样自然，最后通过管道将这些操作符组合起来实现复杂的功能变换。</p><p><br><br><br></p><h1 id="为什么建议你去学习-rxjs？"><a href="#为什么建议你去学习-rxjs？" class="headerlink" title="为什么建议你去学习 rxjs？"></a>为什么建议你去学习 rxjs？</h1><p>至少它可以帮助你写好 Vue 代码。它可以帮你写出更简洁、结构更清晰、低耦合、更容易测试的代码，这些代码更能体现原本的交互逻辑或业务流程。</p><p>相信我，尝试换个思路，可能原本复杂的实现，会变得更加简单。</p><p><br></p><h1 id="rxjs-和-vue-reactivity-data-有什么关联？"><a href="#rxjs-和-vue-reactivity-data-有什么关联？" class="headerlink" title="RxJS 和 Vue Reactivity Data 有什么关联？"></a>RxJS 和 Vue Reactivity Data 有什么关联？</h1><p>一些和 RxJS 相似的概念</p><ul><li><p>响应式数据。我们用 ref 或reactive 创建的数据，可以等似于 RxJS 的 Observable。只不过响应式数据并不像 rxjs 有显式的事件发布和订阅过程，也不存在事件流(序列)。</p><p>  <strong>我们可以认为Vue 数据的每次变更就相当于 RxJS 发出每次事件</strong>。</p></li><li><p>衍生数据。我们会使用 computed 来衍生新的数据，等似于 RxJS 用操作符衍生出新的 Observable。<strong>即 Vue 数据衍生数据，RxJS 事件衍生事件</strong></p></li><li>副作用。在 Vue 中， watch/watcheffects/render 相当于 RxJS 的 subscribe，RxJS 的数据流的终点通常也是副作用处理，比如将数据渲染到页面上。</li></ul><p><br></p><p>RxJS 的很多东西并不能直接套用过来，但思想和原则是可以复用的。</p><p>其中一个重要的思想就是：管道变换。这是一种思维方式的转变，在以往的编程设计中，我们更多操心的是类、模块、数据结构和算法。而管道变换我们会把程序视作从输入到输出的一个变换去构思:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># “列出目录树中最长的五个文”</span></span><br><span class="line">find . -<span class="built_in">type</span> f | xargs wc -l | sort -n | tail -5</span><br></pre></td></tr></table></figure><p>不要把数据看作是遍布整个系统的小数据池，而要把数据看作是一条浩浩荡荡的河流。</p><p>另一方面，编写 RxJS 代码一些原则，对我们编写 Vue 代码也大有裨益：</p><ul><li>避免副作用。RxJS 的操作符应该是没有副作用的函数，只关注输入的数据，然后对数据进行变换，传递给下一个。</li><li><p>避免外部状态/缓存状态。外部状态也是副作用的一种，单独拎出来讲，是因为我们在 Vue 中创建外部状态太容易了，而 RxJS 则相对来说麻烦一些，毕竟外部状态和事件流显得格格不入。</p><p>  在 RxJS 中管道是自包含的， 所有的状态从一个操作器流向下一个操作器，而不需要外部变量：</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Observable.from([1, 2, 3, 4, 5, 6, 7, 8])</span><br><span class="line">  .filter(val =&gt; val % 2)</span><br><span class="line">  .map(val =&gt; val * 10);</span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><h1 id="看看你代码中的坏味道"><a href="#看看你代码中的坏味道" class="headerlink" title="看看你代码中的坏味道"></a>看看你代码中的坏味道</h1><p>看看你的 Vue 代码有没有这些现象，如果存在这些坏味道，说明你并没有正确使用 Vue 的 Reactivity API。</p><ul><li>创建了大量的缓存状态。比如 sum，avg，temp…</li><li>使用了很多 <code>watch</code> / <code>watchEffect</code>…</li><li>冗长的 <code>setup</code> 方法或者组件代码</li><li>状态被随意修改，修改不属于管辖范围内的状态</li><li>…</li></ul><p><br><br><br></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>先从简单的场景开始: 分页请求。</p><p>❌ 常规的做法：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = reactive(&#123;&#125;) <span class="comment">// 查询参数</span></span><br><span class="line"><span class="keyword">const</span> pagination = reactive(&#123;<span class="attr">pageNo</span>: <span class="number">1</span>, <span class="attr">pageSize</span>: <span class="number">10</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> total = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> list = ref([])</span><br><span class="line"><span class="keyword">const</span> loading = ref(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">const</span> error = ref()</span><br><span class="line"></span><br><span class="line">watch([query, pagination], <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    error.value = <span class="literal">undefined</span></span><br><span class="line">    loading.value = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> request(<span class="string">`/something?<span class="subst">$&#123;qs(&#123;...query, ...pagination&#125;</span>)&#125;`</span>)</span><br><span class="line">    total.value = data.total</span><br><span class="line">    list.value = data.list</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err)&#123;</span><br><span class="line">    error.value = err</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    loading.value = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;<span class="attr">immediate</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p>✅ 推荐做法：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = reactive(&#123;&#125;) <span class="comment">// 查询参数</span></span><br><span class="line"><span class="keyword">const</span> pagination = reactive(&#123;<span class="attr">pageNo</span>: <span class="number">1</span>, <span class="attr">pageSize</span>: <span class="number">10</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// data 包含了 list、loading、error、total 等信息</span></span><br><span class="line"><span class="keyword">const</span> data = useRequest(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`/something?<span class="subst">$&#123;qs(&#123;...query, ...pagination&#125;</span>)&#125;`</span>)</span><br></pre></td></tr></table></figure><ul><li><p>自然地表达 query/pagination → data 的数据流。useRequest 更像 computed 的语义，从一个数据衍生出新的数据，不管它是同步的还是异步的。</p><p>  而使用 watch 会中断数据的流动，并且我们需要创建冗余缓存状态，代码看起来会比较混乱。想象一下复杂的页面，我们可能会有很多复杂、联动的异步请求，情况就会慢慢失控。</p></li><li><p><code>useRequest</code> 是啥？它封装了网络请求， useRequest 可以基于 <a href="https://docs-swrv.netlify.app/guide.html" target="_blank" rel="noopener">swrv</a>(swr 在 Vue 下的实现, 非官方)、或者VueUse 里面的 <a href="https://vueuse.org/core/computedAsync/" target="_blank" rel="noopener">computedAsync</a>、<a href="https://vueuse.org/core/useFetch/" target="_blank" rel="noopener">useFetch</a> 来封装。</p><p>  useRequest 类似于 RxJS 的 switchMap，当新的发起新的请求时，应该将旧的请求抛弃。</p><p>  笔者推荐使用 swr 这类库去处理网络请求，相比直接用 watch, 这类库支持数据缓存、Stale-while-revalidate 更新、还有并发竞态的处理等等。</p></li></ul><p><br><br><br></p><h2 id="实时搜索"><a href="#实时搜索" class="headerlink" title="实时搜索"></a>实时搜索</h2><p>第二个例子也比较简单，用户输入文本，我们debounce 发起数据请求</p><p>⚠️ 常规的实现：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = ref(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法一：在事件处理器加 debounce</span></span><br><span class="line"><span class="comment">// 如果这么实现，双向绑定到表单可能有卡顿问题</span></span><br><span class="line"><span class="keyword">const</span> handleQueryChange = debounce(<span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">  query.value = evt.target.value</span><br><span class="line">&#125;, <span class="number">800</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = ref()</span><br><span class="line"></span><br><span class="line">watch(query, <span class="keyword">async</span> (q) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetchData(q)</span><br><span class="line">  <span class="comment">// <span class="doctag">FIXME:</span> 需要处理竞态问题</span></span><br><span class="line">  data.value = res</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 法二，在 watch 回调或者 fetchData 加上 debounce</span></span><br><span class="line"><span class="keyword">const</span> handleQueryChange = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">  query.value = evt.target.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">watch(query, debounce(<span class="keyword">async</span> (q) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetchData(q)</span><br><span class="line">  data.value = res</span><br><span class="line">&#125;, <span class="number">800</span>))</span><br></pre></td></tr></table></figure><p>RxJS  实现:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> searchInput$ = fromEvent(searchInput, <span class="string">'input'</span>).pipe(</span><br><span class="line">  <span class="comment">// 使用 debounceTime 进行防抖处理</span></span><br><span class="line">  debounceTime(<span class="number">800</span>),</span><br><span class="line">  <span class="comment">// 使用 map 将事件转换为输入框的值</span></span><br><span class="line">  map(<span class="function"><span class="params">event</span> =&gt;</span> event.target.value),</span><br><span class="line">  <span class="comment">// 使用 distinctUntilChanged 进行去重处理</span></span><br><span class="line">  distinctUntilChanged(),</span><br><span class="line">  <span class="comment">// 使用 switchMap 进行请求并转换为列表数据</span></span><br><span class="line">  switchMap(<span class="function"><span class="params">keyword</span> =&gt;</span> <span class="keyword">from</span>(searchList(keyword)))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们使用 Vue 也可以表达类似的流程：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = ref(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">const</span> debouncedQuery = refDebounced(input, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = useRequest(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`/something?<span class="subst">$&#123;qs(&#123;query: query.value&#125;</span>)&#125;`</span>)</span><br></pre></td></tr></table></figure><p>refDebounce 来源于 VueUse，可以 “Debounce” 指定输入 ref 值的变动。</p><p><br><br><br></p><h2 id="定时刷新"><a href="#定时刷新" class="headerlink" title="定时刷新"></a>定时刷新</h2><p>假设我们要在上面的分页基础上实现定时轮询的功能：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = reactive(&#123;&#125;) <span class="comment">// 查询参数</span></span><br><span class="line"><span class="keyword">const</span> tick = useInterval(<span class="number">5000</span>)</span><br><span class="line"><span class="keyword">const</span> pagination = reactive(&#123;<span class="attr">pageNo</span>: <span class="number">1</span>, <span class="attr">pageSize</span>: <span class="number">10</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// data 包含了 list、loading、error、total 等信息</span></span><br><span class="line"><span class="keyword">const</span> data = useRequest(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`/something?<span class="subst">$&#123;qs(&#123;...query, ...pagination, _t: tick.value&#125;</span>)&#125;`</span>)</span><br></pre></td></tr></table></figure><p>我们看到上面的流程很自然。</p><p>现在加大难度，如果要在特定条件下终止呢？</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = reactive(&#123;&#125;) <span class="comment">// 查询参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认关闭</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">counter</span>: tick, pause, resume&#125; = useInterval(<span class="number">5000</span>, &#123;<span class="attr">controls</span>: <span class="literal">true</span>, <span class="attr">immediate</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> pagination = reactive(&#123;<span class="attr">pageNo</span>: <span class="number">1</span>, <span class="attr">pageSize</span>: <span class="number">10</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// data 包含了 list、loading、error、total 等信息</span></span><br><span class="line"><span class="keyword">const</span> data = useRequest(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`/something?<span class="subst">$&#123;qs(&#123;...query, ...pagination, _t: tick.value&#125;</span>)&#125;`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否轮询</span></span><br><span class="line"><span class="keyword">const</span> shouldPoll = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> data.data?.some(<span class="function"><span class="params">i</span> =&gt;</span> i.expired &gt; <span class="built_in">Date</span>.now())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按条件开启轮训</span></span><br><span class="line">watch(shoudPoll, (p) =&gt; p ? resume() : pause())</span><br></pre></td></tr></table></figure><p>如果用 RxJS 来实现的话，代码大概如下：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> interval$ = interval(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> poll$ = interval$.pipe(</span><br><span class="line">  <span class="comment">// 查询</span></span><br><span class="line">  switchMap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">from</span>(fetchData())),</span><br><span class="line">  share()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stop$ = poll$.pipe(</span><br><span class="line">  <span class="comment">// 终止轮询条件</span></span><br><span class="line">  filter(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i.every(<span class="function"><span class="params">i</span> =&gt;</span> i.expired &lt;= <span class="built_in">Date</span>.now())</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 poll$ 和 stop$ 组合在一起</span></span><br><span class="line">poll$</span><br><span class="line">  .pipe(</span><br><span class="line">    <span class="comment">// 使用 takeUntil 在 stop$ 发送事件后停止轮询</span></span><br><span class="line">    takeUntil(stop$)</span><br><span class="line">  )</span><br><span class="line">  .subscribe(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>因为 RxJS 的 Observable 是惰性的，只有被 subscribe 时才会开始执行，同理停止订阅就会中断执行。</p><p>中断执行后，如果要重新发起请求，重新订阅就好了。有点异曲同工之妙吧</p><p><br><br><br></p><h2 id="省市区选择器"><a href="#省市区选择器" class="headerlink" title="省市区选择器"></a>省市区选择器</h2><p>再来看一个稍微复杂一点的例子，常见的省市区选择器，这是一个典型的数据联动的场景。</p><p>我们先来看一个反例吧，我们的选择器需要先选择国家或地区，然后根据它来确定行政区域的划分，接着渲染各级行政区域选择器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default defineComponent(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    modelValue: &#123;</span><br><span class="line">      type: Array as () =&gt; number[],</span><br><span class="line">      default: () =&gt; [],</span><br><span class="line">    &#125;,</span><br><span class="line">    onChange: &#123;</span><br><span class="line">      type: Function,</span><br><span class="line">      default: () =&gt; &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    const isEchoingData = ref(false);</span><br><span class="line">    const regionList = ref&lt;RegionInfoDTO[][]&gt;([]);</span><br><span class="line">    const regionUrl = ref(&apos;&apos;);</span><br><span class="line">    const queryParams = ref(&#123;&#125; as IQueryParams);</span><br><span class="line"></span><br><span class="line">    const selectedRegion = computed&lt;number[]&gt;(&#123;</span><br><span class="line">      get: () =&gt; props.modelValue,</span><br><span class="line">      set: value =&gt; emit(&apos;update:modelValue&apos;, [...value]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const &#123; data: countryList &#125; = useRequest&lt;CountryInfoDTO&gt;(</span><br><span class="line">      () =&gt; `请求国家列表`</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 请求区域列表</span><br><span class="line">    const &#123; data: regionItems &#125; = useRequest&lt;RegionInfoDTO&gt;(() =&gt; regionUrl.value);</span><br><span class="line"></span><br><span class="line">    watch(regionItems, () =&gt; &#123;</span><br><span class="line">      regionList.value[queryParams.value.level] = regionItems.value?.data!;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const countryOptions = computed(() =&gt; &#123;</span><br><span class="line">      return countryList.value?.data.map(i =&gt; &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          label: i.name,</span><br><span class="line">          value: i.id,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    watch(queryParams, async newValue =&gt; &#123;</span><br><span class="line">      if (!Object.keys(newValue).length) return;</span><br><span class="line"></span><br><span class="line">      const query = `&amp;countryId=$&#123;newValue.level ? &apos;&apos; : newValue.value&#125;&amp;parentId=$&#123;</span><br><span class="line">        newValue.level ? newValue.value : &apos;&apos;</span><br><span class="line">      &#125;&amp;level=$&#123;newValue.level + 1&#125;`;</span><br><span class="line">      regionUrl.value = `区域请求路径$&#123;query&#125;`;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    watch(</span><br><span class="line">      props.modelValue,</span><br><span class="line">      async (newValue, oldValue) =&gt; &#123;</span><br><span class="line">        const newLen = newValue.length;</span><br><span class="line">        const oldLen = oldValue?.length ?? 0;</span><br><span class="line"></span><br><span class="line">        if (newLen &amp;&amp; newLen !== oldLen) &#123;</span><br><span class="line">          const index = 0;</span><br><span class="line"></span><br><span class="line">          queryParams.value = &#123; value: newValue[index], level: index &#125;;</span><br><span class="line">          isEchoingData.value = true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; immediate: true &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    watch(</span><br><span class="line">      regionList,</span><br><span class="line">      newVal =&gt; &#123;</span><br><span class="line">        const len = newVal.length;</span><br><span class="line">        const selectedLen = selectedRegion.value.length;</span><br><span class="line"></span><br><span class="line">        if (isEchoingData.value &amp;&amp; selectedLen &gt; len) &#123;</span><br><span class="line">          if (len === selectedLen - 1) return (isEchoingData.value = false);</span><br><span class="line"></span><br><span class="line">          queryParams.value = &#123; value: selectedRegion.value[len], level: len &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; deep: true &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    const onRegionChange = (value: number, level: number) =&gt; &#123;</span><br><span class="line">      selectedRegion.value.splice(level);</span><br><span class="line">      regionList.value.splice(level);</span><br><span class="line">      selectedRegion.value.push(value);</span><br><span class="line"></span><br><span class="line">      const currentRegion = regionList.value[level - 1]?.find(region =&gt; region.id === value);</span><br><span class="line"></span><br><span class="line">      if (!currentRegion?.isLeaf) &#123;</span><br><span class="line">        queryParams.value = &#123; value, level &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      props.onChange?.([...selectedRegion.value], [...selectedRegionNames.value]);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const currentRegionPlaceholder = (index: number) =&gt; &#123;</span><br><span class="line">      return `$&#123;selectedCountry.value?.regionLevelInfos[index]?.name ?? &apos;区域&apos;&#125;`;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const selectedCountry = computed(() =&gt; &#123;</span><br><span class="line">      const selectedCountryId = selectedRegion.value[0];</span><br><span class="line">      const selectedCountry = countryList.value?.data.find(country =&gt; country.id === selectedCountryId);</span><br><span class="line"></span><br><span class="line">      return selectedCountry;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const selectedRegionNames = computed(() =&gt; &#123;</span><br><span class="line">      const names = [];</span><br><span class="line"></span><br><span class="line">      if (selectedCountry.value) &#123;</span><br><span class="line">        names.push(selectedCountry.value.name);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      selectedRegion.value.slice(1).forEach((id, index) =&gt; &#123;</span><br><span class="line">        const region = regionList.value[index]?.find(region =&gt; region.id === id);</span><br><span class="line">        if (region) &#123;</span><br><span class="line">          names.push(region.name);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      return names;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return () =&gt; (</span><br><span class="line">      &lt;FatSpace&gt;</span><br><span class="line">        &lt;ElSelect</span><br><span class="line">          modelValue=&#123;selectedRegion.value[0]&#125;</span><br><span class="line">          placeholder=&quot;请选择国家&quot;</span><br><span class="line">          onChange=&#123;val =&gt; onRegionChange(val, 0)&#125;</span><br><span class="line">          filterable</span><br><span class="line">        &gt;</span><br><span class="line">          &#123;countryOptions.value?.map(country =&gt; (</span><br><span class="line">            &lt;ElOption key=&#123;country.value&#125; label=&#123;country.label&#125; value=&#123;country.value&#125; /&gt;</span><br><span class="line">          ))&#125;</span><br><span class="line">        &lt;/ElSelect&gt;</span><br><span class="line"></span><br><span class="line">        &#123;regionList.value.map((regions, index) =&gt; (</span><br><span class="line">          &lt;ElSelect</span><br><span class="line">            key=&#123;index&#125;</span><br><span class="line">            modelValue=&#123;selectedRegion.value[index + 1]&#125;</span><br><span class="line">            placeholder=&#123;`请选择$&#123;currentRegionPlaceholder(index)&#125;`&#125;</span><br><span class="line">            onChange=&#123;val =&gt; onRegionChange(val, index + 1)&#125;</span><br><span class="line">            filterable</span><br><span class="line">          &gt;</span><br><span class="line">            &#123;regions.map(region =&gt; (</span><br><span class="line">              &lt;ElOption key=&#123;region.id&#125; label=&#123;region.name&#125; value=&#123;region.id&#125; /&gt;</span><br><span class="line">            ))&#125;</span><br><span class="line">          &lt;/ElSelect&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/FatSpace&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>也就 150 行左右的代码，实现的是 <code>国家-国家各种区域</code> 的选择器，比如选择了中国就会有 <code>中国-省-市-区</code> 这样的分级。</p><p>读者也没必要读懂这些代码，我看到也头大，你只需要记住，这个充斥着我们上文提到的各种坏味道：过渡依赖 watch、数据流混乱…</p><p><img src="/images/vue-with-rx/Untitled%201.png" alt="Untitled"></p><p>让我们回归到业务本身，我们为什么需要不恪守这样的联动关系去组织代码呢？</p><p>可以的，一个比较重要的技巧就是自顶而下地去分析流程/数据流变换的过程。</p><p>首先从国家开始，只有用户选择了指定国家之后，我们才能获取到区域的结构信息(是省/市/区, 还是州/城市，anyway):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const AreaSelect2 = defineComponent(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    // 表单值是数组格式，每一项保存的是区域的 id</span><br><span class="line">    modelValue: Array as PropType&lt;number[]&gt;,</span><br><span class="line">  &#125;,</span><br><span class="line">  emits: [&apos;update:modelValue&apos;],</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    // 🔴 获取国家列表</span><br><span class="line">    const country = useCountryList();</span><br><span class="line"></span><br><span class="line">    // 🔴 计算当前选中的国家，我们从这里拿到行政区域结构</span><br><span class="line">    const currentCountry = computed(() =&gt; &#123;</span><br><span class="line">      return country.data.value?.data?.find(i =&gt; i.id === props.modelValue?.[0]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const handleCountryChange = (value: number) =&gt; &#123;</span><br><span class="line">      if (value !== props.modelValue?.[0]) &#123;</span><br><span class="line">        // 🛑 国家变动后，重置掉后续的数据</span><br><span class="line">        emit(&apos;update:modelValue&apos;, [value]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;ElSelect</span><br><span class="line">            modelValue=&#123;props.modelValue?.[0]&#125;</span><br><span class="line">            placeholder=&quot;请选择国家&quot;</span><br><span class="line">            onUpdate:modelValue=&#123;handleCountryChange&#125;</span><br><span class="line">            filterable</span><br><span class="line">            fitInputWidth</span><br><span class="line">            loading=&#123;country.isValidating.value&#125;</span><br><span class="line">          &gt;</span><br><span class="line">            &#123;country.data.value?.data?.map(i =&gt; &#123;</span><br><span class="line">              return &lt;ElOption key=&#123;i.id&#125; label=&#123;i.name&#125; value=&#123;i.id&#125;&gt;&lt;/ElOption&gt;;</span><br><span class="line">            &#125;)&#125;</span><br><span class="line">          &lt;/ElSelect&gt;</span><br><span class="line">          &#123;/* 此处暂时忽略 */&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>Composition API 的好处是，它让组合和封装变得非常便利。如上面的代码，我们将获取国家的相关逻辑封装成 useCountryList，代码变得更加简洁易读。</li><li>避免中间变量。恪守 v-model 单向数据流</li></ul><p><br></p><hr><p><br></p><p>接着我们根据选中的国家来渲染后续的区域联动。</p><p>这里提醒一下读者：“不要吝啬创建组件”</p><p>我在  <a href="https://juejin.cn/post/6844903844711759880#heading-2" target="_blank" rel="noopener">React组件设计实践总结04 - 组件的思维</a> 中讲过：</p><blockquote><p>大部分情况下, 组件表示是一个 UI 对象. 其实组件不单单可以表示 UI, 也可以用来抽象业务对象, 有时候抽象为组件可以巧妙地解决一些问题</p></blockquote><p>组件这个设计实在太好用了，笔者觉得它体现的更重要的思想是分治，而不是复用。组件一些比较重要的特性是：</p><ul><li>和函数一样，它是一个封闭的、自包含的单元。父组件不应该操心它，而应该让他自我组织。</li><li>组件有状态。这个是和函数不一样的地方</li><li><p>组件有生命周期。这就意味着组件可以自己管理和销毁自己的资源，不会泄露出去。</p><p>  这是组件和 Hooks 是有本质区别的！我们使用 Hooks 也可以实现一个自我组织的、封闭的、自包含的单元，但是它的生命周期不是它决定的，而是由使用它的宿主组件决定的</p></li></ul><blockquote><p>关于这块的详细阐述可以看笔者的<a href="https://juejin.cn/post/6844903844711759880#heading-2" target="_blank" rel="noopener">旧文章</a>。</p></blockquote><p>所以说，我们可以创建组件来封装区域选择的逻辑，将复杂度分流出去。或者说通过 props 将数据流往下传递给子组件… </p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">export const AreaSelect2 = defineComponent(&#123;</span><br><span class="line">  // 省略</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    // 省略</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;ElSelect</span><br><span class="line">           // 省略</span><br><span class="line">          &gt;</span><br><span class="line">            &#123;country.data.value?.data?.map(i =&gt; &#123;</span><br><span class="line">              return &lt;ElOption key=&#123;i.id&#125; label=&#123;i.name&#125; value=&#123;i.id&#125;&gt;&lt;/ElOption&gt;;</span><br><span class="line">            &#125;)&#125;</span><br><span class="line">          &lt;/ElSelect&gt;</span><br><span class="line">     </span><br><span class="line"><span class="addition">+          &#123;!!currentCountry.value &amp;&amp;</span></span><br><span class="line"><span class="addition">+            currentCountry.value?.regionLevelInfos?.map((i, index) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+              // 父区域 id</span></span><br><span class="line"><span class="addition">+              const parentValue = props.modelValue?.[index];</span></span><br><span class="line"><span class="addition">+              // 当前区域</span></span><br><span class="line"><span class="addition">+              const value = props.modelValue?.[index + 1];</span></span><br><span class="line"><span class="addition">+              // 父区域信息</span></span><br><span class="line"><span class="addition">+              const parentRegion: RegionLevelDTO =</span></span><br><span class="line"><span class="addition">+                index === 0</span></span><br><span class="line"><span class="addition">+                  ? &#123; code: currentCountry.value?.code!, name: currentCountry.value?.name! &#125;</span></span><br><span class="line"><span class="addition">+                  : currentCountry.value?.regionLevelInfos?.[index - 1]!;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+              const handleChange = (nextValue: number) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+                if (value === nextValue) &#123;</span></span><br><span class="line"><span class="addition">+                  return;</span></span><br><span class="line"><span class="addition">+                &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+                assert(Array.isArray(props.modelValue), 'modelValue is required');</span></span><br><span class="line"><span class="addition">+                // 裁剪掉当前区域后面的区域数据</span></span><br><span class="line"><span class="addition">+                const clone = [...props.modelValue].slice(0, index + 2);</span></span><br><span class="line"><span class="addition">+                clone[index + 1] = nextValue;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+                emit('update:modelValue', clone);</span></span><br><span class="line"><span class="addition">+              &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+              return (</span></span><br><span class="line"><span class="addition">+                &lt;Section</span></span><br><span class="line"><span class="addition">+                  index=&#123;index&#125;</span></span><br><span class="line"><span class="addition">+                  parentValue=&#123;parentValue&#125;</span></span><br><span class="line"><span class="addition">+                  modelValue=&#123;value&#125;</span></span><br><span class="line"><span class="addition">+                  region=&#123;i&#125;</span></span><br><span class="line"><span class="addition">+                  parentRegion=&#123;parentRegion&#125;</span></span><br><span class="line"><span class="addition">+                  country=&#123;currentCountry.value!&#125;</span></span><br><span class="line"><span class="addition">+                  onUpdate:modelValue=&#123;handleChange&#125;</span></span><br><span class="line"><span class="addition">+                /&gt;</span></span><br><span class="line"><span class="addition">+              );</span></span><br><span class="line"><span class="addition">+            &#125;)&#125;</span></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p>继续分流, 看看 Section 组件的实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Section = defineComponent(&#123;</span><br><span class="line">  name: &apos;AreaSelectSection&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 当前索引</span><br><span class="line">     */</span><br><span class="line">    index: &#123; type: Number, required: true &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 区域信息</span><br><span class="line">     */</span><br><span class="line">    region: &#123; type: Object as PropType&lt;RegionLevelDTO&gt;, required: true &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当前国家</span><br><span class="line">     */</span><br><span class="line">    country: &#123; type: Object as PropType&lt;CountryInfoDTO&gt;, required: true &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 父级</span><br><span class="line">     */</span><br><span class="line">    parentRegion: &#123; type: Object as PropType&lt;RegionLevelDTO&gt;, required: true &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 父级的值</span><br><span class="line">     */</span><br><span class="line">    parentValue: Number,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当前值</span><br><span class="line">     */</span><br><span class="line">    modelValue: Number,</span><br><span class="line">  &#125;,</span><br><span class="line">  emits: [&apos;update:modelValue&apos;],</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    // 获取区域列表</span><br><span class="line">    const region = useRegion(</span><br><span class="line">      computed(() =&gt; &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          countryId: props.country.id,</span><br><span class="line">          level: props.index + 1,</span><br><span class="line">          parentId: props.parentValue,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    const handleChange = (value: number) =&gt; &#123;</span><br><span class="line">      emit(&apos;update:modelValue&apos;, value);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;ElSelect</span><br><span class="line">          modelValue=&#123;props.modelValue&#125;</span><br><span class="line">          placeholder=&#123;`请选择$&#123;props.region.name&#125;`&#125;</span><br><span class="line">          filterable</span><br><span class="line">          fitInputWidth</span><br><span class="line">          disabled=&#123;!props.parentValue&#125;</span><br><span class="line">          onUpdate:modelValue=&#123;handleChange&#125;</span><br><span class="line">          loading=&#123;region.isValidating.value&#125;</span><br><span class="line">          class=&#123;s.select&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          &#123;region.data.value?.data?.map(i =&gt; &#123;</span><br><span class="line">            return &lt;ElOption key=&#123;i.id&#125; label=&#123;i.name&#125; value=&#123;i.id&#125;&gt;&lt;/ElOption&gt;;</span><br><span class="line">          &#125;)&#125;</span><br><span class="line">        &lt;/ElSelect&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可见，Section 的实现也再简单不过了。到这里，我相信很多读者已经感受到“响应式”编程的魅力了吧</p><p><br><br><br><br><br></p><h1 id="原则和建议"><a href="#原则和建议" class="headerlink" title="原则和建议"></a>原则和建议</h1><ol><li>优先使用 <code>computed</code>，警惕 <code>watch</code>/<code>watchEffect</code> 等 API 的使用。转换思维先从克制使用 watch 开始。</li><li>适当使用 <code>readonly</code>, 禁止状态被坏人修改</li><li>最小化状态。避免创建‘缓存’状态，让数据自然流动，不要阻断。</li><li>自顶而下，将细节/副作用分流到 hooks 或子组件中，起一个好一点的名字， 让流程看起来更清晰</li><li>将 watch 转换为 computed 的语义。外观上的差别是 watch 有 callback， 而 computed 是「管道」，会衍生新的数据。比如上面 useRequest 的例子</li><li>推荐使用 VueUse</li><li>封装 hooks， 让各种外部的状态或副作用优雅地集成进来</li><li>单向数据流，对这个有两层理解<ul><li>表示是一种数据流动的方向，通常和 CQRS 模式配合，比如 Redux、Vuex，只能单向的修改和查询</li><li>表示一种数据管辖的范围。 通常应用只有数据的拥有者才有权限变更。进一步地讲，我们应该以组件为边界，来限定数据的管辖范围。需要变更时，通过‘事件’ 来通知拥有者。比如 严格遵循 v-model 协议。</li></ul></li><li><p>使用响应式开发思维，构造单向的数据流</p><ul><li>尽量管道化的方式去设计你的程序</li><li>声明式，不要命令式</li><li>拆分组件或hooks来分治数据流</li><li>组件之间 props 传递也属于数据流。</li></ul><ol start="10"><li>使用 ref/reactive → computed → watch → handler → render 这样的顺序组织代码</li></ol></li></ol><p>🌹本文完，你的点赞是我写作的最大动力，欢迎留言转发（备注原文作者和链接）。</p><p><br><br><br></p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://juejin.cn/post/6844903844711759880#heading-4" target="_blank" rel="noopener">React组件设计实践总结04 - 组件的思维</a></li><li><a href="https://rxjs.dev/" target="_blank" rel="noopener">RxJS</a></li><li><a href="https://dev.to/lloyds-digital/comparing-reactivity-models-react-vs-vue-vs-svelte-vs-mobx-vs-solid-29m8" target="_blank" rel="noopener">Comparing reactivity models - React vs Vue vs Svelte vs MobX vs Solid vs Redux</a></li><li><a href="https://zhuanlan.zhihu.com/p/25383159" target="_blank" rel="noopener">RxJS 入门指引和初步应用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vue-with-rx/Untitled.png&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;写这篇文章的动机可以追溯到 3 年前， 我发现很多身边开发者并没有正确地使用 React Hooks, 所以我觉得应该把我的开发经验和思维整
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>次世代前端视图框架都在卷啥？</title>
    <link href="https://bobi.ink/2023/07/02/fe-view-future/"/>
    <id>https://bobi.ink/2023/07/02/fe-view-future/</id>
    <published>2023-07-01T16:00:00.000Z</published>
    <updated>2023-07-04T01:19:01.665Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/fe-view-future/Untitled.png" alt="state of JavaScript 2022 满意度排名"></p><p>state of JavaScript 2022 满意度排名</p><p>上图是 <a href="https://2022.stateofjs.com/zh-Hans/libraries/front-end-frameworks/" target="_blank" rel="noopener">State of JavaScript</a> 2022 前端框架满意度排名。前三名分别是 <code>Solid</code>、<code>Svelte</code>、<code>Qwik</code>。我们可以称他们为次世代前端框架的三大代表，前辈是 <code>React</code>/<code>Angular</code>/<code>Vue</code>。<br>目前 React/Augular/Vue 还占据的主流的市场地位， 现在我们还不知道下一个五年、十年谁会成为主流，有可能前辈会被后浪拍死在沙滩上， 也有可能你大爷还是你大爷。</p><p>就像编程语言一样，尽管每年都有新的语言诞生，但是撼动主流编程语言的地位谈何容易。在企业级项目中，我们的态度会趋于保守，选型会偏向稳定、可靠、生态完善的技术，因此留给新技术的生存空间并不多。除非是革命性的技术，或者有大厂支撑，否则这些技术或框架只会停留小众圈子内。</p><blockquote><p>比如有一点革命性、又有大厂支撑的 Flutter。</p></blockquote><p><br></p><p>那么从更高的角度看，这些次时代的前端视图框架在卷哪些方向呢？有哪些是革命性的呢?</p><p>先说一下本文的结论：</p><ul><li>整体上视图编程范式已经固化</li><li>局部上体验上内卷</li></ul><p><br><br><br></p><h1 id="视图编程范式固化"><a href="#视图编程范式固化" class="headerlink" title="视图编程范式固化"></a>视图编程范式固化</h1><p>从 JQuery 退出历史舞台，再到 React 等占据主流市场。视图的编程范式基本已经稳定下来，不管你在学习什么视图框架，我们接触的概念模型是趋同的，无非是实现的手段、开发体验上各有特色：</p><ul><li><strong>数据驱动视图</strong>。数据是现代前端框架的核心，视图是数据的映射， <code>View=f(State)</code> 这个公式基本成立。</li><li><strong>声明式视图</strong>。相较于上一代的 jQuery，现代前端框架使用声明式描述视图的结构，即描述结果而不是描述过程。</li><li><strong>组件化视图</strong>。组件是现代前端框架的第一公民。组件涉及的概念无非是 props、slots、events、ref、Context…</li></ul><p><br><br><br></p><h1 id="局部体验内卷"><a href="#局部体验内卷" class="headerlink" title="局部体验内卷"></a>局部体验内卷</h1><p>回顾一下 4 年前写的 <strong><a href="https://juejin.cn/post/6844903865926549511" target="_blank" rel="noopener">浅谈 React 性能优化的方向</a></strong>，现在看来依旧不过时，各大框架无非也是围绕着这些「方向」来改善。</p><p>当然，在「框架内卷」、「既要又要还要」时代，新的框架要脱颖而出并不容易，它既要服务好开发者(<code>开发体验</code>)，又要服务好客户(<code>用户体验</code>) ， 性能不再是我们选择框架的首要因素。</p><p><br></p><p>以下是笔者总结的，次世代视图框架的内卷方向:</p><ul><li><strong>用户体验</strong><ul><li>性能优化<ul><li>精细化渲染：这是次世代框架内卷的主要战场，它们的首要目的基本是实现低成本的精细化渲染<ul><li>预编译方案：代表有 Svelte、Solid</li><li>响应式数据：代表有 Svelte、Solid、Vue、Signal(不是框架)</li><li>动静分离</li></ul></li></ul></li><li>并发(Concurrent)：React 在这个方向独枳一树。</li><li>去 JavaScript：为了获得更好的首屏体验，各大框架开始「抛弃」JavaScript，都在比拼谁能更快到达用户的眼前，并且是完整可交互的形态。</li></ul></li><li><strong>开发体验</strong><ul><li>Typescript 友好：不支持 Typescript 基本就是 ca</li><li>开发工具链/构建体验: Vite、Turbopack… 开发的工具链直接决定了开发体验</li><li>开发者工具：框架少不了开发者工具，从 Vue Devtools 再到 <a href="https://devtools.nuxtjs.org/" target="_blank" rel="noopener">Nuxt Devtools</a>，酷炫的开发者工具未来可能都是标配</li><li>元框架: 毛坯房不再流行，从前到后、大而全的元框架称为新欢，内卷时代我们只应该关注业务本身。代表有 Nextjs、Nuxtjs</li></ul></li></ul><p><br><br><br><br><br></p><h2 id="精细化渲染"><a href="#精细化渲染" class="headerlink" title="精细化渲染"></a>精细化渲染</h2><p><br><br><br></p><h3 id="预编译方案"><a href="#预编译方案" class="headerlink" title="预编译方案"></a>预编译方案</h3><p>React、Vue 这些以 Virtual DOM 为主的渲染方式，通常只能做到组件级别的精细化渲染。<strong>而次世代的 Svelte、Solidjs 不约而同地抛弃了 Virtual DOM，采用静态编译的手段，将「声明式」的视图定义，转译为「命令式」的 DOM 操作</strong>。</p><p>Svelte</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> count = <span class="number">0</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    count += 1</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">on:click</span>=<span class="string">"&#123;handleClick&#125;"</span>&gt;</span>Clicked &#123;count&#125; &#123;count === 1 ? 'time' : 'times'&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编译结果：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ....</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_fragment</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> button</span><br><span class="line">  <span class="keyword">let</span> t0</span><br><span class="line">  <span class="keyword">let</span> t1</span><br><span class="line">  <span class="keyword">let</span> t2</span><br><span class="line">  <span class="keyword">let</span> t3_value = <span class="comment">/*count*/</span> (ctx[<span class="number">0</span>] === <span class="number">1</span> ? <span class="string">'time'</span> : <span class="string">'times'</span>) + <span class="string">''</span></span><br><span class="line">  <span class="keyword">let</span> t3</span><br><span class="line">  <span class="keyword">let</span> mounted</span><br><span class="line">  <span class="keyword">let</span> dispose</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    c() &#123;</span><br><span class="line">      button = element(<span class="string">'button'</span>)</span><br><span class="line">      t0 = text(<span class="string">'Clicked '</span>)</span><br><span class="line">      t1 = text(<span class="comment">/*count*/</span> ctx[<span class="number">0</span>])</span><br><span class="line">      t2 = space()</span><br><span class="line">      t3 = text(t3_value)</span><br><span class="line">    &#125;,</span><br><span class="line">    m(target, anchor) &#123;</span><br><span class="line">      insert(target, button, anchor)</span><br><span class="line">      append(button, t0)</span><br><span class="line">      append(button, t1)</span><br><span class="line">      append(button, t2)</span><br><span class="line">      append(button, t3)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!mounted) &#123;</span><br><span class="line">        dispose = listen(button, <span class="string">'click'</span>, <span class="comment">/*handleClick*/</span> ctx[<span class="number">1</span>])</span><br><span class="line">        mounted = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    p(ctx, [dirty]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dirty &amp; <span class="comment">/*count*/</span> <span class="number">1</span>) set_data(t1, <span class="comment">/*count*/</span> ctx[<span class="number">0</span>])</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        dirty &amp; <span class="comment">/*count*/</span> <span class="number">1</span> &amp;&amp;</span><br><span class="line">        t3_value !== (t3_value = <span class="comment">/*count*/</span> (ctx[<span class="number">0</span>] === <span class="number">1</span> ? <span class="string">'time'</span> : <span class="string">'times'</span>) + <span class="string">''</span>)</span><br><span class="line">      )</span><br><span class="line">        set_data(t3, t3_value)</span><br><span class="line">    &#125;,</span><br><span class="line">    i: noop,</span><br><span class="line">    o: noop,</span><br><span class="line">    d(detaching) &#123;</span><br><span class="line">      <span class="keyword">if</span> (detaching) &#123;</span><br><span class="line">        detach(button)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mounted = <span class="literal">false</span></span><br><span class="line">      dispose()</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance</span>(<span class="params">$$self, $$props, $$invalidate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $$invalidate(<span class="number">0</span>, (count += <span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [count, handleClick]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">SvelteComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    init(<span class="keyword">this</span>, options, instance, create_fragment, safe_not_equal, &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><p>我们看到，简洁的模板最终被转移成了底层 DOM 操作的命令序列。</p><p>我写文章比较喜欢比喻，这种场景让我想到，编程语言对内存的操作，DOM 就是浏览器里面的「内存」：</p><ul><li>Virtual DOM 就是那些那些带 GC 的语言，使用运行时的方案来屏蔽 DOM 的操作细节，这个抽象是有代价的</li><li>预编译方案则更像 Rust，没有引入运行时 GC, 使用了一套严格的所有权和对象生命周期管理机制，让编译器帮你转换出安全的内存操作代码。</li><li>手动操作 DOM, 就像 C、C++ 这类底层语言，需要开发者手动管理内存</li></ul><p>使用 Svelte/SolidJS 这些方案，可以做到修改某个数据，精细定位并修改 DOM 节点，犹如我们当年手动操作 DOM 这么精细。而 Virtual DOM 方案，只能到组件这一层级，除非你的组件粒度非常细。</p><p><br><br><br><br><br></p><h3 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h3><p>和精细化渲染脱不开身的还有<code>响应式数据</code>。</p><p>React 一直被诟病的一点是当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树，如果要避免不必要的子组件的重渲染，需要开发者手动进行优化(比如 <code>shouldComponentUpdate</code>、<code>PureComponent</code>、<code>memo</code>、<code>useMemo</code>/<code>useCallback</code>)  。同时你可能会需要使用不可变的数据结构来使得你的组件更容易被优化。</p><p>在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。</p><p>近期比较火热的 signal (信号，Angular、Preact、Qwik、Solid 等框架都引入了该概念)，如果读者是 Vue 或者 MobX 之类的用户， Signal 并不是新的概念。</p><p>按 Vue 官方文档的话说：<em>从根本上说，信号是与 Vue 中的 ref 相同的响应性基础类型。它是一个在访问时跟踪依赖、在变更时触发副作用的值容器。</em></p><p>不管怎样，响应式数据不过是<code>观察者模式</code>的一种实现。相比 React 主导的通过不可变数据的比对来标记重新渲染的范围，响应式数据可以实现更细粒度的绑定；而且响应式的另一项优势是它的可传递性(有些地方称为 <code>Props 下钻</code>(Props Drilling))。</p><p><br><br><br></p><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>Vue 3 就是动静结合的典型代表。在我看来 Vue 深谙中庸之道，在它身上我们很难找出短板。</p><p>Vue 的模板是需要静态编译的，这使得它可以像 Svelte 等框架一样，有较大的优化空间；同时保留了 Virtual DOM 和运行时 Reactivity，让它兼顾了灵活和普适性。</p><p>基于静态的模板，Vue 3 做了很多优化，笔者将它总结为<code>动静分离</code>吧。比如静态提升、更新类型标记、树结构打平，无非都是将模板中的静态部分和动态部分作一些分离，避免一些无意义的更新操作。</p><p>更长远的看，受 SolidJS 的启发， Vue 未来可能也会退出 Vapor 模式，不依赖 Virtual DOM 来实现更加精细的渲染。</p><p><br><br><br><br><br></p><h2 id="再谈编译时和运行时"><a href="#再谈编译时和运行时" class="headerlink" title="再谈编译时和运行时"></a>再谈编译时和运行时</h2><p>编译时和运行时没有优劣之分， 也不能说纯编译的方案就必定是未来的趋势。</p><p>这几年除了新的编译时的方案冒出来，宣传自己是未来；也有从编译时的焦油坑里爬出来， 转到运行时方案的，这里面的典型代表就是 Taro。</p><p>Taro 2.0 之前采用的是静态编译的方案，即将 ’React‘ 组件转译为小程序原生的代码:</p><p><img src="/images/fe-view-future/Untitled%201.png" alt="Untitled"></p><p>但是这个转译工作量非常庞大，JSX 的写法千变万化，非常灵活。Taro 只能采用 <code>穷举</code> 的方式对 JSX 可能的写法进行了一 一适配，这一部分工作量很大，实际上 Taro 有大量的 Commit 都是为了更完善的支持 JSX 的各种写法。这也是 Taro 官方放弃这种架构的原因。</p><p>也就是说 <strong>Taro 也只能覆盖我们常见的 JSX 用法，而且我们必须严格遵循 Taro 规范才能正常通过。</strong></p><p>有非常多的局限：</p><ul><li>静态的 JSX</li><li>不支持高阶组件</li><li>不支持动态组件</li><li>不支持操作 JSX 的结果</li><li>不支持 render function</li><li>不能重新导出组件</li><li>需要遵循 on<em>、render</em> 约束</li><li>不支持 Context、Fragment、props 展开、forwardRef</li><li>….</li></ul><p><a href="https://www.notion.so/Taro-React-65161e2a09f648c0ad1c69f314ff3cea?pvs=21" target="_blank" rel="noopener">有太多太多的约束</a>，这已经不是带着镣铐跳舞了，是被五花大绑了。</p><p><br></p><p>使用编译的方案不可避免的和实际运行的代码有较大的 <code>Gap</code>，源码和实际运行的代码存在较大的差别会导致什么？</p><ul><li>比较差的 Debug 体验。</li><li>比较黑盒。</li></ul><p>我们在歌颂编译式的方案，能给我们带来多大的性能提升、带来多么简洁的语法的同时。另一方面，一旦我们进行调试/优化，我们不得不跨越这层 Gap，去了解它转换的逻辑和底层实现。</p><p>这是一件挺矛盾的事情，当我们「精通」这些框架的时候，估计我们已经是一个<code>人肉编译器</code>了。</p><p>Taro 2.x 配合小程序， 这对卧龙凤雏, 可以将整个开发体验拉到地平线以下。</p><p><br></p><p>回到这些『次世代』框架。React/Vue/Angular 这些框架先入为主， 在它们的教育下，我们对前端视图开发的概念和编程范式的认知已经固化。</p><p><img src="/images/fe-view-future/Untitled%202.png" alt="Untitled"></p><p>比如在笔者看来 Svelte 是违法直觉的。因为 JavaScript 本身并不支持这种语义。Svelte 要支持这种语义需要一个编译器，而作为一个 JavaScript 开发者，我也需要进行心智上的转换。</p><p>而 SolidJS 则好很多，目之所及都是我们熟知的东西。尽管编译后可能是一个完全不一样的东西。</p><blockquote><p>💡 Vue 曾经也过一个名为<strong><a href="https://cn.vuejs.org/guide/extras/reactivity-transform.html" target="_blank" rel="noopener">响应性语法糖</a></strong>的实验性功能来探索这个方向，但最后由于<strong><a href="https://github.com/vuejs/rfcs/discussions/369#discussioncomment-5059028" target="_blank" rel="noopener">这个原因</a></strong>，废弃了。这是一次明智的决定</p></blockquote><p>当然，年轻的次世代的前端开发者可能不这么认为，他们毕竟没有经过旧世代框架的先入为主和洗礼，他们更能接受新的开发范式，然后扛起这些旗帜，让它们成为未来主流。</p><p>总结。纯编译的方能可以带来更简洁的语法、更多性能优化的空间，甚至也可以隐藏一些跨平台/兼容性的细节。另一方面，源码和实际编译结果之间的 Gap，可能会逼迫开发者成为人肉编译器，尤其在复杂的场景，对开发者的心智负担可能是翻倍的。</p><p>对于框架开发者来说，纯编译的方案实现复杂度会更高，这也意味着，会有较高贡献门槛，间接也会影响生态。</p><p><br><br><br><br><br></p><h2 id="去-javascript"><a href="#去-javascript" class="headerlink" title="去 JavaScript"></a>去 JavaScript</h2><p>除了精细化渲染，Web 应用的首屏体验也是框架内卷的重要方向，这个主要的发展脉络，笔者在 <a href="https://juejin.cn/post/7241027834490437669" target="_blank" rel="noopener">现代前端框架的渲染模式</a> 一文已经详细介绍，推荐大家读一下：</p><p><img src="/images/fe-view-future/Untitled%203.png" alt="Untitled"></p><p>这个方向的强有力的代表主要有 Astro(Island Architecture 岛屿架构)、Next.js(React Server Component)、Qwik(Resumable 去 Hydration)。</p><p>这些框架基本都是秉承 SSR 优先，在首屏的场景，JavaScript 是「有害」的，为了尽量更少地向浏览器传递 JavaScript，他们绞尽脑汁 ：</p><ul><li>Astro：’静态 HTML‘优先，如果想要 SPA 一样实现复杂的交互，可以申请开启一个岛屿，这个岛屿支持在客户端进行水合和渲染。你可以把岛屿想象成一个 iframe 一样的玩意。</li><li>React Server Component: 划分服务端组件和客户端组件，服务端组件仅在服务端运行，客户端只会看到它的渲染结果，JavaScript 执行代码自然也仅存于服务端。</li><li>Qwik：我要直接革了水合(Hydration)的命，我不需要水合，需要交互的时候，我惰性从服务端拉取事件处理器不就可以了…</li></ul><p>不得不说，「去 JavaScript」的各种脑洞要有意思多了。</p><p><br><br><br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要讲了次世代前端框架的内卷方向，目前来看还处于量变的阶段，并没有脱离现在主流框架的心智模型，因此我们上手起来基本不会有障碍。</p><p>作为普通开发者，我们可以站在更高的角度去审视这些框架的发展，避免随波逐流和无意义的内卷。</p><p><br><br><br></p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/597473358" target="_blank" rel="noopener">新时代的 SSR 框架破局者：<em>qwik</em></a></li><li><a href="https://cn.vuejs.org/guide/extras/rendering-mechanism.html" target="_blank" rel="noopener">Vue 渲染机制</a></li><li><a href="https://cn.vuejs.org/guide/extras/reactivity-in-depth.html" target="_blank" rel="noopener">Vue 深入响应式系统</a></li><li><a href="https://2022.stateofjs.com/zh-Hans/libraries/front-end-frameworks/" target="_blank" rel="noopener">State of JavaScript</a></li><li><a href="https://juejin.cn/post/6844903865926549511" target="_blank" rel="noopener">浅谈 React 性能优化的方向</a></li><li><a href="https://zhuanlan.zhihu.com/p/350507037" target="_blank" rel="noopener">新兴前端框架 Svelte 从入门到原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/fe-view-future/Untitled.png&quot; alt=&quot;state of JavaScript 2022 满意度排名&quot;&gt;&lt;/p&gt;
&lt;p&gt;state of JavaScript 2022 满意度排名&lt;/p&gt;
&lt;p&gt;上图是 &lt;a 
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>全新 JavaScript 装饰器实战下篇：实现依赖注入</title>
    <link href="https://bobi.ink/2023/06/30/decorator-2/"/>
    <id>https://bobi.ink/2023/06/30/decorator-2/</id>
    <published>2023-06-29T16:00:00.000Z</published>
    <updated>2023-06-30T08:43:56.329Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/decorator-2/Untitled.jpeg" alt="cover"></p><p><br></p><p>系列文章：</p><ul><li><a href="https://www.notion.so/Javascript-MobX-Vue-5e1c633167094d9784e602d66a5877f8?pvs=21" target="_blank" rel="noopener">全新 Javascript 装饰器实战上篇：用 MobX 的方式打开 Vue </a></li><li><a href="https://www.notion.so/JavaScript-0729df8081ec44b48f6f2e6ec7835120?pvs=21" target="_blank" rel="noopener">全新 JavaScript 装饰器实战下篇：实现依赖注入</a></li></ul><p>上一篇<a href="https://www.notion.so/Javascript-MobX-Vue-5e1c633167094d9784e602d66a5877f8?pvs=21" target="_blank" rel="noopener">文章</a>我们介绍了 JavaScript 最新的装饰器提案，以及它和旧版的区别。这篇文章我们将继续深入装饰器，尝试实现一个简易的依赖注入库。</p><p><br></p><p>谈到装饰器我们总会听到 <code>reflect-metadata</code>, 尤其是社区上的依赖注入库，比如 <a href="https://github.com/inversify/InversifyJS" target="_blank" rel="noopener">inversify.js</a></p><p><br></p><p><img src="/images/decorator-2/Untitled.png" alt="inversify.js"></p><p><br></p><p><strong>我们在上一篇文章的装饰器实现中，会直接去转换或者修改类的结构，大部分场景这并不是最佳实践。</strong></p><p><strong>大部分情况下我们应该利用装饰器来收集一些标注信息</strong>，比如 MobX 用装饰器来标注哪些是 observable、哪些是 computed；Inversify.js 用 inject 标注哪些属性需要进行注入；Angular.js 使用 Input/Output 标记属性….</p><p>如果我们要通过装饰器来标记类的原信息，那就得来认识一下：装饰器的好搭子 <code>reflect-metadata</code> 。</p><p><br><br><br><br><br></p><h2 id="di-库经常提及的-reflect-metadata-到底是什么？"><a href="#di-库经常提及的-reflect-metadata-到底是什么？" class="headerlink" title="DI 库经常提及的 reflect-metadata 到底是什么？"></a>DI 库经常提及的 reflect-metadata 到底是什么？</h2><p>这是一个 JavaScript 提案，但是作者并没有<a href="https://github.com/rbuckton/reflect-metadata/issues/96" target="_blank" rel="noopener">将其提交到 TC39</a>。它的继任者现在是 <a href="https://github.com/tc39/proposal-decorator-metadata" target="_blank" rel="noopener">Decorator Metadata</a>，现在已经进入了 Stage 3 阶段，Typescript 也将在 5.2 中实现这个提案。</p><p>Decorator Metadata 会在下文详细介绍，我们先来看看 reflect-metadata。</p><p>先来看看使用它能用来干啥：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test(&apos;reflect-metadata&apos;, () =&gt; &#123;</span><br><span class="line">  const key = &apos;myKey&apos;</span><br><span class="line"></span><br><span class="line">  // 🔴 装饰器语法</span><br><span class="line">  @Reflect.metadata(key, &apos;inClass&apos;)</span><br><span class="line">  class Foo &#123;</span><br><span class="line">    @Reflect.metadata(key, &apos;inStaticMember&apos;)</span><br><span class="line">    static staticMember = 1</span><br><span class="line"></span><br><span class="line">    @Reflect.metadata(key, &apos;inMember&apos;)</span><br><span class="line">    member = 2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 🔴 上述装饰器等价于</span><br><span class="line">  Reflect.defineMetadata(key, &apos;inClass&apos;, Foo)</span><br><span class="line">  Reflect.defineMetadata(key, &apos;inStaticMember&apos;, Foo, &apos;staticMember&apos;)</span><br><span class="line">  Reflect.defineMetadata(key, &apos;inMember&apos;, Foo.prototype, &apos;member&apos;)</span><br><span class="line"></span><br><span class="line">  // 🔴 静态成员</span><br><span class="line">  expect(Reflect.getMetadata(key, Foo)).toBe(&apos;inClass&apos;)</span><br><span class="line">  expect(Reflect.getMetadata(key, Foo, &apos;staticMember&apos;)).toBe(&apos;inStaticMember&apos;)</span><br><span class="line"></span><br><span class="line">  // 🔴 实例成员，**需要通过实例获取**</span><br><span class="line">  expect(Reflect.getMetadata(key, Foo, &apos;member&apos;)).toBeUndefined()</span><br><span class="line">  const foo = new Foo()</span><br><span class="line">  expect(Reflect.getMetadata(key, foo, &apos;member&apos;)).toBe(&apos;inMember&apos;)</span><br><span class="line">  // 或者通过原型对象获取</span><br><span class="line">  expect(Reflect.getMetadata(key, Foo.prototype, &apos;member&apos;)).toBe(&apos;inMember&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>通过上面的 「hello world」 我们可以发现：</p><ol><li>可以作为<code>装饰器</code>使用。这个表示这个提案和装饰器有不解的渊源，所以当我们谈及装饰器的时候，总会看到它的身影。</li><li>元数据? 没那么高大上，就是一些 key/value 存储</li><li>扩展了 Reflect API？为什么是 Reflect API?</li><li>关于存储位置，类和静态成员存储在类上，实例成员存储在类的原型上(prototype)</li></ol><p><br></p><p>通过上面的皮毛，我们 GET 不到它要解决痛点是啥。不就是存储一些元数据嘛，我们不需要这个 API 也可以做到，比如 MobX 的装饰器就是放在原型上的一个隐藏自定义属性上：</p><p><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function storeAnnotation(prototype: any, key: PropertyKey, annotation: Annotation) &#123;</span><br><span class="line">  if (!hasProp(prototype, storedAnnotationsSymbol)) &#123;</span><br><span class="line">    addHiddenProp(prototype, storedAnnotationsSymbol, &#123;</span><br><span class="line">      // Inherit annotations</span><br><span class="line">      ...prototype[storedAnnotationsSymbol],</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><p>实际上这个概念是从其他语言借鉴的，比如下面 Java Spring 依赖注入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 中，可以通过它的 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html" target="_blank" rel="noopener">Reflect API</a> 可以获取到类的<code>类型信息</code>，比如方法、方法的参数、返回值等类型信息。</p><p>然而，JavaScript 是一门弱类型语言，没有这类信息。所以我们在实现<code>依赖注入</code>时，并不能做到像 Java 那么强大：</p><p><br></p><p>Java:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> Engine engine;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      engine.turnOn();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vs Typescript</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Engine &#123;&#125;</span><br><span class="line"></span><br><span class="line">@injectable()</span><br><span class="line">class Car &#123;</span><br><span class="line">  @inject(&apos;EngineKey&apos;)</span><br><span class="line">  private engine: Engine</span><br><span class="line">  start() &#123;</span><br><span class="line">    this.engine.turnOn()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Java Spring 可以自动推断类型来进行注入</strong>，这个类型可以是接口、具体的类、抽象类等等。而现在 JavaScript 下的 DI 库，我们通常需要显式指定一个标识符，或者只能是一个具体的类(不支持接口)， 一点也不够优雅。</p><p>既然现在有了 <code>Typescript</code> ，能不能做到呢？Typescript 最终也是转换为 JavaScript ，默认情况下<code>类型信息</code>都会被裁减掉。</p><p>而 reflect-metadata 的初衷还是想将 Java/C# 这类语言的 Reflect 能力带到 JavaScript。<strong>因此就拟定了这样一个协议， 让 Typescript 或者其他转译到 JavaScript 强类型语言，可以通过它将类型信息保留下来。</strong></p><p><br></p><p>所以我们看到 Typescript 是它的主要推动者。我们在 Typescript 中可以通过开启 <code>emitDecoratorMetadata</code> 实现装饰器类型信息的保留:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Bar &#123;&#125;</span><br><span class="line"></span><br><span class="line">@d</span><br><span class="line">class Foo &#123;</span><br><span class="line">  @d</span><br><span class="line">  static staticMember = 1</span><br><span class="line"></span><br><span class="line">  @d</span><br><span class="line">  member = 2</span><br><span class="line"></span><br><span class="line">  @d</span><br><span class="line">  method(foo: number, bar: Bar, baz: Foo): string &#123;&#125;</span><br><span class="line"></span><br><span class="line">  constructor(a: Bar) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var __metadata =</span><br><span class="line">  (this &amp;&amp; this.__metadata) ||</span><br><span class="line">  function (k, v) &#123;</span><br><span class="line">    if (typeof Reflect === &apos;object&apos; &amp;&amp; typeof Reflect.metadata === &apos;function&apos;)</span><br><span class="line">      return Reflect.metadata(k, v)</span><br><span class="line">  &#125;</span><br><span class="line">// 省略部分代码</span><br><span class="line">__decorate([d, __metadata(&apos;design:type&apos;, Object)], Foo.prototype, &apos;member&apos;, void 0)</span><br><span class="line">__decorate(</span><br><span class="line">  [</span><br><span class="line">    d,</span><br><span class="line">    __metadata(&apos;design:type&apos;, Function),</span><br><span class="line">    __metadata(&apos;design:paramtypes&apos;, [Number, Object, Foo]),</span><br><span class="line">    __metadata(&apos;design:returntype&apos;, String),</span><br><span class="line">  ],</span><br><span class="line">  Foo.prototype,</span><br><span class="line">  &apos;method&apos;,</span><br><span class="line">  null</span><br><span class="line">)</span><br><span class="line">__decorate([d, __metadata(&apos;design:type&apos;, Object)], Foo, &apos;staticMember&apos;, void 0)</span><br><span class="line">Foo = __decorate([d, __metadata(&apos;design:paramtypes&apos;, [Object])], Foo)</span><br></pre></td></tr></table></figure><p>我们看到大部分的类型信息都保留下来了，比如成员类型、方法的参数/返回值类型。</p><p>但是它也有局限性，比如接口等自定义类型依旧无法保留，毕竟 JavaScript 并没有这些概念。这也直接决定了依旧无法和 Java 这种「原生」强类型语言比肩。</p><p><br></p><blockquote><p>reflect-metadata 可能代表的是 JavaScript 作为一个新汇编语言的觉悟，但是目前的事实也证明了这条路比较难。就拿 Typescript 来说，保留的信息比较有限，而且这会让开发者的技术栈严重依赖 Typescript，另外像 esbuild、swc、babel 这些转译器也很难跟进这种特性。<br><br><br>实际上，现在流行的 DI 库，如 <code>inversify</code>、<code>tsyringe</code> 对 Typescript <code>emitDecoratorMetadata</code> 的依赖也很小，去掉基本上不影响其有效运行。</p></blockquote><blockquote></blockquote><p><br></p><p>总结, reflect-metadata 视图提供一个类(class)元信息的存储标准。在笔者开来，主要的愿景是为上层更高级的语言(比如 Typescript)保留静态类型信息提供一种方式。其次，普通开发者也能使用这个标准化的 API 来给类标注信息。</p><p><br><br><br><br><br></p><h2 id="decorator-metadata"><a href="#decorator-metadata" class="headerlink" title="Decorator Metadata"></a>Decorator Metadata</h2><p>如今的 Metadata 提案已经从装饰器中分离出来，目前也进入了 Stage 3 阶段。经过重新设计的 Metadata 和 reflect-metadata 不是同一个玩意。</p><p>这个提案非常简单，就是新增了一个内置 Symbol —— <code>Symbol.metadata</code>。在装饰器的配合将元数据存储在类的 Symbol.metadata 下面:</p><p><br><br><br></p><p>针对装饰器协议的扩展:</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">type Decorator = (value: Input, context: &#123;</span><br><span class="line">  kind: string;</span><br><span class="line">  name: string | symbol;</span><br><span class="line">  access: &#123;</span><br><span class="line">    get?(): unknown;</span><br><span class="line">    set?(value: unknown): void;</span><br><span class="line">  &#125;;</span><br><span class="line">  isPrivate?: boolean;</span><br><span class="line">  isStatic?: boolean;</span><br><span class="line">  addInitializer?(initializer: () =&gt; void): void;</span><br><span class="line"><span class="addition">+ metadata?: Record&lt;string | number | symbol, unknown&gt;;</span></span><br><span class="line">&#125;) =&gt; Output | void;</span><br></pre></td></tr></table></figure><p><br></p><p>所有装饰器的 context 对象新增了 metadata 对象。 metadata 只是一个普通的对象，没什么特别：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function meta(key: string) &#123;</span><br><span class="line">  return (value: unknown, context: DecoratorContext) =&gt; &#123;</span><br><span class="line">    context.metadata![key] = true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@meta(&apos;inClass&apos;)</span><br><span class="line">class Foo &#123;</span><br><span class="line">  @meta(&apos;inStaticMember&apos;)</span><br><span class="line">  static staticMember = 1</span><br><span class="line"></span><br><span class="line">  @meta(&apos;inMember&apos;)</span><br><span class="line">  member = 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 类的所有装饰器共享</span><br><span class="line">expect(Foo[Symbol.metadata]).toEqual(&#123;</span><br><span class="line">  inStaticMember: true,</span><br><span class="line">  inMember: true,</span><br><span class="line">  inClass: true,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>就是这么朴实且无华。因为<strong>所有装饰器都是共享一个对象空间</strong>，避免冲突的职责就交给开发者了。</p><p>大概有两种方式：</p><ul><li>命名空间。比如单纯用字符串 key <code>库名称.{是否静态}.{装饰器位置}.{属性名}</code>，或者创建一个私有 Symbol 按嵌套的结构存储。</li><li><p>私有空间。以下是 MetaData 提案中的例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const PRIVATE_METADATA = new WeakMap();</span><br><span class="line"></span><br><span class="line">function meta(key, value) &#123;</span><br><span class="line">  return (_, context) =&gt; &#123;</span><br><span class="line">    let metadata = PRIVATE_METADATA.get(context.metadata);</span><br><span class="line"></span><br><span class="line">    if (!metadata) &#123;</span><br><span class="line">      metadata = &#123;&#125;;</span><br><span class="line">      PRIVATE_METADATA.set(context.metadata, metadata);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    metadata[key] = value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@meta(&apos;a&apos; &apos;x&apos;)</span><br><span class="line">class C &#123;</span><br><span class="line">  @meta(&apos;b&apos;, &apos;y&apos;)</span><br><span class="line">  m() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PRIVATE_METADATA.get(C[Symbol.metadata]).a; // &apos;x&apos;</span><br><span class="line">PRIVATE_METADATA.get(C[Symbol.metadata]).b; // &apos;y&apos;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><p>Anyway，解决命名冲突有无数的办法。</p><blockquote><p>🙋  那 <code>Typescript</code> 的 <code>emitDecoratorMetadata</code> 还支持吗？暂时看到相关的计划</p></blockquote><p><br><br><br><br><br></p><h2 id="简单理解依赖注入"><a href="#简单理解依赖注入" class="headerlink" title="简单理解依赖注入"></a>简单理解依赖注入</h2><p>现在开始实战部分，首先我们需要了解一下什么是依赖注入：</p><p><img src="/images/decorator-2/Untitled%201.png" alt="di"></p><p>理解依赖注入，需要搞清楚以下几个概念：</p><ul><li><strong>接口(interface)。</strong>接口是一个协议，或者是一个需求。这个由’甲方‘提出来，比如我们要一个手机，那么能“打电话”、”发短信”, 就是需求。接口是一个抽象的东西，并不是具体的实现。对于消费者来说它并不关心的内部细节、是怎么制造出来的。</li><li><strong>实现(implements)</strong>。满足接口需求的具体实现，比如“手机”这个接口的实现，可以是 iphone、小米手机、华为手机等等。</li><li><strong>依赖注入</strong>。依赖注入的意思就是<code>需求者</code>描述好自己的<code>需求</code>，然后由<code>经销商</code>来查找<strong>符合需求</strong>的<code>实现</code>，给到需求者。需求者从头到尾，不会去关心这个需求是怎么去实现的，它只关心它自己要干的事情。</li><li><strong>三种角色</strong>:<ul><li><code>需求者</code>。或者说<code>消费者</code></li><li><code>经销商</code>(容器)。我们也称为容器，他负责协调需求和实现。</li><li><code>供应商</code>。需求的具体实现者。</li></ul></li></ul><p><br><br><br></p><p>可以通过一个例子(来源<a href="https://www.notion.so/wakeapp-framework-b08cb3cb5f8e49f597aa90bbb89a1641?pvs=21" target="_blank" rel="noopener">这里</a>)来理解一下：</p><p><br></p><ol><li><p>定义需求(协议)</p><p>首先定义需求，描述我们期望得到一个怎样的东西。</p><p>需求通常使用 <code>interface</code> 来描述，当然，这并没有限制。你要一个类也可以、字符串、数字也可以，取决你的需求。</p><p>比如我想要一个手机:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface IPhone &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 打电话</span><br><span class="line">   */</span><br><span class="line">  call(num: string): void</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 发短信</span><br><span class="line">   */</span><br><span class="line">  sendMessage(num: string, message: string): void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册你的需求和标识符的绑定关系：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare global &#123;</span><br><span class="line">  interface DIMapper &#123;</span><br><span class="line">    &apos;DI.IPhone&apos;: IPhone</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>请求注入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class WeChat &#123;</span><br><span class="line">  // 注入请求</span><br><span class="line">  @inject(&apos;DI.IPhone&apos;)</span><br><span class="line">  myPhone: IPhone</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 打电话老妈</span><br><span class="line">   */</span><br><span class="line">  callMom() &#123;</span><br><span class="line">    this.myPhone.call(&apos;137****110&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现需求</p><p>接下来就是供应商来实现需求了。通常使用类来实现需求：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">@injectable()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TheIPhone</span> <span class="title">implements</span> <span class="title">IPhone</span> </span>&#123;</span><br><span class="line">  call(num: string) &#123;</span><br><span class="line">    <span class="comment">// 拨打电话流程</span></span><br><span class="line">  &#125;</span><br><span class="line">  sendMessage(num: string, <span class="attr">message</span>: string) &#123;</span><br><span class="line">    <span class="comment">// 发送短信流程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注册实现</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">configureDI((registerSingletonClass) =&gt; &#123;</span><br><span class="line">  registerSingletonClass(&apos;DI.IPhone&apos;, TheIPhone)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p><br><br><br></p><p>如果你理解了上面的例子，那么你已经懂依赖注入了。不过，当你接触到依赖注入的相关实现库时，还有听到这些概念：</p><ul><li><code>容器(Container)</code>。 就是上文提到的<code>经销商</code>，用最简单技术术语来描述的话，他就是一个<code>对象池</code>。他负责协调<code>消费者</code>需求和<code>提供商</code>的实现。</li><li><code>作用域(Scope)</code>。就是对象的存活时间和活动范围<ul><li>存活时间：比较典型的有 singleton(单例)、request(请求， 这个一句话说不清楚，你可以类比为 「HTTP 请求」，这些对象仅在这一次 HTTP 的请求周期内有效)、transient(临时，即每次 inject 请求都创建一个新的对象)。当然，根据实际的场景还可以扩展，比如在 React 组件生命周期</li><li>活动范围： 很多依赖注入库中，容器不是一个单一的对象，而是一个树状的结构，如果要限制某些对象的活动范围，或者覆盖对象的实现，可以通过 Fork 子容器的形式来实现隔离。</li></ul></li><li><code>绑定(binding)</code>。即协议的绑定，比如上面的例子中我们使用 <code>DI.IPhone</code> 字符串来绑定协议和实现。其他编程语言可以做得更加灵活，只需要声明类型，容器会根据类型的兼容性来协调注入。</li></ul><p><br></p><p>当然，一个生产级别的依赖注入实现还会涉及很多技术细节和概念，比如循环依赖、对象构造和析构、工厂、异步加载、对象生命周期管理、中间件、标签(Tagged)等等。</p><p><br></p><p>不过上面我们掌握的知识已经足够覆盖正常的开发场景了。</p><p><br><br><br></p><p><strong>依赖注入的好处就不多说了：</strong></p><ul><li>解耦。面向接口编程。</li><li>可扩展性。每个依赖注入的点就是一个扩展点。</li><li>可测试性。可以让程序职责更加单一，关注真正需要关注的内容。屏蔽干扰，让核心逻辑更容易被测试。</li></ul><p><br><br><br><br><br></p><h2 id="继续探索-typescript-装饰器的能力边界"><a href="#继续探索-typescript-装饰器的能力边界" class="headerlink" title="继续探索 Typescript 装饰器的能力边界"></a>继续探索 Typescript 装饰器的能力边界</h2><p>在上篇<a href="https://www.notion.so/Javascript-MobX-Vue-5e1c633167094d9784e602d66a5877f8?pvs=21" target="_blank" rel="noopener">文章</a>中，我们提到 Typescript 对新版的装饰器有了更严格的检查。</p><p><br></p><p>它可以约束装饰器的位置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare function injectable&lt;T, Class extends abstract new (...args: any) =&gt; T&gt;(): (</span><br><span class="line">  value: Class,</span><br><span class="line">  context: ClassDecoratorContext&lt;Class&gt;</span><br><span class="line">) =&gt; void</span><br><span class="line"></span><br><span class="line">@injectable()</span><br><span class="line">class Foo &#123;</span><br><span class="line">  // @ts-expect-error ❌ 只能装饰类</span><br><span class="line">  @injectable()</span><br><span class="line">  member = 1</span><br><span class="line"></span><br><span class="line">  // @ts-expect-error ❌ 只能装饰类</span><br><span class="line">  @injectable()</span><br><span class="line">  method() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>这还不止，我们还可以对被装饰的目标值进行约束。以依赖注入的场景来看, 旧版的装饰器很难做到根据注入的标识符来约束<code>实现</code>和<code>注入</code>。现在我们很容易做到：</p><p>先来构造<code>注入标识符</code>的类型(灵感来源于 <code>Vue</code> 的 <code>provide/inject</code>)：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface InjectionKey&lt;T&gt; extends Symbol &#123;&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>现在可以这样定义标识符：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 定义注入的协议，鸟类</span><br><span class="line">interface Bird &#123;</span><br><span class="line">  fly(): void</span><br><span class="line">  searchForFood(): void</span><br><span class="line">  breed(): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将接口和标识符实现绑定</span><br><span class="line">const BIRD_BINDING: InjectionKey&lt;Bird&gt; = Symbol(&apos;Bird&apos;)</span><br></pre></td></tr></table></figure><p><br></p><p>我们再来定义 <code>injectable</code> 装饰器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare function injectable&lt;T, Class extends abstract new (...args: any) =&gt; T&gt;(</span><br><span class="line">  // 传入 InjectionKey 类型，推断出 T 来约束 class</span><br><span class="line">  key: InjectionKey&lt;T&gt;</span><br><span class="line">): (value: Class, context: ClassDecoratorContext&lt;Class&gt;) =&gt; void</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// @ts-expect-error ❌ 没有履行 Bird 协议</span><br><span class="line">@injectable(BIRD_BINDING)</span><br><span class="line">class Eagle &#123;&#125;</span><br><span class="line"></span><br><span class="line">// ✅ 履行了 Bird 协议</span><br><span class="line">@injectable(BIRD_BINDING)</span><br><span class="line">class Pigeon implements Bird &#123;</span><br><span class="line">  fly() &#123;&#125;</span><br><span class="line">  searchForFood() &#123;&#125;</span><br><span class="line">  breed() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在可以对<code>实现者</code>的<code>协议履行</code>进行严格检查。</p><p><br><br><br></p><p>同理我们可以检查注入侧：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare function inject&lt;T&gt;(</span><br><span class="line">  key: InjectionKey&lt;T&gt;</span><br><span class="line">): (value: undefined, context: ClassFieldDecoratorContext&lt;unknown, T | undefined&gt;) =&gt; void</span><br><span class="line"></span><br><span class="line">declare function injectAll&lt;T&gt;(</span><br><span class="line">  key: InjectionKey&lt;T&gt;</span><br><span class="line">): (value: undefined, context: ClassFieldDecoratorContext&lt;unknown, T[] | undefined&gt;) =&gt; void</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Zoo &#123;</span><br><span class="line">  // @ts-expect-error ❌ 类型不匹配</span><br><span class="line">  @inject(BIRD_BINDING)</span><br><span class="line">  private unknown?: number</span><br><span class="line"></span><br><span class="line">  // ✅</span><br><span class="line">  @inject(BIRD_BINDING)</span><br><span class="line">  private bird?: Bird</span><br><span class="line"></span><br><span class="line">  // @ts-expect-error ❌ 类型不匹配</span><br><span class="line">  @injectAll(BIRD_BINDING)</span><br><span class="line">  private allBirds?: Bird</span><br><span class="line"></span><br><span class="line">  // ✅</span><br><span class="line">  @injectAll(BIRD_BINDING)</span><br><span class="line">  private birds?: Bird[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很酷?！</p><p><br><br><br><br><br></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>接下来我们把上面讲到的知识点运用起来，实现一个简易的依赖注入库。</p><p>🔴  运行环境：由于使用了较新的特性，其他构建平台暂未跟进(包括 Babel、Vite)。下面代码基于 Typescript 5.2(next) + <code>jest</code> + <code>ts-jest</code> 运行。</p><p>为了确保运行， 需要添加以下 polyfill：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// typescript polyfill</span><br><span class="line">declare global &#123;</span><br><span class="line">  interface SymbolConstructor &#123;</span><br><span class="line">    readonly metadata: unique symbol</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  interface Function &#123;</span><br><span class="line">    [Symbol.metadata]?: DecoratorMetadata</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// runtime polyfill</span><br><span class="line">if (typeof Symbol.metadata === &apos;undefined&apos;) &#123;</span><br><span class="line">  // @ts-expect-error</span><br><span class="line">  Symbol.metadata = Symbol(&apos;Symbol.metadata&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>💡  在新版的装饰器中，实现依赖注入不一定要用到 Decorator Metadata, 可以看装饰器提案中的<a href="https://github.com/tc39/proposal-decorators#access-and-metadata-sidechanneling" target="_blank" rel="noopener">例子</a>。</p></blockquote><p><br><br><br><br><br><br><br></p><h3 id="装饰器-api"><a href="#装饰器-api" class="headerlink" title="装饰器 API"></a>装饰器 API</h3><p>首先，我们把关键的装饰器 API 定义出来:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 🔴 InjectionKey 用于定义依赖注入的标识符, 可是实现标志服和协议的绑定，我们在上文介绍过了</span><br><span class="line">export interface InjectionKey&lt;T&gt; extends Symbol &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 作用域类型, 作为简单示例，我们就支持两种作用域类型</span><br><span class="line">export enum Scope &#123;</span><br><span class="line">  Singleton,</span><br><span class="line">  Transient,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 类装饰器，支持被注入的类都需要使用它来装饰</span><br><span class="line">// 可以接受一个 scope，默认为 单例</span><br><span class="line">export function injectable&lt;T, Class extends abstract new (...args: any) =&gt; T&gt;(</span><br><span class="line">  key: InjectionKey&lt;T&gt;,</span><br><span class="line">  scope?: Scope</span><br><span class="line">) &#123;</span><br><span class="line">  return (value: Class, context: ClassDecoratorContext&lt;Class&gt;) =&gt; &#123;</span><br><span class="line">    const metadata = getOrCreateMetadata(context.metadata)</span><br><span class="line"></span><br><span class="line">    if (metadata.injectable) &#123;</span><br><span class="line">      throw new Error(&apos;injectable is already defined&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    metadata.injectable = key</span><br><span class="line">    metadata.scope = scope</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 属性装饰器, 声明注入</span><br><span class="line">export function inject&lt;T&gt;(key: InjectionKey&lt;T&gt;) &#123;</span><br><span class="line">  return (value: undefined, context: ClassFieldDecoratorContext&lt;unknown, T | undefined&gt;) =&gt; &#123;</span><br><span class="line">    injectToField(&#123; key, context &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 属性装饰器, 声明注入所有绑定</span><br><span class="line">export function injectAll&lt;T&gt;(key: InjectionKey&lt;T&gt;) &#123;</span><br><span class="line">  return (value: undefined, context: ClassFieldDecoratorContext&lt;unknown, T[] | undefined&gt;) =&gt; &#123;</span><br><span class="line">    injectToField(&#123; key, multiple: true, context &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述装饰器不会对类进行改造，只是利用 Decorator Metadata 进行一些标注：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 🔴 我们存储在类 Decorator Metadata 的数据</span><br><span class="line">interface InjectionMetadata &#123;</span><br><span class="line">  // 类是否装饰了 @injectable</span><br><span class="line">  injectable?: InjectionKey&lt;unknown&gt;</span><br><span class="line">  // 作用域</span><br><span class="line">  scope?: Scope</span><br><span class="line">  // 类需要进行注入的属性</span><br><span class="line">  injections?: Map&lt;PropertyKey, Injection&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 类属性注入信息</span><br><span class="line">interface Injection &#123;</span><br><span class="line">  // 属性名</span><br><span class="line">  key: InjectionKey&lt;unknown&gt;</span><br><span class="line">  // 是否获取多个实例</span><br><span class="line">  multiple?: boolean</span><br><span class="line">  // 装饰器的上下文</span><br><span class="line">  context: ClassFieldDecoratorContext</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 Decorator Metadata 的 KEY, 使用 Symbol，避免和其他库冲突</span><br><span class="line">const METADATA_KEY: unique symbol = Symbol(&apos;METADATA_KEY&apos;)</span><br><span class="line"></span><br><span class="line">// 初始化 metadata</span><br><span class="line">function getOrCreateMetadata&lt;T&gt;(metadata: DecoratorMetadata): InjectionMetadata &#123;</span><br><span class="line">  if (metadata == null) &#123;</span><br><span class="line">    throw new Error(&apos;Decorator metadata is not defined&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return metadata[METADATA_KEY] ?? (metadata[METADATA_KEY] = &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 标记属性注入</span><br><span class="line">function injectToField(injection: Injection) &#123;</span><br><span class="line">  const &#123; context &#125; = injection</span><br><span class="line"></span><br><span class="line">  if (context.static === true) &#123;</span><br><span class="line">    throw new Error(&apos;inject cannot be used on static fields&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const metadata = getOrCreateMetadata(context.metadata)</span><br><span class="line"></span><br><span class="line">  if (metadata.injections == null) &#123;</span><br><span class="line">    metadata.injections = new Map()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (metadata.injections.has(context.name)) &#123;</span><br><span class="line">    throw new Error(`inject is already defined for $&#123;context.name.toString()&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  metadata.injections.set(context.name, injection)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试驱动开发，我们先把测试用例写了，也方便读者对我们 API 的用法有基本的了解：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 定义协议</span><br><span class="line">interface Bird &#123;</span><br><span class="line">  fly(): void</span><br><span class="line">  searchForFood(): void</span><br><span class="line">  breed(): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IZoo &#123;</span><br><span class="line">  getAllBirds(): Bird[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义标识符，并绑定协议</span><br><span class="line">const BIRD_BINDING: InjectionKey&lt;Bird&gt; = Symbol.for(&apos;Bird&apos;)</span><br><span class="line">const ZOO_KEY: InjectionKey&lt;IZoo&gt; = Symbol.for(&apos;Zoo&apos;)</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">test(&apos;property inject&apos;, () =&gt; &#123;</span><br><span class="line">  // 🔴 使用 @injectable 标注支持注入的类</span><br><span class="line">  @injectable(BIRD_BINDING)</span><br><span class="line">  class MyBird &#123;</span><br><span class="line">    fly() &#123;&#125;</span><br><span class="line">    searchForFood() &#123;&#125;</span><br><span class="line">    breed() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @injectable(BIRD_BINDING)</span><br><span class="line">  class MyBird2 &#123;</span><br><span class="line">    fly() &#123;&#125;</span><br><span class="line">    searchForFood() &#123;&#125;</span><br><span class="line">    breed() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @injectable(ZOO_KEY)</span><br><span class="line">  class Zoo implements IZoo &#123;</span><br><span class="line">    // 🔴 获取所有 Bird 实例</span><br><span class="line">    @injectAll(BIRD_BINDING)</span><br><span class="line">    birds?: Bird[]</span><br><span class="line"></span><br><span class="line">    getAllBirds() &#123;</span><br><span class="line">      return this.birds!</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 🔴 注册到容器</span><br><span class="line">  const container = new Container()</span><br><span class="line">  container.bind(BIRD_BINDING, MyBird)</span><br><span class="line">  container.bind(BIRD_BINDING, MyBird2)</span><br><span class="line">  container.bind(ZOO_KEY, Zoo)</span><br><span class="line"></span><br><span class="line">  // 测试</span><br><span class="line">  const zoo = container.get(ZOO_KEY)</span><br><span class="line"></span><br><span class="line">  expect(zoo).toBeInstanceOf(Zoo)</span><br><span class="line">  expect(zoo.getAllBirds().length).toBe(2)</span><br><span class="line">  expect(zoo.getAllBirds()[0]).toBeInstanceOf(MyBird)</span><br><span class="line">  expect(zoo.getAllBirds()[1]).toBeInstanceOf(MyBird2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="容器实现"><a href="#容器实现" class="headerlink" title="容器实现"></a>容器实现</h3><p>接下来就是实现容器了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Ctor&lt;T = unknown&gt; = new (...args: any) =&gt; T</span><br><span class="line"></span><br><span class="line">export class Container &#123;</span><br><span class="line">  // 存储绑定关系</span><br><span class="line">  private bindings: Map&lt;InjectionKey&lt;unknown&gt;, Ctor[]&gt; = new Map()</span><br><span class="line">  // 单例对象池</span><br><span class="line">  private pools: Map&lt;Ctor, unknown&gt; = new Map()</span><br><span class="line"></span><br><span class="line">  // 🔴 绑定，传入 InjectionKey 和 类实现</span><br><span class="line">  bind&lt;T&gt;(key: InjectionKey&lt;T&gt;, impl: new (...args: any) =&gt; T) &#123;</span><br><span class="line">    // 装饰器信息检查</span><br><span class="line">    if (impl[Symbol.metadata] == null) &#123;</span><br><span class="line">      throw new Error(`No metadata found for $&#123;impl.name&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const metadata = impl[Symbol.metadata]![METADATA_KEY] as InjectionMetadata | undefined</span><br><span class="line"></span><br><span class="line">    if (metadata == null || metadata.injectable == null) &#123;</span><br><span class="line">      throw new Error(`No injectable found for $&#123;impl.name&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 存储</span><br><span class="line">    if (this.bindings.has(key)) &#123;</span><br><span class="line">      this.bindings.get(key)!.push(impl)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.bindings.set(key, [impl])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 🔴 获取实例</span><br><span class="line">  get&lt;T&gt;(key: InjectionKey&lt;T&gt;): T &#123;</span><br><span class="line">    return this.resolve(key, false) as T</span><br><span class="line">  &#125;</span><br><span class="line">  // 🔴 获取所有实例</span><br><span class="line">  getAll&lt;T&gt;(key: InjectionKey&lt;T&gt;): T[] &#123;</span><br><span class="line">    return this.resolve(key, true) as T[]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 🔴 对象查找</span><br><span class="line">   */</span><br><span class="line">  private resolve(key: InjectionKey&lt;unknown&gt;, multiple: boolean): unknown &#123;</span><br><span class="line">    const binding = this.bindings.get(key)</span><br><span class="line"></span><br><span class="line">    if (binding == null) &#123;</span><br><span class="line">      throw new Error(`No binding found for $&#123;key.toString()&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!multiple &amp;&amp; binding.length &gt; 1) &#123;</span><br><span class="line">      throw new Error(`Multiple bindings found for $&#123;key.toString()&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return multiple</span><br><span class="line">      ? binding.map((impl) =&gt; this.createInstance(impl))</span><br><span class="line">      : this.createInstance(binding[0])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 🔴 对象实例化</span><br><span class="line">   */</span><br><span class="line">  private createInstance(impl: Ctor): unknown &#123;</span><br><span class="line">    const metadata = impl[Symbol.metadata]![METADATA_KEY] as InjectionMetadata</span><br><span class="line">    const &#123; scope = Scope.Singleton, injections &#125; = metadata</span><br><span class="line"></span><br><span class="line">    // 单例</span><br><span class="line">    if (scope === Scope.Singleton &amp;&amp; this.pools.has(impl)) &#123;</span><br><span class="line">      return this.pools.get(impl)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实例化</span><br><span class="line">    const instance = new impl()</span><br><span class="line"></span><br><span class="line">    // 依赖注入，递归调用</span><br><span class="line">    if (injections != null) &#123;</span><br><span class="line">      for (const injection of injections.values()) &#123;</span><br><span class="line">        const &#123; key, context, multiple &#125; = injection</span><br><span class="line">        const value = multiple ? this.getAll(key) : this.get(key)</span><br><span class="line">        // 🔴 利用新版装饰器的 access 实现注入</span><br><span class="line">        context.access.set(instance, value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (scope === Scope.Singleton) &#123;</span><br><span class="line">      this.pools.set(impl, instance)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>整个代码非常简单，这里对新版装饰器的妙用在于 <code>context.access.set(instance, value)</code> , 用起来非常方便，我们不需要关心属性的存储过程，比如<code>私有属性</code>。</p><p><br></p><p>上面的代码有一个问题没有解决，就是<code>循环依赖</code>。我们写一个测试来复现一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test(&apos;cycle dependency&apos;, () =&gt; &#123;</span><br><span class="line">  const container = new Container()</span><br><span class="line"></span><br><span class="line">  const A_KEY: InjectionKey&lt;A&gt; = Symbol(&apos;A&apos;)</span><br><span class="line">  const B_KEY: InjectionKey&lt;B&gt; = Symbol(&apos;B&apos;)</span><br><span class="line"></span><br><span class="line">  @injectable(A_KEY)</span><br><span class="line">  class A &#123;</span><br><span class="line">    @inject(B_KEY)</span><br><span class="line">    b?: B</span><br><span class="line"></span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @injectable(B_KEY)</span><br><span class="line">  class B &#123;</span><br><span class="line">    @inject(A_KEY)</span><br><span class="line">    a?: A</span><br><span class="line"></span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  container.bind(A_KEY, A)</span><br><span class="line">  container.bind(B_KEY, B)</span><br><span class="line"></span><br><span class="line">  const a = container.get(A_KEY)</span><br><span class="line">  expect(a).toBeInstanceOf(A)</span><br><span class="line">  const b = container.get(B_KEY)</span><br><span class="line">  expect(b).toBeInstanceOf(B)</span><br><span class="line">  expect(a.b).toBe(b)</span><br><span class="line">  expect(b.a).toBe(a)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的测试用例会出现<code>调用栈溢出</code>。因为 A → B 之间出现了循环依赖。这个也好办，我们新增一个缓存属性，存储正在实例化的对象，可以简单解决问题：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">export class Container &#123;</span><br><span class="line"><span class="addition">+ // 正在创建的对象</span></span><br><span class="line"><span class="addition">+ private creating: Map&lt;Ctor, unknown&gt; = new Map()</span></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 对象实例化</span><br><span class="line">   */</span><br><span class="line">  private createInstance(impl: Ctor): unknown &#123;</span><br><span class="line"><span class="addition">+   if (this.creating.has(impl)) &#123;</span></span><br><span class="line"><span class="addition">+     return this.creating.get(impl)</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line">    // ...</span><br><span class="line"><span class="addition">+   // 实例化</span></span><br><span class="line"><span class="addition">+   const instance = new impl()</span></span><br><span class="line"><span class="addition">+   // 缓存</span></span><br><span class="line"><span class="addition">+   this.creating.set(impl, instance)</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   try &#123;</span></span><br><span class="line">      // 依赖注入</span><br><span class="line">      if (injections != null) &#123;</span><br><span class="line">        for (const injection of injections.values()) &#123;</span><br><span class="line">          const &#123; key, context, multiple &#125; = injection</span><br><span class="line">          const value = multiple ? this.getAll(key) : this.get(key)</span><br><span class="line">          context.access.set(instance, value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (scope <span class="comment">=== Scope.Singleton) &#123;</span></span><br><span class="line">        this.pools.set(impl, instance)</span><br><span class="line">      &#125;</span><br><span class="line"><span class="addition">+   &#125; finally &#123;</span></span><br><span class="line"><span class="addition">+     this.creating.delete(impl)</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line"></span><br><span class="line">    return instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是装饰器的核心逻辑了。如果你对生产级别 DI 库感兴趣，可以深入看下扩展阅读提及的开源实现。</p><p>上面相关源码可以在<a href="https://github.com/ivan-94/decoractor-in-action/tree/new-di/src/di" target="_blank" rel="noopener">这里</a>找到。</p><p><br><br><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文回顾了装饰器的老搭档 <code>reflect-metadata</code> 的历史，它的愿景给装饰器提供标准化的元数据存储服务，更长远来愿景是给 JavaScript 的上层语言提供保留静态信息的接口。</p><p>但它最终没有提交给 tc39, 现在随着新的装饰器标准的发展，已经被 <code>Decorator Metadata</code> 提案取代。<code>Decorator Metadata</code> 相比 reflect-metadata 简化很多，就是新增了 <code>Symbol.metadata</code>, 配合装饰器 context.metadata，开发者可以存储任意元数据。</p><p>接着我们继续探索了 Typescript 对装饰器类型检查的增强，可以让我们写出更安全的代码。尤其在 DI 这个场景。</p><p>最后我们将上面学到的知识融会贯通，开发了一个简易的依赖注入实现。</p><p><br><br><br><br><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li>Decorator<br><a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noopener">https://github.com/tc39/proposal-decorators</a></li><li>Decorator Metadata<br><a href="https://github.com/tc39/proposal-decorator-metadata" target="_blank" rel="noopener">https://github.com/tc39/proposal-decorator-metadata</a></li><li>reflect-metadata<br><a href="https://github.com/rbuckton/reflect-metadata" target="_blank" rel="noopener">https://github.com/rbuckton/reflect-metadata</a><ul><li><a href="https://dev.to/svehla/why-reflect-metadata-suc-s-5fal" target="_blank" rel="noopener">Why reflect-metadata suc*s</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/decorators.html" target="_blank" rel="noopener">Typescript Experimental Decorator</a></li><li><a href="https://medium.com/jspoint/introduction-to-reflect-metadata-package-and-its-ecmascript-proposal-8798405d7d88" target="_blank" rel="noopener">Introduction to “reflect-metadata” package and its ECMAScript proposal</a></li></ul></li><li>DI 实现<br><a href="https://github.com/inversify/InversifyJS" target="_blank" rel="noopener">https://github.com/inversify/InversifyJS</a><br><a href="https://github.com/microsoft/tsyringe" target="_blank" rel="noopener">https://github.com/microsoft/tsyringe</a><br><a href="https://github.com/midwayjs/injection" target="_blank" rel="noopener">https://github.com/midwayjs/injection</a><br><a href="https://github.com/jeffijoe/awilix" target="_blank" rel="noopener">https://github.com/jeffijoe/awilix</a><br><a href="https://github.com/typestack/typedi" target="_blank" rel="noopener">https://github.com/typestack/typedi</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/decorator-2/Untitled.jpeg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.notion.so/Javascript
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>全新 Javascript 装饰器实战上篇：用 MobX 的方式打开 Vue</title>
    <link href="https://bobi.ink/2023/06/26/decorator/"/>
    <id>https://bobi.ink/2023/06/26/decorator/</id>
    <published>2023-06-25T16:00:00.000Z</published>
    <updated>2023-06-30T08:35:21.851Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/decorator/Untitled.jpeg" alt="cover"></p><p>去年三月份<a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noopener">装饰器提案</a>进入了 Stage 3 阶段，而今年三月份 Typescript 在 5.0 也正式支持了 <a href="https://github.com/tc39/proposal-decorators/tree/8ca65c046dd5e9aa3846a1fe5df343a6f7efd9f8" target="_blank" rel="noopener"></a>。装饰器提案距离正式的语言标准，只差临门一脚。</p><p>这也意味着旧版的装饰器(Stage 1) 将逐渐退出历史舞台。然而旧版的装饰器已经被广泛的使用，比如 MobX、Angular、NestJS… 未来较长的一段时间内，都会是新旧并存的局面。</p><p><br></p><p>本文将把装饰器语法带到 <code>Vue Reactivity API</code> 中，让我们可以像 MobX 一样，使用类来定义数据模型, 例如:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Counter &#123;</span><br><span class="line">  @observable</span><br><span class="line">  count = 1</span><br><span class="line"></span><br><span class="line">  @computed</span><br><span class="line">  get double() &#123;</span><br><span class="line">    return this.count * 2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add = () =&gt; &#123;</span><br><span class="line">    this.count++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>在这个过程中，我们可以体会到新旧装饰器版本之间的差异和实践中的各种陷阱。</p><p><br><br><br></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="/images/decorator/Untitled.png" alt="思维导图"></p><p>关于装饰器的主要 API 都在上述思维导图中，除此之外，读者可以通过下文「扩展阅读」中提及的链接来深入了解它们。</p><p><br><br><br></p><h2 id="legacy"><a href="#legacy" class="headerlink" title="Legacy"></a>Legacy</h2><p>首先，我们使用旧的装饰器来实现相关的功能。</p><p>在 Typescript 下，需要通过 <code>experimentalDecorators</code> 来启用装饰器语法:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;experimentalDecorators&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用 Babel 7 ，配置大概如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    [&quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;version&quot;: &quot;legacy&quot; &#125;]</span><br><span class="line">    [&quot;@babel/plugin-transform-class-properties&quot;, &#123;&quot;loose&quot;: true &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="observable"><a href="#observable" class="headerlink" title="@observable"></a>@observable</h3><p>我们先来实现 <code>@observable</code> 装饰器，它只能作用于「<code>类属性成员</code>」，比如:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Counter &#123;</span><br><span class="line">  @observable</span><br><span class="line">  count = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const counter = new Counter()</span><br><span class="line">expect(counter.count).toBe(1)</span><br></pre></td></tr></table></figure><p>属性值可以是<code>原始类型</code>或者<code>对象类型</code>，没有限制。</p><p>为了让 Vue 的视图可以响应它的变化，我们可以使用 <code>ref</code> 来包装它。<code>ref</code> 刚好符合我们的需求，可以放置原始类型，也可以是对象, <code>ref</code> 会将其包装为 <code>reactive</code> 。</p><p><br></p><p>初步实现如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const observable: PropertyDecorator = function (target, propertyKey) &#123;</span><br><span class="line">  if (typeof target === &apos;function&apos;) &#123;</span><br><span class="line">    throw new Error(&apos;Observable cannot be used on static properties&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (arguments.length &gt; 2 &amp;&amp; arguments[2] != null) &#123;</span><br><span class="line">    throw new Error(&apos;Observable cannot be used on methods&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const accessor: Initializer = (self) =&gt; &#123;</span><br><span class="line">    const value = ref()</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        return unref(value)</span><br><span class="line">      &#125;,</span><br><span class="line">      set(val) &#123;</span><br><span class="line">        value.value = val</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 定义getter /setter 长远</span><br><span class="line">  Object.defineProperty(target, propertyKey, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get: function () &#123;</span><br><span class="line">      // 惰性初始化</span><br><span class="line">      return initialIfNeed(this, propertyKey, accessor).get()</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function (value) &#123;</span><br><span class="line">      initialIfNeed(this, propertyKey, accessor).set(value)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下上面的代码：</p><ul><li>将装饰器的类型设置为 <code>PropertyDecorator</code>。<blockquote><p>📢 对应的类型还有： ClassDecorator、MethodDecorator、ParameterDecorator<br><br></p><p>⚠️ 旧版<em>装饰器使用位置上 Typescript 并没作类型检查，装饰器可以随意用在类、方法、属性各种位置上</em>。<br><br></p></blockquote></li><li>可以通过 <code>target</code> 的类型，来判断装饰器作用于<code>静态成员</code>上还是<code>实例成员</code>上。如果是静态成员，target 是类本身；如果是实例成员，target 为类的<code>原型对象(prototype)</code></li><li><p><code>属性装饰器</code>只会接收两个参数：类和属性名。因为属性在构造函数中创建, 在类定义阶段，获取不到更多信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  foo = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// transpile to</span><br><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.foo = 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们定义了一个新的 <code>getter</code>/<code>setter</code> 成员, 这样外部才能透明地使用 ref, 不需要加上 <code>.value</code> 后缀</p></li><li><p><code>惰性初始化</code> ref。旧版的装饰器并没有提供 <code>addInitializer</code> 这样的初始化钩子，我们曲线救国，使用惰性初始化的方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const REACTIVE_CACHE = Symbol(&apos;reactive_cache&apos;)</span><br><span class="line">export interface ReactiveAccessor &#123;</span><br><span class="line">  get(): any</span><br><span class="line">  set(value: any): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getReactiveCache(target: any): Record&lt;string | symbol, any&gt; &#123;</span><br><span class="line">  if (!hasProp(target, REACTIVE_CACHE)) &#123;</span><br><span class="line">    addHiddenProp(target, REACTIVE_CACHE, &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return target[REACTIVE_CACHE]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export type Initializer = (target: any) =&gt; ReactiveAccessor</span><br><span class="line"></span><br><span class="line">export function initialIfNeed(target: any, key: string | symbol, initializer: Initializer) &#123;</span><br><span class="line">  const cache = getReactiveCache(target)</span><br><span class="line">  // 如果属性未定义，就执行初始化</span><br><span class="line">  if (!hasProp(cache, key)) &#123;</span><br><span class="line">    cache[key] = initializer(target)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return cache[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>这里我们将信息缓存在 REACTIVE_CACHE 字段中，实现惰性初始化。</code></pre></li></ul><p><br><br><br><br><br></p><p>写个单元测试看看:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test(&apos;base type&apos;, () =&gt; &#123;</span><br><span class="line">  class A &#123;</span><br><span class="line">    @observable</span><br><span class="line">    str = &apos;str&apos;</span><br><span class="line"></span><br><span class="line">    @observable</span><br><span class="line">    num = 1</span><br><span class="line"></span><br><span class="line">    @observable</span><br><span class="line">    withoutInitialValue: any</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const a = new A()</span><br><span class="line"></span><br><span class="line">  let str</span><br><span class="line">  let num</span><br><span class="line">  let withoutInitialValue</span><br><span class="line">  // 🔴 初始值应该正常被设置</span><br><span class="line">  expect(a.str).toBe(&apos;str&apos;)</span><br><span class="line">  expect(a.num).toBe(1)</span><br><span class="line">  expect(a.withoutInitialValue).toBe(undefined)</span><br><span class="line"></span><br><span class="line">  // 🔴 属性的变动应该被检测</span><br><span class="line">  watchSyncEffect(() =&gt; &#123;</span><br><span class="line">    str = a.str</span><br><span class="line">  &#125;)</span><br><span class="line">  watchSyncEffect(() =&gt; &#123;</span><br><span class="line">    num = a.num</span><br><span class="line">  &#125;)</span><br><span class="line">  watchSyncEffect(() =&gt; &#123;</span><br><span class="line">    withoutInitialValue = a.withoutInitialValue</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  a.str = &apos;new str&apos;</span><br><span class="line">  a.num = 2</span><br><span class="line">  a.withoutInitialValue = &apos;withoutInitialValue&apos;</span><br><span class="line"></span><br><span class="line">  expect(str).toBe(&apos;new str&apos;)</span><br><span class="line">  expect(num).toBe(2)</span><br><span class="line">  expect(withoutInitialValue).toBe(&apos;withoutInitialValue&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>💥 在较新的构建工具中(比如 vite)，上述的测试大概率无法通过！为什么？</p><p><br></p><p><strong>经过调试会发现我们在 observable 中的 <code>defineProperty</code> 并没有生效？</strong></p><p><br><br><br></p><p>通过阅读 Vite 的文档可以找到一些线索，即 Typescript 的 <code>[useDefineForClassFields](https://cn.vitejs.dev/guide/features.html#usedefineforclassfields)</code>:</p><blockquote><p>从 Vite v2.5.0 开始，如果 TypeScript 的 target 是  <code>ESNext</code>  或  <code>ES2022</code>  及更新版本，此选项默认值则为  <code>true</code>。这与  <strong><code>[tsc</code> v4.3.2 及以后版本的行为](<a href="https://github.com/microsoft/TypeScript/pull/42663" target="_blank" rel="noopener">https://github.com/microsoft/TypeScript/pull/42663</a>)</strong>  一致。这也是标准的 ECMAScript 的运行时行为</p></blockquote><p><br></p><p><code>useDefineForClassFields</code> 会改变<code>类实例属性</code>的定义方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  foo = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 旧</span><br><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.foo = 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 新：useDefineForClassFields</span><br><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    Object.defineProperty(this, &apos;foo&apos;, &#123;</span><br><span class="line">      enumerable: true,</span><br><span class="line">      configurable: true,</span><br><span class="line">      writable: true,</span><br><span class="line">      value: 1,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是为什么我们装饰器内的 <code>defineProperty</code> 无法生效的原因。</p><p><br><br><br></p><p>解决办法：</p><p>方法 1： 显式关闭掉 useDefineForClassFields。如果是 Babel 需要配置 <code>@babel/plugin-transform-class-properties</code> 的 <code>loose</code> 为 true：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    [&quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;version&quot;: &quot;legacy&quot; &#125;]</span><br><span class="line">    [&quot;@babel/plugin-transform-class-properties&quot;, &#123;&quot;loose&quot;: true &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>方法 2： 或者模仿 <a href="https://www.mobxjs.com/enabling-decorators" target="_blank" rel="noopener">MobX V6</a> 的 API:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TodoList &#123;</span><br><span class="line">  @observable todos = []</span><br><span class="line"></span><br><span class="line">  @computed</span><br><span class="line">  get unfinishedTodoCount() &#123;</span><br><span class="line">    return this.todos.filter((todo) =&gt; !todo.finished).length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    makeObservable(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MobX 的 observable、computed 等装饰器只是收集了一些<strong><code>标记信息</code>，</strong> 本身不会对类进行转换，真正进行转换是在 <code>makeObservable</code> 中进行的， 而 <code>makeObservable</code> 的执行时机是在所有属性都初始化完毕之后。</p><p>由于本文只关注装饰器的能力，这里就不展开了，有兴趣的读者可以看下 MobX 的源码。</p><p><br><br><br><br><br></p><h3 id="computed"><a href="#computed" class="headerlink" title="@computed"></a>@computed</h3><p>按照同样的方法，我们来实现一下 <code>@computed</code> 装饰器，MobX 的 computed 和 Vue 的 computed 概念基本一致，就是用来做衍生数据的计算。</p><p><br></p><p>@computed 只能应用在 <code>getter</code> 上面:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const computed: MethodDecorator = function (target, propertyKey, descriptor) &#123;</span><br><span class="line">  // 不支持 static</span><br><span class="line">  if (typeof target === &apos;function&apos;) &#123;</span><br><span class="line">    throw new Error(&apos;computed cannot be used on static member&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 必须是 getter</span><br><span class="line">  if (</span><br><span class="line">    descriptor == null ||</span><br><span class="line">    typeof descriptor !== &apos;object&apos; ||</span><br><span class="line">    typeof descriptor.get !== &apos;function&apos;</span><br><span class="line">  ) &#123;</span><br><span class="line">    throw new Error(&apos;computed can only be used on getter&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const initialGetter = descriptor.get</span><br><span class="line">  const accessor: Initializer = (self) =&gt; &#123;</span><br><span class="line">    const value = vueComputed(() =&gt; initialGetter.call(self))</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        return unref(value)</span><br><span class="line">      &#125;,</span><br><span class="line">      set() &#123;</span><br><span class="line">        // readonly</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  descriptor.get = function () &#123;</span><br><span class="line">    // 惰性初始化</span><br><span class="line">    return initialIfNeed(this, propertyKey, accessor).get()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>getter/setter/method 装饰器的用法一致。会接收 <code>descriptor</code> 作为第三个参数，我们可以对 <code>descriptor</code> 进行修改，或者返回一个新的 <code>descriptor</code>。</li><li>我们使用 vue 的 computed API 对 getter 函数进行简单包装。</li></ul><p><br><br><br></p><p>测试一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test(&apos;computed&apos;, () =&gt; &#123;</span><br><span class="line">  const count = ref(0)</span><br><span class="line">  class A &#123;</span><br><span class="line">    @computed</span><br><span class="line">    get double() &#123;</span><br><span class="line">      return count.value * 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const a = new A()</span><br><span class="line">  let value</span><br><span class="line">  watchSyncEffect(() =&gt; &#123;</span><br><span class="line">    value = a.double</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  expect(value).toBe(0)</span><br><span class="line">  count.value++</span><br><span class="line">  expect(value).toBe(2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Ok, 没问题，可以正常运行。我们配合组件的实际场景再测试看看：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test(&apos;render&apos;, () =&gt; &#123;</span><br><span class="line">  class A &#123;</span><br><span class="line">    @observable</span><br><span class="line">    count = 1</span><br><span class="line"></span><br><span class="line">    @computed</span><br><span class="line">    get double() &#123;</span><br><span class="line">      return this.count * 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let count</span><br><span class="line">  const a = new A()</span><br><span class="line"></span><br><span class="line">  const Comp = defineComponent(&#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">      watchSyncEffect(() =&gt; &#123;</span><br><span class="line">        count = a.double</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      return () =&gt; &#123;</span><br><span class="line">        /* ignore */</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  const &#123; unmount &#125; = render(Comp)</span><br><span class="line"></span><br><span class="line">  let count2</span><br><span class="line">  watchSyncEffect(() =&gt; &#123;</span><br><span class="line">    count2 = a.double</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  expect(count).toBe(2)</span><br><span class="line">  expect(count2).toBe(2)</span><br><span class="line"></span><br><span class="line">  a.count++</span><br><span class="line">  expect(count).toBe(4)</span><br><span class="line">  expect(count2).toBe(4)</span><br><span class="line"></span><br><span class="line">  // 🔴 卸载</span><br><span class="line">  unmount()</span><br><span class="line"></span><br><span class="line">  a.count++</span><br><span class="line">  expect(count).toBe(4)</span><br><span class="line">  // 💥 received 4</span><br><span class="line">  expect(count2).toBe(6)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>上面的用例没有通过，<strong>在组件卸载之后，@computed 装饰的 double 就失去了响应性</strong>。Why?</p><p><br><br><br></p><p>解决这个问题之前，我们需要了解一下 <code>[effectScope](https://cn.vuejs.org/api/reactivity-advanced.html#effectscope)</code>, <code>effectScope</code> 创建一个 <code>effect 作用域</code>，可以捕获其中所创建的响应式副作用 (即计算属性和侦听器)，这样捕获到的副作用可以一起处理和销毁。</p><p><br></p><p><strong>Vue <code>setup</code> 就是包装在 effectScope 之下，如果我们的 computed 在 setup 下被初始化，就会被 setup 捕获，当组件卸载时就会被随之清理掉</strong>。</p><p><br></p><p>我们的 <code>@computed</code> 是为全局作用域设计的，不能因为某个组件卸载而被销毁掉。为了解决这个问题，我们需要自己构造一个独立的 <code>悬挂 effectScope</code> (<code>Detached effectScope</code> )：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">const accessor: Initializer = (self) =&gt; &#123;</span><br><span class="line"><span class="addition">+   // true 标记为 detached</span></span><br><span class="line"><span class="addition">+   const scope = effectScope(true)</span></span><br><span class="line"><span class="deletion">-   const value = vueComputed(() =&gt; initialGetter.call(self))</span></span><br><span class="line"><span class="addition">+   const value = scope.run(() =&gt; vueComputed(() =&gt; initialGetter.call(self)))</span></span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        return unref(value)</span><br><span class="line">      &#125;,</span><br><span class="line">      set() &#123;</span><br><span class="line">        // readonly</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>💡 watch 也会有相同的问题，读者可以自行尝试一下</p></blockquote><p><br></p><p>💥 <strong>会不会内存泄露？</strong>理论上会泄露，取决于被 computed 订阅的数据源。如果该订阅源长期未释放，可能会出现内存泄露。<br><br></p><p>解决办法是将对应的<code>类实例</code>和<code>组件</code>的生命周期绑定。当组件释放时，调用类实例的释放方法，例如：</p><p><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const providerStore = &lt;T,&gt;(store: new () =&gt; T): T =&gt; &#123;</span><br><span class="line">  const instance = new store()</span><br><span class="line">  // 将组件的 effectScope 传入实例中进行绑定</span><br><span class="line">  instance.__effect_scope__ = getCurrentScope()</span><br><span class="line">  return instance</span><br><span class="line">&#125;</span><br><span class="line">// computed 实现调整</span><br><span class="line">const scope = target.__effect_scope__ ?? effectScope(true)</span><br><span class="line">// 在 setup 中调用</span><br><span class="line">const store = providerStore(Store)</span><br></pre></td></tr></table></figure><p><br><br>比如 <code>全局Store</code> 可以和 <code>Vue App</code> 绑定，<code>页面 Store</code> 可以和<code>页面组件</code>绑定。<br><br><br>🔴 <strong>MobX computed 并没有该问题，MobX 的 computed 在<code>订阅者</code>清空时，会「<code>挂起</code>(suspend)」，清空自己的<code>订阅</code>(除非显式设置了 keepAlive)，从而可以规避这种内存泄露。详见<a href="https://github.com/mobxjs/mobx/blob/27efa3cc637e3195589874990c23d4de82c12072/packages/mobx/src/core/observable.ts%23L124" target="_blank" rel="noopener">这里</a>。<br>只能看后续 Vue 官方是否也作类似的支持了。</strong></p><p><br><br><br></p><hr><p><br><br><br></p><h2 id="new"><a href="#new" class="headerlink" title="New"></a>New</h2><p>2022/3 装饰器议案正式进入 Stage 3 阶段，按照惯例，Typescript 也在 5.0 版本加入了该功能。</p><p>新版装饰器外形如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Decorator = (</span><br><span class="line">  value: Input,</span><br><span class="line">  context: &#123;</span><br><span class="line">    kind: string</span><br><span class="line">    name: string | symbol</span><br><span class="line">    access: &#123;</span><br><span class="line">      get?(): unknown</span><br><span class="line">      set?(value: unknown): void</span><br><span class="line">    &#125;</span><br><span class="line">    private?: boolean</span><br><span class="line">    static?: boolean</span><br><span class="line">    addInitializer?(initializer: () =&gt; void): void</span><br><span class="line">  &#125;</span><br><span class="line">) =&gt; Output | void</span><br></pre></td></tr></table></figure><p><br></p><p>相比旧版的装饰器，新版的 API 形式上更加统一了，并且提供了一些上下文信息，对于开发者来说更加便利。</p><p><br><br><br></p><p>核心的变化如下：</p><ul><li><p>形式上更加统一，不管是什么位置，都遵循 <code>(value, context) ⇒ output | void</code>， 这个心智上更接近<code>管道(pipe)</code>, 接收一个 Value , 可以返回一个新的 Value 来<strong>替换旧的 Value</strong>。<br><img src="/images/decorator/Untitled%201.png" alt="linux 管道"><br>linux 管道</p><p><br></p></li><li><p><code>context</code> 提供了必要的上下文信息，对开发者来说更加便利，可以快速判断装饰器的类型、是否为静态属性、私有属性等等。</p></li><li><p>更倾向于将装饰器当做一个纯函数(管道、转换器)来使用，尽量不包含副作用(比如修改类的结构)。</p><p><br></p><p><strong>为了限制副作用，装饰器基本上屏蔽了一些底层细节，比如 descriptor，构造函数、原型对象，这些在新的装饰器中基本拿不到。</strong></p><p><br></p><p>副作用只能在 <code>context.addInitializer</code> 中调用，但是能力也非常有限。就拿<code>属性装饰器</code>来举例，initializer 通常在 class 内置的 defineProperty 之前调用，如果你在 <code>initializer</code> 中使用了 <code>defineProperty</code>，那么将被覆盖:</p><p>以 Typescript 的编译结果为例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Bar &#123;</span><br><span class="line">  @d</span><br><span class="line">  foo = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 编译结果：</span><br><span class="line">let Bar = (() =&gt; &#123;</span><br><span class="line">    var _a;</span><br><span class="line">    let _instanceExtraInitializers_1 = [];</span><br><span class="line">    let _foo_decorators;</span><br><span class="line">    let _foo_initializers = [];</span><br><span class="line">    return _a = class Bar &#123;</span><br><span class="line">            constructor() &#123;</span><br><span class="line">                // 🔴 ③ 定义属性</span><br><span class="line">                Object.defineProperty(this, &quot;foo&quot;, &#123;</span><br><span class="line">                    enumerable: true,</span><br><span class="line">                    configurable: true,</span><br><span class="line">                    writable: true,</span><br><span class="line">                    value:</span><br><span class="line">                      // 🔴 ① 先执行其他装饰器的 addInitializer 回调</span><br><span class="line">                      (__runInitializers(this, _instanceExtraInitializers_1),</span><br><span class="line">                        // 🔴 ② 属性装饰器的 initializer</span><br><span class="line">                        __runInitializers(this, _foo_initializers, 1))</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        (() =&gt; &#123;</span><br><span class="line">            _foo_decorators = [d];</span><br><span class="line">            __esDecorate(null, null, _foo_decorators, &#123; kind: &quot;field&quot;, name: &quot;foo&quot;, static: false, private: false, access: &#123; has: obj =&gt; &quot;foo&quot; in obj, get: obj =&gt; obj.foo, set: (obj, value) =&gt; &#123; obj.foo = value; &#125; &#125; &#125;, _foo_initializers, _instanceExtraInitializers_1);</span><br><span class="line">        &#125;)(),</span><br><span class="line">        _a;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><p>这样做的好处，笔者认为主要有以下几点:</p><ul><li>性能优化：旧版的装饰器可以对 class 进行魔改，这就导致了引擎在解析完 Class 体后再去执行装饰器时，最终的 Class 结构可能发生较大的改变，导致引擎的优化无法生效（来源：<a href="https://developer.aliyun.com/article/892441" target="_blank" rel="noopener">ECMAScript 双月报告：装饰器提案进入 Stage 3</a>）。</li><li>因为旧版可能会对类的结构进行破坏性魔改，这种副作用可能导致多个装饰器组合时，有难以预期的问题。</li><li>更容易测试</li></ul><p><br></p><p><strong>另外 Typescript 针对新的装饰器也提供了更严格的类型检查，比如可以约束装饰器使用的位置，旧版可以使用在任意位置，只能通过运行时进行检查</strong>。</p><p><img src="/images/decorator/Untitled%202.png" alt="Typescript 为新版装饰器提供了更严格的类型检查"></p><p>Typescript 为新版装饰器提供了更严格的类型检查</p><p><br></p><blockquote><p>💡  目前装饰器还未成为正式的语言特性，不排除后面还有特性变更。</p></blockquote><p><br></p><blockquote><p>💡  截止至文章发布的时间，Vite 使用新版装饰器还有一些问题。本文使用 Babel + Jest 来测试相关代码。</p></blockquote><p><br><br><br><br><br></p><h3 id="observable-1"><a href="#observable-1" class="headerlink" title="@observable"></a>@observable</h3><p>新版的<code>属性装饰器</code> API 如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type ClassFieldDecorator = (</span><br><span class="line">  value: undefined,</span><br><span class="line">  context: &#123;</span><br><span class="line">    kind: &apos;field&apos;</span><br><span class="line">    name: string | symbol</span><br><span class="line">    access: &#123; get(): unknown; set(value: unknown): void &#125;</span><br><span class="line">    static: boolean</span><br><span class="line">    private: boolean</span><br><span class="line">  &#125;</span><br><span class="line">) =&gt; (initialValue: unknown) =&gt; unknown | void</span><br></pre></td></tr></table></figure><ul><li>value 始终为 undefined，因为属性在类定义时不存在，无法获取到初始值</li><li>context 没有 <code>addInitializer</code> 。属性装饰器的返回值是一个函数，这个实际上就是一个 <code>initializer</code></li><li>访问不到类和类的原型</li><li>在 initializer 中也不能调用 defineProperty。原因见上文</li></ul><p>也就是说，<strong>属性装饰器基本上堵死了我们去改造属性的机会</strong>…</p><p><br><br><br></p><hr><p><br></p><p>且慢，跟随装饰器发布的还有一个<code>自动访问器</code>(Auto Accessor)的特性(🙂  越来越像 Java、C# 了）</p><p>自动访问器使用 <code>accessor</code> 关键字定义：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">  accessor x = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">  #x = 1</span><br><span class="line"></span><br><span class="line">  get x() &#123;</span><br><span class="line">    return this.#x</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set x(val) &#123;</span><br><span class="line">    this.#x = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这有啥用？稍安勿躁，它在装饰器场景有大用，先来看下它的 API:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type ClassAutoAccessorDecorator = (</span><br><span class="line">  value: &#123;</span><br><span class="line">    get: () =&gt; unknown;</span><br><span class="line">    set(value: unknown) =&gt; void;</span><br><span class="line">  &#125;,</span><br><span class="line">  context: &#123;</span><br><span class="line">    kind: &quot;accessor&quot;;</span><br><span class="line">    name: string | symbol;</span><br><span class="line">    access: &#123; get(): unknown, set(value: unknown): void &#125;;</span><br><span class="line">    static: boolean;</span><br><span class="line">    private: boolean;</span><br><span class="line">    addInitializer(initializer: () =&gt; void): void;</span><br><span class="line">  &#125;</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  get?: () =&gt; unknown;</span><br><span class="line">  set?: (value: unknown) =&gt; void;</span><br><span class="line">  init?: (initialValue: unknown) =&gt; unknown;</span><br><span class="line">&#125; | void;</span><br></pre></td></tr></table></figure><ul><li>value 接收 getter 和 setter</li><li>可以返回新的 getter 和 setter</li><li>init 可以对初始值进行<strong>_转换_</strong>。</li></ul><p><br><br><br></p><p>它的妙用在于，我们可以「兵不血刃」(不改变结构或者新增属性)地实现拦截，看看我们 observable 的实现就知道了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function observable&lt;This, Value&gt;(</span><br><span class="line">  value: ClassAccessorDecoratorTarget&lt;This, Value&gt;,</span><br><span class="line">  context: ClassAccessorDecoratorContext&lt;This, Value&gt;</span><br><span class="line">): ClassAccessorDecoratorResult&lt;This, Value&gt; | void &#123;</span><br><span class="line">  if (context.kind !== &apos;accessor&apos;) &#123;</span><br><span class="line">    throw new Error(&apos;observable can only be used on accessor&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (context.static) &#123;</span><br><span class="line">    throw new Error(&apos;observable can not be used on static accessor&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    init(val) &#123;</span><br><span class="line">      return ref(val)</span><br><span class="line">    &#125;</span><br><span class="line">    get() &#123;</span><br><span class="line">      return (value.get.call(this) as Ref&lt;Value&gt;).value</span><br><span class="line">    &#125;,</span><br><span class="line">    set(val) &#123;</span><br><span class="line">      const ref = value.get.call(this) as Ref&lt;Value&gt;</span><br><span class="line"></span><br><span class="line">      ref.value = val</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>通过 <code>context</code>，我们可以更方便地判断是否是静态成员、是否装饰在预期的位置</li><li>上述代码我们没有修改任何类的结构、新增任何属性。我们直接在 init 中将初始值转换为 ref, 相对应的 getter/setter 也作简单的改造。</li></ul><p><br></p><p>很简单是不是？只不过，这个对已有的代码倾入性太大了，所有相关的属性都需要修改为 <code>accessor</code>, 但对于 API 使用者来说没什么区别：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  @observable</span><br><span class="line">  accessor obj = &#123;</span><br><span class="line">    count: 1,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="computed-1"><a href="#computed-1" class="headerlink" title="@computed"></a>@computed</h3><p>Getter 装饰器和 Setter、Method 装饰器类型基本一致：</p><p><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type ClassGetterDecorator = (</span><br><span class="line">  value: Function,</span><br><span class="line">  context: &#123;</span><br><span class="line">    kind: &apos;getter&apos;</span><br><span class="line">    name: string | symbol</span><br><span class="line">    access: &#123; get(): unknown &#125;</span><br><span class="line">    static: boolean</span><br><span class="line">    private: boolean</span><br><span class="line">    addInitializer(initializer: () =&gt; void): void</span><br><span class="line">  &#125;</span><br><span class="line">) =&gt; Function | void</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>直接来看 computed 实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function computed&lt;This, Return, Value extends () =&gt; Return&gt;(</span><br><span class="line">  value: Value,</span><br><span class="line">  context: ClassGetterDecoratorContext&lt;This, Return&gt;</span><br><span class="line">): Value | void &#123;</span><br><span class="line">  if (context.static) &#123;</span><br><span class="line">    throw new Error(&apos;computed cannot be used on static member&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (context.kind !== &apos;getter&apos;) &#123;</span><br><span class="line">    throw new Error(&apos;computed can only be used on getter&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  context.addInitializer(function (this: unknown) &#123;</span><br><span class="line">    const scope = effectScope(true)</span><br><span class="line"></span><br><span class="line">    const val = scope.run(() =&gt; vueComputed(() =&gt; value.call(this)))</span><br><span class="line"></span><br><span class="line">    Object.defineProperty(this, context.name, &#123;</span><br><span class="line">      configurable: true,</span><br><span class="line">      enumerable: false,</span><br><span class="line">      get() &#123;</span><br><span class="line">        return unref(val)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>通过 <code>addInitializer</code> 来添加初始化逻辑(副作用)， this 为当前类的实例。旧版的装饰器并没有提供类似的时机，我们只能通过<code>惰性初始化</code>去模拟这种效果。</p><p><br></p><p>不过上面的程序也有个潜在的 BUG, 我们在新建一个 log 装饰器，组合在一起看看：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function log(value: Function, context: ClassGetterDecoratorContext) &#123;</span><br><span class="line">  return function (this: unknown) &#123;</span><br><span class="line">    console.log(&apos;start calling...&apos;)</span><br><span class="line">    return value.apply(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">  @observable</span><br><span class="line">  accessor count = 1</span><br><span class="line"></span><br><span class="line">  @log</span><br><span class="line">  @computed</span><br><span class="line">  get double() &#123;</span><br><span class="line">    return this.count * 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，我们会发现并没有打印 <code>start calling...</code> 邪恶的副作用…</p><p><br><br><br></p><p>主要原因是上述代码我们在 <code>addInitializer</code> 中引用的 ‘value’ 是类原始的 getter 值，而我们又重新用 defineProperty 覆盖了属性，导致 @log 装饰的值丢失了。</p><p><br></p><p>实际上在新版的装饰器中，更符合规范的用法是：<strong>返回新的值来替换旧的值</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const COMPUTED_CACHE: unique symbol = Symbol(&apos;computed_cache&apos;)</span><br><span class="line"></span><br><span class="line">export function computed&lt;This, Return, Value extends () =&gt; Return&gt;(</span><br><span class="line">  value: Value,</span><br><span class="line">  context: ClassGetterDecoratorContext&lt;This, Return&gt;</span><br><span class="line">): Value | void &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  // 🔴 初始化缓存对象</span><br><span class="line">  context.addInitializer(function (this: unknown) &#123;</span><br><span class="line">    if (!Object.prototype.hasOwnProperty.call(this, COMPUTED_CACHE)) &#123;</span><br><span class="line">      Object.defineProperty(this, COMPUTED_CACHE, &#123;</span><br><span class="line">        configurable: true,</span><br><span class="line">        enumerable: false,</span><br><span class="line">        value: new Map(),</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return function (this: Object) &#123;</span><br><span class="line">    const cache = this[COMPUTED_CACHE] as Map&lt;string | symbol, Ref&lt;Return&gt;&gt;</span><br><span class="line">    if (!cache.has(context.name)) &#123;</span><br><span class="line">      // 🔴 惰性初始化</span><br><span class="line">      const scope = effectScope(true)</span><br><span class="line"></span><br><span class="line">      const val = scope.run(() =&gt; vueComputed(() =&gt; value.call(this)))!</span><br><span class="line"></span><br><span class="line">      cache.set(context.name, val)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return unref(cache.get(context.name))</span><br><span class="line">  &#125; as Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>上面的代码中，我们返回的新的函数来取代原有的 <code>getter</code>，另外在 <code>addInitializer</code> 中初始化缓存属性。我们建议在 <code>addInitializer</code> 中一次性将需要的属性都初始化完毕，避免在 getter 中动态去添加新的属性，<a href="https://mathiasbynens.be/notes/shapes-ics" target="_blank" rel="noopener">利好 JavaScript 引擎的优化</a>。</p><p><br></p><p>这样做的好处是更符合新版装饰器的心智和设计意图，也可以保证装饰器按照组合的顺序调用。</p><p><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要详细对比了新版和旧版的装饰器差异，通过实战将装饰器的能力和陷阱挖掘出来。</p><p><br></p><p>总得来说，新版的装饰器更加统一直观、更容易入手，在能力上也克制地收敛了。不过目前社区上大量的库和框架还停留在 Stage 1 装饰器，升级和改造需要较大的成本，我们可以暂时观望观望。</p><p><br></p><p>下一步：装饰器比较复杂的应用是依赖注入，当前的依赖注入库都深度依赖 <code>reflect-metadata</code> 来实现。而 <a href="https://github.com/tc39/proposal-decorator-metadata?spm=a2c6h.12873639.article-detail.8.68bd13c4Dt6Qt7" target="_blank" rel="noopener">Decorator Metadata</a> 目前也进入了 Stage 3 阶段，很快就会和我们见面(Typescript 5.2)，届时我们再聊聊如何实现依赖注入(🐶 看你们的点赞)。</p><p><br><br><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><strong><a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noopener">proposal-decorators</a></strong></li><li><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html" target="_blank" rel="noopener">Typescript 5.0</a> 发布日志</li><li><a href="https://mp.weixin.qq.com/s/QnWez2sEWuL8j8GVDmBNTA" target="_blank" rel="noopener">TypeScript 5.0 将支持全新的装饰器写法！</a></li><li><a href="https://developer.aliyun.com/article/892441" target="_blank" rel="noopener">ECMAScript 双月报告：装饰器提案进入 Stage 3</a></li><li><a href="https://cn.vitejs.dev/guide/features.html#usedefineforclassfields" target="_blank" rel="noopener">vite typescript <code>useDefineForClassFields</code></a></li><li><a href="https://babeljs.io/docs/babel-plugin-proposal-decorators" target="_blank" rel="noopener">@babel/plugin-proposal-decorators</a></li><li>Javascript 引擎优化机制:<ul><li><a href="https://mathiasbynens.be/notes/shapes-ics" target="_blank" rel="noopener">JavaScript engine fundamentals: Shapes and Inline Caches</a></li><li><a href="https://mathiasbynens.be/notes/prototypes" target="_blank" rel="noopener">JavaScript engine fundamentals: optimizing prototypes</a></li></ul></li><li><a href="https://cn.mobx.js.org/refguide/action.html" target="_blank" rel="noopener">MobX</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/decorator/Untitled.jpeg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;去年三月份&lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的快乐与苦恼</title>
    <link href="https://bobi.ink/2023/06/21/happiness/"/>
    <id>https://bobi.ink/2023/06/21/happiness/</id>
    <published>2023-06-20T16:00:00.000Z</published>
    <updated>2023-06-21T10:28:32.450Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/happiness/Untitled.jpeg" alt="Universe"></p><blockquote><p>“<strong>我们朝九晚五上班下班，就是为了有朝一日去探索宇宙的</strong>”<br>    —— 宇宙探索编辑部</p></blockquote><p>随着大环境的下行，互联网行业也受到一定的冲击，哀鸿遍野。</p><p>笔者也没有幸免，培养起来的人马陆续被优化，留下一丢光杆司令，我也回到的业务一线，心里很不是滋味。留下来的人，也不知道这艘船什么时候会沉没… 为了活命而拼命挣扎（内卷）</p><p>负面情绪和焦虑不停侵扰，以至于怀疑，当初选的这条路是不是正确的。</p><p>捡起买了多年，但是一直没看的<code>《人月神话》</code>,  开篇就讲了程序员这个职业的乐趣和苦恼，颇有共鸣，所以拿出来给大家分享</p><p>不管过去多少年，不管你的程序载体是纸带、还是 JavaScript，不管程序跑在高对比(high contract)的终端、还是 iPhone，程序员的快乐和烦恼并没有变化。</p><p>尽管国内软件行业看起来不是那么健康。我相信很多人真正热爱的是编程，而不仅仅是一份工作，就是那种纯粹的热爱。你有没有：</p><ul><li>为了修改一个 Bug，茶饭不思</li><li>为了一个 idea，可以凌晨爬起来，决战到天亮</li><li>我们享受没有人打扰的午后</li><li>梦想着参与到一个伟大的开源项目</li><li>有强烈的分享欲，希望我们的作品可以帮助到更多人, 希望能得到用户的反馈，即使是一个点赞</li><li>…</li></ul><p><br><br><br></p><h2 id="我们的快乐"><a href="#我们的快乐" class="headerlink" title="我们的快乐"></a>我们的快乐</h2><blockquote><p>《人月神话》：</p><p>首先，<strong>这种快乐是一种创建事物的纯粹快乐</strong>。如同小孩在玩泥巴时感到快乐一样，成年人喜欢创建事物，特别是自己进行设计。我想这种快乐是上帝创造世界的折射，一种呈现在每片独特的、崭新的树叶和雪花上的喜悦。<br><br><br>其次，<strong>这种快乐来自于开发对他人有用的东西</strong>。内心深处，我们期望我们的劳动成果能够被他人使用，并能对他们有所帮助。从这一角度而言，这同小孩用粘士为“爸爸的办公室”捏制铅笔盒没有任何本质的区别。<br><br><br>第三，<strong>快乐来自于整个过程体现出的一股强大的魅力——将相互啮合的零部件组装在一起，看到它们以精妙的方式运行着，并收到了预期的效果。</strong>比起弹球游戏机或自动电唱机所具有的迷人魅力，程序化的计算机毫不逊色。<br><br><br>第四，<strong>这种快乐是持续学习的快乐，它来自于这项工作的非重复特性</strong>。人们所面临的问题总有这样那样的不同，因而解决问题的人可以从中学习新的事物，有时是实践上的，有时是理论上的，或者兼而有之。<br><br><br>最后，<strong>这种快乐还来自于在易于驾驭的介质上工作</strong>。程序员，就像诗人一样，几乎仅仅在单纯的思考中工作。程序员凭空地运用自己的想象，来建造自己的“城堡”。很少有创造介质如此灵活，如此易于精炼和重建，如此容易实现概念上的设想(不过我们将会看到，容易驾驭的特性也有它自己的问题)。<br><br><br>然而程序毕竞同诗歌不同，它是实实在在的东西;它可以移动和运行，能独立产生可见的输出;它能打印结果，绘制图形，发出声音，移动支架。神话和传说中的魔术在我们的时代已变成现实。在键盘上键入正确的咒语，屏幕会活动、变幻，显示出前所未有的也不可能存在的事物。</p></blockquote><p><br></p><p>编程就是一种纯粹创造的快乐，而且它的成本很低，我们只需要一台电脑，一个趁手的编辑器，一段不被人打扰的整块时间，然后进入心流状态，脑海中的想法转换成屏幕上闪烁的字符。<br>这是多巴胺带给我们的快乐。</p><p><img src="/images/happiness/Untitled.png" alt="飞机引擎"></p><p><br><br><br></p><p>我们也有「<code>机械崇拜</code>」，软件不亚于传统的机械的复杂构造。 它远比外界想象的要复杂和苛刻，而我们享受将无数零部件有机组合起来，点击——成功运行的快感。</p><p>我们享受复杂的问题，被抽象、拆解成一个个简单的问题， 认真描绘分层的弧线以及每个模块轮廓，谨慎设计它的每个锯齿和接口。</p><p>我们崇尚有序，赞赏清晰的边界， 为的就是我们创造的世界能够稳定发展。</p><p><br></p><p>我们认为懒惰是我们的优点，我们也崇拜自动化，享受我们数据通过我们建设的管道在不同模块、系统或者机器中传递和加工；享受程序像多米诺骨牌一样，自动构建、测试、发布、部署、分发到每个用户的手中，优雅地跑起来。</p><p>因为懒，我们时常追求创造出能够取代自己的工具，让我们能腾出时间在新的世界探索。比如可以制造出我们的 <a href="https://baike.baidu.com/item/MOSS/23288071?fr=aladdin" target="_blank" rel="noopener">Moss</a>，帮我们治理让每个程序的生命周期，让它们优雅地死去又重生。</p><p><br></p><p>我们是一群乐于分享和学习的群体，有繁荣的技术社区、各种技术大会、技术群…</p><p>不管是分享还是编程本身，其实都是希望我们的作品能被其他人用到，能产生价值：</p><ul><li>我们都有开源梦，多少人梦想着能参与那些广为人知开源项目。很少有哪个行业，有这么一群人,  能够自我组织，用爱发电、完全透明地做出一个个伟大的作品。</li><li>我们总会怀揣着乐观的设想，基于这种设想，我们会趋向打造更完美的作品，想象未来各种高并发、极端的场景，我们的程序能够游刃有余。</li><li>我们总是不满足于现有的东西，乐于不停地改进，造出更多的轮子，甚至不惜代价推翻重来</li><li>我们更会懊恼，自己投入大量精力的项目，无人问津，甚至胎死腹中。</li></ul><p><br></p><p>看着它们，从简单到繁杂，这是一种迭代的快乐。</p><p><br><br><br><br><br></p><h2 id="我们的苦恼"><a href="#我们的苦恼" class="headerlink" title="我们的苦恼"></a>我们的苦恼</h2><blockquote><p>《人月神话》<br>然而这个过程并不全都是快乐的。我们只有事先了解一些编程固有的苦恼，这样，当它们真的出现时，才能更加坦然地面对。<br><br><br>首先，<strong>苦恼来自追求完美</strong>。因为计算机是以这样的方式来变戏法的: 如果咒语中的一个字符、一个停顿，没有与正确的形式一致，魔术就不会出现(现实中，很少有人类活动会要求如此完美，所以人类对它本来就不习惯)。实际上，我认为，学习编程最困难的部分，是将做事的方式向追求完美的方向调整”。</p><p><br><br>其次，<strong>苦恼来自由他人来设定目标、供给资源和提供信息</strong>。编程人员很少能控制工作环境和工作目标。用管理的术语来说，个人的权威和他所承担的责任是不相配的。不过，似乎在所有的领域中，对要完成的工作，很少能提供与责任相一致的正式权威。而现实情况中，实际(相对于形式)的权威来自于每次任务的完成。</p><p><strong>对于系统编程人员而言，对其他人的依赖是一件非常痛苦的事情</strong>。他依靠其他人的程序，而这些程序往往设计得并不合理、实现拙劣、发布不完整(没有源代码或测试用例)或者文档记录得很糟。所以，系统编程人员不得不花费时间去研究和修改，而它们在理想情况下本应该是可拿的、完整的。</p><p><br><br>下一个苦恼 —— <strong>概念性设计是有趣的，但寻找琐碎的bug却是一项重复性的活动</strong>。伴随着创造性活动的，往往是枯燥沉闷的时间和艰苦的劳动。程序编制工作也不例外。</p><p><br><br>另<strong>外，人们发现调试和查错往往是线性收敛的，或者更糟糕的是，具有二次方的复杂度</strong>。结果，测试一拖再拖，寻找最后一个错误比第一个错误将花费更多的时间。</p><p><br><br>最后一个苦恼，有时也是一种无奈 —— <strong>当投入了大量辛苦的劳动，产品在即将完成或者终于完成的时候，却己显得陈旧过时</strong>。可能是同事和竞争对手己在追逐新的、更好的构思;也许替代方案不仅仅是在构思，而且己经在安排了。<br><br></p></blockquote><p>前阵子读到了 @<a href="https://www.zhihu.com/people/doodlewind" target="_blank" rel="noopener">doodlewind</a> 的 <a href="https://zhuanlan.zhihu.com/p/595759878" target="_blank" rel="noopener">全职开源，出海创业：我的 2022</a>，说的是他 all in 去做 AFFiNE 。我眼里只有羡慕啊，能够找到 all in 的事业…</p><p><br><br><br></p><p>这些年 OKR 也很火，我们公司也跟风了一年; 后面又回到了 KPI，轰轰烈烈搞全员KPI, 抓着每个人,  要定自己的全年KPI;  后年裁员，KPI 就不再提起了…</p><p>这三个阶段的演变很有意思，第一个阶段，期望通过 OKR 上下打通，将目标捆在一起，让团队自己驱动自己。实际上实施起来很难，让团队和个人自我驱动起来并不是一件容易的事情，虽然用的是 OKR，但内核还是 KPI，或者说 OKR 变成了领导的 OKR。<br>后面就变成了 KPI, 限定团队要承担多少销售额，交付多少项目；<br>再后来 KPI 都没有了，换成要求每个人设定自己工作日历，不能空转，哪里项目缺资源，就调配到哪里，彻底沦为了人矿…</p><p>能让我们 all in 的事情，首先得是我们认同的事情，其次我们能在这件事情上深度参与和发挥价值，并获得预期的回报。这才能实现「自我驱动」</p><p>对于大部分人来说，很少有这种工作机会，唯一值得 all in的，恐怕就只有自己了。</p><p><br><br><br></p><p>所以程序员的苦恼很多，虽然编程是一个创造性的工作，但是我们的工作是由其他人来设定目标和提供资源的。</p><p>也就是说我们只不过是困在敏捷循环里面的一颗螺丝钉，每天在早会上机械复读着：昨天干了什么，今天要干什么。<br>企业总会想法设法量化我们的工作，最好是像流水线一样透明、可预测。</p><p><br></p><p>培训机构四个月就能将高中生打造成可以上岗敲代码的程序员。我们这个行业已经不存在我们想象中高门槛。程序员可能就是新时代的蓝领工人，如果我们的工作是重复的、可预见的，那本质上就没什么区别了。</p><hr><p><br></p><p>追求完美是好事，也是坏事。苛刻的编译器会提高开发的门槛，但同样可以降低我们犯错的概率。</p><p>计算机几乎不会犯错的，只是我们不懂它，而人经常会犯错。相比苛刻的计算机，人更加可怕：</p><ul><li>应付领导或产品拍脑袋的需求</li><li>接手屎山代码</li><li>浪费时间的会议</li><li>狼性文化</li><li>…</li></ul><p><br><br><br></p><hr><p><br></p><p>还有一个苦恼是技术的发展实在太快了，时尚的项目生命周期太短，而程序员又是一群喜新厌旧的群体。</p><p>比如在前端，可能两三年前的项目就可以被定义为”老古董”了，上下文切换到这种项目会比较痛苦。不幸的是，这些老古董可能会因为某些程序员的偏见，出现破窗效应，慢慢沦为屎山。</p><p>我们虽然苦恼于项目的腐败，而大多数情况我们也是推手。</p><p><br></p><p>我们还有很多苦恼：</p><ul><li>35 岁危机，继续做技术还是转管理</li><li>面试的八股文</li><li>内卷</li><li>被 AI 取代</li><li>…</li></ul><p><br><br><br></p><p>对于读者来说，是快乐多一些呢？还是苦恼多一些呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/happiness/Untitled.jpeg&quot; alt=&quot;Universe&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“&lt;strong&gt;我们朝九晚五上班下班，就是为了有朝一日去探索宇宙的&lt;/strong&gt;”&lt;br&gt;    —— 宇宙探
      
    
    </summary>
    
      <category term="程序人生" scheme="https://bobi.ink/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>前端如何破解 CRUD 的循环</title>
    <link href="https://bobi.ink/2023/06/16/crud/"/>
    <id>https://bobi.ink/2023/06/16/crud/</id>
    <published>2023-06-15T16:00:00.000Z</published>
    <updated>2023-06-16T02:05:00.408Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/crud/Untitled.jpeg" alt="Untitled"></p><p>据说，西西弗斯是一个非常聪明的国王，但他也非常自负和狂妄。他甚至敢欺骗神灵，并把死者带回人间。为此，他被宙斯（Zeus）惩罚，被迫每天推着一块巨石上山，但在接近山顶时，巨石总是会滚落下来，他不得不重新开始推石头，永远困在这个循环中…</p><p>很多开发工作也如此单调而乏味，比如今天要讲的中后台开发的场景。中后台业务基本上就是一些数据的增删改查、图表，技术含量不高，比较容易范式化。</p><p>前端如何破除 CRUD 的单调循环呢？</p><p><br><br><br><br><br></p><h2 id="低代码"><a href="#低代码" class="headerlink" title="低代码"></a>低代码</h2><p>过去几年前端的低代码很火，这些<code>低代码平台</code>通常支持创建<code>数据模型</code>后，一键生成对应的增删改查页面：</p><p><br></p><p><img src="/images/crud/Untitled.png" alt="Untitled"></p><p><br></p><aside><br>💡 本文提及的低代码是<code>狭义</code>的<code>低代码</code>，你可以认为就是<code>可视化搭建平台</code>。<br><br></aside><p><br></p><p>低代码在过去几年就是 「雷声大，雨点小」，跟现在的 AI 颇为相似。</p><p>不管是大厂还是小厂都在搞低代码，包括笔者也参与过几个低代码项目，但是小厂支撑不起来这样的资源投入，最后都胎死腹中。我相信很多读者也经历过这种情况。<br>大部分公司只是尾随市场营销噱头，盲目跟风，压根就没有做这种低代码平台资源准备和沉淀。</p><p>作为前端，能参与到低代码项目的开发是一件非常兴奋的事情，毕竟是少数前端能主导的项目，架构、组件设计、编辑器的实现可玩性很高，可以跟同行吹很久。</p><p>作为用户(开发者)呢？可能会<a href="https://www.zhihu.com/question/561025857" target="_blank" rel="noopener">排斥和质疑</a>，不管怎么说，它并没有发挥市场所期望的价值。</p><p><br></p><p>最主要的原因是：<strong>它解决不了复杂的问题</strong>。</p><p><br></p><p>低代码直观、门槛低， 前期开发确实很爽，可视化数据建模、拖拉拽生成页面、流程编排，很快就可以把一些简单的业务开发出来。</p><p>然而软件编码本身占用研发流程的比例，据 <code>ChatGPT</code> 估算大约只有 20% ~ 30%。而且业务持续变化，代码也需要持续迭代。试想一下如何在这些低代码平台上进行重构和检索？</p><p><br><br><br></p><p>总的来说，有一些缺点：</p><ul><li><p><strong>复杂的业务逻辑用低代码可能会更加复杂。</strong>低代码应该是特定领域问题的简化和抽象，如果只是单纯将原有的编码工作转换为 GUI 的模式，并没有多大意义。</p><p>  例如流程编排，若要用它从零搭建一个复杂的流程，如果照搬<code>技术语言</code>去表达它，那有可能是个地狱：</p><p>  <img src="/images/crud/Untitled%201.png" alt="Untitled"></p><p>  理想的<strong>流程编排的节点应该是抽象程度更高的、内聚的<code>业务节点</code>，来表达<code>业务流程</code>的流转。然而</strong>这些节点的设计和开发其实是一件非常有挑战性的事情。</p></li><li><p><strong>软件工程是持续演进的，在可维护性方面，目前市面上的低代码平台并不能提供可靠的辅助和验证。</strong>因此企业很难将核心的稳态业务交给这些平台。</p></li><li>还有很多… 平台锁定，缺乏标准，性能问题、复用、扩展性、安全问题、黑盒，可迁移性，研发成本高，可预测性/可调试性差，高可用，版本管理，不能自动化…</li></ul><p><br><br><br></p><p>当然，低代码有低代码的适用场景，比如解决特定领域问题(营销活动页面，海报，数据大屏，表单引擎、商城装修、主页)，POC 验证。<strong>即一些临时的/非核心的敏态业务</strong>。</p><aside><br>💡 目前有些低代码平台也有「出码能力」，让二开有了一定的可行性。<br><br></aside><aside><br>💡 AI 增强后的低代码可能会更加强大。但笔者依旧保持观望的态度，毕竟准确地描述软件需求，本身就是就是软件研发的难题之一，不然我们也不需要 DDD中的各种方法论，开各种拉通会，或许也不需要需求分析师，产品…<br><br>非专业用户直接描述需求来产出软件，大多是不切实际的臆想<br></aside><p><br><br><br><br><br></p><h2 id="中间形态"><a href="#中间形态" class="headerlink" title="中间形态"></a>中间形态</h2><p>有没有介于可视化低代码平台和专业代码之间的中间形态？既能保持像低代码平台易用性，同时维持代码的灵活性和可维护性。</p><p>我想那就是 DSL(<code>domain-specific language</code>) 吧? <strong>DSL 背后体现的是对特定领域问题的抽象，其形式和语法倒是次要的。</strong></p><aside><br>💡 DSL 的形式有很多，可以创建一门新的微语言(比如 SQL, GraphQL)；可以是一个 JSON 或者 YAML 形式；也可以基于一门现有的<code>元语言</code>(比如 Ruby、Groovy，Rust…)来创建，这些元语言，提供的元编程能力，可以简洁优雅地表达领域问题，同时能够复用<code>元语言</code> 本身的语言能力和基础设施。<br><br></aside><p><strong>严格上可视化低代码平台也是一种‘可视化’ 的 DSL，笔者认为它的局限性更多还是来源‘可视化’，相对的，它优点也大多来源’可视化‘</strong>。</p><blockquote><p>这又牵扯到了持续了半个多世纪的： GUI vs CLI（程序化/文本化） 之争。这个在《UNIX 编程艺术》中有深入的探讨。命令行和命令语言比起可视化接口来说，更具表达力，尤其是针对复杂的任务。另外命令行接口具有高度脚本化的能力。缺点就是需要费劲地记忆，易用性差，透明度低。当问题规模变大、程序的行为日趋单一、过程化和重复时， CLI 也常能发挥作用。<br><br><br>如果按照<code>友好度</code>和问题域的<code>复杂度/规模</code>两个维度来划分，可以拉出以下曲线：<br><br><br><img src="/images/crud/Untitled%202.png" alt="Untitled"></p><p>中间会出现一个交叉点，在这个交叉点之后，命令行的简要行和表达力变得要比避免记忆负担更有价值。</p><p>《反 Mac 接口》一书中也进行了总结：可视化接口在处理小数量物体简单行为的情况下，工作的很好，但是当行为或物体的数量增加是，直接操作很快就编程机械重复的苦差…</p></blockquote><p><strong>也就是说，DSL 的形式会约束 DSL 本身的表达能力。</strong></p><p><br></p><p>正如前文说的，如果‘低代码’仅仅是将原本的编码工作转换为 GUI 形式，其实并没有多大意义，因为没有抽象。</p><p>反例：</p><p><img src="/images/crud/Untitled%203.png" alt="JSON GUI vs  JSON"></p><p>JSON GUI vs JSON</p><p><br><br><br></p><p>正例： VSCode 案例</p><p><img src="/images/crud/Untitled%204.png" alt="Untitled"></p><p><img src="/images/crud/Untitled%205.png" alt="Untitled"></p><p>充分利用 GUI 的优势，提供更好的目录组织、文本提示、数据录入的约束和校验。</p><p><br><br><br></p><p>我们可能会说 GUI 形式用户体验更好，门槛低更低，不用关心底层的细节。<strong>其实并不一定是 GUI 带来的，而是抽象后的结果。GUI 只不过是一种接口形式</strong>。</p><p><br></p><p>回到正题，为了摆脱管理后台 CRUD 的 「西西弗斯之石」： 我们可以创建一个 DSL，这个 DSL 抽象了管理端的各种场景，将繁琐的实现细节、重复的工作封装起来，暴露简洁而优雅的用户接口(User Interface)。</p><aside><br>💡 小结。DSL 是可视化低代码与 pro code 之间的中间中间形态，权衡了易用性/灵活性和实现成本。DSL 的形式会直接影响它的表达能力，但比形式更重要的是 DSL 对特定问题域的抽象。<br><br>我们不必重新发明一门语言，而是复用元语言的能力和生态，这基本上是零成本。<br></aside><p><br><br><br><br><br><br><br></p><h2 id="抽象过程"><a href="#抽象过程" class="headerlink" title="抽象过程"></a>抽象过程</h2><p>典型的增删改查页面：</p><p><img src="/images/crud/Untitled%206.png" alt="Untitled"></p><p>分析过程：</p><ol><li>后端增删改查主要由两大组件组成: <code>表单</code>和<code>表格</code>。</li><li>而表单和表格又由更原子的’<code>字段</code>’组成。字段的类型决定了存储类型、录入方式、和展示方式</li><li>字段有两种形态：<code>编辑态</code>和<code>预览态</code>。表格列、详情页通常是预览态，而表单和表格筛选则使用编辑态。</li></ol><p><br></p><p><img src="/images/crud/Untitled%207.png" alt="Untitled"></p><p>借鉴低代码平台的<code>组件库</code>/<code>节点库</code>，我们可以将这些‘字段’ 提取出来， 作为表单和表格的‘原子’单位， 这里我们给它取个名字，就叫<code>原件</code>(<code>Atomic</code>)吧。</p><p><img src="/images/crud/Untitled%208.png" alt="Untitled"></p><p><code>原件</code>将取代组件库里面的<code>表单组件</code>，作为我们 <code>CRUD</code> 页面的<strong>最小组成单位</strong>。它有且只有职责：</p><p><img src="/images/crud/Untitled%209.png" alt="Untitled"></p><ul><li>数据类型和校验。原件代表的是一种数据类型，可以是<code>基础类型</code>，比如数字、字符串、布尔值、枚举；也可以是基础类型上加了一些约束和交互，比如邮件、手机号码、链接；甚至可能有<code>业务属性</code>，比如用户，商品，订单，二维码。</li><li>数据的预览。</li><li>数据的录入，严格约束为 <code>value</code>/<code>onChange</code> 协议。好处是方便进行状态管理，可能保证原件实现的统一性。</li></ul><p><br><br><br></p><p>接着组合原件来实现表单和表格组件，满足 CRUD 场景：</p><p><img src="/images/crud/Untitled%2010.png" alt="Untitled"></p><p>理想状态下，我们仅需声明式地指定表格的列和原件类型，其余的技术细节应该隐藏起来。表格伪代码示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建包含 名称、创建时间、状态三列的表格，其中可以搜索名称和创建时间</span></span><br><span class="line">Table(</span><br><span class="line">  columns(</span><br><span class="line">    column(名称，name, queryable=<span class="literal">true</span>)</span><br><span class="line">    column(创建时间, created, data-range, queryable=<span class="literal">true</span>)</span><br><span class="line">    column(状态, status, select, options=[&#123;label: 启用，value: 1, &#123;label: 禁用， value: 0&#125;&#125;])</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br></p><p>表单伪代码示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建包含 名称、状态、地址的表单</span></span><br><span class="line">Form(</span><br><span class="line">  item(名称，name, required=<span class="literal">true</span>)</span><br><span class="line">  item(状态，status, select, options=[&#123;label: 启用，value: 1, &#123;label: 禁用， value: 0&#125;&#125;])</span><br><span class="line">  item(地址, address, address)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br></p><p>如上所示，本质上，开发者就应该只关注业务数据本身，而应该忽略掉前端技术实现的噪音(比如状态管理、展示风格、分页、异常处理等等)。</p><p><br><br><br></p><p>表格和表单为了适应不同的需求，还会衍生出不同的展现形式：</p><p><img src="/images/crud/Untitled%2011.png" alt="Untitled"></p><p><code>原件</code> + <code>核心的表单/表格能力</code> + <code>场景/展示形式</code>，一套「组合拳」下来，基本就可以满足常见的后台 CRUD 需求了。</p><p><br><br><br><br><br></p><h2 id="约定大于配置"><a href="#约定大于配置" class="headerlink" title="约定大于配置"></a>约定大于配置</h2><p>前端的在研发流程中相对下游，如果上游的产品定义，UI 设计，后端协议没有保持一致性，就会苦于应付各种混乱的差异，复用性将无从谈起。</p><p>为了最小化样板代码和沟通成本，实现开箱即用的效果。我们最好拉通上下游，将相关的规范确定下来，前端开发者应该扮演好串联的角色。</p><p><br></p><p>这些规范包含但不限于：</p><ul><li>页面的布局</li><li>UI 风格</li><li>提示语</li><li>验证规则</li><li>数据的存储格式</li><li>通用的接口(比如文件上传，导入导出)</li><li>…</li></ul><p><img src="/images/crud/Untitled%2012.png" alt="Untitled"></p><p>组件库可以内置这些约定，或者提供全局的配置方式。这些规范固化后，我们就享受开箱即用的快感了。</p><p><br><br><br><br><br></p><h2 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h2><p>基于上述思想，我们开发了一套<a href="https://wakeadmin.wakedata.com/components-doc/" target="_blank" rel="noopener">组件库</a>(基于 Vue 和 element-ui)，配合一套简洁的 DSL，来快速开发 CRUD 页面。</p><p><br></p><aside><br>💡 <strong><em>这套组件库耦合了我们自己的约定</em></strong>。因此可能不适用于外部通用的场景。本文的意义更多是想启发读者，去构建适合自己的一套解决方案。<br><br></aside><p><strong>列表页定义：</strong></p><p><img src="/images/crud/Untitled%2013.png" alt="Untitled"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; defineFatTable &#125; from &apos;@wakeadmin/components&apos;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 表格项类型</span><br><span class="line"> */</span><br><span class="line">export interface Item &#123;</span><br><span class="line">  id: number</span><br><span class="line">  name: string</span><br><span class="line">  createDate: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const MyTable = defineFatTable&lt;Item&gt;((&#123; column &#125;) =&gt; &#123;</span><br><span class="line">  // 可以在这里放置 Vue hooks</span><br><span class="line">  return () =&gt; (&#123;</span><br><span class="line">    async request(params) &#123;</span><br><span class="line">      /* 数据获取，自动处理异常和加载状态 */</span><br><span class="line">    &#125;,</span><br><span class="line">    // 删除操作</span><br><span class="line">    async remove(list, ids) &#123;</span><br><span class="line">      /*列删除*/</span><br><span class="line">    &#125;,</span><br><span class="line">    // 表格列</span><br><span class="line">    columns: [</span><br><span class="line">      // queryable 标记为查询字段</span><br><span class="line">      column(&#123; prop: &apos;name&apos;, label: &apos;名称&apos;, queryable: true &#125;),</span><br><span class="line">      column(&#123; prop: &apos;createDate&apos;, valueType: &apos;date-range&apos;, label: &apos;创建时间&apos;, queryable: true &#125;),</span><br><span class="line">      column(&#123;</span><br><span class="line">        type: &apos;actions&apos;,</span><br><span class="line">        label: &apos;操作&apos;,</span><br><span class="line">        actions: [&#123; name: &apos;编辑&apos; &#125;, &#123; name: &apos;删除&apos;, onClick: (table, row) =&gt; table.remove(row) &#125;],</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>语法类似于 Vue defineComponent，传入一个’setup’, 。这个 setup 中可以放置一些逻辑和状态或者 Vue hooks，就和 Vue defineComponent 定义一样灵活。</p><p>返回关于表格结构的”声明”。最优的情况下，开发者只需要定义表格结构和后端接口，其余的交由组件库处理。</p><p>当然复杂的定制场景也能满足，这里可以使用 JSX，监听事件，传递组件支持的任意 props 和 slots。</p><p><br><br><br></p><p><strong>表单页示例:</strong></p><p><img src="/images/crud/Untitled%2014.png" alt="Untitled"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; defineFatForm &#125; from &apos;@wakeadmin/components&apos;</span><br><span class="line">import &#123; ElMessageBox &#125; from &apos;element-plus&apos;</span><br><span class="line"></span><br><span class="line">export default defineFatForm&lt;&#123;</span><br><span class="line">  // 🔴 这里的泛型变量可以定义表单数据结构</span><br><span class="line">  name: string</span><br><span class="line">  nickName: string</span><br><span class="line">&#125;&gt;((&#123; item, form, consumer, group &#125;) =&gt; &#123;</span><br><span class="line">  // 🔴 这里可以放置 Vue Hooks</span><br><span class="line"></span><br><span class="line">  // 返回表单定义</span><br><span class="line">  return () =&gt; (&#123;</span><br><span class="line">    // FatForm props 定义</span><br><span class="line">    initialValue: &#123;</span><br><span class="line">      name: &apos;ivan&apos;,</span><br><span class="line">      nickName: &apos;狗蛋&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    submit: async (values) =&gt; &#123;</span><br><span class="line">      await ElMessageBox.confirm(&apos;确认保存&apos;)</span><br><span class="line">      console.log(&apos;保存成功&apos;, values)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // 🔴 子节点</span><br><span class="line">    children: [</span><br><span class="line">      item(&#123; prop: &apos;name&apos;, label: &apos;账号名&apos; &#125;),</span><br><span class="line">      item(&#123;</span><br><span class="line">        prop: &apos;nickName&apos;,</span><br><span class="line">        label: &apos;昵称&apos;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><aside><br>💡 和 tailwind 配合食用更香。我们假设整体的页面是符合UI规范的，细微的调整使用 tw 会很方便<br><br></aside><p><br><br><br></p><p><strong>全局配置：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; provideFatConfigurable &#125; from &apos;@wakeadmin/components&apos;</span><br><span class="line">import &#123; Message &#125; from &apos;element-ui&apos;</span><br><span class="line"></span><br><span class="line">export function injectFatConfigurations() &#123;</span><br><span class="line">  provideFatConfigurable(&#123;</span><br><span class="line">    // ...</span><br><span class="line">    // 统一处理 images 原件上传</span><br><span class="line">    aImagesProps: &#123;</span><br><span class="line">      action: &apos;/upload&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    // 统一 date-range 原件属性</span><br><span class="line">    aDateRangeProps: &#123;</span><br><span class="line">      rangeSeparator: &apos;至&apos;,</span><br><span class="line">      startPlaceholder: &apos;开始日期&apos;,</span><br><span class="line">      endPlaceholder: &apos;结束日期&apos;,</span><br><span class="line">      valueFormat: &apos;yyyy-MM-dd&apos;,</span><br><span class="line">      shortcuts: [</span><br><span class="line">        &#123;</span><br><span class="line">          text: &apos;最近一周&apos;,</span><br><span class="line">          onClick(picker: any) &#123;</span><br><span class="line">            picker.$emit(&apos;pick&apos;, getTime(7))</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          text: &apos;最近一个月&apos;,</span><br><span class="line">          onClick(picker: any) &#123;</span><br><span class="line">            picker.$emit(&apos;pick&apos;, getTime(30))</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          text: &apos;最近三个月&apos;,</span><br><span class="line">          onClick(picker: any) &#123;</span><br><span class="line">            picker.$emit(&apos;pick&apos;, getTime(90))</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>更多示例和深入讲解见<a href="https://wakeadmin.wakedata.com/components-doc/" target="_blank" rel="noopener">这里</a>。</p><p><br><br><br><br><br></p><h2 id="更多实现"><a href="#更多实现" class="headerlink" title="更多实现"></a>更多实现</h2><p>前端社区有很多类似的产品，比如：</p><ul><li><a href="https://xrender.fun/" target="_blank" rel="noopener">XRender</a>。中后台「表单/表格/图表」开箱即用解决方案</li><li><a href="https://procomponents.ant.design/docs/intro" target="_blank" rel="noopener">Antd ProComponents</a>。ProComponents 是基于 Ant Design 而开发的模板组件，提供了更高级别的抽象支持，开箱即用。可以显著的提升制作 CRUD 页面的效率，更加专注于页面</li><li><a href="https://github.com/baidu/amis" target="_blank" rel="noopener">百度 Amis</a> 。 用 JSON 作为 DSL，来描述界面</li></ul><p>读者不妨多参考参考。</p><p><br><br><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单来说，我们就是从提供「<strong>毛坯房</strong>」升级到了「<strong>精装房</strong>」，精装房的设计基于我们对市场需求的充分调研和预判。目的是对于 80% 的用户场景，可以实现拎包入住，当然也允许用户在约束的范围内改装。</p><p>本文主要阐述的观点：</p><ul><li>低代码平台的高效和易用大多来源于抽象，而不一定是 GUI，GUI ≠ 低代码。</li><li>摆脱「西西弗斯之石」 考验的是开发者的抽象能力，识别代码中固化/重复的逻辑。将模式提取出来，同时封装掉底层的实现细节。最终的目的是让开发者将注意力关注到业务本身，而不是技术实现细节。</li><li>用声明式、精简、高度抽象 DSL 描述业务 。DSL 的形式会约束他的表达能力，我们并不一定要创建一门新的语言，最简单的是复用元语言的生态和能力。</li><li>约定大于配置。设计风格、交互流程、数据存储等保持一致性，才能保证抽象收益的最大化。因此规范很重要。这需要我们和设计、产品、后端深入沟通，达成一致。</li><li>沉淀原件。低代码平台的效率取决于平台提供的组件能力、数量和粒度。比如前端的组件库，亦或者流程引擎的节点，都属于原件的范畴。</li><li>要求不要太高，这并不是一个万精油方案，我们期望能满足 80% 常见的场景，这已经是一个很好的成绩。至于那 20% 的个性需求，还是从毛坯房搞起吧。</li></ul><p><br><br><br><br><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://github.com/ascoders/weekly/issues/319" target="_blank" rel="noopener">精读《低代码逻辑编排》</a></li><li>UNIX 编程艺术</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/crud/Untitled.jpeg&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;据说，西西弗斯是一个非常聪明的国王，但他也非常自负和狂妄。他甚至敢欺骗神灵，并把死者带回人间。为此，他被宙斯（Zeus）惩罚，被迫每天推着一块巨石上山，
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>如何实现支持跨 Vue 2/3 的组件库</title>
    <link href="https://bobi.ink/2023/06/11/component-for-vue2-3/"/>
    <id>https://bobi.ink/2023/06/11/component-for-vue2-3/</id>
    <published>2023-06-10T16:00:00.000Z</published>
    <updated>2023-06-11T14:21:51.353Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><p><img src="/images/component-for-vue2-3/Untitled.jpeg" alt="Untitled"></p><p>Vue 3 已经<a href="https://vue-js.com/topic/5f65624c96b2cb0032c38550" target="_blank" rel="noopener">发布</a>三年，我们有较多项目还停留在 Vue 2。Vue 3 的升级是比较割裂的。</p><p>我们主要做的是 <code>2B</code> 业务，项目、模块、分支都非常多，升级的成本和风险都比较高。</p><p>我们目前的策略是 “新旧并存，渐进式升级”， 旧的项目就尽量不变了，新的项目强制使用新的技术栈。利用<code>微前端</code>架构，新旧应用可以灵活地组合起来。</p><p>因此我们的业务组件库、工具库之类需要考虑兼容旧的 Vue 2 项目。这篇文章，就向大家展示我们开发跨版本组件库，其中的决策和实现过程。</p><p><br><br><br></p><h2 id="方案决策"><a href="#方案决策" class="headerlink" title="方案决策"></a>方案决策</h2><p>实现跨版本的组件都多种方案，下面列举分析几种主要方案：</p><p><br></p><p><strong>方案一：使用 Vue SFC / 模板</strong></p><p>单纯从外观上看 Vue 2 / 3 在模板的语法上<a href="https://v3-migration.vuejs.org/zh/breaking-changes/v-model.html" target="_blank" rel="noopener">差别并不大</a>。在 <a href="https://blog.vuejs.org/posts/vue-2-7-naruto" target="_blank" rel="noopener">Vue 2.7</a> 开始内置了对 <code>script setup</code> 也有了较好的支持。</p><p>理论上，我们可以编写一份代码，然后分别针对 2 / 3 编译两份输出。</p><p><img src="/images/component-for-vue2-3/Untitled.png" alt="总体流程如上"></p><p>总体流程如上</p><p><strong>笔者提供了一个简单的 DEMO 来验证了这个方案的可行性，详见<a href="https://github.com/wakeadmin/cvv-sfc-demo" target="_blank" rel="noopener">这里</a>。</strong></p><ul><li>优点<ul><li>模板是 Vue 的第一公民，不需要为了兼容不同版本改变原有的开发习惯。学习成本比较低</li><li>支持静态编译，比如可以针对不同的版本进行条件编译，<strong>优化包体积</strong>。另外可以<strong>保留<a href="https://cn.vuejs.org/guide/extras/rendering-mechanism.html#compiler-informed-virtual-dom" target="_blank" rel="noopener">Vue 模板编译优化</a>机制</strong>。</li><li>使用公开标准语法，不需要 hack 或者关心太多框架底层的差异。</li></ul></li><li>缺点<ul><li>构建相对复杂，需要两份代码输出。</li><li>灵活性较差。模板语法差异很小，但不以为着没有差异，当需要处理某些跨版本差异时可能会比较棘手。比如<a href="https://v3-migration.vuejs.org/zh/breaking-changes/render-function-api.html" target="_blank" rel="noopener">向下透传事件、props 或者 slots</a> , <a href="https://v3-migration.vuejs.org/zh/breaking-changes/v-bind.html" target="_blank" rel="noopener">v-bind.sync 废弃了</a> 、<a href="https://v3-migration.vuejs.org/zh/breaking-changes/key-attribute.html" target="_blank" rel="noopener">template v-for key</a> <strong>、</strong>v-model 协议变化。</li><li>⚠️ 语法固化，为了兼容 Vue 2，template 语法需要停留在 Vue 3.0，这意味着后续发布的新特性可能无法使用，比如 <code>defineModel</code>，<code>defineOptions</code>。</li></ul></li></ul><p><br><br><br><br><br></p><p><strong>方案 2： 渲染函数</strong></p><p>Vue 2 和 Vue 3 都支持渲染函数，但是两者之间有非常大的差异。<strong>详细的差异对比可以看笔者整理的这篇文档： <a href="https://www.notion.so/Vue-2-3-302cbe0e37794345bbfbd89e32d617db?pvs=21" target="_blank" rel="noopener">Vue 2/3 渲染函数差异以及兼容方案</a></strong></p><p><br></p><p><strong>那 Vue 官方的 JSX 插件呢？</strong></p><p>Vue 2/3 JSX Babel (<strong><a href="https://github.com/vuejs/jsx-vue2" target="_blank" rel="noopener">jsx-vue2</a>、<a href="https://github.com/vuejs/babel-plugin-jsx" target="_blank" rel="noopener">babel-plugin-jsx</a></strong>)插件加了一些语法糖，来简化渲染函数的编写，但是这两个插件的语法完全是两个东西。</p><p>因此这个方案不在我们的考虑之列。</p><p><br><br><br><br><br></p><p><strong>方案 3：标准的 JSX</strong></p><p>那为什么不用标准的 <code>JSX</code> 呢？使用统一的 JSX 语法，转换为不同版本的渲染函数。</p><p><img src="/images/component-for-vue2-3/Untitled%201.png" alt="Untitled"></p><p>使用标准的 JSX 语法，意味着：</p><ul><li><p>不需要任何 <code>Babel</code> 插件，能够被市面上主流的编译器(如 tsc， swc，esbuild)直接处理。<br>例如 Typescript</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">/** tsconfig.json */</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"jsx"</span>: <span class="string">"react-jsx"</span>,</span><br><span class="line">    <span class="attr">"jsxImportSource"</span>: <span class="string">"JSX 运行时名称"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<strong>运行时</strong>转换到对应版本的渲染函数。</p></li><li>Typescript friendly。纯 TSX，不需要额外插件(比如 <code>Volar</code>)辅助。</li><li><p>使用习惯上接近 <code>React</code>。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">/** 🔴 1. 事件订阅  **/</span><br><span class="line">// 🤮</span><br><span class="line"><span class="deletion">- &lt;input vOn:click=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;input vOn:click_stop_prevent=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line">// 👍 使用 on* 注册时间</span><br><span class="line"><span class="addition">+ &lt;input onClick=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line"></span><br><span class="line">/** 🔴 2. 没有指令  **/</span><br><span class="line">// 🤮</span><br><span class="line"><span class="deletion">- &lt;input v-show=&#123;this.visible&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;input vModel=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;input vModel_trim=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;A v-model=&#123;[val, "argument", ["modifier"]]&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;a v-loading=&#123;val&#125; /&gt;;</span></span><br><span class="line"></span><br><span class="line">// 👍 没有语法糖</span><br><span class="line"><span class="addition">+ &lt;input modelValue=&#123;val&#125; onUpdate:modelValue=&#123;handleValChange&#125; /&gt;</span></span><br><span class="line"><span class="addition">+ &lt;input style=&#123;&#123;display: this.visible ? 'block' : 'none' &#125;&#125; /&gt;</span></span><br><span class="line"><span class="addition">+ &lt;a &#123;...withDirectives([[vLoading, val]])&#125;&gt;</span></span><br><span class="line"></span><br><span class="line">/** 🔴 3. slots  **/</span><br><span class="line">// 🤮</span><br><span class="line"><span class="deletion">- &lt;MyComponent&gt;</span></span><br><span class="line"><span class="deletion">-   &lt;header slot="header"&gt;header&lt;/header&gt;</span></span><br><span class="line"><span class="deletion">-   &lt;footer slot="footer"&gt;footer&lt;/footer&gt;</span></span><br><span class="line"><span class="deletion">- &lt;/MyComponent&gt;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">- const scopedSlots = &#123;</span></span><br><span class="line"><span class="deletion">-   header: () =&gt; &lt;header&gt;header&lt;/header&gt;,</span></span><br><span class="line"><span class="deletion">-   footer: () =&gt; &lt;footer&gt;footer&lt;/footer&gt;</span></span><br><span class="line"><span class="deletion">- &#125;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">- &lt;MyComponent scopedSlots=&#123;scopedSlots&#125; /&gt;</span></span><br><span class="line"></span><br><span class="line">// 👍 对齐 vue 3</span><br><span class="line"><span class="addition">+ const App = &#123;</span></span><br><span class="line"><span class="addition">+   setup() &#123;</span></span><br><span class="line"><span class="addition">+     const slots = &#123;</span></span><br><span class="line"><span class="addition">+       bar: () =&gt; &lt;span&gt;B&lt;/span&gt;,</span></span><br><span class="line"><span class="addition">+     &#125;;</span></span><br><span class="line"><span class="addition">+     return () =&gt; (</span></span><br><span class="line"><span class="addition">+       &lt;A v-slots=&#123;slots&#125;&gt;</span></span><br><span class="line"><span class="addition">+         &lt;div&gt;A&lt;/div&gt;</span></span><br><span class="line"><span class="addition">+       &lt;/A&gt;</span></span><br><span class="line"><span class="addition">+     );</span></span><br><span class="line"><span class="addition">+   &#125;,</span></span><br><span class="line"><span class="addition">+ &#125;;</span></span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><ul><li><p>优点</p><ul><li>构建很简单，使用标准的 JSX 只需构建一次。不需要引入特定的编译器，使用 <code>Typescript CLI</code>，<code>esbuild</code> 就可以直接编译。</li><li>Typescript Friendly, 另外相比 <code>vue-tsc</code> 编译结果会好一点。</li><li>灵活性。毋庸置疑，<code>JSX</code> 的灵活性，可操行性太强了。</li><li>相对模板编译来说，可控一点(Hackable)。</li><li>可以替换官方的 JSX 库，除了本文介绍的<code>跨版本组件库</code>场景，在日常 Vue 2/3 应用开发中也可以使用啊。</li></ul></li><li><p>缺点</p><ul><li>使用 <code>JSX</code> 则意味着放弃<a href="https://cn.vuejs.org/guide/extras/rendering-mechanism.html#compiler-informed-virtual-dom" target="_blank" rel="noopener">模板编译优化</a>的机会，比如动态节点标注，预字符串化，缓存，静态提升等等。</li><li>为了抹平版本之间的差异，多了一层抽象转换(主要是 Vue 2 上)，会有一些性能损耗。</li><li>实现上需要熟知两个版本之间的差异性。比较 hack</li><li>可读性较差，相比 <code>React</code> 简洁的 Api，Vue 上的一些特殊的框架特性，还是会让代码有些不太优雅，比如指令、Slot</li></ul></li></ul><p>后面我们选择了 <code>JSX</code> 方案，因为实现起来更简单，方案更加可控，尤其是应对后续的版本更新。</p><p><br><br><br><br><br></p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>构建跨版本的组件库，需要考虑的不仅仅是组件语法问题。Vue 2/3 从底层的 API 到渲染函数、再到应用层的组件库、路由、多语言等等，都出现了割裂。我们得兼顾这些变化。</p><p><br></p><ol><li><strong>分层策略</strong></li></ol><p><img src="/images/component-for-vue2-3/Untitled%202.png" alt="Untitled"></p><p>我们按照引用关系进行分层：</p><ul><li><strong><code>API 层</code></strong>。好在 Vue 3 大部分特性(主要是 <code>Composition API</code> 和 <code>defineComponent</code>) 已经下放到了 Vue 2，我们只需要使用 <a href="https://github.com/vueuse/vue-demi" target="_blank" rel="noopener">vue-demi</a> 就可以无缝使用这些核心的 API。<br>相对应的，上层的组件库、适配器代码禁止直接导入 ‘vue’</li><li><strong><code>视图语法层</code></strong>。就如上文说的，我们会封装一个 jsx-runtime, 抹平 Vue 2/3 在渲染函数上的差异。</li><li><strong><code>适配器层</code></strong>。应用层的各种类库的适配。比如我们公司主要使用 element-ui, 新旧版本的差异会在 element-adapter 中处理，并暴露统一接口。</li><li><strong><code>组件库层</code></strong>。最后我们的组件库基于下层提供的抽象能力，实现跨版本。</li><li><strong><code>应用</code></strong>。上层的 Vue 2 / 3 应用。下层的适配器，会根据应用使用的 Vue 版本，动态切换适配。</li></ul><p><br><br><br></p><p><strong>2) 新版本优先策略</strong></p><p>在封装适配器 或者 jsx-runtime 时，当新旧版本出现差异时，我们如何抉择？</p><p>这里采用的是“新版本优先”的策略，举一些例子：</p><ul><li>JSX 的语法对齐 Vue 3 的渲染函数。</li><li>只使用 Composition API</li><li>只使用 defineComponent</li></ul><p>换句话说，如果情况允许，我们始终以 Vue 3 为基准。</p><p><br><br><br></p><p><strong>3) 短板优先策略</strong></p><p>短板对齐是实现兼容的基础策略，主要分两个方面：</p><ul><li>削头: 并不是所有 Vue 3 的特性都能下放到 Vue 2, 比如 <code>Fragment</code>、<code>Teleport</code>、<code>Suspense</code>/<code>await setup</code>。我们只能放弃这些功能。</li><li>补尾：针对一些 Vue 2 的短板，需要一些额外的工作，比如 <a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">Vue 2 响应式系统的局限性</a>。</li></ul><p><br><br><br></p><p><strong>4) 回退策略</strong></p><p>对于一些无法抹平的差异，可以按照不同的版本特殊处理。可以使用 vue-demi 的 <code>isVue2</code> 来分条件处理。</p><p><br><br><br><br><br></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="api-兼容：vue-demi"><a href="#api-兼容：vue-demi" class="headerlink" title="API 兼容：vue demi"></a>API 兼容：vue demi</h3><p><a href="https://github.com/vueuse/vue-demi" target="_blank" rel="noopener">vue-demi</a> 为实现跨 Vue 版本的库提供基础的支持。它的主要策略：</p><ul><li><code>&lt;=2.6</code>: 导出  <code>vue</code> + <code>@vue/composition-api</code>.</li><li><code>2.7</code>: 导出  <code>vue</code> ( Vue 2.7 内置支持 Composition API).</li><li><code>&gt;=3.0</code>: 导出  <code>vue</code>, 模拟了 Vue 2 的<code>set</code> 、 <code>del</code> API.</li></ul><p>vue-demi 的实现很简单，就是在 npm 的 <code>postinstall</code> 钩子中，判断当前环境安装的 vue 库版本，决定导入的库。</p><p>在我们的场景中，除了 Composition API 和一些基础类型信息还不够，我们 Fork 了 vue-demi 来扩充了一些填充物，进一步抹平一些差异。</p><p><br><br><br><br><br></p><h3 id="渲染语法：jsx-runtime-的实现"><a href="#渲染语法：jsx-runtime-的实现" class="headerlink" title="渲染语法：JSX runtime 的实现"></a>渲染语法：JSX runtime 的实现</h3><p>JSX runtime 的实现并不涉及太复杂的技术，主要还是处理渲染函数的繁琐 API 差异。</p><p>文章篇幅有限，这里我就不展开讲细节了。<strong>⚠️ 完整的差异对比和应对方式可以看这里</strong>：</p><p><br></p><p><a href="https://www.notion.so/Vue-2-3-302cbe0e37794345bbfbd89e32d617db?pvs=21" target="_blank" rel="noopener">🎉Vue 2 / 3 渲染函数的差异 🎉</a></p><p><br></p><p>简单来说，我们的 JSX 语法以 Vue 3 为基准，主要涉及事件订阅、slots、指令的转换。</p><p><br></p><p><img src="/images/component-for-vue2-3/Untitled%203.png" alt="Untitled"></p><p>具体实现可以看<a href="https://github.com/wakeadmin/tools/tree/main/packages/h" target="_blank" rel="noopener">这里</a></p><p><br><br><br><br><br></p><h3 id="组件定义与-typescript-支持"><a href="#组件定义与-typescript-支持" class="headerlink" title="组件定义与 Typescript 支持"></a>组件定义与 Typescript 支持</h3><p>Typescript + Volar 就是一门玄学，类型‘体操’几乎占据了开发的三分之一时间。主要问题：</p><ul><li>Vue 2/3 类型定义和导出有细微的差别。我们的 jsx-runtime 要求一致的类型。</li><li>JSX 的 slots 不支持类型检查。渲染函数毕竟不是 Vue 的第一公民，slots 在 JSX 下无法类型检查。</li><li>为了兼容 options API, <code>defineComponent</code> 类型定义和推导比较<a href="https://github.com/vuejs/core/blob/a95e612b252ae59eaf56e0b8ddba66948d4ac20e/packages/runtime-core/src/apiDefineComponent.ts#L44" target="_blank" rel="noopener">复杂</a>。</li><li>泛型组件实现比较复杂，Volar 泛型的支持也比较玄学。</li></ul><p><br><br><br></p><p>为了能够更好地定义跨版本的组件，提供更好的类型支持，我们打算简化 <code>defineComponent</code>。为了避免命名冲突，尚且命名为 <code>declareComponent</code> 吧, 这个函数有以下职责：</p><ul><li>为实现跨版本支持提供必要约束。<code>declareComponent</code> 裁剪掉了 <code>Options API</code>, 只保留 setup、props、render 等属性。强制走 <code>Composition API</code>。</li><li>为 JSX (比如 v-slots 属性)提供更好类型检查支持</li><li>同时兼容 vue template 的类型检查 (<code>volar</code>)。</li><li>在运行时抹平一些跨版本的差异。绝大部分差异，Vue 2.7 在 <code>defineComponent</code> 方法内部已经抹平了。还有一些 <code>inheritAttrs</code> 带来的<a href="https://www.notion.so/Vue-2-3-302cbe0e37794345bbfbd89e32d617db?pvs=21" target="_blank" rel="noopener">隐式差异</a>，<strong>declareComponent 直接关闭了 <code>inheritAttrs</code></strong> 。</li><li>补全短板，并且向下保持兼容。Vue 2 已经不更新了，我们想要支持一些新的特性，比如泛型。</li></ul><p><br></p><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Counter = declareComponent(&#123;</span><br><span class="line">  name: &apos;Counter&apos;,</span><br><span class="line">  // 定义 props</span><br><span class="line">  props: declareProps&lt;&#123;</span><br><span class="line">    initialValue: number</span><br><span class="line">  &#125;&gt;(</span><br><span class="line">    // ⚠️ 和 defineComponent 一样，我们还是需要显式定义 props, 否则会被当做 attrs</span><br><span class="line">    [&apos;initialValue&apos;]</span><br><span class="line">  ),</span><br><span class="line"></span><br><span class="line">  // 定义事件</span><br><span class="line">  emits: declareEmits&lt;&#123; change: (value: number) =&gt; void &#125;&gt;(),</span><br><span class="line"></span><br><span class="line">  // 定义插槽</span><br><span class="line">  // slots: declareSlots&lt;&#123; foo: &#123; a: number &#125; &#125;&gt;(),</span><br><span class="line"></span><br><span class="line">  // setup</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    const count = ref(props.initialValue)</span><br><span class="line">    const handleClick = () =&gt; &#123;</span><br><span class="line">      count.value++</span><br><span class="line"></span><br><span class="line">      emit(&apos;change&apos;, count.value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return () =&gt; (</span><br><span class="line">      &lt;div title=&quot;count&quot; onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">        count: &#123;count.value&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>为了实现这个目标，我们先来看下 <code>Volar</code> 是如何推断组件的类型：</p><p><br></p><p>大致的推导过程如下, 其次可以参考 <code>vue-tsc</code> 的编译输出或者 Vue <code>defineComponent</code> 的类型声明。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// https://github.com/vuejs/language-tools/blob/71240c78f1a205605f4c079a299b2701250ef9be/packages/vue-component-type-helpers/index.d.ts#L5</span><br><span class="line">export type ComponentProps&lt;T&gt; = T extends new () =&gt; &#123; $props: infer P &#125;</span><br><span class="line">  ? NonNullable&lt;P&gt;</span><br><span class="line">  : T extends (props: infer P, ...args: any) =&gt; any</span><br><span class="line">  ? P</span><br><span class="line">  : &#123;&#125;</span><br><span class="line"></span><br><span class="line">export type ComponentSlots&lt;T&gt; = T extends new () =&gt; &#123; $slots: infer S &#125;</span><br><span class="line">  ? NonNullable&lt;S&gt;</span><br><span class="line">  : T extends (props: any, ctx: &#123; slots: infer S &#125;, ...args: any) =&gt; any</span><br><span class="line">  ? NonNullable&lt;S&gt;</span><br><span class="line">  : &#123;&#125;</span><br><span class="line"></span><br><span class="line">export type ComponentEmit&lt;T&gt; = T extends new () =&gt; &#123; $emit: infer E &#125;</span><br><span class="line">  ? NonNullable&lt;E&gt;</span><br><span class="line">  : T extends (props: any, ctx: &#123; emit: infer E &#125;, ...args: any) =&gt; any</span><br><span class="line">  ? NonNullable&lt;E&gt;</span><br><span class="line">  : &#123;&#125;</span><br><span class="line"></span><br><span class="line">export type ComponentExposed&lt;T&gt; = T extends new () =&gt; infer E</span><br><span class="line">  ? E</span><br><span class="line">  : T extends (props: any, ctx: &#123; expose(exposed: infer E): any &#125;, ...args: any) =&gt; any</span><br><span class="line">  ? NonNullable&lt;E&gt;</span><br><span class="line">  : &#123;&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Vue 2.x</span><br><span class="line"> */</span><br><span class="line">export type Vue2ComponentSlots&lt;T&gt; = T extends new () =&gt; &#123; $scopedSlots: infer S &#125;</span><br><span class="line">  ? NonNullable&lt;S&gt;</span><br><span class="line">  : T extends (props: any, ctx: &#123; slots: infer S &#125;, ...args: any) =&gt; any</span><br><span class="line">  ? NonNullable&lt;S&gt;</span><br><span class="line">  : &#123;&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>简单来说 <code>defineComponent</code> 方法最终输出的组件的类型外观长这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type YourComponent = new (...args: any[]): &#123;</span><br><span class="line">  $props: Props 类型</span><br><span class="line">  $emit: 事件类型</span><br><span class="line">  $slots: 插槽类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>💡 那 Typescript 的 JSX 怎么对组件进行类型检查呢？这个可以参考 Typescript 的 <a href="https://www.typescriptlang.org/docs/handbook/jsx.html" target="_blank" rel="noopener">JSX 文档</a>，还有 Vue 的 JSX <a href="https://github.com/vuejs/core/blob/a95e612b252ae59eaf56e0b8ddba66948d4ac20e/packages/vue/jsx.d.ts#L3" target="_blank" rel="noopener">类型定义</a>。简单说也是从上述的 <code>$props</code> 中推导的。</p></blockquote><p><br><br><br></p><p>我们的 <code>declareComponent</code> 只要保持和上面的类型兼容，就可以让 <code>volar</code> 在 vue template 下进行类型检查了。</p><p><br></p><p>因为刨除掉了不必要的 Options API, 相比 defineComponent, 类型定义可以简化很多:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function declareComponent&lt;</span><br><span class="line">  Props extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Emit extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Slots extends &#123;&#125; = &#123;&#125;</span><br><span class="line">&gt;(</span><br><span class="line">  options: SimpleComponentOptions&lt;Props, Emit, Expose, Slots&gt;</span><br><span class="line">): DefineComponent&lt;Props, Emit, Expose, Slots&gt; &#123;</span><br><span class="line">  /// .. 实现忽略，简单封装 defineComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 简化 defineComponent API, 只保留 Composition API</span><br><span class="line">export type SimpleComponentOptions&lt;</span><br><span class="line">  Props extends &#123;&#125;,</span><br><span class="line">  Emit extends &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125;,</span><br><span class="line">  Slots extends &#123;&#125;</span><br><span class="line">&gt; = &#123;</span><br><span class="line">  name?: string</span><br><span class="line">  props?: Props</span><br><span class="line">  emits?: Emit</span><br><span class="line">  slots?: Slots</span><br><span class="line">  expose?: Expose</span><br><span class="line">  setup: (</span><br><span class="line">    props: Props,</span><br><span class="line">    ctx: SetupContext&lt;Emit, DefaultSlots &amp; Slots, Expose, Data&gt;</span><br><span class="line">  ) =&gt; Promise&lt;RenderFunction | void&gt; | RenderFunction | void</span><br><span class="line">  inheritAttrs?: boolean</span><br><span class="line">  serverPrefetch?(): Promise&lt;any&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export interface ComponentInstance&lt;</span><br><span class="line">  Props extends &#123;&#125;,</span><br><span class="line">  Emit extends &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125;,</span><br><span class="line">  Slots extends &#123;&#125;</span><br><span class="line">&gt; &#123;</span><br><span class="line">  // props 定义</span><br><span class="line">  $props: Props &amp;</span><br><span class="line">    // 🔴 将 emit 转换为 on* 形式，方便 JSX 场景使用</span><br><span class="line">    EmitsToProps&lt;Emit&gt; &amp; &#123; &apos;v-slots&apos;?: Partial&lt;VSlotType&lt;Slots&gt;&gt; &#125; &amp; &#123;</span><br><span class="line">      // 🔴 扩展了 v-slots 的定义，方便 JSX 场景使用</span><br><span class="line">      &apos;v-children&apos;?: VChildrenType&lt;Slots&gt;</span><br><span class="line">    &#125; &amp; &#123;</span><br><span class="line">      ref?: RefType&lt;Expose | Expose[]&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  // 🔴 支持 volar 推断 slots</span><br><span class="line">  $slots: VSlotType&lt;Slots&gt;</span><br><span class="line">  // 🔴 支持 volar 推断 事件</span><br><span class="line">  $emit: EmitFn&lt;Emit&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以对比 Vue 的 DefineComponent 看看</span><br><span class="line">export interface DefineComponent&lt;</span><br><span class="line">  Props extends &#123;&#125;,</span><br><span class="line">  Emit extends &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125;,</span><br><span class="line">  Slots extends &#123;&#125;</span><br><span class="line">&gt; &#123;</span><br><span class="line">  new (...args: any[]): ComponentInstance&lt;Props, Emit, Expose, Slots&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>那怎么支持泛型组件吗？</strong></p><p><br><br><br><br><br></p><h3 id="泛型组件"><a href="#泛型组件" class="headerlink" title="泛型组件"></a><strong>泛型组件</strong></h3><blockquote><p>Volar 需要升级到最新版本。</p></blockquote><blockquote><p>Volar 的泛型支持比较玄学，我建议不要随意尝试！</p></blockquote><p>Vue 3.3 官方正式支持了<a href="https://blog.vuejs.org/posts/vue-3-3" target="_blank" rel="noopener">泛型 SFC</a> 和 defineComponent, 笔者实测 Volar 这块支持还有待改进。但是不妨碍我们进行初步的尝试。</p><p>上文的 <code>declareComponent</code> 写法是不支持泛型组件的。有两种方式可以实现泛型组件的声明，先来看一个比较简单的：</p><ol><li><p><strong>类型断言</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 🔴 使用泛型定义 props、emit 和 expose 等类型</span><br><span class="line">interface Props&lt;T&gt; &#123;</span><br><span class="line">  list: T[]</span><br><span class="line">  filter: (item: T) =&gt; boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 📢 这里要用 type</span><br><span class="line">type Emit&lt;T&gt; = &#123;</span><br><span class="line">  add: (item: T) =&gt; void</span><br><span class="line">  change: (list: T[]) =&gt; void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Expose&lt;T&gt; = &#123;</span><br><span class="line">  open: (item: T) =&gt; void</span><br><span class="line">  list: T[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Slots&lt;T&gt; = &#123;</span><br><span class="line">  foo: (list: T[]) =&gt; any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const GenericBar = declareComponent(&#123;</span><br><span class="line">  props: declareProps&lt;Props&lt;any&gt;&gt;([]),</span><br><span class="line">  emits: declareEmits&lt;Emit&lt;any&gt;&gt;(),</span><br><span class="line">  expose: declareExpose&lt;Expose&lt;any&gt;&gt;(),</span><br><span class="line">  slots: declareSlots&lt;Slots&lt;any&gt;&gt;(),</span><br><span class="line">  setup(props, ctx) &#123;</span><br><span class="line">    expectType&lt;any[]&gt;(props.list)</span><br><span class="line">    ctx.emit(&apos;change&apos;, [])</span><br><span class="line">    ctx.slots.foo?.([])</span><br><span class="line">    ctx.expose(&#123;</span><br><span class="line">      list: [],</span><br><span class="line">      open() &#123;</span><br><span class="line">        // ignore</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    return &#123;&#125; as any</span><br><span class="line">  &#125;,</span><br><span class="line">  // 🔴 重新断言，支持 泛型</span><br><span class="line">&#125;) as new &lt;T&gt;(...args: any[]) =&gt; ComponentInstance&lt;Props&lt;T&gt;, Emit&lt;T&gt;, Expose&lt;T&gt;, Slots&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">;&lt;GenericBar</span><br><span class="line">  list=&#123;[1, 2]&#125;</span><br><span class="line">  filter=&#123;(i) =&gt; &#123;</span><br><span class="line">    expectType&lt;number&gt;(i)</span><br><span class="line">    return true</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  onAdd=&#123;(i) =&gt; &#123;</span><br><span class="line">    expectType&lt;number&gt;(i)</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  onChange=&#123;(i) =&gt; &#123;</span><br><span class="line">    expectType&lt;number[]&gt;(i)</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  v-slots=&#123;&#123;</span><br><span class="line">    foo(i) &#123;</span><br><span class="line">      expectType&lt;number[]&gt;(i)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;&lt;/GenericBar&gt;</span><br></pre></td></tr></table></figure><p> <br></p><p>上面的方式在 JSX 表现正常，<strong>但是目前 Volar 在 vue template 并不支持。</strong></p><blockquote><p>💡 <strong>这里也有一些冷知识。</strong>假设 目标类型约束了 <code>Index Signature</code>, 比如 <code>{[key: string]: Function }</code>, 那么 <code>interface</code> 是无法赋值给它的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; interface Indexed &#123;</span><br><span class="line">&gt;   [key: string]: Function</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; interface Foo &#123;</span><br><span class="line">&gt;   hello: () =&gt; void</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; declare let a: Indexed</span><br><span class="line">&gt; declare let b: Foo</span><br><span class="line">&gt;</span><br><span class="line">&gt; a = b // 🚨 Index signature for type &apos;string&apos; is missing in type &apos;Foo&apos;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>如果使用 <code>type</code> 创建类型就可以:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; type Bar = &#123;</span><br><span class="line">&gt;   hello: () =&gt; void</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; declare let c: Bar</span><br><span class="line">&gt; a = c // it&apos;s work</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>笔者推测，应该<strong>是 interface 允许 <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces" target="_blank" rel="noopener">合并</a>，不是静态的，因此不能安全地满足 Index Signature 的约束</strong>。</p><p>了解更多：</p><p><a href="https://stackoverflow.com/questions/60697214/how-to-fix-index-signature-is-missing-in-type-error" target="_blank" rel="noopener">How to fix “Index signature is missing in type” error?</a></p></blockquote><p> <br><br> <br></p></li><li><p><strong>函数形式</strong></p><p>Vue 3.3 的 <code>defineComponent</code> 新增了一种<a href="https://cn.vuejs.org/api/general.html#definecomponent" target="_blank" rel="noopener">函数签名形式</a>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Comp = defineComponent(</span><br><span class="line">  &lt;T extends string | number&gt;(props: &#123; msg: T; list: T[] &#125;) =&gt; &#123;</span><br><span class="line">    // 就像在 &lt;script setup&gt; 中一样使用组合式 API</span><br><span class="line">    const count = ref(0)</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      // 渲染函数或 JSX</span><br><span class="line">      return &lt;div&gt;&#123;count.value&#125;&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 去掉注释，泛型会失效</span><br><span class="line">  // 目前仍然需要手动声明运行时的 props</span><br><span class="line">  // &#123;</span><br><span class="line">  //  props: [&apos;msg&apos;, &apos;list&apos;]</span><br><span class="line">  /// &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>尴尬的是，Vue 组件必须显式定义 props 参数，不然会被当做 attrs 处理。所以，当你将上面的<strong>props 参数注释去掉时，泛型就会失效了 😀</strong> 。</p><p>另外一件尴尬的事情是，截止目前为止，用上面语法创建的组件，在 Volar 上并不能得到很好的支持(只能正确推断 props)。</p><p><br></p><p>但使用 <a href="https://cn.vuejs.org/api/sfc-script-setup.html#generics" target="_blank" rel="noopener">SFC 泛型语法</a> 则会表现好一点。SFC 有什么特殊？</p><p>我使用 vue-tsc 将组件编译了一下，大概结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare const _default: &lt;T&gt;(</span><br><span class="line">  // 🔴 props 类型</span><br><span class="line">  __VLS_props: &#123;</span><br><span class="line">    list: T[]</span><br><span class="line">    filter: (item: T) =&gt; boolean</span><br><span class="line">  &#125; &amp; VNodeProps &amp;</span><br><span class="line">    AllowedComponentProps &amp;</span><br><span class="line">    ComponentCustomProps,</span><br><span class="line"></span><br><span class="line">  // 🔴 context 类型</span><br><span class="line">  __VLS_ctx?:</span><br><span class="line">    | Pick&lt;</span><br><span class="line">        &#123;</span><br><span class="line">          props: &#123;</span><br><span class="line">            list: T[]</span><br><span class="line">            filter: (item: T) =&gt; boolean</span><br><span class="line">          &#125;</span><br><span class="line">          expose(exposed: &#123; data: Ref&lt;T[] | null | undefined&gt; &#125;): void</span><br><span class="line">          attrs: any</span><br><span class="line">          slots: &#123;</span><br><span class="line">            foo: (scope: &#123; list: T[] &#125;) =&gt; any</span><br><span class="line">          &#125;</span><br><span class="line">          emit: &#123;</span><br><span class="line">            change: [T[]]</span><br><span class="line">            foo: [T, number]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;attrs&apos; | &apos;emit&apos; | &apos;slots&apos;</span><br><span class="line">      &gt;</span><br><span class="line">    | undefined</span><br><span class="line">) =&gt; // 🔴 返回值</span><br><span class="line">VNode &amp; &#123;</span><br><span class="line">  __ctx?:</span><br><span class="line">    | &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">          list: T[]</span><br><span class="line">          filter: (item: T) =&gt; boolean</span><br><span class="line">        &#125;</span><br><span class="line">        expose(exposed: &#123; data: Ref&lt;T[] | null | undefined&gt; &#125;): void</span><br><span class="line">        attrs: any</span><br><span class="line">        slots: &#123;</span><br><span class="line">          foo: (scope: &#123; list: T[] &#125;) =&gt; any</span><br><span class="line">        &#125;</span><br><span class="line">        emit: &#123;</span><br><span class="line">          change: [T[]]</span><br><span class="line">          foo: [T, number]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    | undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SFC 的编译结果多出了 <code>__ctx</code> 字段，实际上 Volar 就是从 __ctx 中提取了相关类型。</p><aside><br>💡 __ctx 应该是 volar 的内部实现细节，不排除后面会变动<br><br></aside><p>那我们现在就模仿它，重构一下 <code>declareComponent</code> 的签名:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface DefineComponentContext&lt;</span><br><span class="line">  Emit extends ObjectEmitsOptions = &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Slots extends &#123; [key: string]: Function &#125; = &#123;&#125;,</span><br><span class="line">  Attrs extends &#123;&#125; = &#123;&#125;</span><br><span class="line">&gt; &#123;</span><br><span class="line">  attrs: Attrs</span><br><span class="line">  slots: Slots</span><br><span class="line">  emit: EmitFn&lt;Emit&gt;</span><br><span class="line">  expose: ExposeFn&lt;Expose&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function declareComponent&lt;</span><br><span class="line">  Props extends &#123;&#125;,</span><br><span class="line">  Emit extends ObjectEmitsOptions = &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Slots extends &#123; [key: string]: Function &#125; = &#123;&#125;,</span><br><span class="line">  Attrs extends &#123;&#125; = &#123;&#125;</span><br><span class="line">&gt;(</span><br><span class="line">  setup: (</span><br><span class="line">    props: Props,</span><br><span class="line">    ctx: DefineComponentContext&lt;Emit, Expose, Slots, Attrs&gt;</span><br><span class="line">  ) =&gt; Promise&lt;RenderFunction | void&gt; | RenderFunction | void,</span><br><span class="line">  options?: &#123;</span><br><span class="line">    props?: Array&lt;keyof Props&gt; | ComponentObjectPropsOptions&lt;Partial&lt;Props&gt;&gt;</span><br><span class="line">    name?: string</span><br><span class="line">    inheritAttrs?: boolean</span><br><span class="line">    serverPrefetch?(): Promise&lt;any&gt;</span><br><span class="line">  &#125;</span><br><span class="line">): (</span><br><span class="line">  props: PropsType&lt;Props, Emit, Slots, Expose&gt;,</span><br><span class="line">  ctx: DefineComponentContext&lt;Emit, Expose, Slots, Attrs&gt;</span><br><span class="line">) =&gt; VNode &amp; &#123;</span><br><span class="line">  // 🛑</span><br><span class="line">  __ctx: &#123;</span><br><span class="line">    emit: EmitFn&lt;Emit&gt;</span><br><span class="line">    slots: Slots</span><br><span class="line">    expose: ExposeFn&lt;Expose&gt;</span><br><span class="line">    attrs: Attrs</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo&lt;T&gt;(</span><br><span class="line">  props: &#123; list: T[]; filter: (item: T) =&gt; boolean &#125;,</span><br><span class="line">  ctx: DefineComponentContext&lt;</span><br><span class="line">    &#123; change: (list: T[]) =&gt; void; add: (item: T) =&gt; void &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      open: (item: T) =&gt; void</span><br><span class="line">      list: T[]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      foo: (list: T[]) =&gt; any</span><br><span class="line">    &#125;</span><br><span class="line">  &gt;</span><br><span class="line">) &#123;</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    // render</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ⚠️ props 还是要定义</span><br><span class="line">Foo.props = [&apos;list&apos;, &apos;filter&apos;]</span><br><span class="line"></span><br><span class="line">export default declareComponent(Foo)</span><br></pre></td></tr></table></figure><p>目前 Volar 在泛型的支持上还有不少的坑。比如上面的示例中事件处理器的泛型变量会推断为 unknown。让子弹再飞一会吧。</p></li></ol><p><br><br><br><br><br> </p><h3 id="element-adapter"><a href="#element-adapter" class="headerlink" title="element-adapter"></a>element-adapter</h3><p>实现的原理和 vue-demi 类似，在 postinstall 时决定使用哪个版本。项目的结构如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scripts/             <span class="comment"># 和 vue-demi 一样，实现了 postinstall 和切换 CLI</span></span><br><span class="line">  postinstall.mjs</span><br><span class="line">  switch-cli.mjs</span><br><span class="line">src/</span><br><span class="line">  shared/</span><br><span class="line">  v2/                <span class="comment"># element-ui 导出</span></span><br><span class="line">    components/</span><br><span class="line">      Table.js</span><br><span class="line">      Slide.js</span><br><span class="line">      ...</span><br><span class="line">  v3/                <span class="comment"># element-plus 导出</span></span><br><span class="line">    components/</span><br><span class="line">      ...</span><br><span class="line">types/               <span class="comment"># 重新声明组件的类型信息。</span></span><br><span class="line">  alert.d.ts</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p><br> </p><p>大部分组件不需要特殊处理，重新导出就行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> &#123; Button &#125; from <span class="string">'element-ui'</span>;</span><br></pre></td></tr></table></figure><p><br> </p><p>有一些组件参数名称发生了变化，则以 element-plus 为基准做一下调整：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; TimePicker as ElTimePicker &#125; from &apos;element-ui&apos;</span><br><span class="line">import &#123; h &#125; from &apos;@wakeadmin/h&apos;</span><br><span class="line"></span><br><span class="line">import &#123; normalizeDateFormat &#125; from &apos;../../shared/date-format&apos;</span><br><span class="line"></span><br><span class="line">export const TimePicker = &#123;</span><br><span class="line">  functional: true,</span><br><span class="line">  render(_, context) &#123;</span><br><span class="line">    const &#123; format, selectableRange, valueFormat, ...other &#125; = context.props</span><br><span class="line"></span><br><span class="line">    // vue3 pickerOptions 提取到了全局</span><br><span class="line">    other.pickerOptions = &#123;</span><br><span class="line">      ...other.pickerOptions,</span><br><span class="line">      format: format &amp;&amp; normalizeDateFormat(format),</span><br><span class="line">      selectableRange,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (valueFormat) &#123;</span><br><span class="line">      other.valueFormat = normalizeDateFormat(valueFormat)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return h(</span><br><span class="line">      ElTimePicker,</span><br><span class="line">      Object.assign(&#123;&#125;, context.data, &#123; props: other, attrs: undefined &#125;),</span><br><span class="line">      context.slots()</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br> </p><p>另外，我们也会移植一些 element-plus 的新组件，比如 <code>TreeSelect</code>。</p><p>对于 icon 这类差异比较大，我们直接放弃了。可以使用外部图标库或者 SVG 组件库（参考这个<a href="https://github.com/wakeadmin/tools/tree/main/packages/icons" target="_blank" rel="noopener">实现</a>跨版本的 SVG 图标库）。</p><p><br><br><br><br><br> </p><h3 id="router-adapter"><a href="#router-adapter" class="headerlink" title="router-adapter"></a>router-adapter</h3><p>我们的组件库是可能会涉及到路由的订阅和操作。因为 vue-router API 差异并不大，处理起来会简单很多。</p><p>不管是 vue 2 还是 3，vue-router 都会在组件实例上挂载相关的 API, 我们直接获取就行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface RouteLike &#123;</span><br><span class="line">  query: Record&lt;string, any&gt;</span><br><span class="line">  params: Record&lt;string, any&gt;</span><br><span class="line">  hash: string</span><br><span class="line">  path: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export type RouteLocation =</span><br><span class="line">  | string</span><br><span class="line">  | &#123;</span><br><span class="line">      query?: Record&lt;string, any&gt;</span><br><span class="line">      hash?: string</span><br><span class="line">      path?: string</span><br><span class="line">      name?: string</span><br><span class="line">      params?: Record&lt;string, any&gt;</span><br><span class="line">      replace?: boolean</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">export interface RouterLike &#123;</span><br><span class="line">  push(to: RouteLocation): Promise&lt;any&gt;</span><br><span class="line">  replace(to: RouteLocation): Promise&lt;any&gt;</span><br><span class="line">  back(): void</span><br><span class="line">  forward(): void</span><br><span class="line">  go(delta: number): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function useRouter() &#123;</span><br><span class="line">  const instance = getCurrentInstance()</span><br><span class="line"></span><br><span class="line">  if (isVue2) &#123;</span><br><span class="line">    return (instance?.proxy?.$root as &#123; $router: RouterLike &#125; | undefined)?.$router</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return (instance?.root?.proxy as unknown as &#123; $router: RouterLike &#125;)?.$router</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ... useRoute 同理</span><br></pre></td></tr></table></figure><p><br> </p><p>其他的库可以采取类似的策略。</p><p><br><br><br><br><br> </p><h3 id="🎉-开源-🎉"><a href="#🎉-开源-🎉" class="headerlink" title="🎉 开源 🎉"></a>🎉 开源 🎉</h3><p>借着这篇文章，我们也将相关的<a href="https://github.com/wakeadmin" target="_blank" rel="noopener">程序开源了</a>! 希望能帮助到大家！</p><ul><li><a href="https://github.com/wakeadmin/tools/tree/main/packages/h" target="_blank" rel="noopener">jsx-runtime 实现</a></li><li><a href="https://github.com/wakeadmin/components" target="_blank" rel="noopener">组件库实现</a></li></ul><p>欢迎 Fork Star PR</p><p><br><br><br><br><br> </p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://www.notion.so/Vue-2-3-302cbe0e37794345bbfbd89e32d617db?pvs=21" target="_blank" rel="noopener">Vue 2/3 渲染函数差异以及兼容方案</a></li><li><a href="https://github.com/vuejs/core/pull/7963" target="_blank" rel="noopener">feat(types): <code>defineComponent()</code> with generics support</a></li><li><a href="https://cn.vitejs.dev/config/" target="_blank" rel="noopener">vitejs</a></li><li><a href="https://github.com/vitejs/vite-plugin-vue" target="_blank" rel="noopener">https://github.com/vitejs/vite-plugin-vue</a></li><li><a href="https://github.com/vitejs/vite-plugin-vue2" target="_blank" rel="noopener">https://github.com/vitejs/vite-plugin-vue2</a></li><li><a href="https://github.com/vuejs/babel-plugin-jsx" target="_blank" rel="noopener">https://github.com/vuejs/babel-plugin-jsx</a></li><li><a href="https://github.com/vuejs/jsx-vue2" target="_blank" rel="noopener">https://github.com/vuejs/jsx-vue2</a></li><li><a href="https://github.com/vuejs/language-tools" target="_blank" rel="noopener">https://github.com/vuejs/language-tools</a></li><li><a href="https://github.com/vuejs/vue-loader/" target="_blank" rel="noopener">https://github.com/vuejs/vue-loader/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/component-for-vue2-3/Untitled.jpeg&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;Vue 3 已经&lt;a href=&quot;https://vue-js.com/topic/5f6562
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>现代前端框架的渲染模式</title>
    <link href="https://bobi.ink/2023/06/05/render-patterns/"/>
    <id>https://bobi.ink/2023/06/05/render-patterns/</id>
    <published>2023-06-04T16:00:00.000Z</published>
    <updated>2023-06-05T03:25:04.885Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要参考的内容来源是<a href="https://www.patterns.dev/" target="_blank" rel="noopener">patterns.dev</a>。这个网站收录了许多实用的前端设计模式，大家赶紧收藏起来！</p></blockquote><p><br></p><p>React 发布已经十年了，笔者接触前端差不多也有十年时间了。说实话，如果没有 <a href="https://search.douban.com/book/subject_search?search_text=head+first&amp;cat=1001" target="_blank" rel="noopener">Head First 系列图书</a>，我可能都没有走上编程这条道路。</p><p><br></p><p><img src="/images/render-patterns/Untitled.png" alt="Head first"><br>Head first</p><p><br></p><p>尽管现在看来这系列图书内容可能过时了。</p><p>Head First 系列图书让我知道，原来编程也可以这么通俗易懂的，对于刚接触这个领域的同学来说，从这里可以获得很多信心和成就感。<br>这种风格也一直影响着我，学习和工作、传道授业过程中，我会努力把复杂的事情简化、通俗化，提炼本质。</p><p><br><br><br></p><p>这十年，前端渲染方式一直在演进，我觉得大概可以分为以下三个阶段：</p><p><img src="/images/render-patterns/Untitled%201.png" alt="Untitled"></p><ul><li>传统 SSR: 那时候前端还没有分离，在 JSP、ASP、Ruby on Rails、Django 这些 MVC 框架下，通过模板来渲染页面。jQuery 是这个阶段的主角</li><li>前后端分离：从 Node.js 发布，到目前为止，是前端发展最迅速的 10 年。<br>前后端分离的典型代表是 Angular 和 React、Vue 等框架，我觉得，促进前后端分离的主要原因还是<strong>随着需求的复杂化，分工精细化了</strong>。 前端可以专注于 UI 的设计和交互逻辑。后端只需要提供 API，不需要关心前端的具体实现。</li><li>同构前端：这几年前端框架的发展进入的深水区，随着云原生、容器技术、Serverless、边缘计算等底层技术设施的普及，也让‘前端’生存范围延展到服务端。前端开始寻求 <code>UX</code> 和 <code>DX</code> 的平衡点</li></ul><p><br><br><br><br><br></p><p>通过这篇文章，你就可以知道近些年前端渲染模式的演变。</p><p>废话不多说，直接开始吧。</p><p><br><br><br><br><br></p><h2 id="csr-客户端渲染"><a href="#csr-客户端渲染" class="headerlink" title="CSR - 客户端渲染"></a>CSR - 客户端渲染</h2><p><img src="/images/render-patterns/Untitled%202.png" alt="Untitled"></p><p>这个我们再熟悉不过了， 即前端页面在浏览器中渲染，服务端仅仅是静态资源服务器(比如 nginx)。</p><p>初始的 HTML 文件只是一个空壳，我们需要等待 JavaScript 包加载和执行完毕，才能进行交互，白屏时间比较长。</p><ul><li>优点<ul><li>部署简单</li><li>页面过渡、功能交互友好</li><li>适合复杂交互型应用程序开发</li></ul></li><li>缺点<ul><li><code>SEO</code> 不友好</li><li>白屏时间长</li><li>可能需要复杂的状态管理。时至今日，状态管理方面的轮子还在不停地造</li></ul></li></ul><p><br><br><br><br><br></p><h2 id="ssr-服务端渲染"><a href="#ssr-服务端渲染" class="headerlink" title="SSR - 服务端渲染"></a>SSR - 服务端渲染</h2><p><img src="/images/render-patterns/Untitled%203.png" alt="Untitled"></p><p>为了解决 SEO 和白屏问题，各大框架开始支持在服务端渲染 HTML 字符串。</p><p>SSR 把数据拉取放到了服务端，因为离数据源比较近，数据拉取的速度会快一点。但这也不是完全没有副作用，因为需要在服务端等待数据就绪, <code>TTFB(Time to First Byte)</code> 相比 CSR 会长一点。</p><p>SSR 只是给我们准备好了初始的数据和 HTML, 实际上和 CSR 一样，我们还是需要加载完整的<code>客户端程序</code>，然后在浏览器端重新渲染一遍(更专业的说是 <code>Hydration  水合/注水</code>)，才能让 DOM 有交互能力。</p><p><strong>也就说， <code>FCP(First Contentful Paint)</code> 相比 CSR 提前了, 但是 <code>TTI(Time to Interactive)</code> 并没有太多差别。只是用户可以更快地看到内容了。</strong></p><blockquote><p>hydration 的主要目的是挂载事件处理器、触发副作用等等</p></blockquote><p>优点</p><ul><li>SEO 友好</li><li>用户可以更快看到内容了</li></ul><p>缺点</p><ul><li>部署环境要求。需要 Nodejs 等 JavaScript 服务端运行环境</li><li>需要包含完整的 JavaScript 客户端渲染程序，<code>TTI</code> 还有改善空间</li></ul><p><br><br><br><br><br><br><br></p><h2 id="ssg-静态生成"><a href="#ssg-静态生成" class="headerlink" title="SSG - 静态生成"></a>SSG - 静态生成</h2><p><img src="/images/render-patterns/Untitled%204.png" alt="Untitled"></p><p>对于完全静态的页面，比如博客，公司主页等等，也可以使用 SSG 静态渲染。</p><p>和 SSR 的区别是，SSG 是在<code>构建时</code>渲染的。</p><p>和 CSR 一样，因为是静态的，所以在服务端不需要渲染运行时，部署在静态服务器就行了。</p><p>VuePress、VitePress、Gatsby、Docusaurus 这些框架都属于 SSG 的范畴。</p><p><br><br><br></p><p>优点</p><ul><li>相比 SSR, 因为不需要服务端运行时、数据拉取，TTFB/FCP 等都会提前。</li></ul><p>缺点</p><ul><li>和 SSR 一样，也有客户端渲染程序、需要进行 Hydrate。<br>对于<code>内容为中心</code>的站点来说，实际上并不需要太多交互，客户端程序还有较大压缩的空间。</li><li>在构建时渲染，如果内容变更，需要重新构建，比较麻烦</li></ul><p><br><br><br><br><br><br><br></p><h2 id="isg-增量静态生成"><a href="#isg-增量静态生成" class="headerlink" title="ISG - 增量静态生成"></a>ISG - 增量静态生成</h2><p><img src="/images/render-patterns/Untitled%205.png" alt="Untitled"></p><p>ISG 是 SSG 的升级版。解决 SSG 内容变更繁琐问题。</p><p>ISG 依旧会在构建时预渲染页面，但是这里多出了一个<code>服务端运行时</code>，这个运行时会按照一定的过期/刷新策略(通常会使用 <strong><a href="https://web.dev/stale-while-revalidate/" target="_blank" rel="noopener">stale-while-revalidate</a></strong> )来重新生成页面。</p><p><br><br><br><br><br><br><br></p><h2 id="progressive-hydration-渐进水合"><a href="#progressive-hydration-渐进水合" class="headerlink" title="Progressive Hydration - 渐进水合"></a>Progressive Hydration - 渐进水合</h2><p><img src="/images/render-patterns/Untitled%206.png" alt="Untitled"></p><p>上文提到，常规的 SSR 通常需要完整加载客户端程序(上图的 bundle.js)，水合之后才能得到可交互页面，这就导致 <code>TTI</code> 会偏晚。</p><p>最直接的解决办法就是压缩客户端程序的体积。那么自然会想到使用<code>代码分割</code>(code splitting)技术。<br><code>渐进式水合 （Progressive Hydration ）</code> 就是这么来的。</p><p>如上图，我们使用<code>代码分割</code>的方式，将 Foo、Bar 抽取为<code>异步组件</code>，抽取后<code>主包</code>的体积下降了，<code>TTI</code> 就可以提前了。</p><p>而 Foo、Bar 可以按照一定的策略来按需加载和水合，比如在视口可见时、浏览器空闲时，或者交给 <code>React Concurrent Mode</code> 根据交互的优先级来加载。</p><p>React 18 官方支持了渐进式水合（官方叫 <code>Selective Hydration</code>）。</p><p>要深入了解 Progress Hydration, 可以看这个<a href="https://www.youtube.com/watch?v=k-A2VfuUROg&amp;t=960s" target="_blank" rel="noopener">视频</a>。</p><p><br><br><br><br><br></p><h2 id="ssr-with-streaming-流式-ssr"><a href="#ssr-with-streaming-流式-ssr" class="headerlink" title="SSR with streaming - 流式 SSR"></a>SSR with streaming - 流式 SSR</h2><p><img src="/images/render-patterns/Untitled%207.png" alt="Untitled"></p><p>这个很好理解。尤其是在最近 <code>ChatGPT</code> 这么火。ChatGPT API 有两种响应模式：普通响应、流式响应</p><ul><li><a href="https://react.dev/reference/react-dom/server/renderToString" target="_blank" rel="noopener">renderToString</a> → 普通响应。即 SSR 会等待完整的 HTML 渲染完毕后，才给客户端发送第一个字节。</li><li><a href="https://react.dev/reference/react-dom/server/renderToNodeStream" target="_blank" rel="noopener">renderToNodeStream</a> → 流式响应。渲染多少，就发送多少。就像 ChatGPT 聊天消息一样，一个字一个字的蹦，尽管接收完整消息的时间可能差不多，用户体验却相差甚远。</li></ul><p>浏览器能够很好地处理 HTML 流，快速地将内容呈现给用户，而不是白屏干等。</p><p>下面这张图可以更直观感受两者区别：</p><p><img src="/images/render-patterns/Untitled%208.png" alt="来源：[https://mxstbr.com/thoughts/streaming-ssr/](https://mxstbr.com/thoughts/streaming-ssr/)"></p><p>来源：<a href="https://mxstbr.com/thoughts/streaming-ssr/" target="_blank" rel="noopener">https://mxstbr.com/thoughts/streaming-ssr/</a></p><p>对于常规的流式 SSR，优化效果可能没有我们想象的那么明显。<strong>因为框架还是得等数据拉取完成之后才能开始渲染</strong>。因此，除非是比较复杂、长序列的 HTML 树，至上而下需要较长时间的渲染，否则效果并不明显。</p><p><br><br><br></p><p>优点</p><ul><li>相比普通响应，流式响应可以提前 TTFB 和 FCP, 浏览器不用空转等待，可以连续绘制。</li></ul><p>缺点</p><ul><li><strong>数据拉取是 TTFB/FCP 的主要阻塞原因。为了解决这个问题，下文的 <code>Selective Hydration</code> 如何巧妙地解决这个问题。</strong></li></ul><p><br><br><br><br><br></p><h2 id="selective-hydration-选择性水合"><a href="#selective-hydration-选择性水合" class="headerlink" title="Selective Hydration - 选择性水合"></a>Selective Hydration - 选择性水合</h2><p><img src="/images/render-patterns/Untitled%209.png" alt="Untitled"></p><p><code>选择性水合（Progressive Hydration）</code> 是 <code>渐进式水合(Progressive Hydration)</code> 和 <code>流式SSR(SSR with Streaming)</code> 的升级版。<strong>主要通过选择性地跳过‘<code>慢组件</code>’，避免阻塞，来实现更快的 HTML 输出， 从而让流式响应发挥应有的作用。</strong></p><blockquote><p><code>慢组件</code>通常指的是：需要异步获取数据、体积较大、或者是计算量比较复杂的组件。</p></blockquote><p>比较典型的<code>慢组件</code>是异步数据获取的组件, 如下图，未开启 Selective Hydration 的情况，会等待所有异步任务完成后才开始输出，而 Selective Hydration 可以跳过这些组件，等待它们就绪后，继续输出。</p><p><img src="/images/render-patterns/Untitled%2010.png" alt="Untitled"></p><p>我们可以在最新的 Next.js(当前是 13.4) 演示一下。</p><details><br> <summary>没有开启 Selective Hydration 的 Demo:</summary><br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function delay(time: number) &#123;</span><br><span class="line">  return new Promise((resolve) =&gt; setTimeout(resolve, time))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取关键数据</span><br><span class="line"> */</span><br><span class="line">function getCrucialData() &#123;</span><br><span class="line">  return delay(1000).then(() =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      data: Math.random(),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getData(time: number) &#123;</span><br><span class="line">  return delay(time).then(() =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      data: Math.random(),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Foo = async () =&gt; &#123;</span><br><span class="line">  const data = await getData(1000)</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;foo: &#123;data.data&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Bar = async () =&gt; &#123;</span><br><span class="line">  const data = await getData(2000)</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;bar: &#123;data.data&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 页面 🔴</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">export default async function WithoutSelective() &#123;</span><br><span class="line">  // 获取关键数据</span><br><span class="line">  const crucialData = await getCrucialData()</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Without Selective&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;This page is rendered without Selective Hydration.&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;crucial data: &#123;crucialData.data&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Foo&gt;&lt;/Foo&gt;</span><br><span class="line">      &lt;Bar&gt;&lt;/Bar&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>运行结果：浏览器等待响应的时间为 3s<br><img src="/images/render-patterns/Untitled%2011.png" alt="Untitled"><br>即所有<code>服务端组件（Server Component）</code> 就绪后才会有实际的内容输出。<br><br></details><p><br><br><br></p><p>开启 Selective Hydration 很简单，我们只需要用 Suspend 包裹起来，提示 React 这可能是一个‘慢组件’，可以跳过他：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default async function WithoutSelective() &#123;</span><br><span class="line">  // 获取关键数据</span><br><span class="line">  const crucialData = await getCrucialData()</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Without Selective&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;This page is rendered without Selective Hydration.&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;crucial data: &#123;crucialData.data&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Suspense fallback=&quot;foo loading&quot;&gt;</span><br><span class="line">        &lt;Foo&gt;&lt;/Foo&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">      &lt;Suspense fallback=&quot;bar loading&quot;&gt;</span><br><span class="line">        &lt;Bar&gt;&lt;/Bar&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>现在来看运行结果：</p><p><img src="/images/render-patterns/Untitled%2012.png" alt="Untitled"></p><p>明显 TTFB 提前了！但是完整的请求时间没变。</p><p><br></p><p>当 Foo 和 Bar 就绪后，Next.js 会将渲染结果写入流中。怎么做到的？</p><p><br></p><p>看一眼 HTML 就知道了：</p><p><img src="/images/render-patterns/Untitled%2013.png" alt="Untitled"></p><p>对于<code>慢组件</code>，React 会先渲染 Suspend 的 fallback 内容，并留一个插槽。</p><p>继续往下看，可以看到 Foo、Bar 的渲染结果：</p><p><img src="/images/render-patterns/Untitled%2014.png" alt="Untitled"></p><p>接着将渲染结果替换掉插槽。用于后续的水合。</p><p><br><br><br><br><br></p><p>总之，在服务端，Selective Hydration 在 SSR With Streaming 的基础上，通过选择性地跳过一些低优先级的慢组件来优化了 TTFB(主要的，相对于 FCP 等指标也优化了)，更快地向用户呈现页面。</p><p>在客户端 Selective Hydration 的运行过程同 Progressive Hydration 。</p><p>关于 Selective Hydration 细节，可以阅读以下文章：</p><ul><li><a href="https://github.com/reactwg/react-18/discussions/130" target="_blank" rel="noopener">New in 18: Selective Hydration</a></li><li><a href="https://github.com/reactwg/react-18/discussions/37" target="_blank" rel="noopener">New Suspense SSR Architecture in React 18</a></li></ul><p><br><br><br><br><br><br><br></p><h2 id="islands-architecture-岛屿架构"><a href="#islands-architecture-岛屿架构" class="headerlink" title="Islands Architecture - 岛屿架构"></a>Islands Architecture - 岛屿架构</h2><p><img src="/images/render-patterns/Untitled%2015.png" alt="Untitled"></p><p>近两年，<strong>去 JavaScript 成为一波小趋势</strong>，这其中的典型代表是 <code>Islands Architecture</code> (岛屿架构)和 <code>React Server Component</code>(RSC, React 服务端组件)。</p><p>它们主张是：<strong>在服务端渲染，然后去掉不必要 JavaScript</strong></p><p>岛屿架构的主要代表是 <code>Astro</code>。如上图，Astro 在服务端渲染后，<strong>默认情况下，在客户端侧没有客户端程序和水合的过程。而对于需要 JavaScript 增强，实现动态交互的组件，需要显式标记为岛屿。</strong></p><p><br></p><p>这有点类似 Progressive Hydration 的意思。但是还是有很大的差别：</p><ul><li>岛屿是在<code>去 JavaScript</code> 这个背景下的交互增强手段。按 Astro 解释是： 你可以将‘岛屿’想象成在一片由<em>静态（不可交互）的 HTML</em> 页面中的<em>动态岛屿</em></li><li>每个岛屿都是独立加载、局部水合。而 Progressive Hydration 是整棵树水合的分支，只不过延后了。</li><li>岛屿可以框架无关。</li></ul><p><br></p><p>去 JavaScript 后，可以缓解典型的 SSR <code>TTI</code> 问题。<strong>但是岛屿架构并不能通吃所有的场景，最擅长的是”内容为中心“的站点，即当静态的页面比重远高于动态比重时，去 JavaScript 的收益才是显著的。</strong></p><p><br><br><br><br><br></p><h2 id="react-server-component-react-服务端组件"><a href="#react-server-component-react-服务端组件" class="headerlink" title="React Server Component - React 服务端组件"></a>React Server Component - React 服务端组件</h2><p><img src="/images/render-patterns/Untitled%2016.png" alt="Untitled"></p><p>在笔者看来，<code>React Server Component(RSC)</code> 本质上和岛屿架构的目的是一样的，都是去 JavaScript。只是实现的手段不同。</p><p><br></p><p>这是 Next.js 官方文档的示例图：和岛屿架构类似，对于静态的内容推荐使用 <code>Server Component (SC),</code> 而需要交互增强的，可以使用 <code>Client Component (CC)</code>。</p><p><img src="/images/render-patterns/Untitled%2017.png" alt="Untitled"></p><p><br></p><p>顾名思义，RSC <strong>就是只能在服务端运行的组件</strong>。下面简单对比一下两者的区别：</p><table><thead><tr><th></th><th>Server Component</th><th>Client Component</th></tr></thead><tbody><tr><td>运行环境</td><td>服务端</td><td>- 服务端 + 客户端</td></tr><tr><td>- 仅客户端</td></tr><tr><td>JavaScript</td><td>服务端组件依赖的相关程序对客户端不可见。</td></tr><tr><td>在这里实现了 ‘去 JavaScript’</td><td>需要打包分发给客户端</td></tr><tr><td>水合</td><td>不需要水合</td><td>需要水合</td></tr><tr><td>支持 async</td><td>Y</td><td>N</td></tr><tr><td>支持状态(state, context)</td><td>N</td><td>Y</td></tr><tr><td>支持事件、副作用</td><td>N</td><td>Y</td></tr></tbody></table><blockquote><p>RSC 优点类似 React Hooks 出来之前的<a href="https://web.archive.org/web/20170621181013/https://facebook.github.io/react/docs/components-and-props.html" target="_blank" rel="noopener">函数组件</a>: 就是一个普通的函数，不能使用 hooks，没有状态，只会被调用一次。</p></blockquote><p>你可以通过 <a href="https://nextjs.org/docs/getting-started/react-essentials" target="_blank" rel="noopener">Next.js 的文档</a>，深入学习 RSC。React 官方的<a href="https://github.com/reactwg/server-components/discussions" target="_blank" rel="noopener">讨论组</a>也是不错的一手学习场地。</p><p><br><br><br></p><p><strong>那么相比岛屿架构呢？</strong></p><p>优点</p><ul><li>Server Component 和 Client Component 都是 React 框架的组件，尽管有些区别，但是心智模型是统一的。</li><li>React Server Component 是 React 框架下一体化的原生解决方案，支持和 Selective Hydration 配合使用。岛屿架构只是一个架构模式。</li><li>可以进行更细粒度和更灵活的组合。</li></ul><p>缺点</p><ul><li>Server Component 和 Client Component 还是有较大差别，在组合、通信上也有较多限制，需要开发者规划好服务端和客户端的边界。初期有一定上手门槛。<br>当然，Islands 可能也有类似的问题。</li></ul><p><br><br><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文篇幅较长，我给大家整理了这些渲染模式的发展历程和关系脉络</p><p><img src="/images/render-patterns/Untitled%2018.png" alt="Untitled"></p><p>任何技术的迭代都是有其动机和脉络。不推荐大家面向热度编程，大部分情况下，做到‘知其然，也知其所以然’，就足够了。</p><p><br><br><br><br><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://www.patterns.dev/posts/react-selective-hydration" target="_blank" rel="noopener">Pattern dev</a></li><li><a href="https://nextjs.org/docs/getting-started/react-essentials" target="_blank" rel="noopener">Next.js</a></li><li><a href="https://nextjs.org/docs/pages/building-your-application/data-fetching/incremental-static-regeneration" target="_blank" rel="noopener">Next.js Incremental Static RegenerationExamples</a></li><li><a href="https://github.com/reactwg/server-components/discussions" target="_blank" rel="noopener">reactwg/<strong>server-components</strong></a></li><li><strong><a href="https://dev.to/this-is-learning/is-0kb-of-javascript-in-your-future-48og" target="_blank" rel="noopener">Is 0kb of JavaScript in your Future?</a></strong></li><li><a href="https://jasonformat.com/islands-architecture/" target="_blank" rel="noopener">Islands Architecture</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文主要参考的内容来源是&lt;a href=&quot;https://www.patterns.dev/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;patterns.dev&lt;/a&gt;。这个网站收录了许多实用的前端设计模式，大家赶紧收藏起来！
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>岛屿架构</title>
    <link href="https://bobi.ink/2023/06/01/island-pattern/"/>
    <id>https://bobi.ink/2023/06/01/island-pattern/</id>
    <published>2023-05-31T16:00:00.000Z</published>
    <updated>2023-06-01T10:07:58.113Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1516091877740-fde016699f2c?ixlib=rb-4.0.3&amp;q=85&amp;fm=jpg&amp;crop=entropy&amp;cs=srgb&amp;w=6000" alt="https://images.unsplash.com/photo-1516091877740-fde016699f2c?ixlib=rb-4.0.3&amp;q=85&amp;fm=jpg&amp;crop=entropy&amp;cs=srgb&amp;w=6000"></p><p>好久没跟大家见面了。这两三年一直专注于公司的开发工作，做了很多事情，但回头看看，感觉这两年一直在吃 ’老本‘，前端相关的技术也没怎么追了。</p><p>现在重新捡起笔吧！补补课，记录一些最近学到的新东西，以及过去几年总结。</p><p>首先从岛屿架构开始吧。</p><h2 id="岛屿架构"><a href="#岛屿架构" class="headerlink" title="岛屿架构"></a>岛屿架构</h2><p>岛屿架构(<a href="https://www.patterns.dev/posts/islands-architecture" target="_blank" rel="noopener">Islands Architecture</a>) 如今已经不是新鲜的概念了，社区上已经有了较多成熟的方案。</p><p>概览图：</p><p><img src="/images/island-pattern/Untitled.png" alt="Untitled"></p><p><br><br><br><br><br></p><p>这其中的典型代表是 <a href="https://docs.astro.build/zh-cn/concepts/islands/" target="_blank" rel="noopener">Astro</a>。Astro 对岛屿架构的解释，也非常直观：</p><blockquote><p>“Astro 群岛“指的是<code>静态 HTML</code> 中的<code>交互性的 UI 组件</code>。一个页面上可以有多个岛屿，并且每个岛屿都被<code>独立呈现</code>。<strong>你可以将它们想象成在一片由静态（不可交互）的 HTML 页面中的动态岛屿</strong>。</p></blockquote><p>从上面这句话的定义中可以提炼一些要点：</p><ul><li>静态 HTML。</li><li>交互性的 UI 组件。</li><li>多个岛屿，支持独立呈现。</li></ul><p><br><br><br></p><p>为了解析这些要点，我们还是得简单了解一下 Astro 这个框架的特性。</p><p>Astro 宣称自己是 ‘<strong><code>zero-JS frontend architecture</code></strong>’，即 Astro 在服务端渲染静态 HTML，客户端中不需要加载额外的 JS 就能完整呈现内容。</p><p><br><br><br><br><br><br><br></p><hr><p>写一个简单 DEMO 试试：</p><p>React 组件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; useState &#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">export const Counter = () =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0)</span><br><span class="line"></span><br><span class="line">  return &lt;div onClick=&#123;() =&gt; setCount((i) =&gt; i + 1)&#125;&gt;click me to increment: &#123;count&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Astro 文件：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">import Layout from '../layouts/Layout.astro';</span><br><span class="line">import Card from '../components/Card.astro';</span><br><span class="line">import &#123; Counter &#125; from '../components/Counter';</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Layout</span> <span class="attr">title</span>=<span class="string">"Welcome to Astro."</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">role</span>=<span class="string">"list"</span> <span class="attr">class</span>=<span class="string">"link-card-grid"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Card</span></span></span><br><span class="line"><span class="tag">        <span class="attr">href</span>=<span class="string">"https://docs.astro.build/"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">title</span>=<span class="string">"Documentation"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">body</span>=<span class="string">"Learn how Astro works and explore the official API docs."</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Card</span></span></span><br><span class="line"><span class="tag">        <span class="attr">href</span>=<span class="string">"https://astro.build/integrations/"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">title</span>=<span class="string">"Integrations"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">body</span>=<span class="string">"Supercharge your project with new frameworks and libraries."</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  ...;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这语法，astro 集大家之所长，吸取了 Vue SFC 和 React 的 JSX, 还有 MDX。</p><p><img src="/images/island-pattern/Untitled%201.png" alt="Untitled"></p><p>运行后， 服务端直出 HTML，除了 HMR ，没有引入额外的 JavaScript。真 Zero JS!</p><p><br><br><br><br><br></p><hr><p>然而，这个有别于典型的 SSR 框架。SSR 也是在服务端渲染完整 HTML 树，但是在客户端依然需要加载完整的视图框架代码，然后进行水合(Hydration)，才能让页面变得可交互:</p><p><img src="/images/island-pattern/Untitled%202.png" alt="Untitled"></p><p>那 Astro 没有 JS，显然是无法与用户进行动态交互的。Astro 的解决办法就是 <code>岛屿架构</code>, 我们只需将需要动态交互的页面模块声明为岛屿，如下图，页头和图片轮播就是可交互的岛屿。</p><p><img src="/images/island-pattern/Untitled%203.png" width="400px"></p><p>来源：astro 文档</p><p><br><br><br><br><br><br><br></p><hr><p>现在将 React 组件声明为岛屿：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">---</span></span><br><span class="line">import Layout from '../layouts/Layout.astro';</span><br><span class="line">import Card from '../components/Card.astro';</span><br><span class="line">import &#123; Counter &#125; from '../components/Counter';</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"></span><br><span class="line">&lt;Layout title="Welcome to Astro."&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line"><span class="deletion">-    &lt;Counter/&gt;</span></span><br><span class="line"><span class="addition">+    &lt;Counter client:load /&gt;</span></span><br><span class="line">    &lt;ul role="list" class="link-card-grid"&gt;</span><br><span class="line">      &lt;Card</span><br><span class="line">        href="https://docs.astro.build/"</span><br><span class="line">        title="Documentation"</span><br><span class="line">        body="Learn how Astro works and explore the official API docs."</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Card</span><br><span class="line">        href="https://astro.build/integrations/"</span><br><span class="line">        title="Integrations"</span><br><span class="line">        body="Supercharge your project with new frameworks and libraries."</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">&lt;/Layout&gt;</span><br></pre></td></tr></table></figure><p>我们只需将对应的 React 组件加上 <code>client:load</code> 指令，Astro 就是将其识别为岛屿，该 React 组件的代码及其相关依赖会被打包到一起，在客户端端加载和水合。</p><p><img src="/images/island-pattern/Untitled%204.png" alt="Untitled"></p><p>现在我们的 Counter 组件在客户端就是一个可交互的状态了。Astro 基本上没有什么上手门槛，建议读者自己玩一下。有机会再展开讲一下它的实现原理。</p><hr><p><br><br><br><br><br></p><p>有了‘岛屿’赋能的 Astro 架构：</p><p><img src="/images/island-pattern/Untitled%205.png" alt="Untitled"></p><p>Astro 在服务端渲染完整的 HTML 树，然后在客户端中按需加载岛屿代码，并进行水合。看起来有点像微前端、或者 iframe 这样的机制。</p><p>现在来回顾一下开头提到的 <code>‘要点’</code>：</p><table><thead><tr><th></th><th>岛屿架构</th><th>SSR + CSR</th><th>CSR</th></tr></thead><tbody><tr><td>静态 HTML</td><td>静态 HTML 优先，无 JavaScript</td><td>服务端渲染 HTML 初始内容, 包含完整的客户端副本</td><td>完全在客户端加载渲染</td></tr><tr><td>交互性的 UI 组件</td><td>默认完全静态，通过岛屿局部增强可交互性</td><td>全局可交互</td><td>全局可交互</td></tr><tr><td>多个岛屿，支持独立呈现</td><td>岛屿之间互相独立，可以独立加载和交互</td><td>完整加载。可以通过代码分块 + <a href="https://www.patterns.dev/posts/progressive-hydration" target="_blank" rel="noopener">https://www.patterns.dev/posts/progressive-hydration</a> 实现按需加载</td><td>完整加载。可以通过代码分块实现按需加载</td></tr></tbody></table><p><br><br><br><br><br></p><h2 id="岛屿架构的优势"><a href="#岛屿架构的优势" class="headerlink" title="岛屿架构的优势"></a>岛屿架构的优势</h2><p>岛屿架构非常适合<code>以内容为中心</code>的网站，比如博客，文档网站，新闻网站等等。在 Astro 的定位非常清晰，它把站点类型分为两种：</p><ul><li>内容为中心 → 也称为 网站 → Astro 擅长</li><li>交互为中心的 → 也称为 Web 应用程序 → 应该使用 Next.js 或者 Nuxt.js 这样的框架</li></ul><p>在岛屿架构擅长的场景中，Astro 给出了比较：</p><ul><li><a href="https://twitter.com/t3dotgg/status/1437195415439360003" target="_blank" rel="noopener">Astro vs. SPA (Next.js)</a> - 94% less JavaScript</li><li><a href="https://twitter.com/jlengstorf/status/1442707241627385860?lang=en" target="_blank" rel="noopener">Astro vs. SPA (Next.js)</a> - 34% 更快地加载</li><li><a href="https://vanntile.com/blog/next-to-astro" target="_blank" rel="noopener">Astro vs. SPA (Next.js)</a> – 65% 网络使用减少</li><li><a href="https://www.youtube.com/watch?v=2ZEMb_H-LYE&amp;t=8163s" target="_blank" rel="noopener">Astro vs. SPA (Remix, SvelteKit)</a> - “这令人置信的 Google Lighthouse 分数”</li><li><a href="https://www.youtube.com/watch?v=2ZEMb_H-LYE&amp;t=8504s" target="_blank" rel="noopener">Astro vs. Qwik</a> - 43% 更快的 TTI</li></ul><p><br><br><br><br><br></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>岛屿架构本身概念并不复杂，是前端框架和工程化发展的一个阶段性质变结果。</p><p>前后端分离(分工上)还是不变的趋势，相比传统的 MPA ，岛屿架构更加现代化，拥有更好的开发体验。</p><p>相比 SPA，岛屿架构在<code>以内容为中心</code>的场景下，优势也非常明显。</p><p><br><br><br><br><br></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.patterns.dev/posts/islands-architecture" target="_blank" rel="noopener">Islands Architecture</a></li><li><a href="https://jasonformat.com/islands-architecture/" target="_blank" rel="noopener">Islands Architecture</a></li><li><a href="https://www.youtube.com/watch?v=k-A2VfuUROg" target="_blank" rel="noopener">Rendering on the Web: Performance Implications of Application Architecture</a></li><li><a href="https://dev.to/this-is-learning/is-0kb-of-javascript-in-your-future-48og" target="_blank" rel="noopener">Is 0kb of JavaScript in your Future?</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1516091877740-fde016699f2c?ixlib=rb-4.0.3&amp;amp;q=85&amp;amp;fm=jpg&amp;amp;crop=entropy&amp;amp;cs=srgb&amp;am
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Electron 低延迟视频流播放方案探索</title>
    <link href="https://bobi.ink/2020/04/05/video-stream/"/>
    <id>https://bobi.ink/2020/04/05/video-stream/</id>
    <published>2020-04-04T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.331Z</updated>
    
    <content type="html"><![CDATA[<p>好久不见，接近四个月没更新博客了! </p><p>去年<a href="https://juejin.im/post/5e0010866fb9a015fd69c645#comment" target="_blank" rel="noopener">最后一篇</a>文章介绍了我们的 Electron 桌面客户端的一些优化措施，这篇文章也跟我们正在开发的 Electron 客户端有一定关系。最近我们正在预研在 Electron 页面中实时播放会议视频流的方案。</p><p><br></p><p><img src="/images/video-push/conf.jpeg" alt></p><p><br></p><p>视频会议界面是最后一块没有被 Web 取代的页面, 它完全用原生开发的，所以开发效率比较低，比如要做一些动画效果开发很痛苦，难以响应多变的产品需求。所以我们在想: <strong>能不能将 Web 页面端来播放底层库 WebRTC 接收到的视频流</strong>? <strong>或者为什么不直接通过浏览器的 WebRTC API 来进行通讯呢</strong>？</p><p>先回答后者，因为我们视频会议这块的逻辑处理、音视频处理已经被抽取成独立的、跨平台的模块，统一进行维护；另外浏览器的 WebRTC API 提供的接口非常高级，就像一个黑盒一样，无法定制化、扩展，遇到问题也很难诊断和处理, 受限于浏览器。最大的原因还是变动有点大，时间上不允许。</p><p>因此目前只能选前者，即底层库给 Electron 页面推送视频流，在页面实时播放。 再此之前，笔者几乎没有接触过音视频开发，我能想到的是通过类似直播的方式，底层库作为”主播端”, Web 页面作为”观众端”。</p><p><img src="/images/video-push/overall.png" alt></p><p><br></p><p>因为视频流只是在本地进行转发，所以我们不需要考虑各种复杂的网络情况、带宽限制。唯一的要求是低延迟，低资源消耗：</p><ul><li>我们视频会议语音和视频是分离的。 只有一路混合语音，通过 SIP 传输。而会议视频则可能存在多路，使用 WebRTC 进行传输。我们不需要处理语音(由底层库直接播放), 这就要求我们的视频播放延迟不能太高, 出现语音和视频不同步。</li><li>不需要考虑浏览器兼容性。Electron 浏览器版本为 Chrome 80</li><li>本地转发，不需要考虑网络情况、带宽限制</li></ul><p><br><br><br></p><p><strong>最近因为工作需要才有机会接触到音视频相关的知识，我知道的只是皮毛，所以文章肯定存在不少问题，敬请斧正</strong>。下面，跟着音视频小白的我，一起探索探索有哪些方案。</p><p><br><br><br></p><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#①-典型的web直播方案">① 典型的Web直播方案</a><ul><li><a href="#rtmp-推流">RTMP 推流</a></li><li><a href="#rtmp-拉流">RTMP 拉流</a></li><li><a href="#rtmp-低延迟优化">RTMP 低延迟优化</a></li></ul></li><li><a href="#②-jsmpeg--broadwayjs">② JSMpeg &amp; BroadwayJS</a><ul><li><a href="#relay-服务器">Relay 服务器</a></li><li><a href="#推送">推送</a></li><li><a href="#视频播放">视频播放</a></li><li><a href="#多进程优化">多进程优化</a></li><li><a href="#简单说一下-broadwayjs">简单说一下 Broadway.js</a></li></ul></li><li><a href="#③-直接渲染-yuv">③ 直接渲染 YUV</a></li><li><a href="#扩展阅读">扩展阅读</a></li></ul><!-- /TOC --><p><br><br><br></p><h2 id="①-典型的web直播方案"><a href="#①-典型的web直播方案" class="headerlink" title="① 典型的Web直播方案"></a>① 典型的Web直播方案</h2><p>Web 直播有很多方案(参考这篇文章：<a href="https://imweb.io/topic/5a542e43a192c3b460fce3a8" target="_blank" rel="noopener">《Web 直播，你需要先知道这些》</a>):</p><ul><li><strong>RTMP (Real Time Messaging Protocol)</strong> 属于 Adobe。延时低，实时性较好。不过浏览器需要借助 Flash 才能播放; 但是我们也可以转换成 HTTP/Websocket 流喂给 <a href="https://github.com/bilibili/flv.js/tree/master/docs" target="_blank" rel="noopener"><code>flv.js</code></a> 实现播放。</li><li><strong>RTP (Real-time Transport Protocol)</strong> <a href="https://www.jianshu.com/p/17997567d828" target="_blank" rel="noopener">WebRTC 底层就基于 RTP/RTCP</a>。实时性非常好，适用于视频监控、视频会议、IP 电话。</li><li><strong>HLS (Http Live Streaming)</strong> 苹果提出的基于 HTTP 的流媒体传输协议。Safari 支持较好，高版本 Chrome 也支持，也有一些比较成熟的第三方方案。</li></ul><p><br></p><p>HLS 延迟太高，不符合我们的要求，所以一开始就放弃了。搜了很多资料，很多都是介绍 RTMP 的，可见 RTMP 在国内采用有多广泛, 因此我们打算试试:</p><p><br></p><p>首先是搭建 RMTP 服务器，可以直接基于 <a href="https://github.com/illuspas/Node-Media-Server" target="_blank" rel="noopener">Node-Media-Server</a>，代码很简单:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NodeMediaServer = <span class="built_in">require</span>(<span class="string">'node-media-server'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// RMTP 服务器, 用于RTMP 推流和拉流</span></span><br><span class="line">  rtmp: &#123;</span><br><span class="line">    port: <span class="number">1935</span>, <span class="comment">// 1935 是RTMP的标准端口</span></span><br><span class="line">    chunk_size: <span class="number">0</span>,</span><br><span class="line">    gop_cache: <span class="literal">false</span>,</span><br><span class="line">    ping: <span class="number">30</span>,</span><br><span class="line">    ping_timeout: <span class="number">60</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// HTTP / WebSocket 流，暴露给 flv.js</span></span><br><span class="line">  http: &#123;</span><br><span class="line">    port: <span class="number">8000</span>,</span><br><span class="line">    allow_origin: <span class="string">'*'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nms = <span class="keyword">new</span> NodeMediaServer(config)</span><br><span class="line">nms.run()</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="rtmp-推流"><a href="#rtmp-推流" class="headerlink" title="RTMP 推流"></a>RTMP 推流</h3><p><a href="http://www.ffmpeg.org" target="_blank" rel="noopener"><code>ffmpeg</code></a> 是音视频开发的必备神器，本文将通过它来捕获摄像头，进行各种转换和处理，最后进行视频流推送。 下面看看怎么用 ffmpeg 进行 RTMP 推流。</p><p>首先进行视频采集，下面命令列举所有支持的设备类型：</p><blockquote><p>本文的所有命令都在 macOS 下面执行, 其他平台用法差不多，自行搜索</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -devices</span></span><br><span class="line">Devices:</span><br><span class="line"> D. = Demuxing supported</span><br><span class="line"> .E = Muxing supported</span><br><span class="line"> --</span><br><span class="line"> D  avfoundation    AVFoundation input device</span><br><span class="line"> D  lavfi           Libavfilter virtual input device</span><br><span class="line">  E sdl,sdl2        SDL2 output device</span><br></pre></td></tr></table></figure><p><br></p><p><code>macOS</code> 下通常使用 <code>avfoundation</code> 进行设备采集, 下面列举当前终端所有支持的输入设备:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> fmpeg -f avfoundation -list_devices <span class="literal">true</span> -i <span class="string">""</span></span></span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] AVFoundation video devices:</span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] [0] FaceTime HD Camera</span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] [1] Capture screen 0</span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] AVFoundation audio devices:</span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] [0] Built-in Microphone</span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] [1] Boom2Device</span><br></pre></td></tr></table></figure><p><br></p><p>我们将使用 <code>FaceTime HD Camera</code> 这个输入设备来采集视频，并推送 RTMP 流：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -r 30 -i <span class="string">"FaceTime HD Camera"</span> -c:v libx264 -preset superfast -tune zerolatency -an -f flv rtmp://localhost/live/<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p><br></p><p>稍微解释一下上面的命令:</p><ul><li><code>-f avfoundation -r 30 -i &quot;FaceTime HD Camera&quot;</code> 表示从 <code>FaceTime HD Camera</code> 中以 30 fps 的帧率采集视频</li><li><code>-c:v libx264</code> 输出视频的编码格式是 H.264,  RTMP 通常采用H.264 编码</li><li><code>-f flv</code> 指的视频的封包格式, RTMP 一般采用 flv 封包格式。</li><li><code>-an</code> 忽略音频流</li><li><code>-preset superfast -tune zerolatency</code> H.264 的转码预设参数和调优参数。会影响视频质量和压缩率</li></ul><p><br></p><blockquote><p><strong>封包格式(format)</strong>和<strong>编码(codec)</strong>是音视频开发中最基础的概念。<br><br><br><strong>封包格式</strong>: 相当于一种储存视频信息的容器，将编码好的音频、视频、或者是字幕、脚本之类的文件根据相应的规范组合在一起，从而生成一个封装格式的文件。常见的封包格式有 avi、mpeg、flv、mov 等<br><br><br><strong>编码格式</strong>: 编码主要的目的是为了压缩。从设备采集到的音视频流称为裸码流(rawvideo 格式, 即没有经过编码压缩处理的数据)。举例：一个 720p，30fps，60min 的电影，裸流大小为：12Bx1280x720x30x60x100 = 1.9T。这不管在文件系统上存储、还是在网络上传输，成本都太高了，所以我们需要编码压缩。 H264 是目前最常见的编码格式之一。</p></blockquote><p><br><br><br></p><h3 id="rtmp-拉流"><a href="#rtmp-拉流" class="headerlink" title="RTMP 拉流"></a>RTMP 拉流</h3><p>最简单的，我们可以使用 <a href="http://www.ffmpeg.org/ffplay.html" target="_blank" rel="noopener"><code>ffplay</code></a> (ffmpeg 提供的工具套件之一) 播放器来测试推流和拉流是否正常:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffplay rtmp://localhost/live/<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p><br></p><p>Flash 已经过时， 为了在 Web 页面中实现 RTMP 流播放，我们还要借助 <a href="https://github.com/bilibili/flv.js" target="_blank" rel="noopener"><code>flv.js</code></a>。 flvjs 估计大家都很熟悉(花边：如何看待哔哩哔哩的 flv.js 作者月薪不到 5000 元？)，它是 B 站开源的 flv 播放器。按照官方的介绍：</p><blockquote><p>flv.js works by transmuxing FLV file stream into ISO BMFF (Fragmented MP4) segments, followed by feeding mp4 segments into an HTML5 <code>&lt;video&gt;</code> element through <code>Media Source Extensions API</code>.</p></blockquote><p><br></p><p>上面提到，flv(Flash Video) 是一个视频封包格式，<code>flvjs</code> 做的就是<strong>把 flv 转换成 Fragmented MP4(ISO BMFF) 封包格式</strong>，然后喂给<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Media_Source_Extensions_API" target="_blank" rel="noopener">Media Source Extension API, MSE</a>, 接着我们将 MSE 挂载到 <code>&lt;video&gt;</code> 就可以直接播放了, 它的架构如下:</p><p><br></p><p><img src="/images/video-push/flv-arch.png" alt></p><p><br><br><br></p><p>flvjs 支持通过 HTTP Streaming、 WebSocket 或者自定义数据源等多种形式拉取二进制视频流。下面示例通过 flvjs 来拉取 <code>node-media-server</code> 的视频流:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/flv.js/1.5.0/flv.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;video id=<span class="string">"video"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span></span><br><span class="line">&lt;button id=<span class="string">"play"</span>&gt;play&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  if (flvjs.isSupported()) &#123;</span></span><br><span class="line"><span class="regexp">    const videoElement = document.getElementById('video');</span></span><br><span class="line"><span class="regexp">    const play = document.getElementById('play');</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    const flvPlayer = flvjs.createPlayer(</span></span><br><span class="line"><span class="regexp">      &#123;</span></span><br><span class="line"><span class="regexp">        type: 'flv',</span></span><br><span class="line"><span class="regexp">        isLive: true,</span></span><br><span class="line"><span class="regexp">        hasAudio: false,</span></span><br><span class="line"><span class="regexp">        url: 'ws:/</span><span class="regexp">/localhost:8000/</span>live/test.flv<span class="string">',</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        enableStashBuffer: true,</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    flvPlayer.attachMediaElement(videoElement);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    play.onclick = () =&gt; &#123;</span></span><br><span class="line"><span class="string">      flvPlayer.load();</span></span><br><span class="line"><span class="string">      flvPlayer.play();</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>完整示例代码在<a href="https://github.com/ivan-94/video-push/tree/master/rtmp" target="_blank" rel="noopener">这里</a></p></blockquote><p><br><br><br></p><h3 id="rtmp-低延迟优化"><a href="#rtmp-低延迟优化" class="headerlink" title="RTMP 低延迟优化"></a>RTMP 低延迟优化</h3><p><strong>推流端</strong></p><p><code>ffmpeg</code> 推流端可以通过一些控制参数来降低推流的延迟，主要优化方向是提高编码的效率、减少缓冲大小，当然有时候要牺牲一些代码质量和带宽。 这篇文章 <a href="https://blog.csdn.net/fireroll/article/details/51902018" target="_blank" rel="noopener">ffmpeg 的转码延时测试与设置优化</a> 总结了一些优化措施可以参考一下:</p><ul><li>关闭 sync-lookahead</li><li>降低 rc-lookahead，但别小于 10,默认是-1</li><li>降低 threads(比如从 12 降到 6)</li><li>禁用 rc-lookahead</li><li>禁用 b-frames</li><li>缩小 GOP</li><li>开启 x264 的 -preset fast/faster/verfast/superfast/ultrafast 参数</li><li>使用-tune zerolatency 参数</li></ul><p><br></p><p><strong>node-media-server</strong></p><p>NMS 也可以通过降低缓冲大小和<a href="https://github.com/ossrs/srs/wiki/v1_CN_LowLatency" target="_blank" rel="noopener">关闭 GOP Cache</a> 来优化延迟。</p><p><br></p><p><strong>flvjs 端</strong></p><p>flvjs 可以开启 <code>enableStashBuffer</code> 来提高实时性。 实际测试中，flvjs 可能会出现’累积延迟’现象，可以通过<a href="https://github.com/bilibili/flv.js/issues/258" target="_blank" rel="noopener">手动 seek</a>来纠正。</p><p><br><br><br></p><p>经过一番折腾，优化到最好的延迟是 400ms，往下就束手无策了(对这块熟悉的同学可以请教一下)。而且在对接到底层库实际推送时，播放效果并不理想，出现各种卡顿、延迟。由于时间和知识有限，我们很难定位到具体的问题在哪， 所以我们暂时放弃了这个方案。</p><p><br><br><br></p><h2 id="②-jsmpeg-amp-broadwayjs"><a href="#②-jsmpeg-amp-broadwayjs" class="headerlink" title="② JSMpeg &amp; BroadwayJS"></a>② JSMpeg &amp; BroadwayJS</h2><p>Jerry Qu 写得 <a href="https://imququ.com/post/html5-live-player-2.html" target="_blank" rel="noopener">《HTML5 视频直播（二）》</a> 给了我不少启发，得知了 <a href="https://github.com/phoboslab/jsmpeg" target="_blank" rel="noopener"><code>JSMpeg</code></a> 和 <a href="https://github.com/mbebenita/Broadway" target="_blank" rel="noopener"><code>Broadwayjs</code></a> 这些方案</p><p><strong>这两个库不依赖于浏览器的 video 的播放机制，使用纯 JS/WASM 实现视频解码器，然后直接通过 Canvas2d 或 WebGL 绘制出来</strong>。Broadwayjs 目前不支持语音，JSMpeg 支持语音(基于 WebAudio)。</p><p><br></p><p>经过简单的测试, 相比 RTMP， JSMpeg 和 BroadwayJS 延迟都非常低，基本符合我们的要求。下面简单介绍一下 JSMpeg 用法。Broadwayjs 用法差不多, 下文会简单带过。它们的基本处理过程如下：</p><p><br></p><p><img src="/images/video-push/jsmpeg.png" alt></p><p><br></p><h3 id="relay-服务器"><a href="#relay-服务器" class="headerlink" title="Relay 服务器"></a>Relay 服务器</h3><p>因为 ffmpeg 无法向 Web 直接推流，因此我们还是需要创建一个中转（relay）服务器来接收视频推流，再通过 WebSocket 转发给页面播放器。</p><p>ffmpeg 支持 HTTP、TCP、UDP 等各种推流方式。HTTP 推流更方便我们处理, 因为是本地环境，这些网络协议不会有明显的性能差别。</p><p>下面创建一个 HTTP 服务器来接收推流，推送路径是 <code>/push/:id</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.server = http</span><br><span class="line">  .createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = req.url || <span class="string">'/'</span></span><br><span class="line">    <span class="keyword">if</span> (!url.startsWith(<span class="string">'/push/'</span>)) &#123;</span><br><span class="line">      res.statusCode = <span class="number">404</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> id = url.slice(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止超时</span></span><br><span class="line">    res.connection.setTimeout(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转发出去</span></span><br><span class="line">    req.on(<span class="string">'data'</span>, (c) =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.broadcast(id, c)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    req.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(port)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>接着通过 <code>WebSocket</code> 将流转发出去, 页面可以通过 <code>ws://localhost:PORT/pull/{id}</code> 拉取视频流:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 webSocket 拉取流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">this</span>.wss = <span class="keyword">new</span> ws.Server(&#123;</span><br><span class="line">  server: <span class="keyword">this</span>.server,</span><br><span class="line">  <span class="comment">// 通过 /pull/&#123;id&#125; 拉流</span></span><br><span class="line">  verifyClient: <span class="function">(<span class="params">info, cb</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (info.req.url &amp;&amp; info.req.url.startsWith(<span class="string">'/pull'</span>)) &#123;</span><br><span class="line">      cb(<span class="literal">true</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cb(<span class="literal">false</span>, <span class="literal">undefined</span>, <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.wss.on(<span class="string">'connection'</span>, (client, req) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> url = req.url</span><br><span class="line">  <span class="keyword">const</span> id = url.slice(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;prefix&#125;</span>new player attached: <span class="subst">$&#123;id&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> buzy = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> listener = &#123;</span><br><span class="line">    id,</span><br><span class="line">    onMessage: <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 推送</span></span><br><span class="line">      <span class="keyword">if</span> (buzy) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      buzy = <span class="literal">true</span></span><br><span class="line">      client.send(data, &#123; <span class="attr">binary</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span> <span class="title">ack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        buzy = <span class="literal">false</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.attachListener(listener)</span><br><span class="line"></span><br><span class="line">  client.on(<span class="string">'close'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;prefix&#125;</span> player dettached: <span class="subst">$&#123;id&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">this</span>.detachListener(listener)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p>这里同样使用 ffmpeg 作为推送示例:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -r 30 -i <span class="string">"FaceTime HD Camera"</span> -f mpegts -codec:v mpeg1video -an  -bf 0 -b:v 1500k -maxrate 2500k http://localhost:9999/push/<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p>稍微解释一下 ffmpeg 命令</p><ul><li><code>-f mpegts -codec:v mpeg1video -an</code> 指定使用 MPEG-TS 封包格式， 并使用 mpeg1 视频编码，忽略音频</li><li><code>-bf 0</code> JSMpeg 解码器暂时不能正确地处理 B 帧。所以这些将 B 帧禁用。关于什么是 I/B/P 帧, 参考这篇<a href="https://www.jianshu.com/p/b3d1004229db" target="_blank" rel="noopener">文章</a></li><li><code>-b:v 1500k -maxrate 2500k</code> 设置推流的平均码率和最大码率。经过测试，JSMpeg 码率过高容易出现花屏和数组越界崩溃。</li></ul><p>另外 JSMpeg 还要求，视频的宽度必须是 2 的倍数。ffmpeg 可以通过滤镜(filter)或设置视频尺寸(-s)来解决这个问题, 不过多余转换都要消耗一定 CPU 资源的：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i in.mp4 -f mpeg1video -vf "crop=iw-mod(iw\,2):ih-mod(ih\,2)" -bf 0 out.mpg</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"video-canvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jsmpeg.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'video-canvas'</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> url = <span class="string">'ws://localhost:9999/pull/test'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> player = <span class="keyword">new</span> JSMpeg.Player(url, &#123;</span></span><br><span class="line"><span class="undefined">    canvas: canvas,</span></span><br><span class="line"><span class="javascript">    audio: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">    pauseWhenHidden: <span class="literal">false</span>,</span></span><br><span class="line"><span class="undefined">    videoBufferSize: 8 * 1024 * 1024,</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>API 很简单，上面我们传递一个画布给 JSMpeg，禁用了 Audio, 并设置了一个较大的缓冲区大小, 来应对一些码率波动。</p><p><br></p><blockquote><p>完整代码见<a href="https://github.com/ivan-94/video-push/tree/master/jsmpeg" target="_blank" rel="noopener">这里</a></p></blockquote><p><br><br><br></p><h3 id="多进程优化"><a href="#多进程优化" class="headerlink" title="多进程优化"></a>多进程优化</h3><p>实际测试下来，JSMpeg 视频延迟在 100ms - 200ms 之间。当然这还取决于视频的质量、终端的性能等因素。</p><p>受限于终端性能以及解码器效率, 对于平均码率(笔者粗略测试大概为 2000k)较高的视频流，JSMpeg 有很大概率会出现花屏或者内存访问越界问题(memory access out of bounds)。</p><p><img src="/images/video-push/jsmpeg-problems.png" alt></p><p><br></p><p>因此我们不得不通过压缩视频的质量、降低视频分辨率等手段来降低视频码率。然而这并不能根本解决问题，这是使用 JSMpeg 的痛点之一。详见<a href="https://github.com/phoboslab/jsmpeg#performance-considerations" target="_blank" rel="noopener">JSMpeg 的性能说明</a></p><p><br></p><p>因为解码本身是一个 CPU 密集型的操作，且由浏览器来执行，CPU 占用还是挺高的(笔者机器单个页面单个播放器, CPU 占用率在 16%左右)，而且 JSMpeg 播放器一旦异常崩溃会难以恢复。</p><p>在我们的实际应用场景中，一个页面可能会播放多路视频, 如果所有视频都在浏览器主进程中进行解码渲染，页面操作体验会很差。 所以最好是将 JSMpeg 分离到 Worker 中, <strong>一来保证主进程可以响应用户的交互，二来 JSMpeg 崩溃不会连累主进程</strong>。</p><p>好在将 JSMpeg 放在 Worker 中执行容易: Worker 中支持独立 WebSocket 请求，另外 Canvas 通过 <code>transferControlToOffscreen()</code> 方法创建 <code>OffscreenCanvas</code> 对象并传递给 Worker，实现 canvas 离屏渲染。</p><p>先来看看 <code>worker.js</code>, 和上面的代码差不多，主要是新增了 worker 通讯:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">importScripts(<span class="string">'./jsmpeg.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.window = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'message'</span>, (evt) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = evt.data</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (data.type) &#123;</span><br><span class="line">    <span class="comment">// 创建播放器</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'create'</span>:</span><br><span class="line">      <span class="keyword">const</span> &#123; url, canvas, ...config &#125; = data.data</span><br><span class="line">      <span class="keyword">this</span>.id = url</span><br><span class="line">      <span class="keyword">this</span>.player = <span class="keyword">new</span> JSMpeg.Player(url, &#123;</span><br><span class="line">        canvas,</span><br><span class="line">        audio: <span class="literal">false</span>,</span><br><span class="line">        pauseWhenHidden: <span class="literal">false</span>,</span><br><span class="line">        videoBufferSize: <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>,</span><br><span class="line">        ...config,</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁播放器</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'destroy'</span>:</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.player) &#123;</span><br><span class="line">          <span class="keyword">this</span>.player.destroy()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.postMessage(&#123; <span class="attr">type</span>: <span class="string">'destroyed'</span> &#125;)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(LOGGER_FREFIX + <span class="string">'销毁失败: '</span>, global.id, err)</span><br><span class="line">        <span class="keyword">this</span>.postMessage(&#123;</span><br><span class="line">          type: <span class="string">'fatal'</span>,</span><br><span class="line">          data: err,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就绪</span></span><br><span class="line"><span class="keyword">this</span>.postMessage(&#123; <span class="attr">type</span>: <span class="string">'ready'</span>, <span class="attr">data</span>: &#123;&#125; &#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>再来看看主进程, 通过 <code>transferControlToOffscreen()</code> 生成离屏渲染画布，让 JSMpeg 可以无缝迁移到 Worker:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.getElementById(<span class="string">'video'</span>)</span><br><span class="line"><span class="keyword">const</span> wk = <span class="keyword">new</span> Worker(<span class="string">'./jsmpeg.worker.js'</span>)</span><br><span class="line"></span><br><span class="line">wk.onmessage = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> data = evt.data</span><br><span class="line">  <span class="keyword">switch</span> (data.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ready'</span>:</span><br><span class="line">      <span class="comment">// 创建 OffscreenCanvas 对象</span></span><br><span class="line">      <span class="keyword">const</span> oc = video.transferControlToOffscreen()</span><br><span class="line"></span><br><span class="line">      wk.postMessage(</span><br><span class="line">        &#123;</span><br><span class="line">          type: <span class="string">'create'</span>,</span><br><span class="line">          data: &#123;</span><br><span class="line">            canvas: oc,</span><br><span class="line">            url: <span class="string">'ws://localhost:9999/pull/test'</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        [oc] <span class="comment">// 注意这里</span></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="简单说一下-broadway-js"><a href="#简单说一下-broadway-js" class="headerlink" title="简单说一下 Broadway.js"></a>简单说一下 Broadway.js</h3><p>还有一个类似 JSMpeg 的解决方案 ———— <a href="https://github.com/mbebenita/Broadway" target="_blank" rel="noopener">Broadwayjs</a>。 它是一个 <code>H.264</code> 解码器, 通过 <a href="https://github.com/emscripten-core/emscripten" target="_blank" rel="noopener"><code>Emscripten</code></a> 工具从 Android 的 H.264 解码器转化而成。它支持接收 H.264 裸流，不过也有一些限制：不支持 <a href="https://github.com/mbebenita/Broadway#encoding-video" target="_blank" rel="noopener"><code>weighted prediction for P-frames</code> &amp; <code>CABAC entropy encoding</code></a>。</p><p><br></p><p>推送示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation  -r 30 -i <span class="string">"FaceTime HD Camera"</span>  -f rawvideo -c:v libx264 -pix_fmt yuv420p -vprofile baseline -tune zerolatency -coder 0 -bf 0 -flags -loop -wpredp 0 -an  http://localhost:9999/push/<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p><br><br><br></p><p>客户端示例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.getElementById(<span class="string">'video'</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="string">`ws://localhost:9999/pull/test`</span></span><br><span class="line"><span class="keyword">const</span> player = <span class="keyword">new</span> Player(&#123;</span><br><span class="line">  canvas: video,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(url)</span><br><span class="line">ws.binaryType = <span class="string">'arraybuffer'</span></span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = evt.data</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data !== <span class="string">'string'</span>) &#123;</span><br><span class="line">    player.decode(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(data))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get command from server: '</span>, data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>完整代码看<a href="https://github.com/ivan-94/video-push/tree/master/broadway" target="_blank" rel="noopener">这里</a></p></blockquote><p>经过测试，同等质量和尺寸的视频流 JSMpeg 和 Broadway CPU 消耗差不多。但是 Broadway 视频流不受码率限制，没有花屏和崩溃现象。当然, 对于高质量视频, ffmpeg 转换和 Broadway 播放, 资源消耗都非常惊人。</p><p><br></p><p>其他类似的方案:</p><ul><li><a href="https://github.com/ChihChengYang/wfs.js" target="_blank" rel="noopener">wfs</a> html5 player for raw h.264 streams.</li></ul><p><br><br><br></p><h2 id="③-直接渲染-yuv"><a href="#③-直接渲染-yuv" class="headerlink" title="③ 直接渲染 YUV"></a>③ 直接渲染 YUV</h2><p><strong>回到文章开始，其实底层库从 WebRTC 中拿到的是 YUV 的原始视频流, 也就是没有经过编码压缩的一帧一帧的图像。上文介绍的方案都有额外的解封包、解编码的过程，最终输出的也是 YUV 格式的视频帧，它们的最后一步都是将这些 YUV 格式视频帧转换成 RGB 格式，渲染到 Canvas 中</strong>。</p><p><strong>那能不能将原始的 YUV 视频帧直接转发过来，直接在 Cavans 上渲染不就得了</strong>？ 将去掉中间的解编码过程, 效果怎样？试一试。</p><p><br></p><blockquote><p>此前已经有文章做过这方面的尝试: <a href="https://juejin.im/post/5de29d7be51d455f9b335efa" target="_blank" rel="noopener">《IVWEB 玩转 WASM 系列-WEBGL YUV 渲染图像实践》</a>。我们参考它搞一个。</p></blockquote><p>至于什么是 <code>YUV</code>，我就不科普, 自行搜索。 YUV 帧的大小可以根据这个公式计算出来： <code>(width * height * 3) &gt;&gt; 1</code>,<br><strong>即 <code>YUV420p</code> 的每个像素占用 1.5 bytes</strong>。</p><p>因此我们只需要知道视频的大小, 就可以切割视频流，将视频帧分离出来了。 下面新建一个中转服务器来接收推流, 在这里将 YUV 裸流切割成一帧一帧图像数据，下发给浏览器：</p><p><br></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> parsed = <span class="keyword">new</span> URL(<span class="string">'http://host'</span> + url)</span><br><span class="line">  <span class="keyword">let</span> id = parsed.searchParams.get(<span class="string">'id'</span>),</span><br><span class="line">    width = parsed.searchParams.get(<span class="string">'width'</span>),</span><br><span class="line">    height = parsed.searchParams.get(<span class="string">'height'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nwidth = <span class="built_in">parseInt</span>(width)</span><br><span class="line">  <span class="keyword">const</span> nheight = <span class="built_in">parseInt</span>(height)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> frameSize = (nwidth * nheight * <span class="number">3</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按照字节大小切割流</span></span><br><span class="line">  <span class="keyword">const</span> stream = req.pipe(<span class="keyword">new</span> Splitter(frameSize))</span><br><span class="line"></span><br><span class="line">  stream.on(<span class="string">'data'</span>, (c) =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.broadcast(id, c)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/ivan-94/video-push/blob/master/yuv/size-split.js" target="_blank" rel="noopener"><code>Splitter</code></a> 根据固定字节大小切割 Buffer。 </p><p><br></p><p>如果渲染 YUV ？ 可以参考 <a href="https://github.com/phoboslab/jsmpeg/blob/master/src/webgl.js" target="_blank" rel="noopener">JSMpeg WebGL 渲染器</a>, <a href="https://github.com/mbebenita/Broadway/blob/master/Player/YUVCanvas.js" target="_blank" rel="noopener">Broadway.js WebGL 渲染器</a>。 具体如何渲染就不展开了， 下面直接将 Broadway.js 的 <a href="https://github.com/mbebenita/Broadway/blob/master/Player/YUVCanvas.js" target="_blank" rel="noopener"><code>YUVCanvas.js</code></a> 直接拿过来用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> YUVCanvas(&#123;</span><br><span class="line">  canvas: video,</span><br><span class="line">  type: <span class="string">'yuv420'</span>,</span><br><span class="line">  width: width,</span><br><span class="line">  height: height,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 WebSocket 接收 YUV 帧. 并抽取出 YUV 分量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ylen = width * height</span><br><span class="line">  <span class="keyword">const</span> uvlen = (width / <span class="number">2</span>) * (height / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  renderer.render(</span><br><span class="line">    buff.subarray(<span class="number">0</span>, ylen),</span><br><span class="line">    buff.subarray(ylen, ylen + uvlen),</span><br><span class="line">    buff.subarray(ylen + uvlen, ylen + uvlen + uvlen),</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><blockquote><p>需要注意的是：JSMpeg 和 Broadway 的 Canvas 渲染都要求视频的宽度必须是 8 的倍数。不符合这个要求的会报错，<a href="https://juejin.im/post/5de29d7be51d455f9b335efa" target="_blank" rel="noopener">《IVWEB 玩转 WASM 系列-WEBGL YUV 渲染图像实践》</a> 处理了这个问题。</p></blockquote><p><br></p><p>最后看看 ffmpeg 推送示例:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -r 30 -i <span class="string">"FaceTime HD Camera"</span> -f rawvideo -c:v rawvideo -pix_fmt yuv420p <span class="string">"http://localhost:9999/push?id=test&amp;width=320&amp;height=240"</span></span></span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>完整代码看<a href="https://github.com/ivan-94/video-push/tree/master/yuv" target="_blank" rel="noopener">这里</a></p></blockquote><p><br><br><br></p><p>下面看看简单资源消耗对比。 笔者设备是 15 款 Macboook pro, 视频源采集自摄像头，分辨率 320x240、像素格式 uyvy422、帧率 30。</p><p><em>下表 <code>J</code> 表示 <code>JSMpeg</code>、<code>B</code> 表示 <code>Broadway</code>、<code>Y</code> 表示 <code>YUV</code></em></p><table><thead><tr><th></th><th>CPU (J/B/Y)</th><th>内存 (J/B/Y)</th><th>平均码率 (J/B/Y)</th></tr></thead><tbody><tr><td>ffmpeg</td><td>9% / 9% / 5%</td><td>12MB / 12MB / 9MB</td><td>1600k / 200k / 27000k</td></tr><tr><td>服务器</td><td>0.6% / 0.6% /1.4%</td><td>18MB / 18MB / 42MB</td><td>N/A</td></tr><tr><td>播放器</td><td>16% / 13% / 8%</td><td>70MB / 200MB / 50MB</td><td>N/A</td></tr></tbody></table><p><br></p><p>从结果来看，直接渲染 YUV 综合占用的资源最少。因为没有经过压缩，码率也是非常高的，不过本地环境不受带宽限制，这个问题也不大。我们还可以利用<code>requestAnimationFrame</code> 由浏览器来调度播放的速率，丢掉积累的帧，保持低延迟播放。</p><p><br><br><br></p><p>本文完</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://juejin.im/post/5ab851b6f265da23826df601" target="_blank" rel="noopener">直播原理与 web 直播实战</a></li><li><a href="https://juejin.im/post/5de29d7be51d455f9b335efa" target="_blank" rel="noopener">IVWEB 玩转 WASM 系列-WEBGL YUV 渲染图像实践</a></li><li><a href="https://github.com/ossrs/srs/wiki/v1_CN_LowLatency" target="_blank" rel="noopener">低延时直播应用</a></li><li><a href="https://zhuanlan.zhihu.com/p/100519553" target="_blank" rel="noopener">基于 H5 的直播协议和视频监控方案</a></li><li><a href="https://imququ.com/post/html5-live-player-2.html" target="_blank" rel="noopener">HTML5 视频直播（二）</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久不见，接近四个月没更新博客了! &lt;/p&gt;
&lt;p&gt;去年&lt;a href=&quot;https://juejin.im/post/5e0010866fb9a015fd69c645#comment&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最后一篇&lt;/a&gt;文章介绍
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>分享这半年的 Electron 应用开发和优化经验</title>
    <link href="https://bobi.ink/2019/12/16/electron/"/>
    <id>https://bobi.ink/2019/12/16/electron/</id>
    <published>2019-12-15T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>2019 年最后一发，谈谈这半年 Electron 应用开发和优化心得。干货也挺多，希望能给你带来一点启发。</p><p>下半年可以拿出来说一说的项目，估计就是我们用 Electron 重构了一个桌面端应用。这个应用类似于<code>钉钉</code>或者<code>企业微信</code>，主要功能有即时通信、语音/视频、会议，基本功能和交互体验和 PC 端微信差不多(其实就是模仿)，具体细节就不展开了, 这些对本文不重要。如下图</p><p><br></p><p><img src="/images/electron/mygzb.jpeg" alt></p><p><br></p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#为什么选择-electron">为什么选择 Electron?</a></li><li><a href="#进程模型">进程模型</a></li><li><a href="#技术选型与代码组织">技术选型与代码组织</a></li><li><a href="#性能优化硬货">性能优化(硬货)</a><ul><li><a href="#1-性能分析">1. 性能分析</a></li><li><a href="#2-优化策略">2. 优化策略</a><ul><li><a href="#21-继续和白屏作斗争">2.1 继续和白屏作斗争</a></li><li><a href="#22-追赶原生的交互体验">2.2 追赶原生的交互体验</a></li><li><a href="#23-优化进程通信">2.3 优化进程通信</a></li></ul></li></ul></li><li><a href="#坑还是会有的">坑还是会有的</a></li><li><a href="#扩展资料">扩展资料</a></li></ul><!-- /TOC --><p><br></p><h2 id="为什么选择-electron"><a href="#为什么选择-electron" class="headerlink" title="为什么选择 Electron?"></a>为什么选择 Electron?</h2><p>原因也很简单: <strong>我们的应用要兼容多个平台，原生开发效率低，我们没有资源</strong>。</p><p>说了跟白说一样，大部分选择 Electron 框架的动机都是差不多的，无非就是穷，尤其是在夹缝中生存的企业。</p><p>为了优化客户端开发资源，<strong>‘混合化’成为了我们今年客户端重构的主题</strong>。</p><p>先来看一下我们现在的客户端基本架构:</p><p><img src="/images/electron/client-arch.png" alt></p><p><br></p><p>混合化对我们来说有两层意思:</p><ol><li>我们的应用架构’混合’了多种技术。通用底层 C/C++, 平台原生(iOS, Android, PC, MacOS)，Web 技术</li><li>跨平台</li></ol><p><br></p><p>基于我们原有的客户端基础和情况，混合化重构自然而然分化为了两个方向:</p><ol><li><strong>业务下沉</strong>。将通用的、核心的业务下沉。例如消息处理、语音/视频、会议、数据存储等核心模块, 核心协议是 XMPP、SIP。这些模块变动频率较低、对性能要求也比较高，而且有跨平台需求，因此适合用 C/C++ 来实现。</li><li><strong>UI 混合</strong>。视图层混合化目前也有较多的解决方案，例如 Electron、React Native、Flutter、或者是 HTML Hybrid。我们选择先从 Electron 开始，因为它在桌面端开发中已经有非常成熟的表现，市场上也有很多大型的 Electron 应用，例如 VSCode、Atom、Slack。在移动端，我们对 React Native 和 Flutter 还比较保守，后续可能会进行尝试。</li></ol><p><br></p><p>理解了我们的动机，现在再看上面的图, 应该就好理解多了, 这是典型的三层结构, 和 MVC 非常相似：</p><ul><li><strong>M – 通用混合层</strong>。 C/C++ 封装核心、通用的业务模块以及业务数据存储。</li><li><strong>V – UI 层</strong>。视图层，使用跨平台视图解决方案，对于性能要求较高的部分使用原生实现。比如 Electron</li><li><strong>C – 平台桥接层</strong>。介于 M 和 V 之间，桥接<code>通用混合层</code>接口，同时也为 UI 层暴露一些<strong>平台相关</strong>的特性。比如在桌面端，这里会通过 Node 原生模块桥接通用混合层, 同时也补充一些 Electron 缺失或不完美的功能。</li></ul><p><br><br><br></p><h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><p>Electron 的主从进程模型是基本的常识。每个 Electron 应用有且只要一个主进程(Main Process)、以及一个或多个渲染进程(Renderer Process), 对应多个 Web 页面。除此之外还有 GPU 进程、扩展进程等等。可以通过 <a href="https://electronjs.org/docs/tutorial/application-architecture#main-and-renderer-processes" target="_blank" rel="noopener">Electron Application Architecture</a> 了解 Electron 的基本架构。</p><p>主进程负责创建页面窗口、协调进程间通信、事件分发。为了安全考虑，原生 GUI 相关的 API 是无法在渲染进程直接访问的，它们必须通过 IPC 调用主进程。<strong>这种主从进程模型缺点也非常明显，即主进程单点故障。主进程崩溃或者阻塞，会影响整个应用的响应</strong>。比如主进程跑长时间的 CPU 任务，将阻塞渲染进程的用户交互事件。</p><p><br></p><p>对我们的应用来说，目前有以下进程, 以及它们的职责:</p><p><strong>① 主进程</strong></p><ul><li>进程间通信、窗口管理</li><li>全局通用服务。</li><li>一些只能或适合在主进程做的事情。例如浏览器下载、全局快捷键处理、托盘、session。</li><li>维护一些必要的全局状态</li><li>上面说的<code>通用混合层</code>也跑在这个进程。通过 Node C++ 插件暴露接口。</li></ul><p><br></p><p><strong>② 渲染进程</strong></p><p>负责 Web 页面的渲染, 具体页面的业务处理。</p><p><br></p><p><strong>③ Service Worker</strong></p><p>负责静态资源缓存。缓存一些网络图片、音频。保证静态资源的稳定加载。</p><p><br><br><br></p><h2 id="技术选型与代码组织"><a href="#技术选型与代码组织" class="headerlink" title="技术选型与代码组织"></a>技术选型与代码组织</h2><p>说说我们的技术选型。</p><ul><li>UI 框架 - <code>React</code></li><li>状态管理 - <code>Mobx</code></li><li>国际化 - <code>i18next</code></li><li>打包 - <code>自研 CLI</code></li></ul><p><br></p><p>源码组织</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bridge/                  # 桥接层代码</span><br><span class="line">resources/               # 构建资源，以及第三方DLL</span><br><span class="line">src/</span><br><span class="line"></span><br><span class="line">  main/                  # 🔴主进程代码</span><br><span class="line">    services/            # 📡**通过 RPC 暴露给渲染进程的全局服务**</span><br><span class="line">      tray.ts            # 托盘状态管理</span><br><span class="line">      shortcut.ts        # 全局快捷键分发</span><br><span class="line">      preferences.ts     # 用户配置管理</span><br><span class="line">      windows.ts         # 窗口管理</span><br><span class="line">      screen-capture.ts  # 截屏</span><br><span class="line">      bridge.ts          # 桥接层接口封装</span><br><span class="line">      context-menu.ts    # 右键菜单</span><br><span class="line">      state.ts           # 全局状态管理, 保存一些必要的全局状态，例如主题、当前语言、当前用户</span><br><span class="line">      ...</span><br><span class="line">    lib/                 # 封装库</span><br><span class="line">      bridge.ts          # 桥接层API 分装</span><br><span class="line">      logger.ts          # 日志</span><br><span class="line">      ...</span><br><span class="line">    bootstrap.ts         # 启动程序</span><br><span class="line">    index.ts             # 🔴入口文件</span><br><span class="line"></span><br><span class="line">  renderer/              # 🔴渲染进程</span><br><span class="line">    services/            # 📡主进程的全局服务的客户端</span><br><span class="line">      windows.ts         # 窗口管理客户端</span><br><span class="line">      tray.ts</span><br><span class="line">      ...</span><br><span class="line">    assets/              # 静态资源</span><br><span class="line">    hooks/               # React Hooks</span><br><span class="line">    components/          # 通用组件</span><br><span class="line">      Webview</span><br><span class="line">      Editor</span><br><span class="line">      toast</span><br><span class="line">      ...</span><br><span class="line">    pages/               # 🔴页面</span><br><span class="line">      Home</span><br><span class="line">        ui/              # 🔴视图代码，由前端团队维护</span><br><span class="line">        store/           # 🔴状态代码，由客户端团队维护，前端Store的公开状态</span><br><span class="line">        translation/     # 国际化翻译文件</span><br><span class="line">        index.tsx        # 页面入口</span><br><span class="line">      Settings</span><br><span class="line">      Login</span><br><span class="line">    page.json            # 🔴声明所有页面及页面配置。类似小程序</span><br></pre></td></tr></table></figure><p><br></p><p>眼尖的读者会发现每个页面下有 <code>ui</code> 和 <code>store</code> 目录，分别对应视图和状态。为什么这么划分？</p><p>首先这是因为这个项目由两个团队共同来开发的，即原有的原生客户端团队和我们的前端团队。分离视图和状态有两个好处:</p><ul><li>前端前期不需要关心客户端底层业务，而客户端也不需要关心前端的页面实现。职责明确，各自干好自己事情。</li><li>降低学习成本。我们状态管理选用了 Mobx，对于客户端同学，只需要掌握少量的 Typescript 语言知识就可以马上上手。如果熟悉 Java、C# 那就更没什么问题了。每个 Store 只是一个简单的类：</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> CounterStore <span class="keyword">extends</span> MobxStore &#123;</span><br><span class="line">  <span class="meta">@observable</span></span><br><span class="line">  <span class="keyword">public</span> count: <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@action</span></span><br><span class="line">  <span class="keyword">public</span> incr = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.count++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> pageReady() &#123;</span><br><span class="line">    <span class="comment">// 页面就绪，可以在这里做一些准备工作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件监听</span></span><br><span class="line">    <span class="comment">// addDisposer 将释放函数添加到队列中，在页面退出时释放</span></span><br><span class="line">    <span class="keyword">this</span>.addDisposer(</span><br><span class="line">      addListener(<span class="string">'someevent'</span>, <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.dosomething(evt)</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.initial()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> pageWillClose() &#123;</span><br><span class="line">    <span class="comment">// 页面释放，可以在这里做一些资源释放</span></span><br><span class="line">    releaseSomeResource()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>使用 Mobx 作为状态管理，相比 Redux，面向对象思想对他们更好理解。在这种场景，简单才是真理；</p><p>分离了状态和业务逻辑，前端页面实现也简化了，视图只是状态的映射，这让我们的页面和组件更好被维护和复用。</p><p><br><br><br></p><h2 id="性能优化-硬货"><a href="#性能优化-硬货" class="headerlink" title="性能优化(硬货)"></a>性能优化(硬货)</h2><p>前戏完了，关于 Electron 的一些性能优化才是本篇文章的重头戏。</p><p>Electron 不是银弹，鱼和熊掌不可兼得。Electron 带来开发效率的提升，其本身也有很多硬伤，譬如常被人吐槽的内存占用高，和原生客户端性能差异等等。为了优化 Electron 应用，我们也做了很多工作。</p><p>性能优化一般都分两步走：</p><ul><li>① 分析、找出问题。参考<a href="https://juejin.im/post/5d06bf0a51882528194a9736" target="_blank" rel="noopener">《React 性能测量和分析》</a></li><li>② 针对问题解决问题。无外乎三个方向, 参考 <a href="https://juejin.im/post/5d045350f265da1b695d5bf2" target="_blank" rel="noopener">《浅谈 React 性能优化的方向》</a></li></ul><p><br></p><h3 id="1-性能分析"><a href="#1-性能分析" class="headerlink" title="1. 性能分析"></a>1. 性能分析</h3><p>最好的分析工具是 Chrome 开发者工具的 <code>Performance</code>。通过火焰图, JavaScript 执行过程的任何蛛丝马迹都可以直观的看到。</p><p><img src="/images/electron/chrome-perf.png" alt></p><p><br></p><p>对于主进程，开启调试后也可以通过 <code>Profile</code> 工具收集 JavaScript 执行信息。</p><p>如果你要分析某段代码的执行过程，也可以通过下面命令生成分析文件，然后导入到 Chrome Performance 中分析:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出 cpu 和 堆分析文件</span></span><br><span class="line">node --cpu-prof --heap-prof -e "require('request’)”“</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="2-优化策略"><a href="#2-优化策略" class="headerlink" title="2. 优化策略"></a>2. 优化策略</h3><h4 id="2-1-继续和白屏作斗争"><a href="#2-1-继续和白屏作斗争" class="headerlink" title="2.1 继续和白屏作斗争"></a>2.1 继续和白屏作斗争</h4><p>即使 Electron 通常从本地文件系统加载 JavaScript 代码，没有网络加载延迟，我们还是需要继续和页面白屏做斗争，因为 JavaScript 等资源的加载、解析和执行还是有相当大的代价(参考<a href="https://v8.dev/blog/cost-of-javascript-2019" target="_blank" rel="noopener">The cost of JavaScript in 2019</a>)。作为一个桌面端应用，细微的白屏延迟用户都可以感觉的到。我们要尽量让用户感觉不到这是一个 Web 页面。</p><p><strong>影响 Electron 白屏的主要因素有：页面窗口的创建、静态资源的加载、JavaScript 解析和执行</strong>。</p><p>见招拆招，针对页面白屏我们做了这些优化:</p><p><br></p><p><strong>① 骨架屏</strong></p><p>最简单的方式。在资源未加载完毕之前，先展示页面的骨架。避免用户看到白茫茫的屏幕。</p><p>另外需要设置背景色或者延迟显示窗口，来避免闪烁。</p><p><img src="/images/electron/shell.png" alt><br><em>VSCode骨架屏</em></p><p><br></p><p><strong>② 惰性加载</strong></p><p>优先加载核心的功能，保证初次加载效率，让用户可以尽快进行交互。</p><p><br></p><p><img src="/images/electron/load-order.gif" alt></p><p><br></p><ul><li><strong>代码分割 + 预加载</strong>： 代码分割是最常见优化方式。我们把隐藏的内容、或者次优先级的模块拆分出去，启动模块中只保留关键路径。我们也可以在浏览器空闲时预加载这些模块。</li><li><p><strong>延后加载 Node 模块</strong>： Nodejs 模块的加载和执行需要花费较大的代价, 例如模块查找、模块文件读取、接着才是模块解析和执行。这些操作都是同步了，别忘了，node_modules 黑洞，某块模块可能会引用大量的依赖….</p><p>Node 应用和 Electron 应用不太一样，通常 Node 服务器应用都会将模块放置在文件顶部, 然后同步加载进来。这个放到 Electron 用户界面上就无法忍受了。 用户界面的启动速度和交互阻塞, 用户是可以感知到的，而且忍耐程度会较低。</p><p>所以要充分评估模块的大小和依赖。或者可以选择使用打包工具优化和合并 Node 模块。</p></li><li><p><strong>划分加载优先级</strong>：既然我们没办法一开始将所有东西都加载出来，那就按照优先级渐进式地将在它们。举个例子，当我们使用 VSCode 打开一个文件时，VScode 会先展示代码面板、接着是目录树、侧边栏、代码高亮、问题面板、初始化各种插件…</p></li></ul><p><br></p><p><strong>③ 使用现代的 JavaScript/CSS 代码</strong></p><p>Electron 每个版本都会预装当时最新的 Chrome，对于前端来说，这是最爽的一件事情:</p><ul><li>没有负担地使用最新的 JavaScript 特性</li><li>没有 Polyfill、没有 runtime-helper。相比老旧浏览器，代码量更少，性能也更好</li><li>我们需要主动抛弃一些老旧的依赖。保持使用最新的库</li></ul><p><br></p><p><strong>④ 打包优化</strong></p><p>即使使用最新最牛逼的浏览器，打包工具还是很有用。</p><ul><li><strong>减少代码体积</strong>: 现代打包工具有非常多优化手段，例如 Webpack 支持作用域提升、摇树，还有代码压缩、预执行… 这可以合并代码、压缩代码体积，裁剪多余的代码, 减少运行时负担。</li><li><strong>优化I/O</strong>: 我们将模块合并之后，可以减少模块查找和加载的I/O往返。</li></ul><p><br></p><p><strong>⑤ <a href="https://v8project.blogspot.it/2015/09/custom-startup-snapshots.html" target="_blank" rel="noopener">v8 Snapshot</a> or <a href="https://v8.dev/blog/code-caching" target="_blank" rel="noopener">v8 Code Cache</a></strong></p><p>Atom 有很多优质的文章，分享了他们优化Atom的经历。例如它们使用了 <a href="https://blog.atom.io/2017/04/18/improving-startup-time.html" target="_blank" rel="noopener">V8 的snapshot 来优化启动时间</a>。</p><p>这是一种 <code>AOT</code> 优化策略，简单说 Snapshot 是堆快照，你可以认为它是 JavaScript 代码在V8中的内存表示形态。</p><p>它有两个好处: 一是相比普通 JavaScript 加载更快，二是它是二进制的，如果你为了‘安全’考虑，可以将模块转换成snapshot，这样更难被‘破解’。</p><p>不过它也有较多限制。对架构的影响比较大。比如要求在初始化的过程中不要有‘副作用’，例如DOM访问。因为在‘编译时‘这些东西不存在。</p><p>这篇文章详细介绍了如何在 Electron 中应用 v8 snapshot: <a href="https://flight-manual.atom.io/behind-atom/sections/how-atom-uses-chromium-snapshots/" target="_blank" rel="noopener">How Atom Uses Chromium Snapshots</a></p><p><br></p><p>还有一个更加广泛使用的方案是 <a href="https://v8.dev/blog/code-caching" target="_blank" rel="noopener">v8 Code Cache</a>。NodeJS 12 <a href="https://www.yuque.com/egg/nodejs/nodejs-12#2e3ceb28" target="_blank" rel="noopener">开始</a>在构建时提前为内置库生成代码缓存，从而提升 30% 的启动耗时。</p><p>通过这些文章，深入了解 Code Cache 扩展阅读:</p><ul><li><a href="https://v8.dev/blog/code-caching-for-devs" target="_blank" rel="noopener">Code caching for JavaScript developers</a></li><li><a href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201" target="_blank" rel="noopener">JavaScript Start-up Performance</a></li><li><a href="https://v8.dev/blog/improved-code-caching" target="_blank" rel="noopener">Improved code caching</a></li><li><a href="https://fed.taobao.org/blog/taofed/do71ct/speed-node-start-time/" target="_blank" rel="noopener">如何加快 Node.js 应用的启动速度</a></li></ul><p><br><br><br></p><p><strong>⑥ 窗口预热 与 窗口池、窗口常驻</strong></p><p>为了追赶原生窗口的打开和展示速度，我们运用了很多技巧，用空间来换取时间。</p><p>例如我们的应用首页，用户在打开登录页面时，我们就会在<strong>后台预热</strong>，将该加载的资源都准备好，在登录成功后，就可以立即渲染显示。窗口打开的延时很短，基本接近原生的窗口体验。</p><p>这里用到了一些 Hack 手段，我们将这些窗口放到了屏幕之外，并设置 <code>skipTaskBar</code> 来实现隐藏或者关闭的效果。</p><p><br></p><p>对于频繁开启/关闭的窗口，也可以使用<strong>窗口池</strong>来优化。比如 Webview 页面，打开的一个 Webview 页面时，会优先从窗口池中选取，当窗口池为空时才创建新的窗口, 后面页面关闭后会再放回窗口池中，方便后续复用。</p><p>另外，对于业务无关的、通用的窗口，也可以采用<strong>常驻模式</strong>，例如通知，图片查看器。这些窗口一旦创建就不会释放，打开效果会更好。</p><p><br></p><p><strong>⑦ 跟进 Electron 最新版本</strong></p><p>保持版本的更新。</p><p><br></p><h4 id="2-2-追赶原生的交互体验"><a href="#2-2-追赶原生的交互体验" class="headerlink" title="2.2 追赶原生的交互体验"></a>2.2 追赶原生的交互体验</h4><p>白屏时间的优化只是一个开始，应用使用过程中的交互体验也是一个非常重要的部分。下面讲讲我们的一些优化手段：</p><p><br></p><p><strong>① 静态资源缓存</strong></p><p>对于一些网络资源，我们采取了一些缓存手段，保证它们展示的速度。我们目前采用的是 Service-Worker + Workbox 的方式，利用 Service-Worker 可以拦截多个页面的网络请求，从而实现跨页面的静态资源缓存，这种方式实现比较简单。</p><p>除了 Service Worker，也可以通过协议拦截方式来实现。详见: <a href="https://electronjs.org/docs/api/protocol" target="_blank" rel="noopener">protocol</a>。后面有时间再尝试一下，看效果怎么样。</p><p><br></p><p><strong>② 预加载机制</strong></p><p>如果你看过我的 <a href="https://juejin.im/post/5dadc6045188255a270a0f85" target="_blank" rel="noopener">《这可能是最通俗的 React Fiber(时间分片) 打开方式》</a>, 应该见识到 <code>requestIdleCallback</code> 的强大，React 利用它来调度一些渲染任务，保证浏览器响应用户的交互。</p><p>这个 API 对于我们的应用优化也有重要的意义。通过它我们可以知道浏览器的资源利用情况，利用浏览器空闲时间来预执行一些低优先级的任务。比如：</p><ul><li>渲染隐藏的 Tab</li><li>延后加载的模块代码</li><li>惰性加载的图片</li><li>未激活的会话</li><li>执行低优先级的任务</li><li>…</li></ul><p><br></p><p>例如 React 代码分割：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">lazy</span>(<span class="params">factory, Fallback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Comp = l(factory)</span><br><span class="line">  <span class="comment">// 预加载调度</span></span><br><span class="line">  scheduleIdle(&#123;</span><br><span class="line">    name: <span class="string">'LazyComponent'</span>,</span><br><span class="line">    size: TaskSize.Heavy,</span><br><span class="line">    task: factory,</span><br><span class="line">    timeout: <span class="number">2000</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">LazyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Suspense fallback=&#123;Fallback ? <span class="xml"><span class="tag">&lt;<span class="name">Fallback</span> /&gt;</span> : null&#125;&gt;</span></span><br><span class="line">        &lt;Comp &#123;...props&#125; /&gt;</span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">    )</span></span><br><span class="line"><span class="xml">  &#125; as typeof Comp</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>使用:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> List = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./List'</span>))</span><br></pre></td></tr></table></figure><p><br></p><p><strong>③ 避免同步操作</strong></p><p>Electron 可以通过 NodeJS 进行 I/O 操作，但是我们一定要尽量避免同步 I/O。例如同步的文件操作、同步的进程间通信。它们会阻塞页面的渲染和事件交互。</p><p><br></p><p><strong>④ 减少主进程负荷</strong></p><p>Electron 的主进程非常重要。它是所有窗口的父进程，它负责调度各种资源。如果主进程被阻塞，将影响整个应用响应性能。</p><p>你可以做一个简单的实验，在主进程上打一个断点，你会发现所有的页面窗口都会失去响应，尽管它们在各自不同的进程。这是因为所有用户交互都是由主进程分发给渲染进程的，主进程阻塞了，渲染进程当然无法接收用户事件啦。</p><p>所以不要让主进程干脏活累活，能在渲染进程做的，就在渲染进程做。<strong>千万避免在主进程中跑计算密集任务和同步I/O</strong>。</p><p><br></p><p><strong>⑤ 分离CPU密集型操作到单独进程或Worker, 避免阻塞UI</strong></p><p><br></p><p><strong>⑥ React 优化</strong></p><p>见 <a href="https://juejin.im/post/5d045350f265da1b695d5bf2" target="_blank" rel="noopener">《React 性能优化的方向》</a></p><p><br></p><p><strong>⑦ 放弃CSS-in-js</strong></p><p>我们为了压缩运行时性能，能在编译时做的就在编译时做，放弃了 CSS-in-js 方案，使用纯 CSS + BEM 来编写样式。主要有两个原因:</p><ul><li>Electron 使用较新的 Chrome，现代 CSS 已经很强大</li><li>我们使用了窗口预热机制，可以率先解析这部分 CSS 代码。而 CSS-in-js 方案则是组件渲染时，动态生成的。</li></ul><p><br></p><p><strong>⑧ 没有退路了，那就只能上 Node 原生模块了</strong></p><p>真好，还有退路</p><p><br><br><br></p><h4 id="2-3-优化进程通信"><a href="#2-3-优化进程通信" class="headerlink" title="2.3 优化进程通信"></a>2.3 优化进程通信</h4><p>涉及到多页面/窗口的 Electron 应用，IPC 会非常频繁，搞不好会成为性能瓶颈。</p><p><br></p><p><strong>① 巨坑 remote</strong></p><p><a href="https://electronjs.org/docs/api/remote" target="_blank" rel="noopener">remote</a> 提供了一种简便的、无侵入的形式来访问主进程的API和数据。<strong>其底层基于同步的 IPC</strong>。你可以通过我<a href="https://juejin.im/post/5d4b79a3e51d4561b072dcb0" target="_blank" rel="noopener">这篇文章</a>来了解它的原理。</p><p>坑在哪里呢？</p><p>① 它是同步的<br>② 属性动态获取。为了确保你能够获取到最新的值，remote底层并不会进行缓存，而是每次获取一个属性就动态到主进程中取。</p><p>比如获取一个主进程中的对象:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主进程</span></span><br><span class="line">global.foo = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: &#123;</span><br><span class="line">    baz: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染进程访问:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;remote&#125; <span class="keyword">from</span> <span class="string">'electron'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(remote.getGlobal(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure><p>这里会触发 4 次 同步 IPC: getGlobal、foo、bar、bar.baz。对于复杂的数据，这个消耗就很难忍受了。</p><p>不要使用 remote，除非你知道你自己在干什么。</p><p><br><br><br></p><p><strong>② 封装IPC 库</strong></p><p>为了优化 IPC 通信，我们自己基于Electron 的IPC接口, 封装了自己的一套 RPC 库。主要特征有:</p><ul><li>异步的。没有同步的选项。避免干蠢事</li><li>消息合并。合并事件推送，批量传递</li><li>序列化。直接传递 JSON 字符串，不让 Electron 干涉序列化。Electron 内部序列化稍微有点复杂，比如会处理 Buffer 等特殊类型。</li><li>一致化的、简单易用的 API。使用一样在接口支持主进程与渲染进程，以及渲染进程与渲染进程之间双向通信。</li></ul><p>举个例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rpc <span class="keyword">from</span> <span class="string">'myrpc'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册方法</span></span><br><span class="line">rpc.registerHandler(<span class="string">'echo'</span>, <span class="keyword">async</span> data =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line">rpc.on(<span class="string">'some-event'</span>, (data, source) =&gt; &#123;</span><br><span class="line">  <span class="comment">// dosomething</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>客户端:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rpc <span class="keyword">from</span> <span class="string">'myrpc'</span></span><br><span class="line"></span><br><span class="line">rpc.emit(target, <span class="string">'some-event'</span>) <span class="comment">// target 为接收的窗口或者主进程。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法调用</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> rpc.callHandler(target, <span class="string">'echo'</span>, <span class="string">'hello-world'</span>)</span><br></pre></td></tr></table></figure><p><br></p><p>还不够，我们还在优化，后续再分享给大家。</p><p><br><br><br></p><h2 id="坑还是会有的"><a href="#坑还是会有的" class="headerlink" title="坑还是会有的"></a>坑还是会有的</h2><p>一路走来也遇到很多坑。痛并快乐着。</p><ul><li>窗口阴影、圆角</li><li>剪切板不够强大</li><li>remote 巨坑</li><li>一些兼容问题</li><li>主进程崩溃，渲染进程不会退出，导致进程‘溢出’</li><li>截屏。刚开始用 Electron 实现，效果不好，现在是原生实现</li><li>…</li></ul><p><br><br><br></p><h2 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/96041706" target="_blank" rel="noopener">从 VSCode 看大型 IDE 技术架构</a></li><li><a href="https://electronjs.org/docs/tutorial/performance" target="_blank" rel="noopener">Electron Performance</a></li><li><a href="https://www.youtube.com/watch?v=r0OeHRUCCb4" target="_blank" rel="noopener">CovalenceConf 2019: Visual Studio Code – The First Second</a></li><li><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/" target="_blank" rel="noopener">Get Started With Analyzing Runtime Performance</a></li><li><a href="https://github.com/atom/electron-link" target="_blank" rel="noopener">electron-link</a></li><li><a href="http://peterforgacs.github.io/2018/09/12/How-to-create-a-V8-snapshot-of-your-javascript-file/" target="_blank" rel="noopener">How to Create a V8 Heap Snapshot of a Javascript File and Use It in Electron</a></li><li><a href="https://blog.atom.io/2018/01/10/the-state-of-atoms-performance.html" target="_blank" rel="noopener">The State of Atom’s Performance</a></li><li><a href="https://blog.atom.io/2017/04/18/improving-startup-time.html" target="_blank" rel="noopener">Improving Startup Time</a></li></ul><p><br><br><br></p><p><img src="/images/group.jpeg" alt><br><em>回复: <code>ivan</code> 进群</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019 年最后一发，谈谈这半年 Electron 应用开发和优化心得。干货也挺多，希望能给你带来一点启发。&lt;/p&gt;
&lt;p&gt;下半年可以拿出来说一说的项目，估计就是我们用 Electron 重构了一个桌面端应用。这个应用类似于&lt;code&gt;钉钉&lt;/code&gt;或者&lt;code&gt;企业
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>if 我是前端Leader，谈谈前端框架体系建设</title>
    <link href="https://bobi.ink/2019/12/06/fe-framework/"/>
    <id>https://bobi.ink/2019/12/06/fe-framework/</id>
    <published>2019-12-05T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>这期来聊一聊前端框架。</p><p>“if 我是前端 Leader” 是我的一个文章系列，说说我人在其位，欲谋其职的一些点点滴滴感悟。跟前端 Leader 只有那么一丢丢关系，干货不多，但老少皆宜，不要被标题给唬住了。</p><p><br></p><p><strong>文章大纲</strong></p><p><br></p><!-- TOC --><ul><li><a href="#什么是框架">什么是框架?</a></li><li><a href="#前端框架的发展历程">前端‘框架’的发展历程</a><ul><li><a href="#前端框架启蒙阶段">前端框架启蒙阶段</a></li><li><a href="#野蛮生长期">野蛮生长期</a></li><li><a href="#前端框架整合期">前端框架整合期</a></li></ul></li><li><a href="#现有的框架都有什么">现有的框架都有什么？</a></li><li><a href="#谈谈前端团队框架体系的建设">谈谈前端团队框架体系的建设</a><ul><li><a href="#第一阶段-前端工程化--基础设施">第一阶段: 前端工程化 / 基础设施</a></li><li><a href="#第二阶段-应用开发方案整合">第二阶段: 应用开发方案整合</a></li><li><a href="#第三阶段-组件体系">第三阶段: 组件体系</a></li><li><a href="#第四阶段打通上下游">第四阶段：打通上下游</a></li><li><a href="#未来-ai">未来: AI?</a></li></ul></li><li><a href="#扩展资料">扩展资料</a></li></ul><!-- /TOC --><p><br><br><br></p><h2 id="什么是框架"><a href="#什么是框架" class="headerlink" title="什么是框架?"></a>什么是框架?</h2><p>这应该不是我第一次谈‘框架‘了。React 是一个框架吗？ Vue 是一个框架吗？ 严格来说不是，它们只是一个视图解决方案，这里面算得上是框架的估计只有 Angular。</p><p>如果说后端框架围绕着<code>数据存储</code>建立起来，那么前端框架的基础就是视图库，毕竟前端的本质工作就是视图。这是为什么前端生态圈一般是围绕着视图库展开的。所以说，<strong>前端框架的基础是‘视图’库</strong>。</p><p>如果跟后端框架比起来，成熟的前端框架其实不多。</p><p><br></p><p><strong>什么是框架？</strong></p><p><br></p><p>看个例子。打开 <a href="https://umijs.org" target="_blank" rel="noopener">UmiJS</a>, 它对自己的描述是:</p><blockquote><p><strong>可插拔的企业级 react 应用框架</strong></p></blockquote><p>关键字是<strong>企业级</strong>。什么是企业级，我自己也说不清楚。我只知道 React 没有说自己是企业级，Koa、Express 也没有，然而 <a href="https://eggjs.org" target="_blank" rel="noopener">Eggjs</a> 和 <a href="https://umijs.org" target="_blank" rel="noopener">Umijs</a> 都说它们是<strong>企业级框架</strong>；Angular 通常也常常跟企业级这个概念联系在一起；语言层面有 Java。</p><p>对比一下他们就知道了，我觉得企业级表示它是 <strong>面向企业生产，目的是提高企业的生产力</strong>。总结一下有以下特点：</p><p><br></p><ul><li>是高效 + 成熟方案的整合</li><li>关注生产的整个链路，而不是某个环节</li><li>有更强的约束和限制</li><li>更严苛的要求。性能、可扩展性(以应对不同的需求)、健壮性、稳定性、可用性、安全性</li><li>标准化</li><li>经过生产环境验证, 有较多用例保证</li></ul><p><br></p><p>归根到底还是成本问题，框架最本质的目的就是要减低各类成本。让更少的人可以做更多的事情、且能保证质量、降低维护成本，且能保证不断优化和演进。</p><p><br></p><p><strong>给个定义吧。</strong></p><p><br></p><p><strong>前端框架体系的建立离不开前端工程化成熟和‘最佳实践‘的沉淀’。你可以认为框架就是一个整合的方案，提供一个前端‘最佳‘的组合配置。开发者需要做的就是在这个框架约束下填充自己业务代码。</strong></p><p><br></p><p>好处：</p><ul><li>效率提升。让开发者关注业务开发</li><li>学习成本降低。框架封装了很多底层复杂性</li><li>更强的约束。所有动作必须按照框架规定的执行, 避免干坏事、蠢事。更强的约束也意味着框架集成度更高、框架内部可以做更多事情，但灵活性也更低。</li><li>产品质量。框架内部会自动处理很多事情，例如性能优化、安全性处理</li><li>可维护性。所有项目都按照一致的、标准化的规范开发，升级迭代方便。这一点对团队项目的可维护性很重要。</li></ul><p><br></p><p>坏处:</p><ul><li>灵活性。不能满足所有人的需求，最佳实践这种东西有点武断</li><li>滞后性。具体方案可能会滞后。</li><li>大而全。对于某些项目可能过重。</li></ul><p><br><br><br></p><h2 id="前端‘框架’的发展历程"><a href="#前端‘框架’的发展历程" class="headerlink" title="前端‘框架’的发展历程"></a>前端‘框架’的发展历程</h2><h3 id="前端框架启蒙阶段"><a href="#前端框架启蒙阶段" class="headerlink" title="前端框架启蒙阶段"></a>前端框架启蒙阶段</h3><p>在 React、Vue 流行之前已经有许多‘前端框架‘，例如 Angular、Ember、Backbone…</p><p>它们大部分都受到后端框架的启发，因为当年也正是后端框架最火的时候，例如 Rails。所以在它们身上会看到很多后端框架的影子。</p><p>但是很多后端的开发模式，在前端有点吃不开。更本质的原因是前端工程化还不成熟，基础相对薄弱，难以支撑上层建筑的发展。</p><p><br><br><br></p><h3 id="野蛮生长期"><a href="#野蛮生长期" class="headerlink" title="野蛮生长期"></a>野蛮生长期</h3><p>随着 NodeJS 的普及、JavaScript 语言日益强大，前端工程化逐步深化。 React 这类视图库出来后，很多东西被打碎重构, 正所谓百花齐放，欣欣向荣。</p><p>围绕着三大视图库各种各样的库百花齐放，前端也拓展到了浏览器以外的领域。人们都乐于造轮子，使用最新的技术。</p><p>由于发展得太快，所谓的框架/最佳实践很难被广泛接受，或者很容易就过时了，每个人每个团队更热衷于创造自己的组合方案，往往也只限于团队内部。</p><p><br><br><br></p><h3 id="前端框架整合期"><a href="#前端框架整合期" class="headerlink" title="前端框架整合期"></a>前端框架整合期</h3><p>几乎每个团队都会重复走这样的路子：<em>稳定技术栈、工程化建设、基础库/组件库建设、沉淀自己的最佳实践</em>。</p><p>团队没有一定的工程能力和资源其实是很难将这些零散的实践体系化、有机地粘合起来, 长期有效的维护更新更是一件难事, 半途而废的居多。</p><p>现在前端发展开始进入平稳阶段。所以大一统的前端‘框架’再一次进入人们的视野。就像 Umi 的作者 <a href="https://www.zhihu.com/people/chenchengpro/activities" target="_blank" rel="noopener">云谦</a> 说的: <em>现在是工业化时代, 框架像是一个魔法球，把各种技术栈吸到一起，加工后吐给用户，以此来支撑业务</em>。</p><p><img src="/images/fe-framework/bigfish.jpg" alt><br><em>上图来源于&lt;蚂蚁前端研发最佳实践&gt; PPT</em></p><p><br></p><p>框架就是将各种技术栈方案、基础设施整合起来, 暴露标准的、一致性的接口, 让开发者专注业务开发。</p><p><br><br><br></p><h2 id="现有的框架都有什么？"><a href="#现有的框架都有什么？" class="headerlink" title="现有的框架都有什么？"></a>现有的框架都有什么？</h2><p><strong>一个前端开发框架应该涵盖前端开发链路的各个环节。为约束和简化业务开发、提供有用的指导</strong>。</p><p>看看现有‘前端框架‘吧，现在社区上比较流行的‘框架’有 Angular、Next.js、Nuxt、Umi。我们横向对比一下它们的一些特性，发现基本上包含这些东西：</p><p><img src="/images/fe-framework/framework-content.png" alt></p><p><br></p><p>跟衣服的标准码一样。社区开源的都是通用类型框架，可以预知的是它们没有办法满足所有团队的要求。我们往往需要根据自己业务情况量身定制框架。</p><p>为了应对这些需求，不同的框架也有不同的应对策略:</p><ul><li><strong>更开放</strong>。框架只提供核心功能，附加几乎什么事情都能干的<strong>插件机制</strong>。插件可以干预框架的整个生命周期，不满足的需求可以自己定制自己的插件</li><li><strong>更决断</strong>。我给你提供的就是最好的，能满足你的尽量满足你，其他的你不要管太多，也没有必要管, 专注你的业务。</li></ul><p><br></p><p>我们也有自己的选择策略:</p><ul><li>自己搞。例如大厂团队，有资源、有丰富的实践经验。他们有能力将自己的‘最佳实践’体系化。他们会选择创建自己的框架。同时他们也乐于将经验分享出来，也可以利用社区完善自己的作品。个人，基于学习和折腾的目的, 也可以搞一套。</li><li>基于开源框架扩展。可以将开源框架作为基础，根据自己团队情况进行扩展开发。</li><li>完全使用开源框架。开源框架可以满足许多通用的需求, 适合简单的应用场景。<strong>我们选择一个框架主要有两个原因：① 我们要提高工作效率；② 我们需要一个标准</strong>。 为了标准，其实可妥协一些事情。更重要的是这些框架是在不断发展和演进的, 从而我们团队的技术也可以免费地跟随他们演进和发展。将开源框架的默认最佳实践开发视为标准。</li></ul><p><br></p><p>我一直坚信<strong>专业的人做专业的事。要善于将事情外包出去，腾空自己去做重要的事情</strong>。大厂有专门的团队在做工具、建设基础设施，社区上开源的框架也由一大帮牛人在维护，而且通常开发迭代很活跃。所以说社区已经有的方案，可以直接拿来用，不要自己去造轮子，因为你一般没那么多精力。</p><p><br><br><br></p><h2 id="谈谈前端团队框架体系的建设"><a href="#谈谈前端团队框架体系的建设" class="headerlink" title="谈谈前端团队框架体系的建设"></a>谈谈前端团队框架体系的建设</h2><p>前端开发的时间都花在了哪里?</p><p><img src="/images/fe-framework/time.jpg" alt><br><em>上图来源于&lt;蚂蚁前端研发最佳实践&gt; PPT</em></p><p><br></p><p>对于前端团队来说，开源前端框架只是一个基础，只是涉及前端开发的某个很小的部分，它就像一艘船。你要航线穿越大西洋，还有做很多工作、需要紧密高效的协作、可靠的后勤保障、目标和方向、坚定的领导… 路还很长。</p><p><strong>现在来聊聊‘广义的‘框架体系，它集成自身业务，涉及前端开发完整链路，关注点从前端应用上升到了前端团队研发体系</strong>。</p><p><br></p><p><img src="/images/fe-framework/framework-order.png" alt></p><p><br></p><p>九层之台，起于累土。 前端团队框架体系的建设是一个渐进式的过程，首先从基础设施开始、接着就是应用开发技术栈组合，再到组件体系，后面是上层的业务开发方案… 上层以下层为基础，共同构建出完整的框架体系。</p><p>我觉得前端团队可以按照这样的分层结构，分阶段来完成这些建设任务。</p><p><br></p><h3 id="第一阶段-前端工程化-基础设施"><a href="#第一阶段-前端工程化-基础设施" class="headerlink" title="第一阶段: 前端工程化 / 基础设施"></a>第一阶段: 前端工程化 / 基础设施</h3><p>最基础的阶段，关注前端的基础设施建设。这个阶段已经比较成熟，社区上有很多开箱即用的方案，例如 Umi、Next.js、Vue-CLI、Create-React-App 等等。主要内容有:</p><p><img src="/images/fe-framework/base.png" alt></p><p><br></p><h3 id="第二阶段-应用开发方案整合"><a href="#第二阶段-应用开发方案整合" class="headerlink" title="第二阶段: 应用开发方案整合"></a>第二阶段: 应用开发方案整合</h3><p>在完善基础设施的同时，团队的应用开发技术栈组合方案也应该稳定下来，成为框架的一部分。这些组合也非常重要，它会影响上层的组件建设和业务开发。主要内容有:</p><p><img src="/images/fe-framework/app-dev.png" alt></p><p><br></p><h3 id="第三阶段-组件体系"><a href="#第三阶段-组件体系" class="headerlink" title="第三阶段: 组件体系"></a>第三阶段: 组件体系</h3><p>组件化现在是前端主流开发模式，这里还有很多工作可以做，还有很大的提效空间。</p><p>整个组件体系也是一个分层式的结构：</p><p><img src="/images/fe-framework/component.png" alt></p><ul><li>基础组件。越底层，就说明可复用的程度越高、越通用。Ant-Design、Element-UI、iView、Material-UI 这些就属于基础组件库，有能力的团队也可以开发一套符合自己设计风格的组件库。</li><li>业务组件。在基础组件之上封装的、耦合自己业务的组件。它们一般从重复的业务场景中抽象出来。</li><li>区块。再往上，就很难用模块化的组件去组织了。于是有人(阿里前端)提出了‘区块’的概念，<strong>你可以认为‘区块’是：代码片段、代码示例、代码模板…</strong> 这么看来，这并不是一种新的概念? 还没完! <strong>区块还要配套‘区块市场’才能展现它的用处。区块市场是一个代码片段分享平台，维护着大量的区块，试图覆盖大部分常见的使用场景。对于开发者来说就是找到尽量匹配自己场景的区块，拷贝过来，稍微改改就行了。这是一种 ‘Ctrl+C，Ctrl+V’ 编程哲学的完美实践啊</strong>。</li><li>页面。和区块差不多，快速生成页面和路由。约定式的路由可以给页面自动化创建带来一些便利。</li><li>布局。例如后台的整体布局。</li><li>项目。项目的整体结构。可以通过‘脚手架‘ 来快速生成项目模板。</li></ul><p><br></p><p><img src="/images/fe-framework/icework.png" alt></p><p><br></p><p>像区块、页面生成这些操作需要一些工具辅助。例如：</p><ul><li>生成器。生成不同级别的元件<ul><li>项目(项目模板)。 俗称脚手架, 支持不同的项目类型：应用、组件库、程序库、 插件</li><li>页面/路由</li><li>区块</li><li>组件</li><li>数据模型</li></ul></li><li>可视化工具。可视化的项目编排工具, 如飞冰。</li></ul><p><br></p><h3 id="第四阶段：打通上下游"><a href="#第四阶段：打通上下游" class="headerlink" title="第四阶段：打通上下游"></a>第四阶段：打通上下游</h3><p>前端只是研发流程的一环，只是前端自嗨，上下游没有资源支持，是很难走远的。</p><p>对于前端来说，通常上游指的是 UI、下游指的是后端。</p><p>对于 UI。上面说的组件体系，其实是建立在稳定的、一致的、统一的 UI 设计语言之上的。否则一切都是空谈。所以我们要求 UI 设计团队要有良好的设计规范、能和前端组件体系绑定并良性迭代。</p><p>对于 后端。可以促进建立更标准的接口范式、封装通用的服务(有利于业务组件复用)、更深的有业务中台、BFF…</p><p>上下游的打通，对前端生产力的解放也有非常大的促进作用。</p><p><br></p><h3 id="未来-ai"><a href="#未来-ai" class="headerlink" title="未来: AI?"></a>未来: AI?</h3><p>AI 自动生成前端代码？ 太高大上了，还是把话筒交给它吧： <a href="https://mp.weixin.qq.com/s/EktHbvCnghkywZE8rOvMhw" target="_blank" rel="noopener">《双 11 模块 79.34% 的代码是怎样智能生成的？》</a>， 溜了</p><p><br><br><br></p><h2 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/94949118" target="_blank" rel="noopener">《蚂蚁前端研发最佳实践》文字稿</a> 好文</li><li><a href="https://mp.weixin.qq.com/s/EktHbvCnghkywZE8rOvMhw" target="_blank" rel="noopener">双 11 模块 79.34% 的代码是怎样智能生成的？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这期来聊一聊前端框架。&lt;/p&gt;
&lt;p&gt;“if 我是前端 Leader” 是我的一个文章系列，说说我人在其位，欲谋其职的一些点点滴滴感悟。跟前端 Leader 只有那么一丢丢关系，干货不多，但老少皆宜，不要被标题给唬住了。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>JSX AS DSL? 写个 Mock API 服务器看看</title>
    <link href="https://bobi.ink/2019/11/29/jsx-as-dsl/"/>
    <id>https://bobi.ink/2019/11/29/jsx-as-dsl/</id>
    <published>2019-11-28T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.329Z</updated>
    
    <content type="html"><![CDATA[<p>这几天打算写一个简单的 API Mock 服务器，老生常谈哈？其实我是想讲 JSX, Mock 服务器只是一个幌子。我在寻找一种更简洁、方便、同时又可以灵活扩展的、和别人不太一样的方式，来定义各种 Mock API。后来我发现了 JSX 在领域问题描述的优势和潜力，当然这可不是空谈，我们会实际写一个项目来证实这个判断。</p><p><br></p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#1-领域问题的描述">1. 领域问题的描述</a><ul><li><a href="#11-配置文件形式">1.1 配置文件形式</a></li><li><a href="#12-编程语言与内部-dsl">1.2 编程语言与内部 DSL</a></li></ul></li><li><a href="#2-javascript-内部-dsl">2. JavaScript 内部 DSL</a><ul><li><a href="#21-对象形式">2.1 对象形式</a></li><li><a href="#22-链式调用形式">2.2 链式调用形式</a></li><li><a href="#23-es2015-template-tag">2.3 ES2015 Template Tag</a></li><li><a href="#24-要不试试-jsx">2.4 要不试试 JSX？</a></li></ul></li><li><a href="#3-jsx-入门">3. JSX 入门</a><ul><li><a href="#31-自定义工厂">3.1 自定义工厂</a></li><li><a href="#32-host-component-vs-custom-component">3.2 Host Component vs Custom Component</a></li><li><a href="#33-简单实现-createelement-工厂方法">3.3 简单实现 createElement 工厂方法</a></li></ul></li><li><a href="#4-基础组件的设计">4. 基础组件的设计</a><ul><li><a href="#41-来源于-koa-的灵感">4.1 来源于 Koa 的灵感</a></li><li><a href="#42-use-基础组件">4.2 use 基础组件</a></li><li><a href="#43-高层组件的封装">4.3 高层组件的封装</a></li></ul></li><li><a href="#5-浅谈实现原理">5. 浅谈实现原理</a><ul><li><a href="#51-渲染">5.1 ‘渲染’</a></li><li><a href="#52-运行">5.2 运行</a></li></ul></li><li><a href="#6-总结终于完事了">6. 总结，终于完事了</a></li><li><a href="#7-扩展">7. 扩展</a></li></ul><!-- /TOC --><p><br></p><h2 id="1-领域问题的描述"><a href="#1-领域问题的描述" class="headerlink" title="1. 领域问题的描述"></a>1. 领域问题的描述</h2><p>一上来就说这么抽象的名词，’领域问题’ 是什么鬼？什么是领域，Wiki 上解释的非常好，<strong>领域就是指某一专业或事物方面范围的涵盖</strong>。那么所谓领域问题就可以理解为，我们需要通过程序或者其他方式去解决的需求。</p><p>比如提到 API Mock 服务器，我们需要解决的就是请求匹配和数据模拟这些问题；Nginx 解决的资源伺服和代理问题；HTML + CSS 解决的是页面 UI 展示问题…</p><p>我们这里重点关注’<strong>描述</strong>‘。<strong>这些描述是提供给领域专家的‘前端‘ 或者 用户界面(UI)</strong>。举个例子：</p><p><br></p><p><img src="/images/jsx-as-dsl/dq-fe.png" alt></p><p><br></p><p>描述的形式有很多，例如配置文件、编程语言、图形界面。 先来看看现在常见的工具是怎么做的：</p><p><br></p><h3 id="1-1-配置文件形式"><a href="#1-1-配置文件形式" class="headerlink" title="1.1 配置文件形式"></a>1.1 配置文件形式</h3><p><strong>JSON?</strong></p><p>JSON 是一种非常简单的数据表述, 没有任何学习成本，解析也非常方便。但是它有非常多致命的缺陷，比如不支持注释、冗余、数据结构单一。</p><p><strong>YAML?</strong></p><p>相比 JSON 语法要简洁很多、可读性也比较强。作为一个配置文件形式非常优秀</p><p><strong>还是其他配置文件形式…</strong></p><p>通常这些配置文件都是语言无关的，因此不会包含特定语言的元素。换句话说配置文件形式数据是相对静态的, 所以灵活性、扩展性比较差。只适合简单的配置场景。</p><p>举个例子，这些配置文件不支持函数。我们的 Mock 服务器可能需要通过一个函数来动态处理请求，所以配置文件在这里并不适用。</p><blockquote><p>当然你可以通过其他方式来取代‘函数’，例如模板、或者脚本支持</p></blockquote><p><br><br><br></p><h3 id="1-2-编程语言与内部-dsl"><a href="#1-2-编程语言与内部-dsl" class="headerlink" title="1.2 编程语言与内部 DSL"></a>1.2 编程语言与内部 DSL</h3><p>我们需要回到编程语言本身，利用它的编程能力，实现配置文件无法实现的更强大的功能。</p><p>不过单纯使用通用类型编程语言，命令式的过程描述可能过于繁琐。<strong>我们最好针对具体领域问题进行简化和抽象，给用户提供一个友好的用户界面，让他们声明式地描述他们的领域问题。我们要尽可能减少用户对底层细节的依赖，与此同时最好能保持灵活的扩展能力</strong>。</p><p>我说的可能就是<a href="https://zh.wikipedia.org/wiki/领域特定语言" target="_blank" rel="noopener"><strong>DSL(Domain-specific languages)</strong></a>:</p><blockquote><p>DSL 是一种用于描述特定应用领域的计算机语言。DSL 在计算机领域有非常广泛的应用，例如描述 Web 页面的 HTML、数据库查询语言 SQL、正则表达式。<br>相对应的是<strong>通用类型语言</strong>(GPL, General-Purpose Language)，例如 Java、C++、JavaScript。它们可以用于描述任意的领域逻辑，它们通常是<a href="https://en.wikipedia.org/wiki/Turing_completeness" target="_blank" rel="noopener">图灵完备</a>的。<br>可以这么认为，虽然不严谨：除了通用类型语言、其他语言都算是 DSL。</p></blockquote><p><br></p><p><strong>怎么创建 DSL？</strong></p><p>从头开发一门新语言？No! 成本太高了</p><p>一种更优雅的方式是在通用编程语言的基础上进行减法或者封装抽象。当然不是所有类型语言都有这个’能力’, 比如 Java、C/C++ 就不行，它们的语法太 Verbose 或者工具链太重了。但是 Groovy、Ruby、Scala、还有 Elixir 这些语言就可以方便地创建出‘DSL’, 而且它们大部分是动态语言。</p><p>它们有的借助宏、有的天生语法就非常适合作为 DSL、有的具备非常强的动态编程能力… 这些因素促就了它们适合作为 DSL 的母体(宿主)。</p><p><strong>我们通常也将这种 DSL 称为 <code>Embedded DSL(嵌入式 DSL)</code> 或者 <code>内部 DSL</code>，因为它们寄生在通用类型编程语言中。而独立的 DSL，如 JSON、HTML，称为<code>外部DSL</code></strong>。</p><p>内部 DSL 好处是省去了实现一门语言的复杂性(Parse-&gt;Transform-&gt;Generate)。</p><p><br></p><p>举两个非常典型的例子:</p><p>Java 开发者常用的 <a href="https://gradle.org" target="_blank" rel="noopener">Gradle</a>，基于 Groovy:</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'java-library'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    api <span class="string">'org.apache.commons:commons-math3:3.6.1'</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">'com.google.guava:guava:27.0.1-jre'</span></span><br><span class="line"></span><br><span class="line">    testImplementation <span class="string">'junit:junit:4.12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>还有 CocoaPods, 基于 Ruby:</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">source <span class="string">'http://source.git'</span></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">'8.0'</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'Demo'</span> <span class="keyword">do</span></span><br><span class="line">    pod <span class="string">'AFNetworking'</span></span><br><span class="line">    pod <span class="string">'SDWebImage'</span></span><br><span class="line">    pod <span class="string">'Masonry'</span></span><br><span class="line">    pod <span class="string">"Typeset"</span></span><br><span class="line">    pod <span class="string">'BlocksKit'</span></span><br><span class="line">    pod <span class="string">'Mantle'</span></span><br><span class="line">    pod <span class="string">'IQKeyboardManager'</span></span><br><span class="line">    pod <span class="string">'IQDropDownTextField'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><br></p><p>具体的实现细节不在本文的范围之内，还是聊回 JavaScript。</p><p><br></p><p><strong>我个人要求 DSL 应该具备这些特性</strong>：</p><ul><li><strong>专注于特定领域</strong>。也就是说它的目的非常明确，因此比通用类型语言要简单很多，但是它的边界有时候并不好把握。</li><li><strong>组织性</strong>。它应该方便组织和描述领域问题, <strong>或者说这是一种约束能力</strong>。配置文件组织性就非常好，比如 JSON，它可以很容易地描述数据结构，没有什么心智负担。另一个典型的例子是单元测试框架(例如 jest)，它们使用 describe、it、expect 这些元件，让单元测试更好的组织起来。</li><li><strong>可读性</strong>。它必须是人类可读的、容易理解的。</li><li><strong>声明式</strong>。声明式优于过程式、描述 What 而不是 How。</li><li><strong>扩展性</strong>。很多 DSL 一开始并不关注这一点，因为一开始问题可能并不复杂。<strong>问题的领域不是静态不变的，它可能会变大，这时候 DSL 的扩展能力就很关键了</strong>。 就比如 HTML，随着前端开发越来越复杂，原有的元素和功能集合已经无法满足需求，所以衍生除了很多组件或者自定义元素方案。如果原本的 DSL 无法扩展，可以在这个基础之上再套一层 DSL，CSS vs SASS、HTML vs React 就是这样的例子。</li></ul><p><br><br><br></p><h2 id="2-javascript-内部-dsl"><a href="#2-javascript-内部-dsl" class="headerlink" title="2. JavaScript 内部 DSL"></a>2. JavaScript 内部 DSL</h2><p>上节提到了 Groovy、Ruby ‘适合‘ 用作 DSL 母体，并不代表一定要用它们实现，这只是说明它们天生具备的一些语言特性让实现更加便捷，或者说外观更加简洁。</p><p>Google 一把 ‘JavaScript DSL‘ 匹配的有效资料很少。 如果你觉得困惑那就应该回到问题本身, 最重要的是解决领域问题，至于怎么组织和描述则是相对次要的。所以不要去纠结 JavaScript 适不适合。</p><p><br></p><p>那我们就针对 Mock Server 这个具体领域，聊一聊 JavaScript 内部 DSL 的典型组织方式:</p><p><br></p><h3 id="2-1-对象形式"><a href="#2-1-对象形式" class="headerlink" title="2.1 对象形式"></a>2.1 对象形式</h3><p>最简单的方式是直接基于对象或者数组进行声明，实现简单又保持组织性。例如 <a href="https://umijs.org/zh/guide/mock-data.html#使用-umi-的-mock-功能" target="_blank" rel="noopener">Umi Mock</a> 还有 <a href="https://ice.work" target="_blank" rel="noopener">飞冰</a> Mock, 就是基于对象组织的:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 支持值为 Object 和 Array</span></span><br><span class="line">  <span class="string">'GET /api/users'</span>: &#123; <span class="attr">users</span>: [<span class="number">1</span>, <span class="number">2</span>] &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// GET POST 可省略</span></span><br><span class="line">  <span class="string">'/api/users/1'</span>: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 支持自定义函数，API 参考 express@4</span></span><br><span class="line">  <span class="string">'POST /api/users/create'</span>: <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">'OK'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 mockjs 等三方库</span></span><br><span class="line">  <span class="string">'GET /api/tags'</span>: mockjs.mock(&#123;</span><br><span class="line">    <span class="string">'list|100'</span>: [&#123; <span class="attr">name</span>: <span class="string">'@city'</span>, <span class="string">'value|1-100'</span>: <span class="number">50</span>, <span class="string">'type|0-2'</span>: <span class="number">1</span> &#125;],</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>和配置文件差不多, 实现和使用都非常简单 ，简单的 API Mock 场景开箱即用，对于复杂的用法和 API 协议，也可以通过自定义函数进一步封装。<strong>但是有时候我们希望库可以承担多一点事情</strong>。</p><p><br><br><br></p><h3 id="2-2-链式调用形式"><a href="#2-2-链式调用形式" class="headerlink" title="2.2 链式调用形式"></a>2.2 链式调用形式</h3><p>JavaScript 作为内部 DSL 的另外一种典型的形式是链式调用。</p><p>其中最出名的是 JQuery, 它让链式调用这种模式广为人知。相比啰嗦的原生 DOM 操作代码，JQuery 确实让人眼前一亮, 它暴露精简的 API, 帮我们屏蔽了许多底层 DOM 操作细节，抚平平台差异，同时还能保持灵活性和扩展性。这才是它真正流行的原因，大众喜闻乐见的都是简单的东西。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'.awesome'</span>)</span><br><span class="line">  .addClass(<span class="string">'flash'</span>)</span><br><span class="line">  .draggable()</span><br><span class="line">  .css(<span class="string">'color'</span>, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><p><br></p><p>JQuery 这种 API 模式也影响到了其他领域，比如 Iot 领域的 <a href="https://ruff.io/zh-cn/docs/getting-started.html" target="_blank" rel="noopener"><code>Ruff</code></a>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ready(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点亮灯</span></span><br><span class="line">  $(<span class="string">'#led-r'</span>).turnOn()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>jest</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(z).not.toBeNull()</span><br><span class="line">expect(z).toBeDefined()</span><br><span class="line">expect(value).toBeGreaterThan(<span class="number">3</span>)</span><br><span class="line">expect(value).toBeGreaterThanOrEqual(<span class="number">3.5</span>)</span><br></pre></td></tr></table></figure><p><br></p><p>API Mock 服务器领域也有两个这样的例子:</p><p><a href="https://github.com/nock/nock" target="_blank" rel="noopener">Nock</a>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scope = nock(<span class="string">'http://myapp.iriscouch.com'</span>)</span><br><span class="line">  .get(<span class="string">'/users/1'</span>)</span><br><span class="line">  .reply(<span class="number">404</span>)</span><br><span class="line">  .post(<span class="string">'/users'</span>, &#123;</span><br><span class="line">    username: <span class="string">'pgte'</span>,</span><br><span class="line">    email: <span class="string">'pedro.teixeira@gmail.com'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .reply(<span class="number">201</span>, &#123;</span><br><span class="line">    ok: <span class="literal">true</span>,</span><br><span class="line">    id: <span class="string">'123ABC'</span>,</span><br><span class="line">    rev: <span class="string">'946B7D1C'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .get(<span class="string">'/users/123ABC'</span>)</span><br><span class="line">  .reply(<span class="number">200</span>, &#123;</span><br><span class="line">    _id: <span class="string">'123ABC'</span>,</span><br><span class="line">    _rev: <span class="string">'946B7D1C'</span>,</span><br><span class="line">    username: <span class="string">'pgte'</span>,</span><br><span class="line">    email: <span class="string">'pedro.teixeira@gmail.com'</span>,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>还有网易云团队的 <a href="https://docs.svrx.io/zh/guide/route.html" target="_blank" rel="noopener">Srvx</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span>('/handle(.*)').to.handle(ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'handle'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">get</span>('/blog(.*)').to.json(&#123; code: <span class="number">200</span> &#125;)</span><br><span class="line"><span class="keyword">get</span>('/code(.*)').to.send('code', 201)</span><br><span class="line"><span class="keyword">get</span>('/json(.*)').to.send(&#123; json: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="keyword">get</span>('/text(.*)').to.send('haha')</span><br><span class="line"><span class="keyword">get</span>('/html(.*)').to.send('&lt;html&gt;haha&lt;/html&gt;')</span><br><span class="line"><span class="keyword">get</span>('/rewrite:path(.*)').to.rewrite('/query&#123;path&#125;<span class="string">')</span></span><br><span class="line"><span class="string">get('</span>/redirect:path(.*)<span class="string">').to.redirect('</span>localhost:<span class="number">9002</span>/proxy&#123;path&#125;<span class="string">')</span></span><br><span class="line"><span class="string">get('</span>/api(.*)<span class="string">').to.proxy('</span>http:<span class="comment">//mock.server.com/')</span></span><br><span class="line"><span class="keyword">get</span>('/test(.*)').to.proxy('http://mock.server.com/', &#123;</span><br><span class="line">  secure: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">get</span>('/test/:id').to.proxy('http://&#123;id&#125;.dynamic.server.com/<span class="string">')</span></span><br><span class="line"><span class="string">get('</span>/query(.*)<span class="string">').to.handle(ctx =&gt; &#123;</span></span><br><span class="line"><span class="string">  ctx.body = ctx.query</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">get('</span>/header(.*)<span class="string">')</span></span><br><span class="line"><span class="string">  .to.header(&#123; '</span>X-From<span class="string">': '</span>svrx<span class="string">' &#125;)</span></span><br><span class="line"><span class="string">  .json(&#123; user: '</span>svrx<span class="string">' &#125;)</span></span><br><span class="line"><span class="string">get('</span>/user<span class="string">').to.json(&#123; user: '</span>svrx<span class="string">' &#125;)</span></span><br><span class="line"><span class="string">get('</span>/sendFile/:path(.*)<span class="string">').to.sendFile('</span>./&#123;path&#125;<span class="string">')</span></span><br></pre></td></tr></table></figure><p><br></p><p>链式调用模式目前是主流的 JavaScript 内部 DSL 形式。而且实现也比较简单，<strong>更重要的是它接近自然语言</strong>。</p><p><br><br><br></p><h3 id="2-3-es2015-template-tag"><a href="#2-3-es2015-template-tag" class="headerlink" title="2.3 ES2015 Template Tag"></a>2.3 ES2015 Template Tag</h3><p>近年基于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings" target="_blank" rel="noopener">ES6 Template Tag</a> 特性引入‘新语言‘到 JavaScript 的库层出不穷。</p><p><strong>不过因为 ES6 Template Tag 本质上是字符串，所以需要解析和转换，因此更像是外部 DSL。别忘了 Compiler as Framework! 通常我们可以利用 Babel 插件在编译时提前将它们转换为 JavaScript 代码。</strong></p><p><br></p><p>举几个流行的例子:</p><p><a href="https://github.com/modernserf/zebu" target="_blank" rel="noopener">Zebu</a>: 这是一个专门用于解析 Template Tag 的小型编译器, 看看它的一些内置例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 范围</span></span><br><span class="line">range<span class="string">`1,3 ... (10)`</span> <span class="comment">// [1, 3, 5, 7, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态机, 牛逼</span></span><br><span class="line"><span class="keyword">const</span> traffic = machine<span class="string">`</span></span><br><span class="line"><span class="string">  initState: #green</span></span><br><span class="line"><span class="string">  states: #green | #yellow | #red</span></span><br><span class="line"><span class="string">  events: #timer</span></span><br><span class="line"><span class="string">  onTransition: <span class="subst">$&#123;state =&gt; <span class="built_in">console</span>.log(state)&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  #green  @ #timer -&gt; #yellow</span></span><br><span class="line"><span class="string">  #yellow @ #timer -&gt; #red</span></span><br><span class="line"><span class="string">  #red    @ #timer -&gt; #green</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">traffic.start() <span class="comment">// log &#123; type: "green" &#125;</span></span><br><span class="line">traffic.send(&#123; <span class="attr">type</span>: <span class="string">'timer'</span> &#125;) <span class="comment">// log &#123; type: "yellow" &#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>Jest 表格测试:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe.each<span class="string">`</span></span><br><span class="line"><span class="string">  a    | b    | expected</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;<span class="number">1</span>&#125;</span> | <span class="subst">$&#123;<span class="number">1</span>&#125;</span> | <span class="subst">$&#123;<span class="number">2</span>&#125;</span></span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;<span class="number">1</span>&#125;</span> | <span class="subst">$&#123;<span class="number">2</span>&#125;</span> | <span class="subst">$&#123;<span class="number">3</span>&#125;</span></span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;<span class="number">2</span>&#125;</span> | <span class="subst">$&#123;<span class="number">1</span>&#125;</span> | <span class="subst">$&#123;<span class="number">3</span>&#125;</span></span></span><br><span class="line"><span class="string">`</span>(<span class="string">'$a + $b'</span>, (&#123; a, b, expected &#125;) =&gt; &#123;</span><br><span class="line">  test(<span class="string">`returns <span class="subst">$&#123;expected&#125;</span>`</span>, () =&gt; &#123;</span><br><span class="line">    expect(a + b).toBe(expected)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  test(<span class="string">`returned value not be greater than <span class="subst">$&#123;expected&#125;</span>`</span>, () =&gt; &#123;</span><br><span class="line">    expect(a + b).not.toBeGreaterThan(expected)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  test(<span class="string">`returned value not be less than <span class="subst">$&#123;expected&#125;</span>`</span>, () =&gt; &#123;</span><br><span class="line">    expect(a + b).not.toBeLessThan(expected)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>除此之外还有:</p><ul><li><a href="https://github.com/developit/htm" target="_blank" rel="noopener">htm</a></li><li><a href="https://github.com/apollographql/graphql-tag" target="_blank" rel="noopener">graphql-tag</a></li><li><a href="http://styled-components.com" target="_blank" rel="noopener">styled-components</a></li></ul><p><br></p><p>Template Tag 这些方案给我们开了很多脑洞。尽管如此，它也带来了一些复杂性，就像开头说的，它们是字符串，需要解析、语法检查和转换，且 JavaScript 本身的语言机制并没有给它们带来多少便利(如语法高亮、类型检查)。</p><p><br><br><br></p><h3 id="2-4-要不试试-jsx？"><a href="#2-4-要不试试-jsx？" class="headerlink" title="2.4 要不试试 JSX？"></a>2.4 要不试试 JSX？</h3><p>铺垫了这么多，只是前戏。上面提到这些方案，要么过于简单、要么过于复杂、要么平淡无奇。我将目光投向了 JSX，我发现它可以满足我的大部分需求。</p><p>先来看看一下我们的 Mock 服务器的原型设计:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Get, Post, mock &#125; <span class="keyword">from</span> <span class="string">'jsxmock'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (</span><br><span class="line">  &lt;server port=<span class="string">"4321"</span>&gt;</span><br><span class="line">    &#123;<span class="comment">/* 首页 */</span>&#125;</span><br><span class="line">    &lt;Get&gt;hello world&lt;<span class="regexp">/Get&gt;</span></span><br><span class="line"><span class="regexp">    &#123;/</span>* 登录 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">    &lt;Post path="/</span>login<span class="string">"&gt;login success&lt;/Post&gt;</span></span><br><span class="line"><span class="string">    &#123;/* 返回 JSON */&#125;</span></span><br><span class="line"><span class="string">    &lt;Get path="</span>/json<span class="string">"&gt;&#123;&#123; id: 1 &#125;&#125;&lt;/Get&gt;</span></span><br><span class="line"><span class="string">    &#123;/* mockjs */&#125;</span></span><br><span class="line"><span class="string">    &lt;Get path="</span>/mockjs<span class="string">"&gt;&#123;mock(&#123; 'id|+1': 1, name: '@name' &#125;)&#125;&lt;/Get&gt;</span></span><br><span class="line"><span class="string">    &#123;/*自定义逻辑*/&#125;</span></span><br><span class="line"><span class="string">    &lt;Get path="</span>/user/:id<span class="string">"&gt;&#123;(req, res) =&gt; res.send('hello')&#125;&lt;/Get&gt;</span></span><br><span class="line"><span class="string">  &lt;/server&gt;</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure><p><br></p><p>嵌套匹配场景</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (</span><br><span class="line">  &lt;server&gt;</span><br><span class="line">    &lt;Get path=<span class="string">"/api"</span>&gt;</span><br><span class="line">      &#123;<span class="comment">/* 匹配 /api?method=foo */</span>&#125;</span><br><span class="line">      &lt;MatchBySearch key=<span class="string">"method"</span> value=<span class="string">"foo"</span>&gt;</span><br><span class="line">        foo</span><br><span class="line">      &lt;<span class="regexp">/MatchBySearch&gt;</span></span><br><span class="line"><span class="regexp">      &#123;/</span>* 匹配 /api?method=bar *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">      &lt;MatchBySearch key="method" value="bar"&gt;</span></span><br><span class="line"><span class="regexp">        bar</span></span><br><span class="line"><span class="regexp">      &lt;/</span>MatchBySearch&gt;</span><br><span class="line">      &lt;BlackHole&gt;我会吃掉任何请求&lt;<span class="regexp">/BlackHole&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Get&gt;</span><br><span class="line">  &lt;<span class="regexp">/server&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p><br></p><p>有点 Verbose? 进一步封装组件:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyAwesomeAPI = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; path = <span class="string">'/api'</span>, children &#125; = props</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Get path=&#123;path&#125;&gt;</span><br><span class="line">      &#123;<span class="built_in">Object</span>.keys(children).map(<span class="function"><span class="params">name</span> =&gt;</span> (</span><br><span class="line">        &lt;MatchBySearch key=<span class="string">"method"</span> value=&#123;name&#125;&gt;</span><br><span class="line">          &#123;children[name]&#125;</span><br><span class="line">        &lt;<span class="regexp">/MatchBySearch&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Get&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (</span><br><span class="line">  &lt;server&gt;</span><br><span class="line">    &lt;MyAwesomeAPI&gt;&#123;&#123; <span class="attr">foo</span>: <span class="string">'foo'</span>, <span class="attr">bar</span>: <span class="string">'bar'</span> &#125;&#125;&lt;<span class="regexp">/MyAwesomeAPI&gt;</span></span><br><span class="line"><span class="regexp">    &lt;MyAwesomeAPI path="/</span>api<span class="number">-2</span><span class="string">"&gt;&#123;&#123; hello: 'foo', world: 'bar' &#125;&#125;&lt;/MyAwesomeAPI&gt;</span></span><br><span class="line"><span class="string">  &lt;/server&gt;</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure><p><br></p><p>看起来不错哈？我们看到了 JSX 作为 DSL 的潜力，也把 React 的组件思维搬到了 GUI 之外的领域。</p><p><br></p><hr><p><br></p><p>你知道我的风格，篇幅较长 ☕️ 休息一会，再往下看。</p><p><br><br><br></p><h2 id="3-jsx-入门"><a href="#3-jsx-入门" class="headerlink" title="3. JSX 入门"></a>3. JSX 入门</h2><p>如果你是 React 的开发者，JSX 应该再熟悉不过了。它不过是一个语法糖，但是它目前不是 JavaScript 标准的一部分。Babel、Typescript 都支持转译 JSX。</p><p>例如</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jsx = (</span><br><span class="line">  &lt;div foo=<span class="string">"bar"</span>&gt;</span><br><span class="line">    &lt;span&gt;<span class="number">1</span>&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span&gt;2&lt;/</span>span&gt;</span><br><span class="line">    &lt;Custom&gt;custom element&lt;<span class="regexp">/Custom&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>会转译为:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jsx = React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    foo: <span class="string">'bar'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  React.createElement(<span class="string">'span'</span>, <span class="literal">null</span>, <span class="string">'1'</span>),</span><br><span class="line">  React.createElement(<span class="string">'span'</span>, <span class="literal">null</span>, <span class="string">'2'</span>),</span><br><span class="line">  React.createElement(Custom, <span class="literal">null</span>, <span class="string">'custom element'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-1-自定义工厂"><a href="#3-1-自定义工厂" class="headerlink" title="3.1 自定义工厂"></a>3.1 自定义工厂</h3><p>JSX 需要一个<strong>工厂方法</strong>来创建创建’节点实例’。默认是 <code>React.createElement</code>。我们可以通过注释配置来提示转译插件。按照习惯，自定义工厂都命名为 <code>h</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* @jsx h */</span></span><br><span class="line"><span class="comment">/* @jsxFrag 'fragment' */</span></span><br><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">'somelib'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jsx = (</span><br><span class="line">  &lt;div foo=<span class="string">"bar"</span>&gt;</span><br><span class="line">    &lt;span&gt;<span class="number">1</span>&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span&gt;2&lt;/</span>span&gt;</span><br><span class="line">    &lt;&gt;fragement&lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>将转译为:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">'somelib'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jsx = h(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    foo: <span class="string">'bar'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  h(<span class="string">'span'</span>, <span class="literal">null</span>, <span class="string">'1'</span>),</span><br><span class="line">  h(<span class="string">'span'</span>, <span class="literal">null</span>, <span class="string">'2'</span>),</span><br><span class="line">  h(<span class="string">'fragment'</span>, <span class="literal">null</span>, <span class="string">'fragement'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-2-host-component-vs-custom-component"><a href="#3-2-host-component-vs-custom-component" class="headerlink" title="3.2 Host Component vs Custom Component"></a>3.2 Host Component vs Custom Component</h3><p>JSX 会区分两种组件类型。小写开头的为内置组件，它们以字符串的形式传入 createElement; 大写开头的表示自定义组件, 作用域内必须存在该变量, 否则会报错。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内置组件</span></span><br><span class="line">;<span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span></span><br><span class="line"><span class="xml">// 自定义组件</span></span><br><span class="line"><span class="xml">;<span class="tag">&lt;<span class="name">Custom</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-3-简单实现-createelement-工厂方法"><a href="#3-3-简单实现-createelement-工厂方法" class="headerlink" title="3.3 简单实现 createElement 工厂方法"></a>3.3 简单实现 createElement 工厂方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> copy = &#123; ...(props || EMPTY_OBJECT) &#125;</span><br><span class="line">  copy.children = copy.children || (children.length &gt; <span class="number">1</span> ? children : children[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    _vnode: <span class="literal">true</span>,</span><br><span class="line">    type,</span><br><span class="line">    props: copy,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="4-基础组件的设计"><a href="#4-基础组件的设计" class="headerlink" title="4. 基础组件的设计"></a>4. 基础组件的设计</h2><h3 id="4-1-来源于-koa-的灵感"><a href="#4-1-来源于-koa-的灵感" class="headerlink" title="4.1 来源于 Koa 的灵感"></a>4.1 来源于 Koa 的灵感</h3><p>大家应该比较熟悉 koa 中间件机制。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// logger</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  <span class="keyword">const</span> rt = ctx.response.get(<span class="string">'X-Response-Time'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;rt&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// x-response-time</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="built_in">Date</span>.now() - start</span><br><span class="line">  ctx.set(<span class="string">'X-Response-Time'</span>, <span class="string">`<span class="subst">$&#123;ms&#125;</span>ms`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// response</span></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'Hello World'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>形象的说，它就是一个洋葱模型:</p><p><img src="/images/jsx-as-dsl/koa.png" alt></p><p><br></p><p>中间件调用 next，就会进入下一级。 如果把函数的边界打破。它的样子确实像洋葱:</p><p><img src="/images/jsx-as-dsl/koa-2.png" alt></p><p><br></p><p>✨<strong>我发现使用 JSX 可以更直观地表示这种洋葱结构</strong></p><p><br></p><p><img src="/images/jsx-as-dsl/koa-3.png" alt></p><p><br><br><br></p><h3 id="4-2-use-基础组件"><a href="#4-2-use-基础组件" class="headerlink" title="4.2 use 基础组件"></a>4.2 use 基础组件</h3><p>于是乎，有了 <code>&lt;use /&gt;</code> 这个基础组件。它类似于 Koa 的 <code>app.use</code>, 用于拦截请求，可以进行响应, 也可以选择进入下一层。</p><p><strong>① 来看看整体设计</strong>。</p><p>use 正是基于上面说的，使用 JSX 来描述中间件包裹层次的基础组件。因为使用的是一种树状结构，所以要区分<strong>兄弟中间件</strong>和<strong>子中间件</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;server&gt;</span><br><span class="line">  &lt;use m=&#123;A&#125;&gt;</span><br><span class="line">    &lt;use m=&#123;Aa&#125; /&gt;</span><br><span class="line">    &lt;use m=&#123;Ab&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">  &lt;use m=&#123;B&#125; /</span>&gt;</span><br><span class="line">  &lt;use m=&#123;C&#125; /&gt;</span><br><span class="line">&lt;<span class="regexp">/server&gt;</span></span><br></pre></td></tr></table></figure><p>其中 <code>Aa</code>、<code>Ab</code> 就是 <code>A</code> 的<strong>子中间件</strong>。在 A 中可以调用类似 koa 的 <code>next</code> 函数，进入下级中间件。</p><p><code>A</code>、<code>B</code>、<code>C</code>之间就是<strong>兄弟中间件</strong>。当前继中间件未匹配时，就会执行下一个相邻中间件。</p><p>乍一看，这就是 koa 和 express 的结合啊!</p><p><br></p><p><strong>② 再看看 Props 设计</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface UseProps &#123;</span><br><span class="line">  m: <span class="function">(<span class="params">req, res, recurse: (</span>) =&gt;</span> <span class="built_in">Promise</span>&lt;boolean&gt;) =&gt; <span class="built_in">Promise</span>&lt;boolean&gt;;</span><br><span class="line">  skip?: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>m</code></p><ul><li><p><code>req</code>、<code>res</code>：Express 的请求对象和响应对象</p></li><li><p><code>recurse</code>：递归执行子级中间件, 类似 koa 的 next。返回一个<code>Promise&lt;boolean&gt;</code>, 它将在下级中间件执行完成后 resolve，boolean 表示下级中间件是否匹配拦截了请求。</p></li><li><p>返回值：返回一个 <code>Promise&lt;boolean&gt;</code> 表示当前中间件是否匹配(拦截请求)。如果匹配，后续的兄弟中间件将不会被执行。</p></li></ul></li><li><p><code>skip</code>：强制跳过，我们在开发时可能会临时跳过匹配请求，这个有点像单元测试中的 skip</p></li></ul><p><br></p><p><strong>③ 看一下运行实例</strong></p><p>假设代码为:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cb = <span class="function"><span class="params">name</span> =&gt;</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (</span><br><span class="line">  &lt;server&gt;</span><br><span class="line">    &lt;use</span><br><span class="line">      m=&#123;<span class="keyword">async</span> (req, res, rec) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'A'</span>)</span><br><span class="line">        <span class="keyword">if</span> (req.path === <span class="string">'/user'</span>) <span class="keyword">await</span> rec() <span class="comment">// 如果匹配，则放行，让其递归进入内部</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'end A'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;use m=&#123;cb(<span class="string">'A-1'</span>)&#125;&gt;如果父级匹配，则这里会被执行&lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">      &lt;use m=&#123;cb('A-2')&#125;&gt;...&lt;/u</span>se&gt;</span><br><span class="line">    &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">    &lt;use m=&#123;cb('B')&#125; /</span>&gt;</span><br><span class="line">    &lt;use m=&#123;cb(<span class="string">'C'</span>)&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/server&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>如果请求的是 ‘/‘，那么打印的是 <code>A -&gt; end A -&gt; B -&gt; C</code>；<br>如果请求为 ‘/user’, 那么打印的是 <code>A -&gt; A-1 -&gt; A-2 -&gt; end A -&gt; B -&gt; C</code></p><p><br></p><p>我们的基础组件和 Koa / Express 一样，核心保持非常小而简洁，当然它也比较低级，这样能够保证灵活性。</p><p><strong>这个简单的基础组件设计就是整个框架的‘基石’</strong>。 如果你了解 Koa 和 Express，这里没有新的东西。只是换了一种表现方式。</p><p><br><br><br></p><h3 id="4-3-高层组件的封装"><a href="#4-3-高层组件的封装" class="headerlink" title="4.3 高层组件的封装"></a>4.3 高层组件的封装</h3><p>Ok, 有了 <code>use</code> 这个基础原语, 我可以做很多有意思的事情，使用组件化的思维封装出更高级的 API。</p><p><br></p><p><strong>① <code>&lt;Log&gt;</code>：打日志</strong></p><p>封装一个最简单的组件:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Log: Component = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;use</span><br><span class="line">      m=&#123;<span class="keyword">async</span> (req, res, rec) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">        <span class="comment">// 进入下一级</span></span><br><span class="line">        <span class="keyword">const</span> rtn = <span class="keyword">await</span> rec()</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">          <span class="string">`<span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;req.path&#125;</span>: <span class="subst">$&#123;<span class="built_in">Date</span>.now() - start&#125;</span>ms`</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> rtn</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>用法:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;server&gt;</span><br><span class="line">  &lt;Log&gt;</span><br><span class="line">    &lt;Get&gt;hello world&lt;<span class="regexp">/Get&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Post path="/</span>login<span class="string">"&gt;login sucess&lt;/Post&gt;</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">  &lt;/Log&gt;</span></span><br><span class="line"><span class="string">&lt;/server&gt;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><p><strong>② <code>&lt;NotFound&gt;</code>: 404</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NotFound = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; children &#125; = props</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;use</span><br><span class="line">      m=&#123;<span class="keyword">async</span> (req, res, rec) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> found = <span class="keyword">await</span> rec()</span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">          <span class="comment">// 下级未匹配</span></span><br><span class="line">          res.status(<span class="number">404</span>)</span><br><span class="line">          res.send(<span class="string">'Not Found'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>用法和 Log 一样。<code>recurse</code> 返回 false 时，表示下级没有匹配到请求。</p><p><br><br><br></p><p><strong>③ <code>&lt;Catch&gt;</code>: 异常处理</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Catch: Component = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;use</span><br><span class="line">      m=&#123;<span class="keyword">async</span> (req, res, rec) =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">await</span> rec()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          res.status(<span class="number">500</span>)</span><br><span class="line">          res.send(err.message)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>用法和 Log 一样。捕获下级中间件的异常。</p><p><br><br><br></p><p><strong>④ <code>&lt;Match&gt;</code>: 请求匹配</strong></p><p>Match 组件也是一个非常基础的组件，其他高层组件都是基于它来实现。它用于匹配请求，并作出响应。先来看看 Props 设计：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type CustomResponder =</span><br><span class="line">  | MiddlewareMatcher</span><br><span class="line">  | MockType</span><br><span class="line">  | boolean</span><br><span class="line">  | string</span><br><span class="line">  | number</span><br><span class="line">  | object</span><br><span class="line">  | <span class="literal">null</span></span><br><span class="line">  | <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface MatchProps &#123;</span><br><span class="line">  match?: <span class="function">(<span class="params">req: Request, res: Response</span>) =&gt;</span> boolean <span class="comment">// 请求匹配</span></span><br><span class="line">  headers?: StringRecord <span class="comment">// 默认响应报头</span></span><br><span class="line">  code?: number | string <span class="comment">// 默认响应码</span></span><br><span class="line">  <span class="comment">// children 类型则比较复杂, 可以是原始类型、对象、Mock对象、自定义响应函数，以及下级中间件</span></span><br><span class="line">  children?: ComponentChildren | CustomResponder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>Match 组件主体:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Match = <span class="function">(<span class="params">props: MatchProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; match, skip, children &#125; = props</span><br><span class="line">  <span class="comment">// 对 children 进行转换</span></span><br><span class="line">  <span class="keyword">let</span> response = generateCustomResponder(children, props)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;use</span><br><span class="line">      skip=&#123;skip&#125;</span><br><span class="line">      m=&#123;<span class="keyword">async</span> (req, res, rec) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 检查是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (match ? match(req, res) : <span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (response) &#123;</span><br><span class="line">            <span class="keyword">return</span> response(req, res, rec)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果没有响应器，则将控制权交给下级组件</span></span><br><span class="line">          <span class="keyword">return</span> rec()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>限于篇幅，Match 的具体细节可以看<a href="https://github.com/ivan-94/jsxmock/blob/master/src/components/Match.tsx" target="_blank" rel="noopener">这里</a></p><p>前进，前进。 <code>Get</code>、<code>Post</code>、<code>Delete</code>、<code>MatchByJSON</code>、<code>MatchBySearch</code> 都是在 <code>Match</code> 基础上封装了，这里就不展开了。</p><p><br><br><br></p><p><strong>⑤ <code>&lt;Delay&gt;</code>: 延迟响应</strong></p><p>太兴奋了，一不小心又写得老长，我可以去写小册了。Ok, 最后一个例子, 在 Mock API 会有模拟延迟响应的场景, 实现很简单:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Delay = <span class="function">(<span class="params">props: DelayProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; timeout = <span class="number">3000</span>, ...other &#125; = props</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;use</span><br><span class="line">      m=&#123;<span class="keyword">async</span> (req, res, rec) =&gt; &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> setTimeout(res, timeout))</span><br><span class="line">        <span class="keyword">return</span> rec()</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;Match &#123;...other&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>用法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Get path=<span class="string">"/delay"</span>&gt;</span><br><span class="line">  &#123;<span class="comment">/* 延迟 5s 返回 */</span>&#125;</span><br><span class="line">  &lt;Delay timeout=&#123;<span class="number">5000</span>&#125;&gt;Delay Delay...&lt;<span class="regexp">/Delay&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Get&gt;</span><br></pre></td></tr></table></figure><p>更多使用案例，请看 <a href="https://github.com/ivan-94/jsxmock" target="_blank" rel="noopener">jsxmock 文档</a>)</p><p>坚持到这里不容易，你对它的原理可能感兴趣，那不妨继续看下去。</p><p><br><br><br></p><h2 id="5-浅谈实现原理"><a href="#5-浅谈实现原理" class="headerlink" title="5. 浅谈实现原理"></a>5. 浅谈实现原理</h2><p>简单看一下实现。如果了解过 React 或者 Virtual-DOM 的实现原理。这一切就很好理解了。</p><p><br></p><h3 id="5-1-‘渲染’"><a href="#5-1-‘渲染’" class="headerlink" title="5.1 ‘渲染’"></a>5.1 ‘渲染’</h3><p>这是打了引号的’渲染’。这只是一种习惯的称谓，并不是指它会渲染成 GUI。它用来展开整颗 JSX 树。对于我们来说很简单，我们没有所谓的更新或者 UI 渲染相关的东西。只需递归这个树、收集我们需要的东西即可。</p><p>我们的目的是收集到所有的中间件，以及它们的嵌套关系。我们用 MiddlewareNode 这个树形数据结构来存储它们：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type Middleware = (</span><br><span class="line">  req: Request,</span><br><span class="line">  res: Response,</span><br><span class="line">  <span class="comment">// 递归</span></span><br><span class="line">  recurse: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>&lt;boolean&gt;,</span><br><span class="line">) =&gt; <span class="built_in">Promise</span>&lt;boolean&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface MiddlewareNode &#123;</span><br><span class="line">  m: Middleware           <span class="comment">// 中间件函数</span></span><br><span class="line">  skip: boolean           <span class="comment">// 是否跳过</span></span><br><span class="line">  children: MiddlewareNode[] <span class="comment">// 子级中间件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染函数:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> currentMiddlewareNode</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 🔴 创建根中间件</span></span><br><span class="line">  <span class="keyword">const</span> middlewares = (currentMiddlewareNode = createMiddlewareNode())</span><br><span class="line">  <span class="comment">// 🔴 挂载</span></span><br><span class="line">  <span class="keyword">const</span> tree = mount(vnode)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>挂载是一个递归的过程，这个过程中，遇到<code>自定义组件</code>我们就展开，遇到 use 组件就将它们收集到 <code>currentMiddlewareNode</code> 中:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prevMiddlewareNode</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode.type === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 🔴自定义组件展开</span></span><br><span class="line">    <span class="keyword">const</span> rtn = vnode.type(vnode.props)</span><br><span class="line">    <span class="keyword">if</span> (rtn != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 递归挂载自定义组件的渲染结果</span></span><br><span class="line">      mount(rtn, inst)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode.type === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="comment">// 内置组件</span></span><br><span class="line">    <span class="keyword">if</span> (vnode.type === <span class="string">'use'</span>) &#123;</span><br><span class="line">      <span class="comment">// 🔴收集中间件</span></span><br><span class="line">      <span class="keyword">const</span> md = createMiddlewareNode(inst.props.m)</span><br><span class="line">      md.skip = !!inst.props.skip</span><br><span class="line">      currentMiddlewareNode.children.push(md)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 保存父级中间件</span></span><br><span class="line">      prevMiddlewareNode = currentMiddlewareNode</span><br><span class="line">      currentMiddlewareNode = md <span class="comment">// ⬇️推入栈，下级的中间件将加入这个列表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ... 其他内置组件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 🔴递归挂载子级节点</span></span><br><span class="line">    mountChilren(inst.props.children, inst)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vnode.type === <span class="string">'use'</span>) &#123;</span><br><span class="line">      currentMiddlewareNode = prevMiddlewareNode <span class="comment">// ⬆️弹出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🔴 子节点列表挂载</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountChilren</span>(<span class="params">children: any, parent: Instance</span>) </span>&#123;</span><br><span class="line">  childrenToArray(children).forEach(mount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="5-2-运行"><a href="#5-2-运行" class="headerlink" title="5.2 运行"></a>5.2 运行</h3><p>现在看看怎么运行起来。我们实现了一个简单的中间件机制，相对 Koa 好理解一点：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">runMiddlewares</span>(<span class="params">req, res, current</span>): <span class="title">Promise</span>&lt;<span class="title">boolean</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; m, skip, children &#125; = current</span><br><span class="line">  <span class="keyword">if</span> (skip) &#123;</span><br><span class="line">    <span class="comment">// 跳过, 直接返回 false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用中间件</span></span><br><span class="line">  <span class="keyword">return</span> m(req, res, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// recurse 回调</span></span><br><span class="line">    <span class="comment">// 🔴 如果有下级中间件，则递归调用子级中间件</span></span><br><span class="line">    <span class="keyword">if</span> (children &amp;&amp; children.length) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> child <span class="keyword">of</span> children) &#123;</span><br><span class="line">        <span class="keyword">const</span> matched = <span class="keyword">await</span> runMiddlewares(req, res, child)</span><br><span class="line">        <span class="keyword">if</span> (matched) &#123;</span><br><span class="line">          <span class="comment">// 🔴 如果其中一个兄弟中间件匹配，后续的中间件都不会被执行</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 🔴 没有下级中间件，或者没有任何下级中间件匹配</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>很简单哈？ 就是递归递归递归</p><p><br><br><br></p><h2 id="6-总结，终于完事了"><a href="#6-总结，终于完事了" class="headerlink" title="6. 总结，终于完事了"></a>6. 总结，终于完事了</h2><p>本文从配置文件讲到 DSL，又讲到了 JavaScript 内部 DSL 表达形式和能力。最后将焦点聚集在了 JSX 上面。</p><p>我通过一个实战的案例展示了 JSX 和 React 的组件化思维，它不仅仅适用于描述用户界面，我们也看到 JSX 作为一种 DSL 的潜力和灵活性。</p><p>最后总结一下优缺点。</p><p><br></p><p><strong>✅ 优点</strong></p><ul><li><strong>更好的类型推断和约束</strong>。 Typescript 友好</li><li><strong>可组合</strong>。具有组件封装和组合能力, 可以轻易封装高级、易于使用的接口</li><li><strong>Just Javascript</strong>。 本身就是 JavaScript 代码，很灵活</li><li><strong>更好的组织性、媲美配置文件</strong>。JSX 语法类似于 XML，有良好的组织性。</li><li><strong>习惯</strong>。 如果你习惯 React，Vue 这类前端框架，JSX 配置方式很容易被接受和上手</li><li><strong>实现简单</strong>。</li><li><strong>更能直观地表现层级结构</strong>。比如表示中间件的洋葱结构</li><li><strong>模块化</strong>。与生俱来，可以将接口分发到不同的文件中，然后可轻易地组合起来。</li></ul><p><br></p><p><strong>⚠️ 缺点</strong></p><ul><li>代码需要转译。需要 Babel 和 Typescript 转译。</li><li>有点 Verbose。</li></ul><p><br></p><p><strong>灵活却有组织性</strong>。灵活通常容易导致杂乱无章，组织性则可能意味着牺牲灵活性，两者在某种意义上面看是矛盾的。能够将两者平衡案例其实很少见，JSX 可能是一个。（我好像在吹 🐂）</p><p><br></p><p><strong>🎉🎉代码已经在 Github, 目前正处于原型阶段: <a href="https://github.com/ivan-94/jsxmock" target="_blank" rel="noopener">ivan-94/jsxmock</a> 欢迎 ⭐️ 和贡献。</strong></p><p><br><br><br></p><h2 id="7-扩展"><a href="#7-扩展" class="headerlink" title="7. 扩展"></a>7. 扩展</h2><ul><li><a href="https://www.yinwang.org/blog-cn/2017/05/25/dsl" target="_blank" rel="noopener">DSL 的误区</a></li><li><a href="https://draveness.me/dsl" target="_blank" rel="noopener">谈谈 DSL 以及 DSL 的应用（以 CocoaPods 为例）</a></li><li><a href="https://www.phodal.com/blog/javascript-dsl-example/" target="_blank" rel="noopener">JavaScript DSL 示例</a></li><li><a href="https://www.zhihu.com/question/35436669" target="_blank" rel="noopener">你是如何构建 Web 前端 Mock Server 的？</a></li><li><a href="https://docs.svrx.io/zh/blog/mock.html" target="_blank" rel="noopener">使用 svrx 实现更优雅的接口 Mock</a></li></ul><p><br></p><p>也学别人建个群(好多读者问过)，试试水吧…</p><p><img src="/images/group.png" alt></p><p><br></p><p><img src="/images/sponsor.jpg" alt></p><p><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天打算写一个简单的 API Mock 服务器，老生常谈哈？其实我是想讲 JSX, Mock 服务器只是一个幌子。我在寻找一种更简洁、方便、同时又可以灵活扩展的、和别人不太一样的方式，来定义各种 Mock API。后来我发现了 JSX 在领域问题描述的优势和潜力，当然这可
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>如何学一门新语言，以 Dart 为例</title>
    <link href="https://bobi.ink/2019/11/23/learn-lang/"/>
    <id>https://bobi.ink/2019/11/23/learn-lang/</id>
    <published>2019-11-22T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.329Z</updated>
    
    <content type="html"><![CDATA[<p>世界上没有一种可以各个领域通吃的语言，为了应对不同的场景和需求，我们摆脱不了要学习一门新的语言。最近准备入坑 <code>Flutter</code>(技术储备)，学了点 Dart, 一点心得分享给大家。</p><p><br></p><p><strong>大纲</strong></p><!-- TOC --><ul><li><a href="#介绍">介绍</a><ul><li><a href="#1-假定前提">1. 假定前提</a></li><li><a href="#2-基本原则">2. 基本原则</a></li><li><a href="#3-基本姿势">3. 基本姿势</a></li></ul></li><li><a href="#已有的语言认知">已有的语言认知</a></li><li><a href="#建立标签云">建立标签云</a></li><li><a href="#刻意学习以-dart-为例">刻意学习，以 Dart 为例</a><ul><li><a href="#①-2018-最坑人语言">① 2018 最坑人语言?</a></li><li><a href="#②-针对客户端优化">② 针对客户端优化</a></li><li><a href="#③-面向对象">③ 面向对象</a></li><li><a href="#④-操作符">④ 操作符</a></li><li><a href="#⑤-constfinal-与静态数据">⑤ const/final 与静态数据</a></li><li><a href="#⑥-类型系统">⑥ 类型系统</a></li><li><a href="#⑦-异步异步">⑦ 异步异步</a></li><li><a href="#⑧-元编程">⑧ 元编程</a></li></ul></li><li><a href="#实践">实践</a></li><li><a href="#深入了解这门语言">深入了解这门语言</a></li><li><a href="#总结">总结</a></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="1-假定前提"><a href="#1-假定前提" class="headerlink" title="1. 假定前提"></a>1. 假定前提</h3><p>我想看这篇文章的应该都是程序员了吧？都有自己熟悉的语言，这就好办了，我们可以复用已有的认知去快速学习一门新语言。如果你是小白，这篇文章可能不适合你</p><p><br></p><h3 id="2-基本原则"><a href="#2-基本原则" class="headerlink" title="2. 基本原则"></a>2. 基本原则</h3><ul><li><p><strong>确定语言的定位和场景</strong>。别再说 PHP 是最好的语言了，大家都知道。每一门语言都有自己定位和适用场景，为了解决不同的问题。<strong>所以学习一门语言的时候，首先要了解语言的定位和领域，这样你才能明白为什么语言设计者设计某个特性的动机</strong>。例如:</p><ul><li><code>JavaScript</code>：浏览器脚本语言霸主, 写前端肯定绕不开 JavaScript 啦。一门十几天搞出来的语言，就不要问 <code>[] == ![] // true</code> 是什么动机了, 不要学这些糟粕。</li><li><code>Dart</code>： 针对客户端(‘Flutter’)优化语言, 当初号称要取代 JavaScript, 官方自己的定位就是客户端</li><li><code>Go</code>： 据说是 <code>C++</code> 编译速度慢倒逼出来的语言。所以你可以站在 C++ 的对立面去思考它的设计：例如 简单的语法、高速编译、垃圾回收、高性能、高并发。半数是为了解决 C++ 的问题。适用于服务器编程、分布式、网络编程、云平台。</li><li><code>Rust</code>： 系统编程语言，<code>C/C++</code> 最有力的挑战者</li></ul><p><br></p><p>当然，也有一些语言只有在特定平台或场景才能使用，这种没办法，这属于<strong>商业壁垒</strong>。例如</p><ul><li><code>Swift/Objective-C</code> 基本只能用于 Apple 平台，尽管 Swift 开源，也可以跑在 Linux 上，但除了 Apple 应用开发，很少看到 Swift 的身影</li><li><code>C#</code> 和 Swift 类似</li></ul><p><br></p></li><li><p><strong>不要陷入语言的语法细节，剥离掉语法糖</strong>。学习新语言，可以暂时忽略掉语法的细节, 切换到上帝视角</p></li><li><p><strong>基于原有的认知，横向进行比较</strong>。正常来说编程语言 80% 概念或范式是通用的，这就是为什么你熟悉一门语言，可以快速入门其他语言。</p></li><li><p><strong>打破认知</strong>。另外 20% 包含该门语言独有的特性和思想, 这才是我们需要关注的核心。</p></li></ul><p><br></p><h3 id="3-基本姿势"><a href="#3-基本姿势" class="headerlink" title="3. 基本姿势"></a>3. 基本姿势</h3><ul><li><strong>确定自己要解决的问题/场景</strong>。 我们学一门语言一般不是为了学习语言而学习。首先你应该有需要解决场景和问题，接着带着这些问题对编程语言进行选型，确定多个语言候选者。</li><li><strong>思考这些语言是怎么解决你的问题的？</strong> 这就是’打破认知’的过程, 分析一下这些候选者优缺点</li><li><strong>确定要学习这门语言了？</strong> 下文会按照这个步骤展开<ul><li><strong>建立标签云</strong>。收集这门语言的 20% 独有特性/思想, 例如 Killer Feature、槽点、吹点，针对性刻意进行学习。</li><li><strong>粗略过一下官方文档</strong>。 也就是那80%，对基本语法有个基本的印象，类比自己熟悉的语言，可以快速理解。</li><li><strong>开始实践</strong>。现在你这门语言建立初步的印象了。趁热开始实践，比如可以跟着官方入门教程。一边实践一边查阅文档，很快就能熟练起来</li><li><strong>深入了解这门语言</strong></li></ul></li></ul><p><br><br><br></p><h2 id="已有的语言认知"><a href="#已有的语言认知" class="headerlink" title="已有的语言认知"></a>已有的语言认知</h2><p>下面是常见编程语言的构成图谱，对照一下，这些概念是否都知道? 是否真的了解你用来吃饭的家伙?</p><p><br></p><p><img src="/images/learn-lang/langmind.png" alt></p><p><br></p><p>没看懂？看来你没学过一门真正(复杂)的语言，如 <code>Scala</code>、<code>C嘎嘎</code>，<code>Rust</code>。😺 翻过这些大山，其他的就是一览众山小了。太难了</p><p>小孩子才做选择，牛逼(有精力)的人是全都要。你也可以学几门比较有代表性语言。参考<a href="https://book.douban.com/subject/10555435/" target="_blank" rel="noopener">《七天七语言》</a>开始点技能树:</p><ul><li><p><strong>按市场划分</strong>:</p><ul><li>通用类型语言(用来吃饭的)。 例如 Java、JavaScript、Python、C/C++、Go、PHP、Objective-C/Swift(iOS开发者, 严格说不算‘通用’)</li><li>符合自己口味的小众语言。Rust、Elixir、Ruby、Kotlin、Clojure、OCaml…</li></ul></li><li><p><strong>按范式划分</strong>:</p><ul><li>面向对象: 例如 Ruby、Java、Python…</li><li>多范式: 例如 JavaScript、Scala、Rust…</li><li>函数式: 例如 Lisp(例如Clojure)、Erlang、Haskell…</li><li>过程式: 例如 C、Go(可以算是面向对象、Whatever)</li><li>原型语言: Io，好小众</li></ul></li><li><p><strong>其他划分方式</strong>:</p><ul><li>类型: 强类型、弱类型; 静态类型、动态类型</li><li>执行方式: 静态语言、脚本语言</li><li>系统层次: 系统编程语言、应用语言</li></ul></li></ul><p><br><br><br></p><h2 id="建立标签云"><a href="#建立标签云" class="headerlink" title="建立标签云"></a>建立标签云</h2><p>上文说了，80% 的知识是可以复用的，我们要针对另外 20% 该语言独有的特性和思想进行刻意学习。我这里介绍一个方法是建立一个标签云。<strong>这个标签云是对这门语言的一些关键描述</strong>。 例如它的主要特性、优点、吐槽点。</p><p>这些关键描述对我们快速了解一门语言有很大的帮助, <strong>这个标签云其实代表的就是你对这门语言的基本印象</strong>。 换句话说，你学了一门语言，但没怎么用，过一段时间就忘光了所有语法细节，但是这门语言的基本印象会长久停留在你脑海中。我想这些印象就是这门语言的精髓所在吧！</p><p>那么怎么收集这个标签云?</p><ul><li>打开官网。看官方怎么描述自己的语言、有哪些主要特性、定位是什么。</li><li>也可以通过 Wiki 看看这门语言的系统的描述和定义</li><li>知乎。看别人怎么吹或者吐槽这门语言的</li><li>道听途说</li><li>快速预览官方指南。找亮点</li></ul><p>随便举几个例子。 Dart 语言:</p><p><img src="/images/learn-lang/dart.png" alt></p><blockquote><p>标签云使用 <a href="https://www.wordclouds.com" target="_blank" rel="noopener">WordClouds</a> 生成</p></blockquote><p><br></p><p>Go 语言：</p><p><img src="/images/learn-lang/go.png" alt></p><p><br></p><p>Javascript:</p><p><img src="/images/learn-lang/javascript.png" alt></p><p><br></p><p>Elixir:</p><p><img src="/images/learn-lang/elixir.png" alt></p><p><br><br><br></p><h2 id="刻意学习，以-dart-为例"><a href="#刻意学习，以-dart-为例" class="headerlink" title="刻意学习，以 Dart 为例"></a>刻意学习，以 Dart 为例</h2><p>接着带着这些问题针对性地去学习这门语言, 这里以Dart 为例，因为这两天正好在学 Dart，准备入坑 Flutter，我自己对 Dart 没什么好感。</p><p>学习方法, 永远是 <strong>What / Why / How</strong>: 是什么，为什么这么设计，具体怎么做?</p><h3 id="①-2018-最坑人语言"><a href="#①-2018-最坑人语言" class="headerlink" title="① 2018 最坑人语言?"></a>① 2018 最坑人语言?</h3><p>没有 Flutter 这门语言确实要挂了。编程语言也要看爹</p><p><br></p><h3 id="②-针对客户端优化"><a href="#②-针对客户端优化" class="headerlink" title="② 针对客户端优化"></a>② 针对客户端优化</h3><p>这是官方自己的定位。</p><p>针对客户端优化主要体现在<code>开发体验</code>和<code>运行性能</code>上面</p><ul><li><code>JIT</code>(Just in Time) 快速编译生效，这是 Hot reload 基础。<strong>Hot reload 可以让 Flutter 接近 Web 的开发体验</strong></li><li><code>AOT</code>(Ahead of Time) 生成高效原生代码。可以得到更快的运行速度和启动速度</li><li>另外一层意思是，Dart 这门语言和 JavaScript 非常相似。比如语法、单线程/事件循环、事件驱动、async/await、Isolate、Generator、Future/Stream、collection if/for 可以媲美JSX</li><li>支持编译到JavaScript。浏览器是重要的客户端，不支持 JavaScript 还敢说客户端优化？</li></ul><p><br></p><h3 id="③-面向对象"><a href="#③-面向对象" class="headerlink" title="③ 面向对象"></a>③ 面向对象</h3><p>语法和 Java 很像，有一些语法糖挺甜的。</p><ul><li><p>没有关键字区分 class 和 interface，可以说 class 就是 interface</p></li><li><p><code>Mixins</code>。前端对 Mixin 的概念应该都不陌生，毕竟这么多人用 Vue?</p></li><li><p>操作符重载。Javascript 不支持操作符重载。所以对前端来说算是一个新东西。 不过个人不推荐，JavaScript 没有操作符重载不也用得挺爽？ 而且操作符的语义不明确，会徒增心智负担，这时候还不如使用定义良好的方法。<strong>有意义的名称比符号要好记忆</strong>。</p></li><li><p><code>new</code> 可选。在某些场景让代码更简洁，比如 Flutter 组件声明。算是弥补没有 JSX 之痛吧。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(</span><br><span class="line">    Center(</span><br><span class="line">      child: Text(</span><br><span class="line">        <span class="string">'Hello, world!'</span>,</span><br><span class="line">        textDirection: TextDirection.ltr,</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Callable Classes</code>。语法糖，没想到有什么应用场景。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WannabeFunction</span> </span>&#123;</span><br><span class="line">  call(<span class="built_in">String</span> a, <span class="built_in">String</span> b, <span class="built_in">String</span> c) =&gt; <span class="string">'<span class="subst">$a</span> <span class="subst">$b</span> <span class="subst">$c</span>!'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wf = <span class="keyword">new</span> WannabeFunction();</span><br><span class="line"><span class="keyword">var</span> out = wf(<span class="string">"Hi"</span>,<span class="string">"there,"</span>,<span class="string">"gang"</span>); <span class="comment">// 🍬</span></span><br></pre></td></tr></table></figure><p>我直接 <code>wf.call</code> 也不麻烦吧? 灵感来自JavaScript？ JavaScript 的函数也是一个对象，可以有自己属性</p></li></ul><p><br></p><h3 id="④-操作符"><a href="#④-操作符" class="headerlink" title="④ 操作符"></a>④ 操作符</h3><p>Dart 也有一些有趣的操作符/表达式，来看看有多甜：</p><ul><li><p><strong>级联操作符(Cascade Notation)</strong>。级联操作符是一个很甜的语法糖。不说废话，看代码:</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">querySelector</span>(<span class="string">'#confirm'</span>) <span class="comment">// Get an object.</span></span><br><span class="line">..text = <span class="string">'Confirm'</span> <span class="comment">// 🍬 甜点，这是类 jQuery 的串行调用的增强版</span></span><br><span class="line">..classes.add(<span class="string">'important'</span>)</span><br><span class="line">..onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">'Confirmed!'</span>));</span><br></pre></td></tr></table></figure><p>等价于:</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">querySelector</span>(<span class="string">'#confirm'</span>);</span><br><span class="line">button.text = <span class="string">'Confirm'</span>;</span><br><span class="line">button.classes.add(<span class="string">'important'</span>);</span><br><span class="line">button.onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">'Confirmed!'</span>));</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><p><strong>容器操作符(Collection Operators)</strong>。这个语法糖也会比较甜，前期用 Dart 来描述 Flutter 的视图是一件很痛苦的事情。Dart 陆续添加了一些甜点，如<code>展开操作符</code>、<code>Collection if/for</code>, 再加上<code>命名函数参数</code>和 <code>new可选</code>，表达力已经很接近 JSX 了</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, ...list];</span><br><span class="line">[<span class="number">0</span>, ...?list]; <span class="comment">// 支持识别null的展开操作符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// collection if</span></span><br><span class="line"><span class="keyword">var</span> nav = [</span><br><span class="line">  <span class="string">'Home'</span>,</span><br><span class="line">  <span class="string">'Furniture'</span>,</span><br><span class="line">  <span class="string">'Plants'</span>,</span><br><span class="line">  <span class="keyword">if</span> (promoActive) <span class="string">'Outlet'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// collection for</span></span><br><span class="line"><span class="keyword">var</span> listOfStrings = [</span><br><span class="line">  <span class="string">'#0'</span>,</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> listOfInts) <span class="string">'#<span class="subst">$i</span>'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><br></p><p><img src="/images/learn-lang/flutter-code.png" alt></p></li></ul><p><br></p><h3 id="⑤-const-final-与静态数据"><a href="#⑤-const-final-与静态数据" class="headerlink" title="⑤ const/final 与静态数据"></a>⑤ const/final 与静态数据</h3><p>在 dart 中 const/final 使用的地方非常多，可以用于修饰变量、实例变量、对象创建。</p><blockquote><p>注意：静态数据和不可变数据是不同的概念</p></blockquote><ul><li>变量修饰</li></ul><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> name = <span class="string">'Bob'</span>;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> foo = [];</span><br><span class="line"><span class="keyword">const</span> baz = [];</span><br><span class="line"></span><br><span class="line">console.log(foo == baz); <span class="comment">// true 编译时常量</span></span><br></pre></td></tr></table></figure><p>const 将被视为’编译时’常量。相对final 有所优化</p><p><br></p><ul><li>修饰对象创建</li></ul><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">const</span> [];</span><br></pre></td></tr></table></figure><p>const 修饰变量创建，Dart 会默认以 const 的上下文来实例化对象:</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> primaryColors = [</span><br><span class="line">  Color(<span class="string">"red"</span>, [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>]),</span><br><span class="line">  Color(<span class="string">"green"</span>, [<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>]),</span><br><span class="line">  Color(<span class="string">"blue"</span>, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>]),</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>primaryColor被修饰 const 修饰，那么其下的对象创建都隐式使用 const 修饰。上面的代码等价于:</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> primaryColors = <span class="keyword">const</span> [</span><br><span class="line">  <span class="keyword">const</span> Color(<span class="string">"red"</span>, <span class="keyword">const</span> [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>]),</span><br><span class="line">  <span class="keyword">const</span> Color(<span class="string">"green"</span>, <span class="keyword">const</span> [<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>]),</span><br><span class="line">  <span class="keyword">const</span> Color(<span class="string">"blue"</span>, <span class="keyword">const</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>]),</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><strong>Dart 内置的容器对象默认支持const</strong>。 对于自定义类，需要类提供<strong>const构造方法</strong>, 而且所有实例都必须使用final修饰。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin =</span><br><span class="line">      <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 所有实例变量都必须用final修饰</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x, y;</span><br><span class="line">  <span class="comment">// const 构造方法</span></span><br><span class="line">  <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="⑥-类型系统"><a href="#⑥-类型系统" class="headerlink" title="⑥ 类型系统"></a>⑥ 类型系统</h3><ul><li><p>名义类型。没有Duck Duck Duck 🦆🦆🦆</p></li><li><p>Sound Type System(soundness，严格类型系统)。即<strong>静态类型+运行时检查</strong>, 比如一个变量静态类型为 String，如果将int赋值给它，编译器会报错。但是通过某些手段，我们可以绕过编译器检查，例如强制类型转换。Sound Type System 可以在运行时进行类型检查，不会放过这些错误。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">int</span> a;</span><br><span class="line">  a = <span class="string">"1"</span> <span class="keyword">as</span> <span class="built_in">int</span>; <span class="comment">// 绕过了静态类型检查, 但是运行会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好处:</p><ul><li>代码更健壮</li><li>有利于AOT</li><li>尽可能消灭bug，编译阶段的漏网之鱼，也会被检测出来，不要抱着侥幸心理。</li></ul></li><li><p>dynamic：可以视作是any类型吧？尽量避免使用</p></li></ul><p><br></p><h3 id="⑦-异步异步"><a href="#⑦-异步异步" class="headerlink" title="⑦ 异步异步"></a>⑦ 异步异步</h3><p>Future/Stream、async/await、Generator。不必多说，熟悉 JavaScript 一看就懂</p><p><br></p><h3 id="⑧-元编程"><a href="#⑧-元编程" class="headerlink" title="⑧ 元编程"></a>⑧ 元编程</h3><ul><li><p>MetaData。和Java的注解差不多。顾名思义，MetaData就是给你的代码提供更多的信息。可以用于提示编译器，在运行时通过反射库也可以获取到MetaData信息。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;...&#125;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>noSuchMethod()</code>。类似于 Ruby 的 method_missing。 当未找到属性或者方法时被调用，可以实现一些动态属性或方法。元编程神器。在 JavaScript 中可以通过Proxy 实现相同的效果。</p></li></ul><p><br><br><br></p><p>说实话，Dart 没有什么多少让人眼前一亮的特性。在它身上你可以看到许多其他语言的影子、例如Java、JavaScript、Swift… 这也无可厚非，现代编程语言确实长得越来越像。</p><p>好处是它特别容易上手，坏处是除了 Flutter 绑定之外，我找不到其他可以用它的理由。</p><p><br><br><br></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>借助已有的经验，很快就可以入门，这时候能马上上手去写是最好的。</p><p>可以从Hello World 开始, 或者也可以从官方的入门教程开始。Dart 的话。</p><p>hello world !</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Hello, World!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过最简单的 hello world 也可以获知一些关键信息:</p><ul><li>类似 C 的前缀式类型声明。</li><li>main 程序入口</li><li>分号不能省略</li><li>标准库。print 来源于 <code>dart:core</code> 这个包是全局的</li><li>List 数组</li><li>泛型</li><li>…</li></ul><p><br></p><p>Flutter 搞起来！</p><p><br><br><br></p><h2 id="深入了解这门语言"><a href="#深入了解这门语言" class="headerlink" title="深入了解这门语言"></a>深入了解这门语言</h2><p>如果你喜欢这门语言，想要让你们的关系进一步发展，你就要深入了解它：</p><ul><li>了解它的最佳实践</li><li>阅读它的语言规范</li><li>造轮子。比如写个静态网页生成器; 如果是面向对象语言，可以实现几个常见的设计模式</li><li>学习标准库</li><li>了解实现原理</li><li>了解性能分析和优化</li></ul><p><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>编程语言也有三重境界:</p><p><strong>看山是山，看山不是山，看山还是山</strong></p><ul><li>① 我用的语言就是最好的语言，如 PHP，很牛逼</li><li>② 所有语言都差不多，本质都是一样</li><li>③ 回归到语言，语言不过是个工具。就像画家的画笔，不过是实现自己想法的一个工具。这个阶段，我们不再争执什么是最好的语言，而且为了不同的绘制效果选择不同的画笔。</li></ul><p>只要能解决我们需要解决的问题，编程语言从来不是门槛，或者说它是最容易被克服的问题。就像别人吐槽 Flutter 用 Dart 而不用JavaScript一样。</p><p><br><br><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://book.douban.com/subject/10555435/" target="_blank" rel="noopener">七周七语言</a></li><li><a href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages" target="_blank" rel="noopener">Wiki: Comparison of programming languages</a></li><li><a href="https://dart.dev/guides/language/language-tour#libraries-and-visibility" target="_blank" rel="noopener">Dart 官方文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;世界上没有一种可以各个领域通吃的语言，为了应对不同的场景和需求，我们摆脱不了要学习一门新的语言。最近准备入坑 &lt;code&gt;Flutter&lt;/code&gt;(技术储备)，学了点 Dart, 一点心得分享给大家。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大纲&lt;/str
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>if 我是前端Leader，怎么走出小微前端团队的围墙?</title>
    <link href="https://bobi.ink/2019/11/17/fe-load/"/>
    <id>https://bobi.ink/2019/11/17/fe-load/</id>
    <published>2019-11-16T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>上一个星期一直忙于救火，周末又赶去参加了 <a href="https://tweb.tencent.com/#/" target="_blank" rel="noopener"><code>Tweb Conf</code></a>(首次参加这类活动)，所以没什么输出。但是这个星期的紧张、忙碌以及焦虑，让我想明白了一些事情，写了本文，没什么干货，只是一些絮絮叨叨。</p><p>上周对我来说还有一个重要的里程碑是掘金等级到达 <strong>LV5</strong>。目标已经达成了，这是一种释然，我不再想为了获取更多点赞、更多阅读量去写文章，不再去取一些哗众取宠的标题，不再需要去证明什么。我发现我打开掘金的频率骤然降低了，以前一天可能 checkout 几十次。</p><p>新的一年，希望能够沉下心来，深入钻研自己的方向，投放更多精力到参与开源上面。</p><p><br></p><p><strong>大纲</strong></p><!-- TOC --><ul><li><a href="#小微外包企业前端的困境">小微/外包企业前端的困境</a></li><li><a href="#中台的概念">中台的概念</a></li><li><a href="#前后端分离再分离">前后端分离再分离</a></li><li><a href="#极简的技术栈">极简的技术栈</a></li><li><a href="#避免单点故障">避免’单点故障’</a></li><li><a href="#集体利益大于个人利益">集体利益大于个人利益</a></li><li><a href="#谈谈个人的发展-跳槽与跳槽路上">谈谈个人的发展: 跳槽与跳槽路上</a></li><li><a href="#总结">总结</a></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br><br><br></p><h2 id="小微-外包企业前端的困境"><a href="#小微-外包企业前端的困境" class="headerlink" title="小微/外包企业前端的困境"></a>小微/外包企业前端的困境</h2><p><img src="/images/fe-load/audi.png" alt></p><p><br></p><p>相信待在大厂的头部程序员只是少数，大部分前端还是蜗居在<strong>小微企业</strong>前端团队(<strong>🔴注意：特指工程能力较弱的团队，排除大厂和大牛创业公司</strong>)，望着大厂的围墙。想象他们光鲜亮丽、充满激情样子。同样是拧螺丝，同样实践着前端工程化、同样用着Vue、React 全家桶，别人是搞的是航母上的铆钉，你拧的是奥迪双钻的螺丝。</p><p><br></p><p>大厂谈高大上技术、谈架构，谈场景。小微企业前端谈温饱，我们或多或少面临这些困境:</p><p><strong>边缘化</strong></p><p>在这类公司，前端没什么<strong>话语权</strong>，他们只是一个简单页面实现，简称切图仔。</p><p>本质上是业务性质和规模决定了前端的工作不会占用太大比重，自然也不会受到太多重视, 可取代性也很高。这类公司往往是传统行业，例如硬件、电力。相反依赖于端行业，如电商、社交，前端的地位会高很多。</p><p>这种环境下，前端不会关心太多业务，当然容易被边缘化，扮演相声里面的捧哏角色。</p><p><br></p><p><strong>协助混乱/基础设施薄弱</strong></p><p>小微企业，因为人员整体水平不高，协作通常也比较混乱、不规范。这里指的是一个项目的整体研发协作。</p><p>对于前端来说，我们的上游可能是后端，后端的代码质量和规范性对前端影响也会特别大。 例如接口混乱、文档不规范、未考虑应用场景、接口不测试等等… 这种工作环境下，效率会非常低，前端开发会非常痛苦。</p><p>基础设施弱，前端工程化总感觉束手束脚。</p><p><br></p><p><strong>忙碌</strong></p><p>感觉每天都很忙碌，却像什么事情都没有做。每天的工作重复一次又一次，原地踏步。</p><p><br></p><p><strong>孤岛</strong></p><p>像置身孤岛，知识和消息是封闭的，个人能力和技术很难有大的突破。公司的格局决定个人的格局。</p><p><br></p><p><strong>人员变动</strong></p><p>吸引不了优秀的人才，而且优秀人才也留不住，整体水平较低，很难有技术沉淀和开拓。</p><p><br></p><p><strong>理想/企业文化的认同感</strong></p><p>我们只是为了赚钱，别跟我谈什么理想。我们感觉自己在被压榨，是机器，这样的工作自然不会有什么幸福感。</p><p>等等等…</p><p><br><br><br></p><h2 id="中台的概念"><a href="#中台的概念" class="headerlink" title="中台的概念"></a>中台的概念</h2><p>今年中台的概念的很火，我没怎么去关注它，因为我认为它跟我们前端的距离还是比较远，而且大厂才能搞得起来。直到在 <code>TWeb Conf</code> 上听 <a href="https://www.zhihu.com/people/fouber" target="_blank" rel="noopener">张云龙</a> 讲了 <a href="https://juejin.im/post/5dd20202e51d453ff47f9c81#heading-2" target="_blank" rel="noopener">《Headless CMS——小微项目的业务中台解决方案》</a> 让我对‘中台’提起了兴趣。</p><blockquote><p>这里有一篇文章<a href="https://juejin.im/post/5d995f82f265da5ba308389d#comment" target="_blank" rel="noopener">《漫画：什么是中台？》</a> 通俗讲解了中台的概念。</p></blockquote><p>不是大厂才能实践中台，我发现我们的应用也存在很多重复的业务，每新建一个应用，后端都要重复去拷贝和实现这些业务。对于后端来说，资源非常浪费，对于前端来说也是一个灾难。 因为我们发现，尽管后端的业务本质上是重复的，但是因为人为原因，他们每一次拷贝暴露出来的接口和流程或多或少和之前的应用不一致，每次前端都需要重新适配。</p><p><br></p><p><img src="/images/fe-load/strapi.png" alt="配图"></p><p><br></p><p>张云龙介绍了一个适合小微项目的业务中台解决方案，它举的例子是 <a href="https://strapi.io" target="_blank" rel="noopener"><code>Strapi</code></a>: 这是一个<code>Headless CMS</code>, 翻译为中文就是’无头’内容管理系统，和传统 CMS 的最大区别是 Headless，即它只暴露接口，没有固定的界面。</p><p><br></p><p>通过它, 你可以实现：</p><ul><li>可视化、快速的业务模型创建。类似创建数据库模型（数据库无关），可以灵活地配置各种字段类型(除了原始类型、还支持邮箱、文件上传)以及模型关系。</li><li>暴露规范的接口。支持 <code>Restful</code> 和 <code>GraphQL</code>。内置支持排序、分页、过滤、自动生成文档</li><li>内置权限控制系统。角色、JWT 鉴权</li><li>轻松集成内部系统。可以灵活地与自己的内部系统对接</li><li>扩展性。插件系统</li></ul><p>Headless CMS 是一种适用于小微企业的业务’中台’解决方案。通过Strapi 我们可以快速搭建简单的外围业务模型, 复用通用的服务和插件。</p><p>你也可以认为这是一种分层的架构，隔离了核心业务和外围业务。外层相比内层更加多变和冗杂，Strapi 中台层隔离了 UI 和 核心服务，它让核心服务可以下沉，专注于实现更加通用的服务；<br>通过 Strapi 可以快速搭建非核心的外围衍生业务模式，暴露标准化的接口范式，一方面可以及时响应前端多变的需求，另一方面提供标准化、一致化的接口范式，也可以降低沟通成本、提高开发效率。基于此, 前端也可以沉淀自己的可复用的业务组件。</p><p>当然，正如张云龙所说的，Strapi 相比大厂中台，就是个玩具。但对于小微企业，迅速开发原型响应市场、提高研发效率，却是一剂良药。</p><p><br><br><br></p><h2 id="前后端分离再分离"><a href="#前后端分离再分离" class="headerlink" title="前后端分离再分离"></a>前后端分离再分离</h2><p>你会发现前端开发的体系化、正规化，其实伴随着前后端分离逐步深化:</p><ul><li><p><strong>盘古开天</strong>：没有前后端之分</p></li><li><p><strong>模板时代</strong>: 按照MVC架构，后端负责MC, 实现业务，给前端提供数据。前端负责 V, 即写模板。前端后在项目结构上并没有分离，但是职责开始了分化。</p></li><li><p><strong>接口时代</strong>：后端提供 HTTP/WS 接口，前端负责请求接口和实现页面渲染。CSR(客户端渲染)技术开始爆发，Backbone、Angular、React… 前端在项目结构上已经从后端脱离。开发效率进一步提高。接口就是一个约定，按照约定先行的原则，前后端可以实现并行开发。但是这个阶段后端接口实现还是需要关心页面的呈现，必须提供能够满足UI渲染的接口。</p></li><li><p><strong>BFF时代</strong>：BFF 即 Backends for Frontend。伴随着阵痛，前后端进一步分离。主要有两个原因：终端多样性，桌面端、iOS、Android、前端、小程序… 不同的客户端对接口有不同的需求、而且这些需求是多变的。另外后端业务也向微服务演化, 于是后端的接口会趋向原子化、功能更加单一、更加通用。</p><p>但是这对于前端开发来说也是比较痛苦的，实现一个页面需要调用很多接口、随之页面性能也会降低。分层架构又派上用场，那就多加一层呗，这一层就是BFF，它让客户端开发者根据的自己需求在服务端来粘合后端的通用服务。这会后端再也不用关心UI了。BFF 时代，GraphQL 和 NodeJS 备受瞩目。</p></li><li><p><strong>Serverless时代</strong>：BFF 推行需要良好的基础设施和研发流程支撑，架构难度也比较高，因此通常只有大厂搞得起来。Serverless 借助云平台, 降低了对基础设施的依赖，以及开发和维护的难度。 所以基于 Serverless 的 BFF 门槛更低。Serverless 对前端开发的意义不止于此，强烈推荐 <a href="https://zhuanlan.zhihu.com/p/65914436" target="_blank" rel="noopener">《Serverless 掀起新的前端技术变革》</a> 这篇文章。</p></li></ul><p><br></p><p>后端不想关心 UI 呈现所需要的数据，只想关注于业务的实现。前端也想摆脱后端的下游依赖，既然大家都觉得不合适，分开是最好的。</p><p>回到开头那句话，前端开发的体系化、正规化伴随着前/后端的分离再分离，反之，正是因为前/后端分离的深化，前端开发得以正规化、体系化。上一节张云龙介绍的‘中台‘的概念，在某种意义上，也是一种前后端分离的深化。</p><p>因此，如果你的团队感受到了阵痛，其实也正好说明公司业务正处于上升状态，如无意外，你们踏上前人走过的路，和后端进一步撕裂。</p><p><br><br><br></p><h2 id="极简的技术栈"><a href="#极简的技术栈" class="headerlink" title="极简的技术栈"></a>极简的技术栈</h2><p><strong>Keep it Simple, Keep it Stupid</strong>。 最近对这个原则体会颇深。小微团队技术选型不应该随大流、追随最新最热的技术，而是应该选择符合自己的团队水平和业务情况的极简技术栈。</p><p>这四个原则非常重要：</p><ul><li><strong>简单</strong></li><li><strong>自动化</strong></li><li><strong>清晰健全的文档</strong></li><li><strong>约束</strong></li></ul><p>举几个例子:</p><p>‘简单’主要是为了减低学习的门槛、降低心智的负担, 接口越简洁越好：</p><ul><li>约定 &gt; 配置</li><li>显式 &gt; 隐式</li><li>声明式 &gt; 命令式</li><li>接口协议: JSONRPC &gt; Restful</li><li>构建工具: Parcel &gt; Webpack, 除此之外还有Vue-cli, create-react-app</li><li>框架：随便举个例子 Vue &gt; React。Vue 入门会‘相对’简单，React 太灵活、社区百花齐放、尽管我很爱它，但是它没办法阻止别人干蠢事。</li><li>状态管理: Mobx &gt; Redux &gt; Rxjs。</li><li>当然, 具体场景具体分析</li></ul><p><br></p><p>‘自动化’，能够自动化解决的事情，就不要靠文档规范、靠口头沟通:</p><ul><li>ESlint、Styleint、HTMLlint、Markdownlint… *Lint。有各种各样的 lint 工具和社区推荐规范，自动检测各个环节是否符合规范。</li><li>Prettier 代码格式化。只有一种代码样式，别BB</li></ul><p><br></p><p>‘文档’，重要性不言而喻。有事先看文档，再问别人</p><p>‘约束’，在事情失去控制时，我能体会到那种绝望。这时候你会希望当初有更多的约束，尽量让代码保持在可控范围之内。例如 Typescript，各种 *Lint。如果没有约束机制，规范永远只是规范。</p><p><br><br><br></p><h2 id="避免’单点故障’"><a href="#避免’单点故障’" class="headerlink" title="避免’单点故障’"></a>避免’单点故障’</h2><p>小微前端团队，人员资源非常有限，往往每个人负责不同的项目，这就可能出现‘单点故障’。假如这时候项目的负责人请假或者离职，就会让人措手不及。一方面项目交接过程会拉长，另一方面其他成员上下文切换的成本也很高。我们尤其害怕接手的项目是一个烂摊子。</p><p>解决单点故障的唯一办法是让更多的成员交叉参与不同的项目，项目的责任在于团队而不在于个人。另外可以配合例如代码 Review 这些手段，多种途径让团队成员可以熟悉项目的代码。</p><p>代码规范和共享代码在这里也可以起到很大的作用。如果’知识’可以在多个项目中复用和共享，那么项目上下文切换的成本就相对比较低。</p><p><br></p><h2 id="集体利益大于个人利益"><a href="#集体利益大于个人利益" class="headerlink" title="集体利益大于个人利益"></a>集体利益大于个人利益</h2><p>不管是大公司还是小公司，集体的利益永远是大于个人利益的。</p><p>上周做了两个错误的决策，一个是批了一个紧急项目负责人请假，二是项目未完整测试上线就带队去参加Tweb Conf。这两个决策导致很大的风险，也挨上级领导批评了，还好最后都搞定了。反省以下几点欠缺：</p><ul><li>集体利益大于个人利益。这是我们从小被灌输的思想，在一个集体中，你的行为和决策是需要对集体负责的。</li><li>对项目缺乏整体的把控，没有充分的风险评估。尽管前端只是一个完整项目的一环，作为前端团队Leader, 还是需要从整体上了解项目的进度。你要知道项目的开始时间、截止时间、提测时间、开发/测试进度、当前资源情况等。通过这些信息来进行制定资源的分配计划和风险预估。</li><li>推动协作效率的改进。作为团队 Leader，就不能只单纯关注技术和代码。我们需要去关注团队之间的协作通道，提高团队层面的协作效率，为团队成员扫除沟通方面的障碍。</li></ul><p>就像我经常跟我们的团队伙伴说：问题不可怕，可怕的是不知道问题在哪里，你要想进步、就要多反思、多问为什么…</p><p><br></p><h2 id="谈谈个人的发展-跳槽与跳槽路上"><a href="#谈谈个人的发展-跳槽与跳槽路上" class="headerlink" title="谈谈个人的发展: 跳槽与跳槽路上"></a>谈谈个人的发展: 跳槽与跳槽路上</h2><p>大公司有什么?</p><p><img src="/images/fe-load/base.png" alt></p><p><br></p><p>小公司有什么，可能什么都没有，百废待兴… 空间可能很大，天花板也可能很低。大部分情况下，它可能只是你的一个跳板。你要么在跳槽，要么在跳槽路上，或者你已经麻木了，迷茫不知进退。</p><p>不管怎么样，小微企业的前端需要多考虑自己的个人发展。包括我自己也在不停地思考，不甘平庸，努力寻找可以花一辈子去奋斗的事业，而不只是工作。</p><p><br></p><p>对于个人发展, 我有以下几点建议：</p><ul><li>确定自己想要深入挖掘方向。很多所谓的大牛大多都是某一具体领域的专家。前端目前也有很多细分领域。见 这次 Tweb Conf 的会场布置就知道了，它细分了主会场(传统前端)、小程序&amp;工程化、Node&amp;架构、跨端&amp;综合。另外<a href="https://gmtc.infoq.cn/2019/shenzhen/" target="_blank" rel="noopener">GMTC 大会主题划分</a>也具有参考性</li><li>跳出自己的舒适区, 去尝试新的东西</li><li>勇气。人有多大胆，地有多大产。没有勇气会错过很多东西</li><li>参与社区, 树立个人品牌</li><li>Stay hungry，Stay foolish</li><li>基础很重要。别着急学花里胡哨的东西，别着急跟着别人去看源码</li><li>尝试去理解业务，理解商业和世界运作的规律，提升格局和软技能</li></ul><p><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>小微企业的围墙不能靠一个人就能推倒，业务的扩张和升级才是真正的动力。如果你觉得你公司有上升的动力和势态，而且你认同公司的价值观，不妨一起努力推动公司的进步。反之，要认真考虑自身的发展。</p><p><br></p><p>不说了，各自珍重，努力奋斗</p><p><img src="/images/fe-load/hard-work.jpg" alt></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/77095720" target="_blank" rel="noopener">Serverless For Frontend 前世今生</a></li><li><a href="https://zhuanlan.zhihu.com/p/65914436" target="_blank" rel="noopener">Serverless 掀起新的前端技术变革</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一个星期一直忙于救火，周末又赶去参加了 &lt;a href=&quot;https://tweb.tencent.com/#/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Tweb Conf&lt;/code&gt;&lt;/a&gt;(首次参加这类活动)，所以没什么输出。但是
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香</title>
    <link href="https://bobi.ink/2019/11/04/react-composition/"/>
    <id>https://bobi.ink/2019/11/04/react-composition/</id>
    <published>2019-11-03T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.330Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5dadc6045188255a270a0f85" target="_blank" rel="noopener">前几篇文章</a>都在讲 React 的 Concurrent 模式, 很多读者都看懵了，这一篇来点轻松的，蹭了一下 Vue 3.0 的热度。讲讲如何在 React 下实现 <a href="https://vue-composition-api-rfc.netlify.com/#type-issues-with-class-api" target="_blank" rel="noopener"><code>Vue Composition API</code></a>(下面简称<strong>VCA</strong>)，只是个玩具，别当真。</p><p>实现 ‘React’ Composition API？看起来很吊，确实也是，通过本文你可以体会到这两种思想的碰撞, 你可以深入学习三样东西：<code>React Hooks</code>、<code>Vue Composition API</code>、<a href="https://mobx.js.org/refguide/api.html" target="_blank" rel="noopener"><code>Mobx</code></a>。篇幅很长(主要是代码)，当然干货也很多。</p><p><br></p><p><strong>目录</strong></p><p><br></p><!-- TOC --><ul><li><a href="#对比-react-hooks-和-vue-composition-api">对比 React Hooks 和 Vue Composition API</a><ul><li><a href="#基本-api-类比">基本 API 类比</a></li></ul></li><li><a href="#api-设计概览">API 设计概览</a></li><li><a href="#响应式数据和-ref">响应式数据和 ref</a><ul><li><a href="#关于-vue-composition-api-ref">关于 Vue Composition API ref</a></li><li><a href="#为什么需要-ref">为什么需要 ref?</a></li><li><a href="#ref-和-useref">ref 和 useRef</a></li></ul></li><li><a href="#生命周期方法">生命周期方法</a></li><li><a href="#watch">watch</a></li><li><a href="#包装-props-为响应式数据">包装 Props 为响应式数据</a></li><li><a href="#支持-context-注入">支持 Context 注入</a></li><li><a href="#跟踪组件依赖并触发重新渲染">跟踪组件依赖并触发重新渲染</a></li><li><a href="#forwardref-处理">forwardRef 处理</a></li><li><a href="#总结">总结</a></li><li><a href="#参考扩展">参考/扩展</a></li></ul><!-- /TOC --><p><br></p><p>Vue Composition API 是 Vue 3.0 的一个重要特性，和 React Hooks 一样，这是一种非常棒的<strong>逻辑组合/复用机制</strong>。尽管初期受到不少<a href="https://juejin.im/post/5d0f64d4f265da1b67211893" target="_blank" rel="noopener">争议</a>，<strong>我个人还是比较看好这个 API 提案，因为确实解决了 Vue 以往的很多痛点</strong>, 这些痛点在它的<a href="https://vue-composition-api-rfc.netlify.com/#motivation" target="_blank" rel="noopener"> RFC 文档</a>中说得很清楚。动机和 React Hooks 差不多，无非就是三点:</p><p><br></p><ul><li>① 逻辑组合和复用</li><li>② 更好的类型推断。完美支持 Typescript</li><li>③ Tree-shakable 和 代码压缩友好</li></ul><p><br></p><p>如果你了解 React Hooks 你会觉得 VCA 身上有很多 Hooks 的影子, 毕竟官方也承认 React Hooks 是 VCA 的主要灵感来源，但是 Vue 没有完全照搬 React Hooks，而是基于自己的数据响应式机制，创建出了自己特色的逻辑复用原语, 辨识度也是非常高的。</p><p><br><br><br></p><h2 id="对比-react-hooks-和-vue-composition-api"><a href="#对比-react-hooks-和-vue-composition-api" class="headerlink" title="对比 React Hooks 和 Vue Composition API"></a>对比 React Hooks 和 Vue Composition API</h2><p>对于 React 开发者来说, VCA 还解决了 React Hooks 的一些有点稍微让人难受、新手不友好的问题。这是驱动我写这篇文章原因之一，来尝试把 VCA 抄过来, 除了学习 VCA，还可以加深对 React Hooks 的理解。</p><p>VCA 官方 RFC 文档已经很详细列举了它和 React Hooks 的差异:</p><p><br></p><p><strong>① 总的来说，更符合惯用的 JavaScript 代码直觉</strong>。这主要是 Immutable 和 Mutable 的数据操作习惯的不同。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue: 响应式数据, 更符合 JavaScript 代码的直觉, 就是普通的对象操作</span></span><br><span class="line"><span class="keyword">const</span> data = reactive(&#123;<span class="attr">count</span>: <span class="number">1</span>&#125;)</span><br><span class="line">data.count++</span><br><span class="line"></span><br><span class="line"><span class="comment">// React: 不可变数据, JavaScript 原生不支持不可变数据，因此数据操作会 verbose 一点</span></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">1</span>)</span><br><span class="line">setCount(count + <span class="number">1</span>)</span><br><span class="line">setCoung(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// React: 或者使用 Reducer, 适合进行一些复杂的数据操作</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>, <span class="comment">/* 假设还有其他状态 */</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState)</span><br><span class="line">dispatch(&#123;<span class="attr">type</span>: <span class="string">'increment'</span>&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>不过, 不能说可变数据就一定好于不可变数据, 反之亦然。 <strong>不可变数据也给 React 发挥和优化的空间, 尤其在 Concurrent 模式下, 不可变数据可以更好地被跟踪和 reduce</strong>。 例如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React</span></span><br><span class="line"><span class="keyword">const</span> [state, setState] = useState(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> [startTransition] = useTransition()</span><br><span class="line"></span><br><span class="line">setState(<span class="number">1</span>)              <span class="comment">// 高优先级变更</span></span><br><span class="line">startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  <span class="comment">// 低优先级状态变更</span></span><br><span class="line">  setState(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>React 中状态变更可以有不同的优先级，实际上这些变更会放入一个队列中，界面可能先显示 <code>1</code>, 然后才是 <code>2</code>。<strong>你可以认为这个队列就是这个状态的历史快照，由 React 来调度进行状态的前进，有点类似于 Redux 的’时间旅行’</strong>。如果是可变数据，实现这种‘时间旅行’会相对比较麻烦。</p><p><br></p><hr><p><br></p><p><strong>② 不关心调用顺序和条件化</strong>。React Hooks <a href="https://juejin.im/post/5cfa29e151882539c33e4f5e" target="_blank" rel="noopener">基于数组实现</a>，每次重新渲染必须保证调用的顺序，否则会出现数据错乱。VCA 不依赖数组，不存在这些限制。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyHooks</span>(<span class="params">someCondition, antherCondition</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="comment">/* ... */</span>&#125;, []) <span class="comment">// 💥</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (anotherCondition) &#123;</span><br><span class="line">    <span class="keyword">return</span> something      <span class="comment">// 提前返回 💥</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [someState] = useState(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><p><strong>③ 不用每次渲染重复调用，减低 GC 的压力</strong>。 每次渲染所有 Hooks 都会重新执行一遍，这中间可能会重复创建一些临时的变量、对象以及闭包。而 VCA 的setup 只调用一次。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComp</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> add = <span class="function"><span class="params">()</span> =&gt;</span> setCount(<span class="function"><span class="params">c</span> =&gt;</span> c+<span class="number">1</span>)  <span class="comment">// 这些内联函数每次渲染都会创建</span></span><br><span class="line">  <span class="keyword">const</span> decr = <span class="function"><span class="params">()</span> =&gt;</span> setCount(<span class="function"><span class="params">c</span> =&gt;</span> c<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(count)</span><br><span class="line">  &#125;, [count])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    count: &#123;count&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">onClick</span>=<span class="string">&#123;add&#125;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">onClick</span>=<span class="string">&#123;decr&#125;</span>&gt;</span>decr<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><p><strong>④ 不用考虑 useCallback/useMemo 问题</strong>。 因为问题 ③ , 在 React 中，为了避免子组件 diff 失效导致无意义的重新渲染，我们几乎总会使用 useCallback 或者 useMemo 来缓存传递给下级的事件处理器或对象。</p><p>VCA 中我们可以安全地引用对象，随时可以存取最新的值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComp</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> add = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> setCount(<span class="function"><span class="params">c</span> =&gt;</span> c+<span class="number">1</span>), [])</span><br><span class="line">  <span class="keyword">const</span> decr = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> setCount(<span class="function"><span class="params">c</span> =&gt;</span> c<span class="number">-1</span>), [])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(count)</span><br><span class="line">  &#125;, [count])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">SomeComplexComponent</span> <span class="attr">count</span>=<span class="string">&#123;count&#125;</span> <span class="attr">onAdd</span>=<span class="string">&#123;add&#125;</span> <span class="attr">onDecr</span>=<span class="string">&#123;decr&#125;/</span>&gt;</span>)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// Vue: 没有此问题, 通过对象引用存取最新值</span></span><br><span class="line"><span class="xml">createComponent(&#123;</span></span><br><span class="line"><span class="xml">  setup((props) =&gt; &#123;</span></span><br><span class="line"><span class="xml">    const count = ref(0)</span></span><br><span class="line"><span class="xml">    const add = () =&gt; count.value++</span></span><br><span class="line"><span class="xml">    const decr = () =&gt; count.value--</span></span><br><span class="line"><span class="xml">    watch(count, c =&gt; console.log(c))</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line">    return () =&gt; &lt;SomeComplexComponent count=&#123;count&#125; onAdd=&#123;add&#125; onDecr=&#123;decr&#125;/&gt;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><p><strong>⑤ 不必手动管理数据依赖</strong>。在 React Hooks 中，使用 <code>useCallback</code>、<code>useMemo</code>、<code>useEffect</code> 这些 Hooks，都需要手动维护一个数据依赖数组。当这些依赖项变动时，才让缓存失效。</p><p>这往往是新手接触 React Hooks 的第一道坎。你要理解好闭包，理解好 Memoize 函数 ，才能理解这些 Hooks 的行为。这还不是问题，问题是这些数据依赖需要开发者手动去维护，很容易漏掉什么，导致bug。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComp</span>(<span class="params">&#123;anotherCount, onClick&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setState] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    onClick(anotherCount + count)</span><br><span class="line">  &#125;, [count]) <span class="comment">// 🐞漏掉了 antherCount 和 onClick</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此 React 团队开发了 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noopener">eslint-plugin-react-hooks</a>插件，辅助检查 React Hooks 的用法, 可以避免漏掉某些依赖。不过这个插件太死了，搞不好要写很多 <code>//eslint-disable-next-line</code> 😂</p><p>VCA 由于不存在 ④ 问题，当然也不存在 ⑤问题。 Vue 的响应式机制可以自动、精确地跟踪数据依赖，而且基于对象引用的不变性，我们不需要关心闭包问题。</p><p><br></p><hr><p><br></p><p>如果你长期被这些问题困扰，你会觉得 VCA 很有吸引力。而且它简单易学, 这简直是 Vue 开发者的‘福报‘啊！ 是不是也想自己动手写一个？把 VCA 搬到 React 这边来，解决这些问题？那请继续往下读</p><p><br><br><br></p><h3 id="基本-api-类比"><a href="#基本-api-类比" class="headerlink" title="基本 API 类比"></a>基本 API 类比</h3><p>首先，你得先了解 React Hooks 和 VCA。最好的学习资料是它们的官方文档。下面简单类比一下两者的 API:</p><p><br></p><table><thead><tr><th></th><th>React Hooks</th><th>Vue Composition API</th></tr></thead><tbody><tr><td>状态</td><td><code>const [value, setValue] = useState(0)</code> <br> <code>useReducer</code></td><td><code>const state = reactive({value: 0})</code> <br> <code>ref(0)</code></td></tr><tr><td>状态变更</td><td><code>setValue(1)</code> <br> <code>setValue(n =&gt; n + 1)</code> <br> <code>dispatch</code></td><td><code>state.value = 1</code> <br> <code>state.value++</code></td></tr><tr><td>状态衍生</td><td><code>useMemo(() =&gt; derived, [deps])</code></td><td><code>computed(() =&gt; derived)</code></td></tr><tr><td>对象引用</td><td><code>const foo = useRef(0);</code> <br> <code>foo.current = 1</code></td><td><code>const foo = ref(0)</code> <br> <code>foo.value = 1</code></td></tr><tr><td>挂载</td><td><code>useEffect(() =&gt; {/*挂载*/}, [])</code></td><td><code>onBeforeMount(() =&gt; {/*挂载前*/})</code> <br> <code>onMounted(() =&gt; {/*挂载后*/})</code></td></tr><tr><td>卸载</td><td><code>useEffect(() =&gt; () =&gt; {/*卸载*/}}, [])</code></td><td><code>onBeforeUnmount(() =&gt; {/*卸载前*/})</code> <br> <code>onUnmounted(() =&gt; {/*卸载后*/})</code></td></tr><tr><td>重新渲染</td><td><code>useEffect(() =&gt; {/*更新*/})</code></td><td><code>onBeforeUpdate(() =&gt; {/*更新前*/})</code> <br> <code>onUpdated(() =&gt; {/*更新后*/})</code></td></tr><tr><td>异常处理</td><td>目前只有类组件支持(<code>componentDidCatch</code>, <br> <code>static getDerivedStateFromError</code>)</td><td><code>onErrorCaptured((err) =&gt; {/*异常处理*/})</code></td></tr><tr><td>依赖监听</td><td><code>useEffect(() =&gt; {/*依赖更新*/}, [deps])</code></td><td><code>const stop = watch(() =&gt; {/*自动检测数据依赖, 更新...*/})</code></td></tr><tr><td>依赖监听 + 清理</td><td><code>useEffect(() =&gt; {/*...*/; return () =&gt; {/*清理*/}}, [deps])</code></td><td><code>watch(() =&gt; [deps], (newVal, oldVal, clean) =&gt; {/*更新*/; clean(() =&gt; {/* 清理*/})})</code></td></tr><tr><td>Context 注入</td><td><code>useContext(YouContext)</code></td><td><code>inject(key)</code> <br> <code>provider(key, value)</code></td></tr></tbody></table><p><br></p><p>对比上表，我们发现两者非常相似，每个功能都可以在对方身上找到等价物。 React Hooks 和 VCA 的主要差别如下:</p><p><br></p><ul><li><strong>数据方面</strong>。<code>Mutable</code> vs <code>Immutable</code>，<code>Reactive</code> vs <code>Diff</code>。</li><li><strong>更新响应方面</strong>。React Hooks 和其组件思维一脉相承，它依赖数据的比对来确定依赖的更新。而Vue 则基于自动的依赖订阅。这点可以通过对比 useEffect 和 watch 体会。</li><li><strong>生命周期钩子</strong>。React Hooks 已经弱化了组件生命周期的概念，类组件也废弃了<code>componentWillMount</code>、 <code>componentWillUpdate</code>、   <code>componentWillReceiveProps</code> 这些生命周期方法。 一则我们确实不需要这么多生命周期方法，React 做了减法；二则，Concurrent 模式下，Reconciliation 阶段组件可能会被重复渲染，这些生命周期方法不能保证只被调用一次，如果在这些生命周期方法中包含副作用，会导致应用异常, 所以废弃会比较好。Vue Composition API 继续沿用 Vue 2.x 的生命周期方法.</li></ul><p><br></p><p>其中第一点是最重要的，也是最大的区别(思想)。这也是为什么 VCA 的 ‘Hooks’ 只需要初始化一次，不需要在每次渲染时都去调用的主要原因: <strong>基于Mutable 数据，可以保持数据的引用，不需要每次都去重新计算</strong>。</p><p><br><br><br></p><h2 id="api-设计概览"><a href="#api-设计概览" class="headerlink" title="API 设计概览"></a>API 设计概览</h2><p>先来看一下，我们的玩具(随便取名叫<strong>mpos</strong>吧)的大体设计:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 就随便取名叫 mpos 吧</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  reactive,</span><br><span class="line">  box,</span><br><span class="line">  createRef,</span><br><span class="line">  computed,</span><br><span class="line">  inject,</span><br><span class="line">  watch,</span><br><span class="line">  onMounted,</span><br><span class="line">  onUpdated,</span><br><span class="line">  onUnmount,</span><br><span class="line">  createComponent,</span><br><span class="line">  Box</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'mpos'</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface CounterProps &#123;</span><br><span class="line">  initial: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MultiplyContext = React.createContext(&#123; <span class="attr">value</span>: <span class="number">0</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 Hooks</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTitle</span>(<span class="params">title: Box&lt;string&gt;</span>) </span>&#123;</span><br><span class="line">  watch(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">document</span>.title = title.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// createComponent 创建组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createComponent&lt;CounterProps&gt;(&#123;</span><br><span class="line">  <span class="comment">// 组件名</span></span><br><span class="line">  name: <span class="string">'Counter'</span>,</span><br><span class="line">  <span class="comment">// ⚛️ 和 Vue Composition API 一样的setup，只会被调用一次</span></span><br><span class="line">  <span class="comment">// 接受组件的 props 对象, 这也是响应式对象, 可以被watch，可以获取最新值</span></span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️创建一个响应式数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> data = reactive(&#123; <span class="attr">count</span>: props.initial, <span class="attr">tick</span>: <span class="number">0</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️等价于 Vue Composition API 的 ref</span></span><br><span class="line"><span class="comment">     * 由于reactive 不能包装原始类型，box 可以帮到我们</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> name = box(<span class="string">'kobe'</span>)</span><br><span class="line">    name.set(<span class="string">'curry'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(name.get()) <span class="comment">// curry</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️衍生数据计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> derivedCount = computed(<span class="function"><span class="params">()</span> =&gt;</span> data.count * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(derivedCount.get()) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️等价于 React.createRef()，用于引用Virtual DOM 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> containerRef = createRef&lt;HTMLDivElement&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️依赖注入，获取 React.Context 值, 类似于 useContext，只不过返回一个响应式数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> ctx = inject(MultiplyContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️可以复合其他 Hooks，实现逻辑组合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    useTitle(computed(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`title: <span class="subst">$&#123;data.count&#125;</span>`</span>))</span><br><span class="line">    <span class="keyword">const</span> awesome = useYourImagination()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️生命周期方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"mounted"</span>, container.current);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 支持类似 useEffect 的方式，返回一个函数，这个函数会在卸载前被调用</span></span><br><span class="line">      <span class="comment">// 因为一般资源获取和资源释放逻辑放在一起，代码会更清晰</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"unmount"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    onUpdated(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"update"</span>, data.count, props);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里是 onUnmount，而 VCA 是 onUnmounted</span></span><br><span class="line">    onUnmount(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"unmount"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️监听数据变动, 类似于 useEffect</span></span><br><span class="line"><span class="comment">     * 返回一个disposer，可以用于显式取消监听，默认会在组件卸载时自动取消</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> stop = watch(</span><br><span class="line">      () =&gt; [data.count], <span class="comment">// 可选</span></span><br><span class="line">      ([count]) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"count change"</span>, count);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 副作用</span></span><br><span class="line">        <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> data.tick++, count)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 副作用清理（可选）, 和useEffect 保持一致，在组件卸载或者当前函数被重新调用时，调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          clearInterval(timer)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// props 是一个响应式数据</span></span><br><span class="line">    watch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"initial change"</span>, props.initial);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// context 是一个响应式数据</span></span><br><span class="line">    watch(</span><br><span class="line">      () =&gt; [ctx.value],</span><br><span class="line">      ([ctxValue], [oldCtxValue]) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"context change"</span>, ctxValue);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️方法，不需要 useCallback，永久不变</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      data.count++;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️返回一个渲染函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 在这里你也可以调用 React Hooks, 就跟普通函数组件一样</span></span><br><span class="line">      useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br><span class="line">      &#125;, [])</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">"counter"</span> onClick=&#123;add&#125; ref=&#123;containerRef&#125;&gt;</span><br><span class="line">          &#123;data.count&#125; : &#123;derivedCount.get()&#125; : &#123;data.tick&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><p><br></p><p>我不打算完全照搬 VCA，因此略有简化和差异。以下是实现的要点:</p><ul><li>① 如何确保 setup 只初始化一次?</li><li>② 因为 ①，我们需要将 Context、Props 这些对象进行包装成响应式数据, 确保我们总是可以拿到最新的值，避免类似 React Hook 的闭包问题.</li><li>③ 生命周期钩子, watch 如何绑定到组件上？我们要实现一个调用上下文</li><li>④ watch 数据监听和释放</li><li>④ Context 支持, inject 怎么实现？</li><li>⑤ 如何触发组件重新渲染?</li></ul><p><br></p><p>我们带着这些问题，一步一步来实现这个 <strong>‘React Composition API’</strong></p><p><br><br><br></p><h2 id="响应式数据和-ref"><a href="#响应式数据和-ref" class="headerlink" title="响应式数据和 ref"></a>响应式数据和 ref</h2><p>如何实现数据的响应式？不需要我们自己去造轮子，现成最好库的是 <a href="https://mobx.js.org/refguide/observable.html" target="_blank" rel="noopener"><code>MobX</code></a>。</p><p><code>reactive</code> 和 <code>computed</code> 以及 <code>watch</code> 都可以在 Mobx 中找到等价的API。以下是 Mobx API 和 VCA 的对照表:</p><p><br></p><table><thead><tr><th>Mobx</th><th>Vue Composition API</th><th>描述</th></tr></thead><tbody><tr><td>observable(object/map/array/set)</td><td>reactive()</td><td>转换响应式对象</td></tr><tr><td>box(原始类型)</td><td>ref()</td><td>转换原始类型为响应式对象</td></tr><tr><td>computed() + 返回 box 类型</td><td>computed() + 返回 ref 类型</td><td>响应式衍生状态计算</td></tr><tr><td>autorun(), reaction()</td><td>watch()</td><td>监听响应式对象变动</td></tr></tbody></table><p><br></p><p>所以我们不需要自己去实现这些 API, 简单设置个别名:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mpos.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; observable, computed, isBoxedObservable &#125; <span class="keyword">from</span> <span class="string">'mobx'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type Box&lt;T&gt; = IObservableValue&lt;T&gt;</span><br><span class="line"><span class="keyword">export</span> type Boxes&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: T[K] extends Box&lt;infer V&gt; ? Box&lt;V&gt; : Box&lt;T[K]&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reactive = observable</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> box = reactive.box        <span class="comment">// 等价于 VCA 的 ref</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isBox = isBoxedObservabl</span><br><span class="line"><span class="keyword">export</span> &#123; computed &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于 VCA 的 toRefs, 见下文</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toBoxes</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>&gt;(<span class="params">obj: T</span>): <span class="title">Boxes</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res: Boxes&lt;T&gt; = &#123;&#125; <span class="keyword">as</span> any</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">k</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isBox(obj[k])) &#123;</span><br><span class="line">      res[k] = obj[k]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res[k] = &#123;</span><br><span class="line">        <span class="keyword">get</span>: () =&gt; obj[k],</span><br><span class="line">        <span class="keyword">set</span>: (v: any) =&gt; (obj[k] = v),</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>下面是它们的简单用法介绍(详细用法见<a href="https://mobx.js.org/refguide/observable.html" target="_blank" rel="noopener">官方文档</a>)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, box, computed &#125; <span class="keyword">from</span> <span class="string">'mpos'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ⚛️ reactive 可以用于转换 Map、Set、数组、对象为响应式数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> data = reactive(&#123;<span class="attr">foo</span>: <span class="string">'bar'</span>&#125;)</span><br><span class="line">data.foo = <span class="string">'baz'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reactive 内部使用Proxy 实现数据响应，他会返回一个新的对象，不会影响原始对象</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">firstName</span>: <span class="string">"Clive Staples"</span>, <span class="attr">lastName</span>: <span class="string">"Lewis"</span> &#125;</span><br><span class="line"><span class="keyword">const</span> person = reactive(initialState)</span><br><span class="line">person.firstName = <span class="string">'Kobe'</span></span><br><span class="line">person.firstName <span class="comment">// "Kobe"</span></span><br><span class="line">initialState.firstName <span class="comment">// "Clive Staples"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换数组</span></span><br><span class="line"><span class="keyword">const</span> arr = reactive([])</span><br><span class="line">arr.push(<span class="number">1</span>)</span><br><span class="line">arr[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ⚛️ 一般情况下都使用reactive，如果你要转换原始类型为响应式数据</span></span><br><span class="line"><span class="comment"> * 或者进行数据传递，可以用 box</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> temperature = box(<span class="number">20</span>)</span><br><span class="line">temperature.set(<span class="number">37</span>)</span><br><span class="line">temperature.get() <span class="comment">// 37</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ⚛️ 衍生数据计算, 它们也具有响应特性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> fullName = computed(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;person.firstName&#125;</span> <span class="subst">$&#123;person.lastName&#125;</span>`</span>)</span><br><span class="line">fullName.get() <span class="comment">// "Kobe Lewis"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="关于-vue-composition-api-ref"><a href="#关于-vue-composition-api-ref" class="headerlink" title="关于 Vue Composition API ref"></a>关于 Vue Composition API ref</h3><p>上面说了，<strong>VCA 的 ref 函数等价于 Mobx 的 box 函数</strong>。可以将原始类型包装为’响应式数据’(本质上就是创建一个reactive对象，监听getter/setter方法), 因此 ref 也被 称为<strong>包装对象</strong>(Mobx 的 box 命名更贴切):</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p><br></p><p>你可以这样理解, ref 内部就是一个 <code>computed</code> 封装(当然是假的):</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = reactive(&#123;value&#125;)</span><br><span class="line">  <span class="keyword">return</span> computed(&#123;</span><br><span class="line">    <span class="keyword">get</span>: () =&gt; data.value,</span><br><span class="line">    <span class="keyword">set</span>: val =&gt; data.value = val</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者这样理解也可以</span><br><span class="line">function ref(value) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = reactive(&#123;value&#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> value() &#123; <span class="keyword">return</span> data.value &#125;,</span><br><span class="line">    <span class="keyword">set</span> value(val) &#123; data.value = val &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>只不过它们需要通过 <code>value</code> 属性来存取值，有时候代码显得有点啰嗦。<strong>因此 VCA 在某些地方支持对 ref 对象进行<code>自动解包(Unwrap, 也称自动展开)</code></strong>, 不过目前自动解包，仅限于读取。 例如:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1️⃣ 作为reactive 值时</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">  count                  <span class="comment">// 可以赋值给 reactive 属性</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(state.count) <span class="comment">// 0 等价于 state.count.value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动展开有时候会让人困惑，这里有个陷阱，会导致原有的 ref 对象被覆盖</span></span><br><span class="line">state.count = <span class="number">1</span>          <span class="comment">// 被覆盖掉了, count 属性现在是 1, 而不是 Ref&lt;count&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2️⃣ 传递给模板时，模板可以自动解包</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// &lt;button @click="increment"&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// &lt;button @click="increment"&gt;&#123;&#123; count.value &#125;&#125;&lt;/button&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3️⃣ 支持直接 watch</span></span><br><span class="line">watch(count, (cur, prev) =&gt; &#123; <span class="comment">// 等价于 watch(() =&gt; count.value, (cur, prev) =&gt; &#123;&#125;)</span></span><br><span class="line">  <span class="built_in">console</span>.log(cur) <span class="comment">// 直接拿到的是 ref 的值，所以不需要 cur.value 这样获取</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>另外 VCA 的 computed 实际上就是返回 ref 对象:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> double = computed(<span class="function"><span class="params">()</span> =&gt;</span> state.count * <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(double.value) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><br></p><p>🤔 VSA 和 Mobx 的 API 惊人的相似。想必 Vue 不少借鉴了 Mobx.</p><p><br><br><br></p><h3 id="为什么需要-ref"><a href="#为什么需要-ref" class="headerlink" title="为什么需要 ref?"></a>为什么需要 ref?</h3><p>响应式对象有一个广为人知的陷阱，如果你对响应式对象进行解构、展开，或者将具体的属性传递给变量或参数，那么可能会导致响应丢失。 看下面的例子, 思考一下响应是怎么丢失的:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = reactive(&#123;<span class="attr">count</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构, 响应丢失了.</span></span><br><span class="line"><span class="comment">// 这时候 count 只是一个普通的、值为1的变量.</span></span><br><span class="line"><span class="comment">// reactive 对象变动不会传导到 count</span></span><br><span class="line"><span class="comment">// 修改变量本身，更不会影响到原本的reactive 对象</span></span><br><span class="line"><span class="keyword">let</span> &#123; count &#125; = data</span><br></pre></td></tr></table></figure><p><br></p><p>因为 Javascript <strong>原始值</strong>是<strong>按值传递</strong>的，这时候传递给变量、对象属性或者函数参数，引用就会丢失。<strong>为了保证 ‘安全引用’, 我们才需要用’对象’来包裹这些值，我们总是可以通过这个对象获取到最新的值</strong>:</p><p><img src="/images/react-composition/pass-by-reference-vs-pass-by-value-animation.gif" alt></p><p><br></p><p>关于 VCA 的 ref，还有 <a href="https://vue-composition-api-rfc.netlify.com/api.html#torefs" target="_blank" rel="noopener"><code>toRefs</code></a> 值得提一下。 <strong>toRefs 可以将 reactive 对象的每个属性都转换为 ref 对象，这样可以实现对象被解构或者展开的情况下，不丢失响应</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用toRefs 转换</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123;<span class="attr">count</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> stateRef = toRefs(state) <span class="comment">// 转换成了 Reactive&lt;&#123;count: Ref&lt;state.count&gt;&#125;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时候可以安全地进行解构和传递属性</span></span><br><span class="line"><span class="keyword">const</span> &#123; count &#125; = stateRef</span><br><span class="line"></span><br><span class="line">count.value    <span class="comment">// 1</span></span><br><span class="line">state.count    <span class="comment">// 1 三者指向同一个值</span></span><br><span class="line">stateRef.count.value <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">state.count++ <span class="comment">// 更新源 state</span></span><br><span class="line">count.value   <span class="comment">// 2 响应到 ref</span></span><br></pre></td></tr></table></figure><p><br></p><p>简单实现一下 toRefs, 没什么黑魔法:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toRefs</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isRef(obj[key])) &#123;</span><br><span class="line">      res[key] = obj[key]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res[key] = &#123;</span><br><span class="line">        <span class="keyword">get</span> value() &#123;</span><br><span class="line">          <span class="keyword">return</span> obj[key]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span> value(val) &#123;</span><br><span class="line">          obj[key] = val</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>toRefs 解决 reactive 对象属性值解构和展开导致响应丢失问题。配合<strong>自动解包</strong>，不至于让代码变得啰嗦(尽管有限制).</p><p><br></p><p> <strong>对于 VCA 来说，① ref 除了可以用于封装原始类型，更重要的一点是：② 它是一个’规范’的数据载体，它可以在 Hooks 之间进行数据传递；也可以暴露给组件层，用于引用一些对象，例如引用DOM组件实例</strong>。</p><p>举个例子, 下面的 <code>useOnline</code> Hook, 这个 Hooks 只返回一个状态:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useOnline</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> online = ref(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  online.value = navigator.onLine</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleOnline = <span class="function"><span class="params">()</span> =&gt;</span> (online.value = <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">const</span> handleOffline = <span class="function"><span class="params">()</span> =&gt;</span> (online.value = <span class="literal">false</span>)</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'online'</span>, handleOnline)</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'offline'</span>, handleOffline)</span><br><span class="line"></span><br><span class="line">  onUnmounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'online'</span>, handleOnline)</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'offline'</span>, handleOffline)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个 ref</span></span><br><span class="line">  <span class="comment">// 如果这时候返回一个 reactive 对象，会显得有点奇怪</span></span><br><span class="line">  <span class="keyword">return</span> online</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>如果 useOnline 返回一个 reactive 对象, 会显得有点怪:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样子？ online 可能会丢失响应</span></span><br><span class="line"><span class="keyword">const</span> &#123; online &#125; = useOnline() <span class="comment">// 返回 Reactive&lt;&#123;online: boolean&#125;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 怎么确定属性命名？</span></span><br><span class="line"><span class="keyword">const</span> online = useOnline()</span><br><span class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> online.online)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以我们需要规范，这个规范可以帮我们规避陷阱，也统一了使用方式</span></span><br><span class="line"><span class="comment">// 更规范的返回一个 ref，使用 value 来获取值</span></span><br><span class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> online.value)</span><br><span class="line"><span class="comment">// 可以更方便地进行监听</span></span><br><span class="line">wacth(online, (ol) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 直接拿到 online.value</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>再看另一个返回多个值的例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMousePosition</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pos = reactive(&#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;)</span><br><span class="line">  <span class="keyword">const</span> update = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    pos.x = e.pageX</span><br><span class="line">    pos.y = e.pageY</span><br><span class="line">  &#125;</span><br><span class="line">  onMounted(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">window</span>.addEventListener(<span class="string">'mousemove'</span>, update))</span><br><span class="line">  onUnmounted(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">window</span>.removeEventListener(<span class="string">'mousemove'</span>, update))</span><br><span class="line">  <span class="comment">// 返回多个值，可以使用 toRefs 批量转换</span></span><br><span class="line">  <span class="keyword">return</span> toRefs(pos)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyHook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 安全地使用解构表达式</span></span><br><span class="line">  <span class="keyword">const</span> &#123; x, y &#125; = useMousePosition()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... do something</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 安全地输出</span></span><br><span class="line">  <span class="keyword">return</span> &#123; x, y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>因此官方也推荐使用 ref 对象来进行数据传递，同时保持响应的传导</strong>。就到这吧，不然写着写着就变成 VCA 的文档了🌚。</p><p><br><br><br></p><h3 id="ref-和-useref"><a href="#ref-和-useref" class="headerlink" title="ref 和 useRef"></a>ref 和 useRef</h3><p>VCA ref 这个命名会让 React 开发者将其和 <code>useRef</code> 联想在一起。的确，VCA 的 ref 在结构、功能和职责上跟 React 的 useRef 很像。例如 <a href="https://vue-composition-api-rfc.netlify.com/api.html#template-refs" target="_blank" rel="noopener">ref 也可以用于引用 Virtual DOM的节点实例</a>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> root = ref(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with JSX</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &lt;div ref=&#123;root&#125;/&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>为了避免和现有的 useRef 冲突，而且在我们也不打算实现 ref 自动解包诸如此类的功能。因此在我们会沿用 Mobx 的 box 命名，对应的还有isBox, toBoxes 函数。</p><p><br></p><p>那怎么引用 Virtual DOM 节点呢？ 我们可以使用 React 的 <a href="https://reactjs.org/docs/react-api.html#reactcreateref" target="_blank" rel="noopener"><code>createRef()</code></a> 函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React 代码</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRef &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line">createComponent(&#123;</span><br><span class="line">  setup(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> containerRef = createRef()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &lt;div className=<span class="string">"container"</span> ref=&#123;containerRef&#125;&gt;?...?<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h2><p>接下来看看怎么实现 useMounted 这些生命周期方法。这些方法是全局、通用的，怎么关联到具体的组件上呢？</p><p>这个可以借鉴 React Hooks 的实现，当 setup() 被调用时，在一个全局变量中保存当前组件的上下文，生命周期方法再从这个上下文中存取信息。</p><p>来看一下 initial 的大概实现:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⚛️ 全局变量, 表示当前正在执行的 setup 的上下文</span></span><br><span class="line"><span class="keyword">let</span> compositionContext: CompositionContext | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * initial 方法接受一个 setup 方法， 返回一个 useComposition Hooks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initial</span>&lt;<span class="title">Props</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">Rtn</span>, <span class="title">Ref</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  setup: (props: Props</span>) =&gt; <span class="title">Rtn</span>,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">useComposition</span>(<span class="params">props: Props, ref?: React.RefObject&lt;Ref&gt;</span>): <span class="title">Rtn</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ⚛️ 使用 useRef 用来保存当前的上下文信息。 useRef，可以保证引用不变</span></span><br><span class="line">    <span class="keyword">const</span> context = useRef&lt;CompositionContext | <span class="literal">undefined</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前上下文为空，则开始初始化</span></span><br><span class="line">    <span class="comment">// ⚛️ 我们这样实现了 setup 只被调用一次!</span></span><br><span class="line">    <span class="keyword">if</span> (context.current == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 创建 Composition 上下文</span></span><br><span class="line">      <span class="keyword">const</span> ctx = (context.current = createCompositionContext(props));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ 进入当前组件的上下文作用域</span></span><br><span class="line">      <span class="keyword">const</span> prevCtx = compositionContext;</span><br><span class="line">      compositionContext = ctx;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ **调用 setup, 并缓存返回值**</span></span><br><span class="line">      ctx._instance = setup(ctx._props);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ 离开当前组件的上下文作用域, 恢复</span></span><br><span class="line">      compositionContext = prevCtx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他，下文展开</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 setup 的返回值</span></span><br><span class="line">    <span class="keyword">return</span> context.current._instance!;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>Ok，现在生命周期方法实现原理已经浮出水面, 当这些方法被调用时，只是简单地在 compositionContext 中注册回调, 例如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">onMounted</span>(<span class="params">cb: (</span>) =&gt; <span class="title">any</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️ 获取当前上下文</span></span><br><span class="line">  <span class="keyword">const</span> ctx = assertCompositionContext();</span><br><span class="line">  <span class="comment">// 注册回调</span></span><br><span class="line">  ctx.addMounted(cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">onUnmount</span>(<span class="params">cb: (</span>) =&gt; <span class="title">void</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = assertCompositionContext();</span><br><span class="line">  ctx.addDisposer(cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">onUpdated</span>(<span class="params">cb: (</span>) =&gt; <span class="title">void</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = assertCompositionContext();</span><br><span class="line">  ctx.addUpdater(cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>assertCompositionContext 获取 compositionContext，如果不在 <code>setup</code> 作用域下调用则抛出异常.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertCompositionContext</span>(<span class="params"></span>): <span class="title">CompositionContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (compositionContext == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`请在 setup 作用域使用`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> compositionContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>看一下 CompositionContext 接口的外形:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface CompositionContext&lt;P = any, R = any&gt; &#123;</span><br><span class="line">  <span class="comment">// 添加挂载回调</span></span><br><span class="line">  addMounted: <span class="function">(<span class="params">cb: (</span>) =&gt;</span> any) =&gt; <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 添加重新渲染回调</span></span><br><span class="line">  addUpdater: <span class="function">(<span class="params">cb: (</span>) =&gt;</span> <span class="keyword">void</span>) =&gt; <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 添加卸载回调</span></span><br><span class="line">  addDisposer: <span class="function">(<span class="params">cb: (</span>) =&gt;</span> <span class="keyword">void</span>) =&gt; <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 注册 React.Context 下文会介绍</span></span><br><span class="line">  addContext: &lt;T&gt;(ctx: React.Context&lt;T&gt;) =&gt; T;</span><br><span class="line">  // 添加通过ref暴露给外部的对象, 下文会介绍</span><br><span class="line">  addExpose: (value: any) =&gt; void</span><br><span class="line"></span><br><span class="line">  /** 私有属性 **/</span><br><span class="line">  // props 引用</span><br><span class="line">  _props: P;</span><br><span class="line">  // 表示是否已挂载</span><br><span class="line">  _isMounted: boolean;</span><br><span class="line">  // setup() 的返回值</span><br><span class="line">  _instance?: R;</span><br><span class="line">  _disposers: Array&lt;() =&gt; void&gt;;</span><br><span class="line">  _mounted: Array&lt;() =&gt; any&gt;;</span><br><span class="line">  _updater: Array&lt;() =&gt; void&gt;;</span><br><span class="line">  _contexts: Map&lt;React.Context&lt;any&gt;, &#123; value: any; updater: () =&gt; void &#125;&gt;</span><br><span class="line">  _exposer?: () =&gt; any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><code>addMounted</code>、<code>addUpdater</code> 这些方法实现都很简单, 只是简单添加到队列中:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCompositionContext</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt;(<span class="params">props: P</span>): <span class="title">CompositionContext</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = &#123;</span><br><span class="line">    addMounted: <span class="function"><span class="params">cb</span> =&gt;</span> ctx._mounted.push(cb),</span><br><span class="line">    addUpdater: <span class="function"><span class="params">cb</span> =&gt;</span> ctx._updater.push(cb),</span><br><span class="line">    addDisposer: <span class="function"><span class="params">cb</span> =&gt;</span> ctx._disposers.push(cb),</span><br><span class="line">    addContext: <span class="function"><span class="params">c</span> =&gt;</span> &#123;<span class="comment">/* ...  */</span>&#125; ,</span><br><span class="line">    _isMounted: <span class="literal">false</span>,</span><br><span class="line">    _instance: <span class="literal">undefined</span>,</span><br><span class="line">    _mounted: [],</span><br><span class="line">    _updater: [],</span><br><span class="line">    _disposers: [],</span><br><span class="line">    _contexts: <span class="keyword">new</span> <span class="built_in">Map</span>(),</span><br><span class="line">    _props: observable(props, &#123;&#125;, &#123; <span class="attr">deep</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">"props"</span> &#125;)</span><br><span class="line">    _exposer: <span class="literal">undefined</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>关键实现还是得回到 initial 方法中:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initial</span>&lt;<span class="title">Props</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">Rtn</span>, <span class="title">Ref</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  setup: (props: Props</span>) =&gt; <span class="title">Rtn</span>,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">useComposition</span>(<span class="params">props: Props, ref?: React.RefObject&lt;Ref&gt;</span>): <span class="title">Rtn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = useRef&lt;CompositionContext | <span class="literal">undefined</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context.current == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 初始化....</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 每次重新渲染, 调用 onUpdated 生命周期钩子</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> ctx = context.current;</span><br><span class="line">      <span class="comment">// 首次挂载时不调用</span></span><br><span class="line">      <span class="keyword">if</span> (ctx._isMounted) executeCallbacks(ctx._updater);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 挂载</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> ctx = context.current;</span><br><span class="line">      ctx._isMounted = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ 调用 useMounted 生命周期钩子</span></span><br><span class="line">      <span class="keyword">if</span> (ctx._mounted.length) &#123;</span><br><span class="line">        ctx._mounted.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// ⚛️ useMounted 如果返回一个函数，则添加到disposer中，卸载前调用</span></span><br><span class="line">          <span class="keyword">const</span> rt = cb();</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> rt === <span class="string">"function"</span>) &#123;</span><br><span class="line">            ctx.addDisposer(rt);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ctx._mounted = EMPTY_ARRAY; <span class="comment">// 释放掉</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ 调用 onUnmount 生命周期钩子</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> executeCallbacks(ctx._disposers);</span><br><span class="line">    &#125;, []);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>没错，这些生命周期方法，最终还是用 useEffect 来实现。</p><p><br><br><br></p><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>接下来看看 watch 方法的实现。watch 估计是除了 reactive 和 ref 之外调用的最频繁的函数了。</p><p>watch 方法可以通过 Mobx 的 <code>authrun</code> 和 <code>reaction</code> 方法来实现。我们进行简单的封装，让它更接近 Vue 的watch 函数的行为。</p><p>这里有一个要点是: watch 即可以在setup 上下文中调用，也可以裸露调用。在setup 上下文调用时，支持组件卸载前自动释放监听。 如果裸露调用，则需要开发者自己来释放监听:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 setup 上下文中调用，watch 会在组件卸载后自动解除监听</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyHook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = reactive(&#123;<span class="attr">count</span>: <span class="number">0</span>&#125;)</span><br><span class="line">  watch(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'count change'</span>, data.count))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 裸露调用，需要手动管理资源释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> stop = watch(<span class="function"><span class="params">()</span> =&gt;</span> someReactiveData, (data) =&gt; &#123;<span class="comment">/* reactiveData change */</span>&#125;)</span><br><span class="line">dosomething(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 手动释放</span></span><br><span class="line">  stop()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 另外watch 回调内部也可以获取到 stop 方法</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">wacth(<span class="function">(<span class="params">stop</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (someReactiveData === <span class="number">0</span>) &#123;</span><br><span class="line">    stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> someReactiveData, (data, stop) =&gt; &#123;<span class="comment">/* reactiveData change */</span>&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>另外 watch 的回调支持返回一个函数，用来释放副作用资源，这个行为和 useEffect 保持一致。VCA 的 watch 使用onClean 回调来释放资源，因为考虑到 async/await 函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="comment">/* do something*/</span>&#125;, time)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearInterval(timer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [time])</span><br><span class="line"></span><br><span class="line"><span class="comment">// watch</span></span><br><span class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="comment">/* do something*/</span>&#125;, time)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearInterval(timer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>看看实现代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reaction, autorun&#125; <span class="keyword">from</span> <span class="string">'mobx'</span></span><br><span class="line"><span class="keyword">export</span> type WatchDisposer = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">watch</span>(<span class="params">view: (stop: WatchDisposer</span>) =&gt; <span class="title">any</span>, <span class="title">options</span>?: <span class="title">IAutorunOptions</span>): <span class="title">WatchDisposer</span>;</span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">function</span> <span class="title">watch</span>&lt;<span class="title">T</span>&gt;(<span class="params">expression: (</span>) =&gt; <span class="title">T</span>, <span class="title">effect</span>: (<span class="params">arg: T, stop: WatchDisposer</span>) =&gt; <span class="title">any</span>, <span class="title">options</span>?: <span class="title">IReactionOptions</span>): <span class="title">WatchDisposer</span>;</span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">function</span> <span class="title">watch</span>(<span class="params">expression: any, effect: any, options?: any</span>): <span class="title">WatchDisposer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 放置 autorun 或者 reactive 返回的释放函数</span></span><br><span class="line">  <span class="keyword">let</span> nativeDisposer: WatchDisposer;</span><br><span class="line">  <span class="comment">// 放置上一次 watch 回调返回的副作用释放函数</span></span><br><span class="line">  <span class="keyword">let</span> effectDisposer: WatchDisposer | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 是否已经释放</span></span><br><span class="line">  <span class="keyword">let</span> disposed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装释放函数，支持被重复调用</span></span><br><span class="line">  <span class="keyword">const</span> stop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (disposed) <span class="keyword">return</span>;</span><br><span class="line">    disposed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (effectDisposer) effectDisposer();</span><br><span class="line">    nativeDisposer();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装回调方法</span></span><br><span class="line">  <span class="keyword">const</span> effectWrapper = <span class="function">(<span class="params">effect: (...args: any[]</span>) =&gt;</span> any, <span class="attr">argnum</span>: number) =&gt; (</span><br><span class="line">    ...args: any[]</span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 重新执行了回调，释放上一个回调返回的释放方法</span></span><br><span class="line">    <span class="keyword">if</span> (effectDisposer != <span class="literal">null</span>) effectDisposer();</span><br><span class="line">    <span class="keyword">const</span> rtn = effect.apply(<span class="literal">null</span>, args.slice(<span class="number">0</span>, argnum).concat(stop));</span><br><span class="line">    effectDisposer = <span class="keyword">typeof</span> rtn === <span class="string">"function"</span> ? rtn : <span class="literal">undefined</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> expression === <span class="string">"function"</span> &amp;&amp; <span class="keyword">typeof</span> effect === <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="comment">// reaction</span></span><br><span class="line">    nativeDisposer = reaction(expression, effectWrapper(effect, <span class="number">1</span>), options);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// autorun</span></span><br><span class="line">    nativeDisposer = autorun(effectWrapper(expression, <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果在 setup 上下文则添加到disposer 队列，在组件卸载时自动释放</span></span><br><span class="line">  <span class="keyword">if</span> (compositionContext) &#123;</span><br><span class="line">    compositionContext.addDisposer(stop);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> stop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>DONE!</p><p><br><br><br></p><h2 id="包装-props-为响应式数据"><a href="#包装-props-为响应式数据" class="headerlink" title="包装 Props 为响应式数据"></a>包装 Props 为响应式数据</h2><p>React 组件每次重新渲染都会生成一个新的 Props 对象，所以无法直接在 setup 中使用，我们需要将其转换为一个可以安全引用的对象，然后在每次重新渲染时更新这个对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">set</span> &#125; from 'mobx'</span><br><span class="line"></span><br><span class="line">export function initial&lt;Props extends object, Rtn, Ref&gt;(setup: (props: Props) =&gt; Rtn) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">useComposition</span>(<span class="params">props: Props, ref?: React.RefObject&lt;Ref&gt;</span>): <span class="title">Rtn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = useRef&lt;CompositionContext | <span class="literal">undefined</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">if</span> (context.current == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ⚛️ createCompositoonContext 会将props 转换为一个响应式数据, 而且这里是浅层转换</span></span><br><span class="line">      <span class="comment">// _props: observable(props, &#123;&#125;, &#123; deep: false, name: "props" &#125;)</span></span><br><span class="line">      <span class="keyword">const</span> ctx = (context.current = createCompositionContext(props));</span><br><span class="line">      <span class="keyword">const</span> prevCtx = compositionContext;</span><br><span class="line">      compositionContext = ctx;</span><br><span class="line">      ctx._instance = setup(ctx._props);</span><br><span class="line">      compositionContext = prevCtx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 每次重新渲染时更新, props 属性</span></span><br><span class="line">    <span class="keyword">set</span>(context.current._props, props);</span><br><span class="line"></span><br><span class="line">    return context.current._instance!;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="支持-context-注入"><a href="#支持-context-注入" class="headerlink" title="支持 Context 注入"></a>支持 Context 注入</h2><p>和 VCA 一样，我们通过 <code>inject</code> 支持依赖注入，不同的是我们的 <code>inject</code> 方法接收一个 <a href="https://reactjs.org/docs/context.html#contextprovider" target="_blank" rel="noopener"><code>React.Context</code></a> 对象。<code>inject</code> 可以从 Context 对象中推断出注入的类型。</p><p>另外受限于 React 的 Context 机制，我们没有实现 provider 函数，用户直接使用 Context.Provider 组件即可。</p><p>实现 Context 的注入还是得费点事，我们会利用 React 的 <a href="https://reactjs.org/docs/hooks-reference.html#usecontext" target="_blank" rel="noopener"><code>useContext</code></a> Hook 来实现，因此必须保证 <code>useContext</code> 的调用顺序。</p><p>和生命周期方法一样，调用 inject 时，将 Context 推入队列中, 只不过我们会立即调用一次 useContext 获取到值:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">inject</span>&lt;<span class="title">T</span>&gt;(<span class="params">Context: React.Context&lt;T&gt;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = assertCompositionContext();</span><br><span class="line">  <span class="comment">// ⚛️ 马上获取值</span></span><br><span class="line">  <span class="keyword">return</span> ctx.addContext(Context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>为了避免重复的 useContext 调用, 同时保证插入的顺序，我们使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="noopener"><code>Map</code></a> 来保存 Context 引用:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCompositionContext</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt;(<span class="params">props: P</span>): <span class="title">CompositionContext</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = &#123;</span><br><span class="line">    _isMounted: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// ⚛️ 使用 Map 保存</span></span><br><span class="line">    _contexts: <span class="keyword">new</span> <span class="built_in">Map</span>(),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 注册Context</span></span><br><span class="line">    addContext: <span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ⚛️ 已添加</span></span><br><span class="line">      <span class="keyword">if</span> (ctx._contexts.has(c)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx._contexts.get(c)!.value</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ 首次使用立即调用 useContext 获取 Context 的值</span></span><br><span class="line">      <span class="keyword">let</span> value = useContext(c)</span><br><span class="line">      <span class="comment">// ⚛️ 和 Props 一样转换为 响应式数据, 让 setup 可以安全地引用</span></span><br><span class="line">      <span class="keyword">const</span> wrapped = observable(value, &#123;&#125;, &#123; <span class="attr">deep</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">"context"</span> &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ 插入到队列</span></span><br><span class="line">      ctx._contexts.set(c, &#123;</span><br><span class="line">        value: wrapped,</span><br><span class="line">        <span class="comment">// ⚛️ 更新器，这个会在组件挂载之后的每次重新渲染时调用</span></span><br><span class="line">        <span class="comment">// 我们需要保证 useContext 的调用顺序</span></span><br><span class="line">        updater: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// ⚛️ 依旧是调用 useContetxt 重新获取 Context 值</span></span><br><span class="line">          <span class="keyword">const</span> newValue = useContext(c)</span><br><span class="line">          <span class="keyword">if</span> (newValue !== value) &#123;</span><br><span class="line">            <span class="keyword">set</span>(wrapped, newValue)</span><br><span class="line">            value = newValue</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      return wrapped as any</span><br><span class="line">    &#125;,</span><br><span class="line">    // ....</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>回到 setup 函数，我们必须保证每一次渲染时都按照一样的次序调用 useContext：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initial</span>&lt;<span class="title">Props</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">Rtn</span>, <span class="title">Ref</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  setup: (props: Props</span>) =&gt; <span class="title">Rtn</span>,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">useComposition</span>(<span class="params">props: Props, ref?: React.RefObject&lt;Ref&gt;</span>): <span class="title">Rtn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = useRef&lt;CompositionContext | <span class="literal">undefined</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">if</span> (context.current == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> ctx = (context.current = createCompositionContext(props))</span><br><span class="line">      <span class="keyword">const</span> prevCtx = compositionContext</span><br><span class="line">      compositionContext = ctx</span><br><span class="line">      ctx._instance = setup(ctx._props)</span><br><span class="line">      compositionContext = prevCtx</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 一定要在其他 React Hooks 之前调用</span></span><br><span class="line">    <span class="comment">// 因为在 setup 调用的过程中已经调用了 useContext，所以只在挂载之后的重新渲染中才调用更新</span></span><br><span class="line">    <span class="keyword">if</span> (context.current._contexts.size &amp;&amp; context.current._isMounted) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> &#123; updater &#125; <span class="keyword">of</span> context.current._contexts.values()) &#123;</span><br><span class="line">        updater()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>DONE!</p><p><br><br><br></p><h2 id="跟踪组件依赖并触发重新渲染"><a href="#跟踪组件依赖并触发重新渲染" class="headerlink" title="跟踪组件依赖并触发重新渲染"></a>跟踪组件依赖并触发重新渲染</h2><p>基本接口已经准备就绪了，现在如何和 React 组件建立关联，在响应式数据更新后触发组件重新渲染?</p><p>Mobx 有一个库可以用来绑定 React 组件, 它就是 <a href="https://github.com/mobxjs/mobx-react-lite" target="_blank" rel="noopener"><code>mobx-react-lite</code></a>, 有了它, 我们可以监听响应式变化并触发组件重新渲染。用法如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">'mobx-react-lite'</span></span><br><span class="line"><span class="keyword">import</span> &#123; initial &#125; <span class="keyword">from</span> <span class="string">'mpos'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useComposition = initial(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;<span class="comment">/* setup */</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> YouComponent = observer(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> state = useComposition(props)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;state.data.count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>How it work? 如果这样一笔带过，估计很多读者会很扫兴，自己写一个 <code>observer</code> 也不难。我们可以参考 <a href="https://github.com/mobxjs/mobx-react" target="_blank" rel="noopener">mobx-react</a> 或者 mobx-react-lite 的实现。</p><p>它们都将渲染函数放在 <code>track</code> 函数的上下文下，track函数可以跟踪渲染函数依赖了哪些数据，当这些数据变动时，强制进行组件更新:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC , useRef, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Reaction &#125; <span class="keyword">from</span> <span class="string">'mobx'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span>&lt;<span class="title">Props</span> <span class="title">extends</span> </span>&#123;&#125;, Ref = <span class="keyword">void</span>&gt;(options: &#123;</span><br><span class="line">  name?: string</span><br><span class="line">  setup: <span class="function">(<span class="params">props: Props</span>) =&gt;</span> () =&gt; React.ReactElement</span><br><span class="line">  forwardRef?: boolean</span><br><span class="line">&#125;): FC&lt;Props&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; setup, name, forwardRef &#125; = options</span><br><span class="line">  <span class="comment">// ⚛️ 创建 useComposition Hook</span></span><br><span class="line">  <span class="keyword">const</span> useComposition = initial(setup)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Comp = <span class="function">(<span class="params">props: Props, ref: React.RefObject&lt;Ref&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 用于强制更新组件, 实现很简单，就是递增 useState 的值</span></span><br><span class="line">    <span class="keyword">const</span> forceUpdate = useForceUpdate()</span><br><span class="line">    <span class="keyword">const</span> reactionRef = useRef&lt;&#123; <span class="attr">reaction</span>: Reaction, <span class="attr">disposer</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span> &#125; | <span class="literal">null</span>&gt;(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> render = useComposition(props, forwardRef ? ref : <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建跟踪器</span></span><br><span class="line">    <span class="keyword">if</span> (reactionRef.current == <span class="literal">null</span>) &#123;</span><br><span class="line">      reactionRef.current = &#123;</span><br><span class="line">        <span class="comment">// ⚛️ 在依赖更新时，调用 forceUpdate 强制重新渲染</span></span><br><span class="line">        reaction: <span class="keyword">new</span> Reaction(<span class="string">`observer(<span class="subst">$&#123;name || <span class="string">"Unknown"</span>&#125;</span>)`</span>, () =&gt;  forceUpdate()),</span><br><span class="line">        <span class="comment">// 释放跟踪器</span></span><br><span class="line">        disposer: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (reactionRef.current &amp;&amp; !reactionRef.current.reaction.isDisposed) &#123;</span><br><span class="line">            reactionRef.current.reaction.dispose()</span><br><span class="line">            reactionRef.current = <span class="literal">null</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> () =&gt; reactionRef.current &amp;&amp; reactionRef.current.disposer(), [])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> rendering</span><br><span class="line">    <span class="keyword">let</span> error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 将 render 函数放在track 作用域下，收集 render 函数的数据依赖</span></span><br><span class="line">    reactionRef.current.reaction.track(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        rendering = render(props, inst)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        error = err</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      reactionRef.current.disposer()</span><br><span class="line">      <span class="keyword">throw</span> error</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rendering</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>接着，我们将 Comp 组件包裹在 React.memo 下，避免不必要重新渲染:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span>&lt;<span class="title">Props</span> <span class="title">extends</span> </span>&#123;&#125;, Ref = <span class="keyword">void</span>&gt;(options: &#123;</span><br><span class="line">  name?: string</span><br><span class="line">  setup: <span class="function">(<span class="params">props: Props</span>) =&gt;</span> () =&gt; React.ReactElement</span><br><span class="line">  forwardRef?: boolean</span><br><span class="line">&#125;): FC&lt;Props&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; setup, name, forwardRef &#125; = options</span><br><span class="line">  <span class="comment">// 创建 useComposition Hook</span></span><br><span class="line">  <span class="keyword">const</span> useComposition = initial(setup)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Comp = <span class="function">(<span class="params">props: Props, ref: React.RefObject&lt;Ref&gt;</span>) =&gt;</span> &#123;<span class="comment">/**/</span>&#125;</span><br><span class="line"></span><br><span class="line">  Comp.displayName = <span class="string">`Composition(<span class="subst">$&#123;name || <span class="string">"Unknown"</span>&#125;</span>)`</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> finalComp</span><br><span class="line">  <span class="keyword">if</span> (forwardRef) &#123;</span><br><span class="line">    <span class="comment">// 支持转发 ref</span></span><br><span class="line">    finalComp = React.memo(React.forwardRef(Comp))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    finalComp = React.memo(Comp)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  finalComp.displayName = name</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> finalComp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="forwardref-处理"><a href="#forwardref-处理" class="headerlink" title="forwardRef 处理"></a>forwardRef 处理</h2><p>最后一步了，有些时候我们的组件需要通过 ref 向外部暴露一些状态和方法。在Hooks 中我们使用 <code>useImperativeHandle</code> 来实现:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyInput</span>(<span class="params">props, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class="line">    focus: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">...</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">FancyInput = forwardRef(FancyInput);</span></span><br></pre></td></tr></table></figure><p><br></p><p>在我们的玩具中，我们自定义一个新的函数 <code>expose</code> 来暴露我们的公开接口：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  expose(&#123;</span><br><span class="line">    somePublicAPI: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>实现如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">expose</span>(<span class="params">value: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = assertCompositionContext();</span><br><span class="line">  ctx.addExpose(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>关键是 useComposition 的处理:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initial</span>&lt;<span class="title">Props</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">Rtn</span>, <span class="title">Ref</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  setup: (props: Props</span>) =&gt; <span class="title">Rtn</span>,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">useComposition</span>(<span class="params">props: Props, ref?: React.RefObject&lt;Ref&gt;</span>): <span class="title">Rtn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = useRef&lt;CompositionContext | <span class="literal">undefined</span>&gt;()</span><br><span class="line">    <span class="keyword">if</span> (context.current == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 初始化...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... useContext</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 如果传递了ref 且 调用了 expose 函数</span></span><br><span class="line">    <span class="comment">// 则使用useImperativeHandle 暴露给 ref</span></span><br><span class="line">    <span class="keyword">if</span> (ref &amp;&amp; context.current._exposer != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 只在 _exposer 变动后更新</span></span><br><span class="line">      useImperativeHandle(ref, context.current._exposer, [context.current._exposer]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><p>🎉🎉 搞定，<strong>所有代码都在这个 <a href="https://codesandbox.io/s/mobx-vue-composition-api-ft9mv?fontsize=14" target="_blank" rel="noopener">CodeSandbox</a> 中，大家可以自行体验</strong>. 🎉🎉 </p><p><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，这只是一个玩具🎃！整个过程也不过百来行代码。</p><p>就如标题所说的，通过这个玩具，学到很多奇淫巧技，你对 React Hooks 以及 Vue Composition API 的了解应该更深了吧？ <strong>之所以是个玩具，是因为它还有一些缺陷，不够 ’React‘, 又不够 ‘Vue’！只能以学习的目的自个玩玩! 而且搞这玩意, 搞不好可能在两个社区都会被喷</strong>。所以我话就撂这了，你们就不要在评论区喷了。</p><p><br></p><p>如果你了解过 <a href="https://juejin.im/post/5dadc6045188255a270a0f85#heading-13" target="_blank" rel="noopener">React Concurrent 模式</a>，你会发现这个架构是 React 自身的状态更新机制是深入绑定的。React 自身的setState 状态更新粒度更小、可以进行优先级调度、Suspense、可以通过 useTransition + Suspense 配合进入 Pending 状态、在’平行宇宙’中进行渲染。 <strong>React 自身的状态更新机制和组件的渲染体系是深度集成</strong>。</p><p>因此我们现在监听响应式数据，然后粗暴地 <code>forceUpdate</code>，会让我们丢失部分 React Concurrent 模式带来的红利。除此之外、开发者工具的集成、生态圈、Benchmark…</p><p>说到生态圈，如果你将这个玩具的 API 保持和 VCA 完全兼容，那么以后 Vue 社区的 Hooks 库也可以为你所用，想想脑洞挺大。</p><p><br></p><p><strong>搞这一套还不如直接上 Vue 是吧</strong>？毕竟 Vue 天生集成响应式数据，跟 React 的不可变数据一样, <strong>Vue 的响应式更新机制和其组件渲染体系是深度集成的</strong>。 整个工作链路自顶向下, 从数据到模板、再到底层组件渲染, 对响应式数据有更好、更高效地融合。</p><p>尽管如此，React 的灵活性、开放、多范式编程方式、创造力还是让人赞叹。(仅代表我作为React爱好者的立场)</p><p><br></p><p><strong>另外响应式机制也不是完全没有心智负担</strong>，最起码你要了解响应式数据的原理，知道什么可以被响应，什么不可以：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如不能使用解构和展开表达式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyHook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将count 拷贝给(按值传递) count变量，这会导致响应丢失，下游无法响应count 的变化</span></span><br><span class="line">  <span class="keyword">const</span> &#123; count &#125; = reactive(&#123;<span class="attr">count</span>: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; count &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有响应式数据转换成本，诸如此类的，网上也有大量的资料, 这里就不赘述了。 关于响应式数据需要注意的东西可以参考这些资料:</p><ul><li><a href="https://vue-composition-api-rfc.netlify.com/#plugin-development" target="_blank" rel="noopener">Vue Composition API Drawbacks</a></li><li><a href="https://mobx.js.org/best/react.html" target="_blank" rel="noopener">What does MobX react to?</a></li><li><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">Vue: 深入响应式原理</a></li></ul><p>除此之外，你有时候会纠结什么时候应该使用 reactive，什么时候应该使用 ref…</p><p>没有银弹，没有银弹。</p><p><br></p><p>最后的最后， <strong>useYourImagination</strong>, React Hooks 早已在 React 社区玩出了花🌸，Vue Composition API 完全可以将这些模式拿过来用，两个从结构和逻辑上都是差不多的，只不过换一下 ‘Mutable’ 的数据操作方式。安利 <a href="https://juejin.im/post/5d594ea5518825041301bbcb" target="_blank" rel="noopener">2019年了，整理了N个实用案例帮你快速迁移到React Hooks</a></p><p><br></p><p>我是荒山，觉得文章可以，请点个赞，下篇文章见！</p><p><br><br><br></p><h2 id="参考-扩展"><a href="#参考-扩展" class="headerlink" title="参考/扩展"></a>参考/扩展</h2><ul><li><a href="https://codesandbox.io/s/mobx-vue-composition-api-ft9mv?fontsize=14" target="_blank" rel="noopener"><strong>🎉本文源码：CodeSandbox</strong></a></li><li><a href="https://vue-composition-api-rfc.netlify.com/" target="_blank" rel="noopener"><strong>Vue Composition API RFC</strong></a></li><li><a href="https://zhuanlan.zhihu.com/p/68477600" target="_blank" rel="noopener">Vue Function-based API RFC 中文</a> 有点过时，不影响理解</li><li><a href="https://github.com/vuejs/composition-api" target="_blank" rel="noopener">@vue/composition-api</a></li><li><a href="https://mobx.js.org/" target="_blank" rel="noopener">Mobx</a></li><li><a href="https://github.com/kefranabg/awesome-vue-composition-api" target="_blank" rel="noopener">awesome-vue-composition-api</a></li><li><a href="https://codesandbox.io/s/github/nuxt/typescript/tree/master/examples/composition-api/minimal" target="_blank" rel="noopener">Vue Composition API CodeSandbox Playground</a></li><li><a href="https://zhuanlan.zhihu.com/p/71667382" target="_blank" rel="noopener">精读《Vue3.0 Function API》</a></li></ul><p><br></p><p><img src="/images/sponsor.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5dadc6045188255a270a0f85&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前几篇文章&lt;/a&gt;都在讲 React 的 Concurrent 模式, 很多读者都看懵了，这一篇
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>React Concurrent 模式抢先预览下篇: useTransition 的平行世界</title>
    <link href="https://bobi.ink/2019/10/28/concurrent-mode-transition/"/>
    <id>https://bobi.ink/2019/10/28/concurrent-mode-transition/</id>
    <published>2019-10-27T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章介绍了 <a href="https://juejin.im/post/5db65d87518825648f2ef899" target="_blank" rel="noopener"><code>Suspense</code></a>, 那么这篇文章就讲讲它的好搭档 <a href="https://reactjs.org/docs/concurrent-mode-reference.html#usetransition" target="_blank" rel="noopener"><code>useTransition</code></a>。如果你是 React 的粉丝，这两篇文章一定不能错过。</p><p>我们知道 React 内部做了翻天覆地的优化，外部也提供了一些紧凑的新 API，<strong>这些 API 主要用来优化用户体验</strong>。React 官方用一篇很长的文档<a href="https://reactjs.org/docs/concurrent-mode-patterns.html" target="_blank" rel="noopener">《Concurrent UI Patterns 》</a> 专门来介绍这一方面的动机和创造，其中的主角就是 <code>useTransition</code>。</p><p><br></p><p><strong>相关文章</strong></p><ul><li><a href="https://juejin.im/post/5dadc6045188255a270a0f85" target="_blank" rel="noopener">这可能是最通俗的 React Fiber(时间分片) 打开方式</a> 🔥先入个门</li><li><a href="https://juejin.im/post/5db65d87518825648f2ef899" target="_blank" rel="noopener">React Concurrent 模式抢先预览上篇: Suspense the world</a> 上篇</li></ul><p><br><br><br></p><p><strong>本文大纲</strong></p><!-- TOC --><ul><li><a href="#应用场景是什么">应用场景是什么？</a></li><li><a href="#usetransition-登场">useTransition 登场</a></li><li><a href="#usetransition-原理初探">useTransition 原理初探</a><ul><li><a href="#1️⃣-利用-starttransition-来运行低优先级任务"><strong>1️⃣ 利用 startTransition 来运行低优先级任务</strong></a></li><li><a href="#2️⃣-starttransition-更新触发-suspense"><strong>2️⃣ startTransition 更新触发 Suspense</strong></a></li><li><a href="#3️⃣-将-tick-更新提到-starttransition-作用域外"><strong>3️⃣ 将 tick 更新提到 startTransition 作用域外</strong></a></li><li><a href="#4️⃣-嵌套suspense"><strong>4️⃣ 嵌套Suspense</strong></a></li><li><a href="#5️⃣-可以和-mobx-和-redux-配合使用吗"><strong>5️⃣ 可以和 Mobx 和 Redux 配合使用吗?</strong></a></li></ul></li><li><a href="#那-usedeferedvalue-呢">那 useDeferedValue 呢？</a></li><li><a href="#总结">总结</a></li><li><a href="#参考资料">参考资料</a></li></ul><!-- /TOC --><p><br></p><p>React 用’<strong>平行宇宙</strong>‘来比喻这个 useTransition 这个 API。What？</p><p>用 Git 分支来比喻会更好理解一点, 如下图，React 可以从当前视图(可以视作 <code>Master</code>) 分支中 <code>Fork</code> 出来一个新的分支(尚且称为 <code>Pending</code>)，在这个新分支上进行更新，同时 <code>Master</code> 保持响应和更新，这两个分支就像’平行宇宙’，两者互不干扰。当 <code>Pending</code> 分支准备’妥当’，再合并(提交)到 <code>Master</code>分支。</p><p><img src="/images/concurrent-mode/suspense-branch.png" alt></p><p><br></p><p><code>useTransition</code> 就像一个时光隧道, 让组件进入一个平行宇宙，在这个平行宇宙中等待<code>异步状态</code>(异步请求、延时、whatever)就绪。当然组件也不能无限期待在平行宇宙，<code>useTranstion</code> 可以配置超时时间，如果超时了，就算<code>异步状态</code>未就绪也会被强制拉回现实世界。回到现实世界后，React 会立即对组件 Pengding 的变更进行合并，呈现在用户面前。</p><p>因此，你可以认为在Concurrent 模式下， React 组件有三种状态:</p><p><img src="/images/concurrent-mode/component-state.png" alt></p><p><br></p><ul><li><strong>Normal</strong> - 正常状态下的组件</li><li><strong>Suspense</strong> - 因异步状态而挂起的组件</li><li><strong>Pending</strong> - 进入平行宇宙的组件。对应的也有 Pending 的’状态变更’，这些变更 React 不会立即提交到用户界面，而是缓存着，等待 Suspense 就绪或超时。</li></ul><p>你可能还不太能理解, 没关系，继续往下读。</p><p><br><br><br></p><h2 id="应用场景是什么？"><a href="#应用场景是什么？" class="headerlink" title="应用场景是什么？"></a>应用场景是什么？</h2><p>‘平行宇宙’有什么用？ 我们不讲代码或者架构层次的东西。单从 <code>UI</code> 上看： <strong>在某些 UI 交互场景，我们并不想马上将变更立即应用到页面上</strong>。</p><p><strong>🔴比如你从一个页面切换到另一个页面，新页面可能需要一些时间才能加载完成，其实我们更乐于稍微停留在上一个页面，保持一些操作响应, 比如我们可以取消，或者进行其他操作，而给我看一个什么都没有的空白页面或者空转加载状态符, 感觉在做无谓的等待</strong>。</p><p>这种交互场景其实非常常见，眼前的例子就是浏览器：</p><p><br></p><p><img src="/images/concurrent-mode/browser.gif" alt><br><i>假装我要买个 AirPods</i></p><p><br></p><p>还有我们常用的 Github:</p><p><img src="/images/concurrent-mode/github.gif" alt><br><i>国外某著名交友网站</i></p><p><br></p><p>比如我想点击买个 <code>AirPods</code>，浏览器会停留在上一个页面，直到下一个页面的请求获得响应或者超时。另外浏览器会通过地址栏的加载指示符提示请求情况。这种交互设计，比直接切换过去，展示一个空白的页面要好得多. 页面可以保持用户响应, 也可以随时取消请求，保留在原来的页面。</p><blockquote><p>当然, Tab 切换时另外一种交互场景，我们希望它马上切换过去, 否则用户会觉得点击不起作用。</p></blockquote><p>‘平行宇宙’，还有一个好处: <strong>🔴我们假设大部分情况下，数据请求都是非常快的，这时候其实没有必要展示加载状态，这会导致页面闪烁和抖动。其实通过短暂的延时，可以来减少加载状态的展示频率</strong>。</p><p>另外，<strong>🔴useTransition 也可以用于包裹低优先级更新</strong>。 从目前的情况看，React 并没有意愿暴露过多的 Concurrent 模式的底层细节。如果你要调度低优先级的更新，只能使用 useTransition。</p><p><br><br><br></p><h2 id="usetransition-登场"><a href="#usetransition-登场" class="headerlink" title="useTransition 登场"></a>useTransition 登场</h2><p><img src="/images/concurrent-mode/page-state.png" alt></p><p><br></p><p>如上图，我们先按照 React 官方文档的描述来定义页面的各种状态。<strong>它提到页面加载有以下三个阶段</strong>:</p><p><strong>① 过渡阶段(Transition)</strong></p><p>指的是页面未就绪，等待加载关键数据的阶段。按照不同的展示策略，页面可以有以下两种状态：</p><ul><li><p><strong>⚛️退化(Receded)</strong>。马上将页面切换过去，展示一个大大的加载指示器或者空白页面。’退化’是什么意思? 按照 React 的说法是，页面原本有内容，现在变为无内容状态，这是一种退化，或者说历史的’退步’。</p></li><li><p><strong>⚛️待定(Pending)</strong>。这是 <code>useTransition</code> 要达到的状态，即停留在当前页面，让当前页面保持响应。在<strong>关键数据准备就绪</strong>时进入 <code>Skeleton</code>(骨架屏) 状态， 亦或者等待超时回退到 <code>Receded</code> 状态。</p></li></ul><p><br></p><p><strong>② 加载阶段(Loading)</strong></p><p>指的是<code>关键数据</code>已经准备就绪，可以开始展示页面的骨架或者框架部分。这个阶段有一个状态:</p><ul><li><strong>⚛️骨架(Skeleton)</strong>。关键数据已经加载完毕，页面展示了主体的框架。</li></ul><p><br></p><p><strong>③就绪阶段(Done)</strong>。</p><p>指的是页面完全加载完毕。这个阶段有一个状态:</p><ul><li><strong>⚛️完成(Complete)</strong> 页面完全呈现</li></ul><p><br><br><br></p><p>传统的 React 中，当我们变更状态进入一个新屏幕时，经历的是 <strong>🔴<code>Receded</code> -&gt; <code>Skeleton</code> -&gt; <code>Complete</code></strong> 路径。在此之前要实现 <strong>🔴<code>Pending</code> -&gt; <code>Skeleton</code> -&gt; <code>Complete</code></strong> 这种加载路径比较困难。 <code>useTransition</code> 可以改变这个局面。</p><p><br></p><p>接下来简单模拟一个页面切换，先来看默认情况下是如何加载的:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"letter"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️ 延迟加载2s，模拟异步数据请求</span></span><br><span class="line">  delay(<span class="string">"B"</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"letter"</span>&gt;</span>B<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️ 延迟加载4s，模拟异步数据请求</span></span><br><span class="line">  delay(<span class="string">"C"</span>, <span class="number">4000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"letter"</span>&gt;</span>C<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Page1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">A</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 页面2</span></span><br><span class="line"><span class="xml">function Page2() &#123;</span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">B</span> /&gt;</span></span></span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;Loading... C&lt;/div&gt;&#125;&gt;</span><br><span class="line">        &lt;C /&gt;</span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line"><span class="xml">  );</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function App() &#123;</span></span><br><span class="line"><span class="xml">  const [showPage2, setShowPage2] = useState(false);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  // 点击切换到页面2</span></span><br><span class="line"><span class="xml">  const handleClick = () =&gt;  setShowPage2(true)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line">    &lt;div className="App"&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;handleClick&#125;&gt;切换&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className="page"&gt;</span><br><span class="line">        &lt;Suspense fallback=&#123;&lt;div&gt;Loading ...&lt;/div&gt;&#125;&gt;</span><br><span class="line">          &#123;!showPage2 ? &lt;Page1 /&gt; : &lt;Page2 /&gt;&#125;</span><br><span class="line">        &lt;/Suspense&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  );</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>看一下运行效果:</p><p><img src="/images/concurrent-mode/demo1.gif" alt></p><p>点击切换后，我们会马上看到一个大大的 <code>Loading...</code>，接着 2s 后 B 加载完毕，再等待 2s 后 C 加载完毕。这个过程就是 <strong><code>Receded</code> -&gt; <code>Skeleton</code> -&gt; <code>Complete</code></strong></p><p><br></p><p>现在有请 useTransition 隆重登场 🎉，只需对上面的代码进行的简单改造：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⚛️ 导入 useTransition</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Suspense, useState, useTransition &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [showPage2, setShowPage2] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// ⚛️ useTransition 接收一个超时时间，返回一个startTransition 函数，以及一个 pending</span></span><br><span class="line">  <span class="keyword">const</span> [startTransition, pending] = useTransition(&#123; <span class="attr">timeoutMs</span>: <span class="number">10000</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">    <span class="comment">// ⚛️ 将可能触发 Suspense 挂起的状态变更包裹在 startTransition 中</span></span><br><span class="line">    startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setShowPage2(<span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;handleClick&#125;&gt;切换&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>* ⚛️ pending 表示处于待定状态, 你可以进行一些轻微的提示 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &#123;pending &amp;&amp; &lt;span&gt;切换中...&lt;/</span>span&gt;&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="page"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Suspense fallback=&#123;&lt;div&gt;Loading ...&lt;/</span>div&gt;&#125;&gt;</span><br><span class="line">          &#123;!showPage2 ? <span class="xml"><span class="tag">&lt;<span class="name">Page1</span> /&gt;</span> : <span class="tag">&lt;<span class="name">Page2</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>useTransition Hook 的API比较简洁，有4个需要关键的点:</p><ul><li><p><code>timeoutMs</code>, 表示切换的超时时间(最长在平行宇宙存在的时间)，useTransition 会让 React 保持在当前页面，直到被触发 Suspense 就绪或者超时。</p></li><li><p><code>startTransition</code>, 将可能触发页面切换(严格说是触发 Suspense 挂起)的状态变更包裹在 <code>startTransition</code> 下，实际上 startTransition 提供了一个’更新的上下文’。 下一节我们会深入探索这里面的细节</p></li><li><p><code>pending</code>, 表示正处于待定状态。我们可以通过这个状态值，适当地给用户一下提示。</p></li><li><p><code>Suspense</code>, useTransition 实现过渡状态必须和 Suspense 配合，也就是 <code>startTransition</code> 中的更新必须触发任意一个 Suspense 挂起。</p></li></ul><p><br></p><p>看一下实际的运行效果吧！</p><p><img src="/images/concurrent-mode/demo2.gif" alt></p><p><br></p><blockquote><p>可以在这个 <a href="https://codesandbox.io/s/usetransition-y74ry?fontsize=14" target="_blank" rel="noopener">CodeSandbox</a> 查看运行效果</p></blockquote><p>这个效果完全跟本节开始的’第一张图’一样: React 会保留在当前页面，<code>pending</code> 变为了true，接着 B 先就绪，界面马上切换过去。整个过程符合 <strong><code>Pending</code> -&gt; <code>Skeleton</code> -&gt; <code>Complete</code></strong> 的路径。</p><p><code>startTransition</code> 中的<code>变更</code>一旦触发 <code>Suspense</code>，React 就会将<code>变更</code>标记的 Pending 状态, React会延后 ’提交‘ 这些变更。所以<strong>实际上并没有开头说的平行宇宙, 那么高大上和神奇，React 只不过是延后了这些变更的提交。我们界面上看到的只不过是旧的或者未被 Pending 的状态，React 在后台进行了预渲染</strong>。</p><p>注意，React 只是暂时没有提交这些变更，不说明 React ’卡死了‘，处于Pending 状态的组件还会接收用户的响应，进行新的状态变更，新的状态更新也可以覆盖或终止 Pending 状态。</p><p><br></p><p>总结一下进入和退出 Pending 状态的条件:</p><ul><li><strong>进入Pending</strong> 状态首先需要将 <code>状态变更</code> 包裹在 <code>startTransition</code> 下，且这些更新会触发 Suspense 挂起</li><li><strong>退出 Pending</strong> 状态有三种方式: ① Suspense 就绪；② 超时；③ 被新的状态更新覆盖或者终止</li></ul><p><br><br><br></p><h2 id="usetransition-原理初探"><a href="#usetransition-原理初探" class="headerlink" title="useTransition 原理初探"></a>useTransition 原理初探</h2><p>这一节，我们深入探索一下 useTransition，但是方式不是去折腾源码，而是把它当成一个黑盒，通过几个实验来加深你对 useTransition 的理解。</p><p>useTransition 的前身是 <code>withSuspenseConfig</code>, <a href="https://github.com/sebmarkbage" target="_blank" rel="noopener">Sebmarkbage</a> 在今年五月份提的一个<a href="https://github.com/facebook/react/pull/15593" target="_blank" rel="noopener">PR</a> 中引进了它。</p><p>从命名上看，它不过是想配置一下 Suspense。 我们也可以通过最新的源码验证这一点。 useTransition 的工作’看似’非常简单:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTransition</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  config: SuspenseConfig | void | null,</span></span></span><br><span class="line">): [(() =&gt; void) =&gt; void, boolean] &#123;</span><br><span class="line">  <span class="keyword">const</span> [isPending, setPending] = updateState(<span class="literal">false</span>); <span class="comment">// 相当于useState</span></span><br><span class="line">  <span class="keyword">const</span> startTransition = updateCallback(             <span class="comment">// 相当于useCallback</span></span><br><span class="line">    callback =&gt; &#123;</span><br><span class="line">      setPending(<span class="literal">true</span>); <span class="comment">// 设置 pending 为 true</span></span><br><span class="line">      <span class="comment">// 以低优先级调度执行</span></span><br><span class="line">      Scheduler.unstable_next(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ⚛️ 设置suspenseConfig</span></span><br><span class="line">        <span class="keyword">const</span> previousConfig = ReactCurrentBatchConfig.suspense;</span><br><span class="line">        ReactCurrentBatchConfig.suspense = config === <span class="literal">undefined</span> ? <span class="literal">null</span> : config;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 还原 pending</span></span><br><span class="line">          setPending(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 执行你的回调</span></span><br><span class="line">          callback();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// ⚛️ 还原suspenseConfig</span></span><br><span class="line">          ReactCurrentBatchConfig.suspense = previousConfig;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    [config, isPending],</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> [startTransition, isPending];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>看似很普通，要点在哪？Sebmarkbage 在上述的 PR 中也提及了一些信息。</p><ul><li><p>startTransition 一开始执行就将 pending 设置为true。接着使用 <code>unstable_next</code> 执行回调, <strong>unstable_next 可以降低更新的优先级</strong>。也就是说 unstable_next 回调中触发的’变更‘优先级会比较低，它会让位为高优先级的更新，或者当前事务繁忙时，调度到下一空闲期再应用，但也可能马上就被应用。</p></li><li><p>要点是 <code>ReactCurrentBatchConfig.suspense</code> 的配置, 这里面会配置 Suspense 的超时时间。<strong>它表明这个区间触发的变更都被关联该 <code>suspenseConfig</code></strong>, 这些变更会根据 suspenseConfig 来计算自己的 <code>expiredTime</code>(可以视作‘优先级’)。我们暂且将这些关联了 suspenseConfig 的变更称为 <code>Pending 变更</code>.</p></li><li><p><code>Pending 变更</code> 触发的重新渲染(Render)也会关联该 <code>suspenseConfig</code>。如果在渲染期间触发了 Suspense，那么<code>Pending 变更</code> 就会被延迟提交(commit)，它们会缓存在内存中, 等到 Suspense 超时或者就绪, 抑或被其他更新覆盖, 才强制提交到用户界面。</p></li><li><p><code>Pending 变更</code> 只是被延迟提交了，但是不会影响最终数据和视图的一致性。React 会在内存中重新渲染，只是不提交到用户界面而已。</p></li></ul><p><br></p><p>React 内部的实现太过复杂，我发现去挖它或者用文字表达出来成本都很高。因此换一种方式，通过实验(黑盒)方式来了解它的行为：</p><blockquote><p>这些实验代码在这个 <a href="https://codesandbox.io/s/react-use-transition-tests-kg8rc?fontsize=14" target="_blank" rel="noopener">CodeSandbox</a> 中</p></blockquote><p><br></p><h3 id="1️⃣-利用-starttransition-来运行低优先级任务"><a href="#1️⃣-利用-starttransition-来运行低优先级任务" class="headerlink" title="1️⃣ 利用 startTransition 来运行低优先级任务"></a><strong>1️⃣ 利用 startTransition 来运行低优先级任务</strong></h3><p>这个实验主要用于验证 <code>unstable_next</code>, 它会让降低更新的优先级。通过下面的实验我们会观察到: 通过<code>startTransition</code> 包裹的变更在任务繁忙的情况会稍微延后更新，但是最终状态是一致的。</p><p>实验代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [tick, setTick] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [startTransition, pending] = useTransition(&#123; <span class="attr">timeoutMs</span>: <span class="number">10000</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ⚛️ 同步更新</span></span><br><span class="line">    setCount(count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ⚛️ 低优先级更新 tick</span></span><br><span class="line">      setTick(<span class="function"><span class="params">t</span> =&gt;</span> t + <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hello useTransition&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;handleClick&#125;&gt;ADD + 1&lt;/</span>button&gt;</span><br><span class="line">        &#123;pending &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>pending<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;Count: &#123;count&#125;&lt;/</span>div&gt;</span><br><span class="line">      &#123;<span class="comment">/* ⚛️ 这是一个复杂的组件，渲染需要一点时间，模拟繁忙的情况 */</span>&#125;</span><br><span class="line">      &lt;ComplexComponent value=&#123;tick&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>实验结果如下：</p><p><img src="/images/concurrent-mode/test1.gif" alt></p><p><br></p><p>在连续点击的情况下，<code>ComplexComponent</code> 的更新会明显滞后，这是因为 tick 变更会被延后和合并，但是最后它们的结果是一致的.</p><p><br><br><br></p><h3 id="2️⃣-starttransition-更新触发-suspense"><a href="#2️⃣-starttransition-更新触发-suspense" class="headerlink" title="2️⃣ startTransition 更新触发 Suspense"></a><strong>2️⃣ startTransition 更新触发 Suspense</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [tick, setTick] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [startTransition, pending] = useTransition(&#123; <span class="attr">timeoutMs</span>: <span class="number">10000</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">      setTick(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hello useTransition &#123;tick&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;handleClick&#125;&gt;ADD + 1&lt;/</span>button&gt;</span><br><span class="line">        &#123;pending &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">"pending"</span>&gt;</span>pending<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Tick /</span>&gt;</span><br><span class="line">      &lt;SuspenseBoundary id=&#123;count&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const SuspenseBoundary = (&#123; id &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;Suspense fallback="Loading..."&gt;</span></span><br><span class="line"><span class="regexp">      &#123;/</span>* 这里会抛出一个<span class="built_in">Promise</span>异常，<span class="number">3</span>s 后 resolved *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">      &lt;ComponentThatThrowPromise id=&#123;id&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Tick 组件每秒递增一次</span></span><br><span class="line"><span class="regexp">const Tick = (&#123; duration = 1000 &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const [tick, setTick] = useState(0);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    const t = setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      setTick(tick =&gt; tick + 1);</span></span><br><span class="line"><span class="regexp">    &#125;, duration);</span></span><br><span class="line"><span class="regexp">    return () =&gt; clearInterval(t);</span></span><br><span class="line"><span class="regexp">  &#125;, [duration]);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return &lt;div className="tick"&gt;tick: &#123;tick&#125;&lt;/</span>div&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/images/concurrent-mode/test2.gif" alt></p><p>当我们点击按钮时会递增 count 和 tick, count 会传递给 SuspenseBoundary，从而触发 Suspense。</p><p>通过上面的结果可以知道，在 startTransition 中进行了变更(携带suspenseConfig), 对应的重新渲染触发了 Suspense，所以进入了Pending状态，它们渲染结果不会被立即‘提交’，页面还是保持在原来的状态。</p><p>另外你会发现 App 组件的 tick 跟 SuspenseBoundary 一样也会被‘停止’(看Hello Transition 后面的tick)，因为 tick 变更也关联了suspenseConfig。</p><p>而 Tick 组件则每一秒递增一次，不会被阻塞。</p><p>这就说明了一旦触发了Suspense，只要关联了 suspenseConfig 的变更就会被‘暂停’提交。</p><p><br><br><br></p><h3 id="3️⃣-将-tick-更新提到-starttransition-作用域外"><a href="#3️⃣-将-tick-更新提到-starttransition-作用域外" class="headerlink" title="3️⃣ 将 tick 更新提到 startTransition 作用域外"></a><strong>3️⃣ 将 tick 更新提到 startTransition 作用域外</strong></h3><p>在 2️⃣ 的基础上，将 setTick 提到 startTransition 作用域外:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [tick, setTick] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [startTransition, pending] = useTransition(&#123; <span class="attr">timeoutMs</span>: <span class="number">10000</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"App rendering with"</span>, count, tick, pending);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTick(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">    startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleAddTick = <span class="function"><span class="params">()</span> =&gt;</span> setTick(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"App committed with"</span>, count, tick, pending);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hello useTransition &#123;tick&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;handleClick&#125;&gt;ADD + 1&lt;/</span>button&gt;</span><br><span class="line">        &lt;button onClick=&#123;handleAddTick&#125;&gt;Tick + <span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &#123;pending &amp;&amp; &lt;span className="pending"&gt;pending&lt;/</span>span&gt;&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Tick /</span>&gt;</span><br><span class="line">      &lt;SuspenseBoundary id=&#123;count&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/images/concurrent-mode/test3.gif" alt></p><p><br></p><p>现在 tick 会被立即更新，而 SuspenseBoundary 还会挂在 pending 状态。</p><p>我们打开控制台看一下，输出情况:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">App rendering with 1 2 true   # pending 被设置为true, count 这是时候是 1， 而 tick 是 2</span><br><span class="line">App rendering with 1 2 true</span><br><span class="line">read  1</span><br><span class="line">App committed with 1 2 true    # 进入Pending 状态之前的一次提交，我们在这里开始展示 pending 指示符</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面 Tick 更新了三次(3s)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们注意到，每一次 React 都会重新渲染一下 App 组件，即 <span class="string">'ping'</span> 一下处于 Pending 状态的组件, 检查一下是否‘就绪’(没有触发Suspense)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果还触发 Suspense, 说明还要继续等待，这些重新渲染的结果不会被提交</span></span><br><span class="line"></span><br><span class="line">App rendering with 2 2 false # ping, 这里count变成了2，且 pending 变成了 false</span><br><span class="line">App rendering with 2 2 false # 但是 React 在内存中渲染它们，我们看不到</span><br><span class="line">read  2</span><br><span class="line"></span><br><span class="line">Tick rendering with 76        # Tick 重新渲染</span><br><span class="line">Tick rendering with 76</span><br><span class="line">Tick committed with 76        # 提交 Tick 更新，刷新到界面上</span><br><span class="line">App rendering with 2 2 false  # ping 还是没有就绪，继续 pending</span><br><span class="line">App rendering with 2 2 false</span><br><span class="line">read  2</span><br><span class="line"></span><br><span class="line">Tick rendering with 77</span><br><span class="line">Tick rendering with 77</span><br><span class="line">Tick committed with 77</span><br><span class="line">App rendering with 2 2 false # ping</span><br><span class="line">App rendering with 2 2 false</span><br><span class="line">read  2</span><br><span class="line"></span><br><span class="line">Tick rendering with 78</span><br><span class="line">Tick rendering with 78</span><br><span class="line">Tick committed with 78</span><br><span class="line">App rendering with 2 2 false # ping</span><br><span class="line">App rendering with 2 2 false</span><br><span class="line">read  2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Ok, Promise 已经就绪了，这时候再一次重新渲染 App</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这次没有触发 Suspense，React 会马上提交用户界面</span></span><br><span class="line">App rendering with 2 2 false</span><br><span class="line">App rendering with 2 2 false</span><br><span class="line">read  2</span><br><span class="line">App committed with 2 2 false</span><br></pre></td></tr></table></figure><p>通过上面的日志，我们可以清晰地理解 Pending 组件的更新行为</p><p><br><br><br></p><h3 id="4️⃣-嵌套suspense"><a href="#4️⃣-嵌套suspense" class="headerlink" title="4️⃣ 嵌套Suspense"></a><strong>4️⃣ 嵌套Suspense</strong></h3><p>在3️⃣的基础上，将 SuspenseBoundary 改写为 DoubleSuspenseBoundary, 这里会嵌套一个 Suspense 加载一个更耗时的资源:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DoubleSuspenseBoundary = <span class="function">(<span class="params">&#123; id &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &#123;/</span>* 需要加载 <span class="number">2</span>s  *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">      &lt;ComponentThatThrowPromise id=&#123;id&#125; timeout=&#123;2000&#125; /</span>&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;Loading second...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>* 需要加载 <span class="number">4</span>s  *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;ComponentThatThrowPromise id=&#123;id + "second"&#125; timeout=&#123;4000&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Suspense&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下效果：</p><p><img src="/images/concurrent-mode/test4-1.gif" alt></p><p><br></p><p>首先注意观察首次挂载，<strong>Suspense 首次挂载时不会触发延迟提交</strong>，因此我们首先会看到 <code>Loading...</code>、接着第一个 <code>ComponentThatThrowPromise</code> 加载完毕，显示<code>ComponentThatThrowPromise id: 0</code> 和 <code>Loading second...</code>, 最后完全加载完毕。</p><p>接着我们点击按钮，这时候 DoubleSuspenseBoundary 会保持不动，等待 5s 后(也就是第二个<code>ComponentThatThrowPromise</code>加载完毕), 才提交。</p><p><br></p><p>理想的效果是跟首次挂载的时候一样：在第一个 ComponentThatThrowPromise 就绪时就切换过来，不用等待第二个加载完毕。</p><p>感觉有点不对？我这这里想了很久, 官方文档上 <a href="https://reactjs.org/docs/concurrent-mode-patterns.html#wrap-lazy-features-in-suspense" target="_blank" rel="noopener">Concurrent UI Patterns (Experimental) - Wrap Lazy Features in \&lt;Suspense></a> 说了，第二个<code>ComponentThatThrowPromise</code> 已经嵌套在 <code>Suspense</code> 中了，理论上应该不会阻塞提交。</p><p>回到开头的第一句话：’<strong>Suspense 首次挂载时不会触发延迟提交</strong>‘。我们再试一下, 给 DoubleSuspenseBoundary 设置一个key，强制让它销毁重新创建:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hello useTransition &#123;tick&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;handleClick&#125;&gt;ADD + 1&lt;/</span>button&gt;</span><br><span class="line">        &#123;pending &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">"pending"</span>&gt;</span>pending<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Tick /</span>&gt;</span><br><span class="line">      &#123;<span class="comment">/* ⚛️ 这里添加key，强制重新销毁创建 */</span>&#125;</span><br><span class="line">      &lt;DoubleSuspenseBoundary id=&#123;count&#125; key=&#123;count&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>试一下效果:</p><p><img src="/images/concurrent-mode/test4-2.gif" alt></p><p><br></p><p>我们发现，每次点击都是<code>Loading...</code>, Pending 状态没有了! 因为每次 <code>count</code> 递增, <code>DoubleSuspenseBoundary</code> 就会重新创建，不会触发延迟提交。</p><p>基于这个原理，我们可以再改造一下 <code>DoubleSuspenseBoundary</code>, 这一次，我们只给嵌套的 <code>Suspense</code> 加上key，让它们重新创建不阻塞 Pending 状态.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DoubleSuspenseBoundary = <span class="function">(<span class="params">&#123; id &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ComponentThatThrowPromise id=&#123;id&#125; timeout=&#123;2000&#125; /</span>&gt;</span><br><span class="line">      &#123;<span class="comment">/* ⚛️ 我们不希望这个 Suspense 阻塞 pending 状态, 给它加个key, 让它强制重新创建 */</span>&#125;</span><br><span class="line">      &lt;Suspense key=&#123;id&#125; fallback=&#123;&lt;div&gt;Loading second...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ComponentThatThrowPromise id=&#123;id + "second"&#125; timeout=&#123;4000&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><p>最后的效果</p><p><img src="/images/concurrent-mode/test4-3.gif" alt></p><p>It’s work! 🍻</p><p><br><br><br></p><h3 id="5️⃣-可以和-mobx-和-redux-配合使用吗"><a href="#5️⃣-可以和-mobx-和-redux-配合使用吗" class="headerlink" title="5️⃣ 可以和 Mobx 和 Redux 配合使用吗?"></a><strong>5️⃣ 可以和 Mobx 和 Redux 配合使用吗?</strong></h3><p>我也不知道，测试一下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mport React, &#123; useTransition, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider, useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"><span class="keyword">import</span> SuspenseBoundary <span class="keyword">from</span> <span class="string">"./SuspenseBoundary"</span>;</span><br><span class="line"><span class="keyword">import</span> Tick <span class="keyword">from</span> <span class="string">"./Tick"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">count</span>: <span class="number">0</span>, <span class="attr">tick</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> ADD_TICK = <span class="string">"ADD_TICK"</span>;</span><br><span class="line"><span class="keyword">const</span> ADD_COUNT = <span class="string">"ADD_COUNT"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(<span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> copy = &#123; ...state &#125;;</span><br><span class="line">  <span class="keyword">if</span> (action.type === ADD_TICK) &#123;</span><br><span class="line">    copy.tick++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    copy.count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copy</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Page = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; count, tick &#125; = useSelector(<span class="function">(<span class="params">&#123; tick, count &#125;</span>) =&gt;</span> (&#123; tick, count &#125;));</span><br><span class="line">  <span class="keyword">const</span> dispatch = useDispatch();</span><br><span class="line">  <span class="keyword">const</span> [startTransition, pending] = useTransition(&#123; <span class="attr">timeoutMs</span>: <span class="number">10000</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> addTick = <span class="function"><span class="params">()</span> =&gt;</span> dispatch(&#123; <span class="attr">type</span>: ADD_TICK &#125;);</span><br><span class="line">  <span class="keyword">const</span> addCount = <span class="function"><span class="params">()</span> =&gt;</span> dispatch(&#123; <span class="attr">type</span>: ADD_COUNT &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    addTick();</span><br><span class="line">    startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Start transition with count: "</span>, count);</span><br><span class="line">      addCount();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"End transition"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`App rendering with count(<span class="subst">$&#123;count&#125;</span>) pendig(<span class="subst">$&#123;pending&#125;</span>)`</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"committed with"</span>, count, tick, pending);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hello useTransition &#123;tick&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;handleClick&#125;&gt;ADD + 1&lt;/</span>button&gt;</span><br><span class="line">        &#123;pending &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">"pending"</span>&gt;</span>pending<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Tick /</span>&gt;</span><br><span class="line">      &lt;SuspenseBoundary id=&#123;count&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;Provider store=&#123;store&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Page /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><br></p><p>先看一下运行效果:</p><p><img src="/images/concurrent-mode/test5.gif" alt></p><p><br></p><p><img src="/images/concurrent-mode/hyhs.png" alt></p><p><br></p><p>What’s the problem? 整个界面都 <code>Pending</code> 了, 整个界面不单单指 <code>App</code> 这颗子树，而且 Tick 也不走了。打开控制台看到了一个警告:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Warning: Page triggered a user-blocking update that suspended.</span><br><span class="line"></span><br><span class="line">The fix is to split the update into multiple parts: a user-blocking update to provide immediate feedback, and another update that triggers the bulk of the changes.</span><br><span class="line">Refer to the documentation for useTransition to learn how to implement this pattern.</span><br></pre></td></tr></table></figure><p><br></p><p>先来看一下目前Rudux 和 Mobx 的Hooks API 是怎么更新的，<strong>本质上它们都采用订阅机制，在事件触发后进行强制更新</strong>, 基本结构如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useSomeOutsideStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取外部 store</span></span><br><span class="line">  <span class="keyword">const</span> store = getOutsideStore()</span><br><span class="line">  <span class="keyword">const</span> [, forceUpdate] = useReducer(<span class="function"><span class="params">s</span> =&gt;</span> s + <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 订阅外部数据源</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> disposer = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ⚛️ 强制更新</span></span><br><span class="line">      forceUpdate()</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> disposer</span><br><span class="line">  &#125;, [store])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>也就是说，我们在 <code>startTransition</code> 中更新 Redux 状态时，会同步接收到事件，然后调用 <code>forceUpdate</code>。<strong><code>forceUpdate</code> 才是真正在 suspenseConfig 上下文中变更的状态</strong>。</p><p>我们再看一下控制台日志:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Start transition with count 0</span><br><span class="line">End transition</span><br><span class="line">App rendering with count(1) pendig(true)  # 这里出问题了 🔴, 你可以和实验 3️⃣ 中的日志对比一下</span><br><span class="line">App rendering with count(1) pendig(true)  # 实验 3️⃣ 中这里的 count 是 0，而这里的count是1，说明没有 defer!</span><br><span class="line">read  1</span><br><span class="line"></span><br><span class="line">Warning: App triggered a user-blocking update that suspended.</span><br><span class="line">The fix is to split the update into multiple parts: a user-blocking update to provide immediate feedback, and another update that triggers the bulk of the changes.</span><br><span class="line">Refer to the documentation for useTransition to learn how to implement this pattern.</span><br></pre></td></tr></table></figure><p>通过日志可以基本上能够定位出问题，count 没有被延迟更新，所以导致’同步’触发了 Suspense，这也是 React 警告的原因。 由于 useTransition 目前还处于实验阶段，<strong>如果不是 startTransition 上下文中的状态更新导致的Suspense，行为还是未确定的</strong>。</p><p>但是最终的行为有点玄学，它会导致整个应用被‘Pending’，所有状态更新都不会被提交。这块我也很疑惑，没有精力深究下去，只能等待后续官方的更新，读者也可以去琢磨琢磨。</p><p>因此，暂时不推荐将会触发 Suspense 的状态放置在 Redux 或者 Mobx 中。</p><p><br><br><br></p><p>最后再重申一下， <code>useTransition</code> 要进入 <code>Pending</code> 状态要符合以下几个条件:</p><ul><li>最好使用 React 本身的状态机制进行更新, 如 Hooks 或 setState, 当前不要使用 Mobx 和 Redux</li><li>这些更新会触发 Suspense。</li><li>更新必须在<code>startTransition</code>作用域下, 这些更新会关联 <code>suspenseConfig</code></li><li>这些更新触发的重新渲染中, 必须触发至少一个 <code>Suspense</code></li><li>这个 <code>Suspense</code> 不是首次挂载</li></ul><p><br><br><br></p><h2 id="那-usedeferedvalue-呢？"><a href="#那-usedeferedvalue-呢？" class="headerlink" title="那 useDeferedValue 呢？"></a>那 useDeferedValue 呢？</h2><p>如果你理解了上面的内容, 那么 <code>useDeferedValue</code> 就好办了，它不过是 useTransition 的简单封装：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDeferredValue</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  value: T,</span></span></span><br><span class="line"><span class="function"><span class="params">  config: TimeoutConfig | void | null,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [prevValue, setValue] = useState(value);</span><br><span class="line">  <span class="keyword">const</span> [startTransition] = useTransition(config)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ useDeferredValue 只不过是监听 value 的变化，</span></span><br><span class="line">  <span class="comment">// 然后在 startTransition 中更新它。从而实现延迟更新的效果</span></span><br><span class="line">  useEffect(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setValue(value);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    [value, config],</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> prevValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><code>useDeferredValue</code> 只不过是使用 useEffect 监听 <code>value</code> 的变化， 然后在 startTransition 中更新它。从而实现延迟更新的效果。上文实验 1️⃣ 已经介绍过运行效果，React 会降低 startTransition 中更新的优先级， 这意味着在事务繁忙时它们会延后执行。</p><p><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们一开始介绍了 useTransition 的应用场景, 让页面实现 <strong><code>Pending</code> -&gt; <code>Skeleton</code> -&gt; <code>Complete</code></strong> 的更新路径, 用户在切换页面时可以停留在当前页面，让页面保持响应。 相比展示一个无用的空白页面或者加载状态，这种用户体验更加友好。</p><p>当然上述的假设条件时数据加载很慢，如果数据加载很快，利用 useTransition 机制，我们实现不让用户看到加载状态，这样能避免页面页面抖动和闪烁, 看起来像没有加载的过程。</p><p>接着我们简单介绍了 useTransition 的运行原理和条件。 如果 startTransition 中的状态更新触发了 Suspense，那么对应的组件就会进入 Pending 状态。在 Pending 状态期间，startTransition中设置变更都会被延迟提交。 Pending 状态会持续到 Suspense 就绪或者超时。</p><p>useTransition 必须和 Suspense 配合使用才能施展魔法。还有一个用户场景是我们可以将低优先级的更新放置到 startTransition 中。比如某个更新的成本很高，就可以选择放到 startTransition 中, 这些更新会让位高优先级的任务，另外会 React 延迟或合并一个比较复杂的更新，让页面保持响应。</p><p><br><br><br></p><p><strong>Ok，关于 Concurrent 模式的介绍就先告一段落了, 这是中文的第一手资料。写这些文章耗掉了我大部分的业余时间，如果你喜欢我的文章，请多给我点赞和反馈。</strong></p><p><br><br><br></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://reactjs.org/docs/concurrent-mode-patterns.html" target="_blank" rel="noopener">Concurrent UI Patterns</a></li><li><a href="https://github.com/facebook/react/pull/15593" target="_blank" rel="noopener">Add withSuspenseConfig API</a></li></ul><p><br></p><p><img src="/images/sponsor.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上篇文章介绍了 &lt;a href=&quot;https://juejin.im/post/5db65d87518825648f2ef899&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Suspense&lt;/code&gt;&lt;/a&gt;, 那么这篇文章就讲讲它的好搭
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>React Concurrent 模式抢先预览上篇: Suspense the world</title>
    <link href="https://bobi.ink/2019/10/26/concurrent-mode-suspense/"/>
    <id>https://bobi.ink/2019/10/26/concurrent-mode-suspense/</id>
    <published>2019-10-25T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.328Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2019.10.24</strong>, 在 <a href="https://www.youtube.com/channel/UCz5vTaEhvh7dOHEyd1efcaQ" target="_blank" rel="noopener">React Conf 2019</a> 首日， React 官方正式发布了关于 <code>Concurrent</code> 模式的第一个早期社区<a href="https://reactjs.org/docs/concurrent-mode-intro.html" target="_blank" rel="noopener">预览文档</a>, 正式和 React 的大众开发者见面, 令人兴奋。</p><p>跟去年的 React Hooks 一样, 尽管 Concurrent 还是<a href="https://reactjs.org/blog/2019/10/22/react-release-channels.html#experimental-channel" target="_blank" rel="noopener">实验性</a>的, 相信这次不会等太久…</p><p><br></p><p><strong>这个大招憋了四年多</strong></p><p><img src="/images/concurrent-mode/release.png" alt></p><p><br></p><p><strong>如果 React Hooks 目的是提高开发体验，那么 Concurrent 模式则专注于提升用户体验</strong>，表面上它对我们的开发的可能影响不大，React 内部已经变了好几重天。</p><p>这系列文章主要来源于官方的<a href="https://reactjs.org/docs/concurrent-mode-intro.html" target="_blank" rel="noopener">预览文档</a>, 专门给 React 尝鲜者准备。</p><p>这个月 Vue 3.0 源码发布，掘金相关文章像井喷一样，没理由 React 这么’大新闻’(尽管这个新闻3年前大家就知道了)… 我来带个头吧。</p><p><br></p><p><strong>🎉下篇：<a href="https://juejin.im/post/5dbee8e7e51d4558040f0830" target="_blank" rel="noopener">React Concurrent 模式抢先预览下篇: useTransition 的平行世界</a></strong></p><p><br></p><p><strong>文章内容框架</strong></p><!-- TOC --><ul><li><a href="#什么是-concurrent-模式">什么是 Concurrent 模式?</a></li><li><a href="#启用-concurrent-模式">启用 Concurrent 模式</a></li><li><a href="#什么是-suspense">什么是 Suspense?</a></li><li><a href="#suspense-的实现原理">Suspense 的实现原理</a></li><li><a href="#缓存-suspense-的异步操作状态">缓存 Suspense 的异步操作状态</a><ul><li><a href="#使用-context-api">使用 Context API</a></li><li><a href="#将缓存状态提取到父级">将缓存状态提取到父级</a></li></ul></li><li><a href="#并发发起请求">并发发起请求</a></li><li><a href="#处理竞态">处理竞态</a></li><li><a href="#错误处理">错误处理</a></li><li><a href="#suspense-编排">Suspense 编排</a></li><li><a href="#总结">总结</a></li><li><a href="#参考资料">参考资料</a></li></ul><!-- /TOC --><p><br><br><br></p><h2 id="什么是-concurrent-模式"><a href="#什么是-concurrent-模式" class="headerlink" title="什么是 Concurrent 模式?"></a>什么是 Concurrent 模式?</h2><p><img src="/images/concurrent-mode/cpu-vs-io.jpg" alt></p><p><strong>这是一个特性集合，可以让你的React 应用保持响应，可以根据用户的设备能力和网络情况优雅地调整</strong>。 这个特性集合，它包含<strong>两个方向</strong>的优化:</p><p><strong>1️⃣ CPU 密集型(CPU-bound)</strong></p><p>CPU 密集型指是 Reconcilation(协调或者Diff) 的优化. 在Concurrent 模式下面，Reconcilation 可以被中断, 让位给高优先级的任务，让应用保持响应.</p><p><strong>上一周，我抢在 React Conf 2019 之前发布了一篇文章<a href="https://juejin.im/post/5dadc6045188255a270a0f85" target="_blank" rel="noopener">《🔥这可能是最通俗的 React Fiber(时间分片) 打开方式》</a> 🤓，你想了解 Concurrent 模式, 强烈建议从这篇文章开始！</strong></p><p>CPU 密集型的优化对现有的代码保持兼容，几乎没有暴露新的API，主要的影响是废弃了一些生命周期方法，这个是众所周知的。</p><p><br></p><p><strong>2️⃣ I/O 密集型(I/O-bound)</strong></p><p>主要优化了 React 对异步的处理。主要的武器是 <code>Suspense</code> 以及 <a href="https://reactjs.org/docs/concurrent-mode-patterns.html" target="_blank" rel="noopener"><code>useTransition</code></a>:</p><ul><li><code>Suspense</code> - 新的异步数据处理方式。</li><li><code>useTransition</code> - 提供了一种预渲染的机制，React 可以在’另一个分支’中<strong>预渲染</strong>，等待数据到达，然后一次性渲染出来，减少中间的加载状态的显示和页面抖动/闪烁。</li></ul><p><br></p><p>这篇文章我就不再深入解释 Concurrent 模式是什么了，<strong>本文会介绍 Suspense，计划下一篇文章会介绍 useTranstion</strong>，敬请期待。</p><p><br><br><br></p><h2 id="启用-concurrent-模式"><a href="#启用-concurrent-模式" class="headerlink" title="启用 Concurrent 模式"></a>启用 Concurrent 模式</h2><p>Concurrent 模式目前还是实验性的，你可以通过以下命令来安装实验版本:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install react@experimental react-dom@experimental</span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">yarn add react@experimental react-dom@experimental</span><br></pre></td></tr></table></figure><p>上文说了，这是为尝鲜者准备的，尽管 API 应该不会有太大的变动, 不要用于生产环境。</p><p><br></p><p>开始 Concurrent 模式:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.createRoot(</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">).render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>);</span></span><br></pre></td></tr></table></figure><p><br></p><p>另外一个要注意的是，开启Concurrent 模式后，之前 deprecated 的生命周期方法就彻底不能用了，确保你的代码已经迁移。</p><p><br><br><br></p><h2 id="什么是-suspense"><a href="#什么是-suspense" class="headerlink" title="什么是 Suspense?"></a>什么是 Suspense?</h2><p>Suspense 这个大家应该都不陌生，在 v16.5 就已经有了这个 <code>Suspense</code> 这个API, 只不过通常利用它配合 <code>React.lazy</code> 实现代码分隔:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./OtherComponent'</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;OtherComponent /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>React.lazy 这是一次小小的尝试, Suspense 还有大用。 </p><p>如果将Suspense 翻译为中文的话是<code>等待</code>、<code>悬垂</code>、<code>悬停</code>的意思。<strong>React给出了一个更规范的定义</strong>：</p><p><strong>Suspense 不是一个‘数据获取库’, 而是一种提供给‘数据获取库’的<code>机制</code>，数据获取库通过这种机制告诉 React 数据还没有准备好，然后 React就会等待它完成后，才继续更新 UI</strong>。 简单总结一下 Suspense 是 React 提供的一种异步处理的机制, 它不是一个具体的数据请求库。<strong>它是React 提供的原生的组件异步调用原语</strong>。它是 Concurrent 模式特性集合中的重要角色。</p><p><br></p><p>现在, 我们可以更酷地使用 Suspense，相信我，马上它就会成为你手中的利剑。 有了它你可以这样请求远程数据:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Posts</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> posts = useQuery(GET_MY_POSTS)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"posts"</span>&gt;</span></span></span><br><span class="line">    &#123;posts.map(i =&gt; &lt;Post key=&#123;i.id&#125; value=&#123;i&#125;/&gt;)&#125;</span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function App() &#123;</span></span><br><span class="line">  return (&lt;div className="app"&gt;</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;Loader&gt;Posts Loading...&lt;/Loader&gt;&#125;&gt;</span><br><span class="line">      &lt;Posts /&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>加载依赖脚本:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyMap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useImportScripts(<span class="string">'//api.map.baidu.com/api?v=2.0&amp;ak=您的密钥'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">BDMap</span> /&gt;</span>)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function App() &#123;</span></span><br><span class="line">  return (&lt;div className="app"&gt;</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;Loader&gt;地图加载中...&lt;/Loader&gt;&#125;&gt;</span><br><span class="line">      &lt;MyMap /&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>仔细观察上面的代码，有两个特点：</p><ul><li>1️⃣ 我们需要 <code>Suspense</code> 来包裹这些包含异步操作的组件，并给它们提供<code>回退(fallback)</code>。在异步请求期间，会显示这个回退。</li><li>2️⃣ 上面的代码获取异步资源就跟同步调用似的。没错，有了 Suspense,  我们可以和<code>async/await</code>或者<code>Generator</code> 一样，用’同步‘的代码风格来处理异步请求</li></ul><p><br></p><p>很神奇对不对？React 是怎么做到的？</p><p><br><br><br></p><h2 id="suspense-的实现原理"><a href="#suspense-的实现原理" class="headerlink" title="Suspense 的实现原理"></a>Suspense 的实现原理</h2><p>早前就<a href="https://zhuanlan.zhihu.com/p/34210780" target="_blank" rel="noopener">有人剖析过 <code>Suspense</code> 的实现</a>，它利用了 React 的 <code>ErrorBoundary</code> 类似的机制来实现, 脑洞很大。</p><p>🤔 嗯… 如果是用 <code>ErrorBoundary</code> 的话，ErrorBoundary 可以用来捕获下级组件的异常，我们在做异步操作时，可以抛出一个异常，中断渲染工作，当我们完成异步操作时，再告诉React，我们已经准备好了，请继续渲染…</p><p>🤭这就能解释，为什么没有使用 async/await 和 Generator，却可以使用用同步的风格来处理异步操作, throw 是可以中断代码执行的…</p><p>🤔 不过这个’异常‘应该跟普通的异常区分开来，同时它应该可以通知 ErrorBoundary 异步操作已经就绪了，让它继续渲染子节点…</p><p><br></p><p>我想流程应该是这样的:</p><p><img src="/images/concurrent-mode/suspense.png" alt></p><p><br></p><p>其实，符合该场景的、现成的最好的’异常对象’是 Promise。 那就撸起袖子，实现一个:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> interface SuspenseProps &#123;</span><br><span class="line">  fallback: React.ReactNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SuspenseState &#123;</span><br><span class="line">  pending: boolean</span><br><span class="line">  error?: any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Suspense</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">SuspenseProps</span>, <span class="title">SuspenseState</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️ 首先，记录是否处于挂载状态，因为我们不知道异步操作什么时候完成，可能在卸载之后</span></span><br><span class="line">  <span class="comment">// 组件卸载后就不能调用 setState 了</span></span><br><span class="line">  private mounted = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件状态</span></span><br><span class="line">  public state: SuspenseState = &#123;</span><br><span class="line">    <span class="comment">// ⚛️ 表示现在正阻塞在异步操作上</span></span><br><span class="line">    pending: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// ⚛️ 表示异步操作出现了问题</span></span><br><span class="line">    error: <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.mounted = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.mounted = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 使用 Error Boundary 机制捕获下级异常</span></span><br><span class="line">  public componentDidCatch(err: any) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.mounted) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 判断是否是 Promise, 如果不是则向上抛</span></span><br><span class="line">    <span class="keyword">if</span> (isPromise(err)) &#123;</span><br><span class="line">      <span class="comment">// 设置为 pending 状态</span></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">pending</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">      err.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ⚛️ 异步执行成功, 关闭pending 状态, 触发重新渲染</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123; <span class="attr">pending</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ⚛️ 异步执行失败, 我们需要妥善处理该异常，将它抛给 React</span></span><br><span class="line">        <span class="comment">// 因为处于异步回调中，在这里抛出异常无法被 React 捕获，所以我们这里先记录下来</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123; <span class="attr">error</span>: err || <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Suspense Error'</span>)&#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 在这里将 异常 抛给 React</span></span><br><span class="line">  public componentDidUpdate() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.pending &amp;&amp; <span class="keyword">this</span>.state.error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">this</span>.state.error</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public render() &#123;</span><br><span class="line">    <span class="comment">// ⚛️ 在pending 状态时渲染 fallback</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.state.pending ? <span class="keyword">this</span>.props.fallback : <span class="keyword">this</span>.props.children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实际上，Suspense不会去捕获异步操作的异常，也就是then和catch只是将pending设置为false。由下级组件自己选择如何去处理异常。这不过这里为了方便让大家理解 Suspense 的外在行为，将异常处理提到了这里。</p></blockquote><p><br></p><p>⚠️ 注意，<strong>以上代码只在<code>v16.6(不包括)</code>之前有效</strong>. 16.6正式推出 Suspense 后，Suspense 就和普通的 ErrorBoundary 隔离开来了，所以无法在 <code>componentDidCatch</code> 中捕获到 Promise. <strong>当组件中抛出 Promise 异常时，React 会向上查找最近的 Suspense 来处理它，如果找不到，React 会抛出错误</strong>。</p><p><br></p><p>上面的代码还算好理解，对吧？ 我们先不管 React 真实的实现如何，其内部显然要复杂得多，这些复杂性并不是所有开发者都需要去关心的。通过上面简单的代码，至少我们知道 Suspense 的行为是怎样的了。现在来测试一下：</p><p><br></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ComponentThatThrowError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error from component'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>throw error<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;ErrorBoundary&gt;</span><br><span class="line">        &lt;Suspense fallback=&#123;<span class="literal">null</span>&#125;&gt; &#123;<span class="comment">/* Suspense 不会捕获除Promise之外的异常，所以这里会被ErrorBoundary捕获 */</span>&#125;</span><br><span class="line">          &lt;ComponentThatThrowError /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>ErrorBoundary&gt;</span><br><span class="line">      &lt;ErrorBoundary&gt;                               &#123;<span class="comment">/* 如果异步操作失败，这个ErrorBoundary可以捕获异步操作的异常 */</span>&#125;</span><br><span class="line">        &lt;Suspense fallback=&#123;&lt;div&gt;loading...&lt;<span class="regexp">/div&gt;&#125;&gt; &#123;/</span>* 这里可以捕获ComponentThatThrowPromise 抛出的<span class="built_in">Promise</span>，并显示loading... *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">          &lt;ComponentThatThrowPromise /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>ErrorBoundary&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>上述代码展示了 Suspense 的基本用法以及异常处理。 你可以通过这个 <a href="https://codesandbox.io/s/react-custom-suspense-huff4?fontsize=14" target="_blank" rel="noopener">CodeSandbox</a> 实际运行一下这个实例.</p><p><br></p><p>现在来看下 <code>ComponentThatThrowResolvedPromise</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> throwed = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ComponentThatThrowResolvedPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!throwed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        throwed = <span class="literal">true</span></span><br><span class="line">        res()</span><br><span class="line">      &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>throw promise.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的要点是<code>throwed</code> 和 <code>throw new Promise</code>。在这个组件中，我们通过 <code>throw new Promise</code> 来中断组件渲染，Suspense会等待这个 Promise 就绪后，接着重新渲染。</p><p><strong>为了避免重新渲染时, 又抛出 Promise，导致’死循环’。这里需要使用一个’缓存’来表示异步操作已经就绪了，避免再次抛出异常</strong>。</p><p><strong>上面通过 throwed 全局变量来缓存异步操作的状态。但是对于组件来说全局状态是 Anti-Pattern，副作用会导致组件无法被复用。另外如果缓存脱离了组件的生命周期，它会变得难以控制, 我们怎么判断缓存是否有效? 这个缓存的生命周期是怎样控制？</strong>。</p><p>当然你可以使用 Redux 或者其他状态管理器来维护这些缓存，但是有时候我们都不想用状态管理器.</p><p><strong>能不能在组件内部缓存这些状态？答案是不行, 至少现在不可以</strong>, 由上面的自定义 Suspense 的实现可以解释: <strong>当 Suspense 切换到 pending 时，原有的组件树会被卸载，所有的组件状态都会丢失</strong>。</p><p>听起来挺沮丧，看来将异步操作迁移到 Suspense 还得花点心思。</p><p><br><br><br></p><h2 id="缓存-suspense-的异步操作状态"><a href="#缓存-suspense-的异步操作状态" class="headerlink" title="缓存 Suspense 的异步操作状态"></a>缓存 Suspense 的异步操作状态</h2><p>上面说了，我们无法在组件内部缓存异步操作的状态，那么现在只能放在外部了，可以考虑这些方案:</p><ul><li>全局缓存。 例如全局变量、全局状态管理器(如Redux、Mobx)</li><li>使用 Context API</li><li>由父级组件来缓存状态</li></ul><p>下面会介绍后面两种</p><p><br></p><h3 id="使用-context-api"><a href="#使用-context-api" class="headerlink" title="使用 Context API"></a>使用 Context API</h3><p>我们先用 Context API 作为例子，简单介绍如何缓存 <code>Suspense</code> 异步操作的状态。</p><p>首先定义一下异步操作的状态有哪些：</p><p><img src="/images/concurrent-mode/promise.png" alt><br><i>其实就是Promise的状态</i></p><p><br></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> enum PromiseState &#123;</span><br><span class="line">  Initial,  <span class="comment">// 初始化状态，即首次创建</span></span><br><span class="line">  Pending,  <span class="comment">// Promise 处于pending 状态</span></span><br><span class="line">  Resolved, <span class="comment">// 正常结束</span></span><br><span class="line">  Rejected, <span class="comment">// 异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们将保存在 Context 中的状态</span></span><br><span class="line"><span class="keyword">export</span> interface PromiseValue &#123;</span><br><span class="line">  state: PromiseState</span><br><span class="line">  value: any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>现在创建一个 <code>React.Context</code> 专门来缓存异步状态, 为了行文简洁，我们这个Context很简单，就是一个 <code>key-value</code> 存储：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface ContextValues &#123;</span><br><span class="line">  getResult(key: string): PromiseValue</span><br><span class="line">  resetResult(key: string): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Context = React.createContext&lt;ContextValues&gt;(&#123;&#125; <span class="keyword">as</span> any)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SimplePromiseCache: FC = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = useRef&lt;<span class="built_in">Map</span>&lt;string, PromiseValue&gt; | <span class="literal">undefined</span>&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据key获取缓存</span></span><br><span class="line">  <span class="keyword">const</span> getResult = useCallback(<span class="function">(<span class="params">key: string</span>) =&gt;</span> &#123;</span><br><span class="line">    cache.current = cache.current || <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache.current.has(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.current.get(key)!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> result = &#123; <span class="attr">state</span>: PromiseState.Initial, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line"></span><br><span class="line">    cache.current.set(key, result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据key c重置缓存</span></span><br><span class="line">  <span class="keyword">const</span> resetResult = useCallback(<span class="function">(<span class="params">key: string</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.current != <span class="literal">null</span>)  cache.current.delete(key)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> value = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> (&#123; getResult, resetResult, &#125;), [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span>&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>后面是重头戏，我们创建一个 <code>usePromise</code> Hooks来封装异步操作, 简化繁琐的步骤:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @params prom 接收一个Promise，进行异步操作</span></span><br><span class="line"><span class="comment"> * @params key 缓存键</span></span><br><span class="line"><span class="comment"> * @return 返回一个包含请求结果的对象，以及一个reset方法, 用于重置缓存，并重新请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>&lt;<span class="title">R</span>&gt;(<span class="params">prom: Promise&lt;R&gt;, key: string</span>): </span>&#123; data: R; reset: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span> &#125; &#123;</span><br><span class="line">  <span class="comment">// 用于强制重新渲染组件</span></span><br><span class="line">  <span class="keyword">const</span> [, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="comment">// 获取context值</span></span><br><span class="line">  <span class="keyword">const</span> cache = useContext(Context)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 监听key变化，并重新发起请求</span></span><br><span class="line">  useEffect(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    [key],</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ️⚛️ 异步处理</span></span><br><span class="line">  <span class="comment">// 从 Context 中取出缓存</span></span><br><span class="line">  <span class="keyword">const</span> result = cache.getResult(key)</span><br><span class="line">  <span class="keyword">switch</span> (result.state) &#123;</span><br><span class="line">    <span class="keyword">case</span> PromiseState.Initial:</span><br><span class="line">      <span class="comment">// ⚛️初始状态</span></span><br><span class="line">      result.state = PromiseState.Pending</span><br><span class="line">      result.value = prom</span><br><span class="line">      prom.then(</span><br><span class="line">        value =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (result.state === PromiseState.Pending) &#123;</span><br><span class="line">            result.state = PromiseState.Resolved</span><br><span class="line">            result.value = value</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        err =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (result.state === PromiseState.Pending) &#123;</span><br><span class="line">            result.state = PromiseState.Rejected</span><br><span class="line">            result.value = err</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      )</span><br><span class="line">      <span class="comment">// 抛出promise，并中断渲染</span></span><br><span class="line">      <span class="keyword">throw</span> prom</span><br><span class="line">    <span class="keyword">case</span> PromiseState.Pending:</span><br><span class="line">      <span class="comment">// ⚛️ 还处于请求状态，一个任务可能有多个组件触发，后面的渲染的组件可能会拿到Pending状态</span></span><br><span class="line">      <span class="keyword">throw</span> result.value</span><br><span class="line">    <span class="keyword">case</span> PromiseState.Resolved:</span><br><span class="line">      <span class="comment">// ⚛️ 已正常结束</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        data: result.value,</span><br><span class="line">        reset: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          cache.resetResult(key)</span><br><span class="line">          setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> PromiseState.Rejected:</span><br><span class="line">      <span class="comment">// ⚛️ 异常结束，抛出错误</span></span><br><span class="line">      <span class="keyword">throw</span> result.value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>上面的代码也没有特别难的地方，就是根据当前的异常请求的状态决定要抛出 Promise 还是返回异步请求的结果。</p><p>赶紧用起来, 首先用 <code>SimplePromiseCache</code> 包裹 <code>Suspense</code> 的上级组件，以便下级组件可以获取到缓存:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">SimplePromiseCache</span>&gt;</span></span></span><br><span class="line">    &lt;Suspense fallback="loading..."&gt;</span><br><span class="line">      &lt;DelayShow timeout=&#123;3000&#125;/&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">SimplePromiseCache</span>&gt;</span>)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>小试牛刀:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DelayShow</span>(<span class="params">&#123;timeout&#125;: &#123;timeout: number&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data &#125; = usePromise(</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>&lt;number&gt;(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> res(timeout), timeout)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="string">'delayShow'</span>, <span class="comment">// 缓存键</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>DelayShow: &#123;data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的运行效果如下：</p><p><img src="/images/concurrent-mode/usePromise.gif" alt></p><p><br></p><p>这一节展示了如何通过 Context API 来对异步操作进行缓存，这可能比你想象的要复杂的点，手动去管理这些缓存确实是一个棘手的问题(<strong>用什么作为缓存键，怎么判断缓存有效，怎么回收缓存</strong>)。包括 React 官方也没有给出一个完美的答案, 这个坑还是留给社区去探索吧。</p><p>除非你是库的作者，对于普通 React 开发者来说不必过早关注这些细节，相信很快会有很多 React 数据请求相关的第三方库会跟进 Suspense。</p><blockquote><p>React 官方有一个实验性的库: <a href="https://github.com/facebook/react/tree/master/packages/react-cache" target="_blank" rel="noopener">react-cache</a>, 目前采用的是 LRU 全局缓存</p></blockquote><p><br><br><br></p><h3 id="将缓存状态提取到父级"><a href="#将缓存状态提取到父级" class="headerlink" title="将缓存状态提取到父级"></a>将缓存状态提取到父级</h3><p><strong>既然无法在 Suspense 的子组件中缓存异步状态，那就提到父级组件呗，这样可以避免全局状态，不需要考虑缓存生命周期管理, 我们可以更灵活地管理这些状态，另外还可以简化下级组件逻辑</strong>。相比 Context API，我个人觉得这是一种更普适的方式。</p><p><br></p><p>So，怎么做？我们基于 <code>usePromise</code>, 再创建一个 <code>createResource</code> 函数, 它不再是一个Hooks，而是创建一个<strong>资源对象</strong>, 函数签名如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createResource</span>&lt;<span class="title">R</span>&gt;(<span class="params">prom: (</span>) =&gt; <span class="title">Promise</span>&lt;<span class="title">R</span>&gt;): <span class="title">Resource</span>&lt;<span class="title">R</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><p><code>createResource</code> 返回一个 <code>Resource</code> 对象:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Resource&lt;R&gt; &#123;</span><br><span class="line">  <span class="comment">// 读取'资源', 在Suspense包裹的下级组件中调用, 和上文的usePromise一样的效果</span></span><br><span class="line">  read(): R</span><br><span class="line">  <span class="comment">// ⚛️外加的好处，预加载</span></span><br><span class="line">  preload(): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>⚛️Resource 对象在父级组件中创建, 然后通过Props传递给下级组件，下级组件调用 <code>read()</code> 方法来读取数据。<code>对于下级组件来说 Resource 和普通的对象没什么区别，它察觉不出来这是一个异步请求</code></strong>。这就是这种 Suspense 的精妙之处!</p><p>另外由于 Resource 对象是在父级组件创建的，这有一个外加的好处: <strong>我们可以在显示下级组件之前，执行 <code>preload()</code> 预先执行异步操作</strong>。</p><p><br></p><p><code>createResource</code> 实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createResource</span>&lt;<span class="title">R</span>&gt;(<span class="params">prom: (</span>) =&gt; <span class="title">Promise</span>&lt;<span class="title">R</span>&gt;): <span class="title">Resource</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存</span></span><br><span class="line">  <span class="keyword">const</span> result: PromiseValue = &#123;</span><br><span class="line">    state: PromiseState.Initial,</span><br><span class="line">    value: prom,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">initial</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.state !== PromiseState.Initial) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    result.state = PromiseState.Pending</span><br><span class="line">    <span class="keyword">const</span> p = (result.value = result.value())</span><br><span class="line">    p.then(</span><br><span class="line">      (value: any) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.state === PromiseState.Pending) &#123;</span><br><span class="line">          result.state = PromiseState.Resolved</span><br><span class="line">          result.value = value</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      (err: any) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.state === PromiseState.Pending) &#123;</span><br><span class="line">          result.state = PromiseState.Rejected</span><br><span class="line">          result.value = err</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    read() &#123;</span><br><span class="line">      <span class="keyword">switch</span> (result.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> PromiseState.Initial:</span><br><span class="line">          <span class="comment">// ⚛️初始状态</span></span><br><span class="line">          <span class="comment">// 抛出promise，并中断渲染</span></span><br><span class="line">          <span class="keyword">throw</span> initial()</span><br><span class="line">        <span class="keyword">case</span> PromiseState.Pending:</span><br><span class="line">          <span class="comment">// ⚛️ 还处于请求状态，一个任务可能有多个组件触发，后面的渲染的组件可能会拿到Pending状态</span></span><br><span class="line">          <span class="keyword">throw</span> result.value</span><br><span class="line">        <span class="keyword">case</span> PromiseState.Resolved:</span><br><span class="line">          <span class="comment">// ⚛️ 已正常结束</span></span><br><span class="line">          <span class="keyword">return</span> result.value</span><br><span class="line">        <span class="keyword">case</span> PromiseState.Rejected:</span><br><span class="line">          <span class="comment">// ⚛️ 异常结束，抛出错误</span></span><br><span class="line">          <span class="keyword">throw</span> result.value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 预加载</span></span><br><span class="line">    preload: initial,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><code>createResource</code> 的用法也很简单, 在父组件创建 Resource，接着通过 Props 传递给子组件。 下面展示一个Tabs组件，渲染三个子Tab，因为同时只能显示一个Tab，我们可以选择预加载那些未显示的Tab, 来提升它们的打开速度:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [active, setActive] = useState(<span class="string">'tab1'</span>)</span><br><span class="line">  <span class="comment">// 创建 Resource</span></span><br><span class="line">  <span class="keyword">const</span> [resources] = useState(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    tab1: createResource(<span class="function"><span class="params">()</span> =&gt;</span> fetchPosts()),</span><br><span class="line">    tab2: createResource(<span class="function"><span class="params">()</span> =&gt;</span> fetchOrders()),</span><br><span class="line">    tab3: createResource(<span class="function"><span class="params">()</span> =&gt;</span> fetchUsers()),</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 预加载未展示的Tab数据</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(resources).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (name !== active) &#123;</span><br><span class="line">        resources[name].preload()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line">    &lt;Suspense fallback="loading..."&gt;</span><br><span class="line">      &lt;Tabs active=&#123;active&#125; onChange=&#123;setActive&#125;&gt;</span><br><span class="line">        &lt;Tab key="tab1"&gt;&lt;Posts resource=&#123;resources.tab1&#125;&gt;&lt;/Posts&gt;&lt;/Tab&gt;</span><br><span class="line">        &lt;Tab key="tab2"&gt;&lt;Orders resource=&#123;resources.tab2&#125;&gt;&lt;/Orders&gt;&lt;/Tab&gt;</span><br><span class="line">        &lt;Tab key="tab3"&gt;&lt;Users resource=&#123;resources.tab3&#125;&gt;&lt;/Users&gt;&lt;/Tab&gt;</span><br><span class="line">      &lt;/Tabs&gt;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>我们随便挑一个子组件, 看一下它的实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Posts: FC&lt;&#123;<span class="attr">resource</span>: Resource&lt;Post[]&gt;&#125;&gt; = <span class="function">(<span class="params">&#123;resource&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> posts = resource.read()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"posts"</span>&gt;</span></span></span><br><span class="line">    &#123;posts.map(i =&gt; &lt;PostSummary key=&#123;i.id&#125; value=&#123;i&#125; /&gt;)&#125;</span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>Ok, 这种方式相比 Context API 好很多了，我个人也偏向这种形式。这种模式下，因为 Resource 是由外部传入的，所以组件行为是确定的，容易被测试和复用。</p><p><br></p><p>不过两种各有应用场景:</p><ul><li>Context API 模式比较适合第三方数据请求库，比如Apollo、Relay。这种模式下，API会更加简洁、优雅。参考 <a href="https://relay.dev/docs/en/experimental/api-reference#uselazyloadquery" target="_blank" rel="noopener">Relay 的 API</a></li><li>createResource 模式则更适合普通开发者封装自己的异步操作。</li></ul><p><br><br><br></p><h2 id="并发发起请求"><a href="#并发发起请求" class="headerlink" title="并发发起请求"></a>并发发起请求</h2><p><img src="/images/concurrent-mode/twitter.png" alt></p><p><br></p><p>如上图，现实项目中经常会有这种场景，一个复杂的界面数据可能来源于多个接口，例如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户信息页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfilePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先拿到用户信息</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fetchUser().then(<span class="function"><span class="params">u</span> =&gt;</span> setUser(u));</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (user === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Loading profile...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;user.name&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ProfileTimeline /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 用户时间线</span><br><span class="line"> *<span class="regexp">/ </span></span><br><span class="line"><span class="regexp">function ProfileTimeline() &#123;</span></span><br><span class="line"><span class="regexp">  const [posts, setPosts] = useState(null);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    fetchPosts().then(p =&gt; setPosts(p));</span></span><br><span class="line"><span class="regexp">  &#125;, []);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  if (posts === null) &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;h2&gt;Loading posts...&lt;/</span>h2&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;posts.map(<span class="function"><span class="params">post</span> =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;post.id&#125;&gt;&#123;post.text&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>上面的代码示例来源于官方文档。上面代码 <code>fetchUser</code> 和 <code>fetchPosts</code> 是串行加载的，我们想让页面尽快的加载出来, 解决这个问题有两个方案：</p><ul><li>1️⃣ 将 fetchPosts 提到上级, 使用 <code>Promise.all</code> 并发加载</li><li>2️⃣ 将两者抽取成独立的组件，变成兄弟关系而不是父子关系. 这样可以被并发渲染，从而并发发起请求</li></ul><p><br></p><p>首先来看一下 1️⃣:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchProfileData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 promise all 并发加载</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">    fetchUser(),</span><br><span class="line">    fetchPosts()</span><br><span class="line">  ]).then(<span class="function">(<span class="params">[user, posts]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;user, posts&#125;;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = fetchProfileData();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfilePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> [posts, setPosts] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    promise.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      setUser(data.user);</span><br><span class="line">      setPosts(data.posts);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (user === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Loading profile...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;user.name&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &#123;/</span>* ProfileTimeline 变成了纯组件，不包含业务请求 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">      &lt;ProfileTimeline posts=&#123;posts&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>看起来不错，然后这个方式也存在硬伤:</p><ul><li>① 异步请求都要上提，然后使用 <code>Promise.all</code> 包裹，我觉得好麻烦, 复杂页面怎么办？</li><li>② 现在加载时间取决于 Promise.all 中执行最长的操作，说好的尽快渲染出来呢？fetchPosts 可能会加载很长，而 fetchUser 应该很快完成了，如果 fetchUser 先执行完，至少应该让用户先看到用户信息。</li></ul><p><br></p><p>1️⃣方案不是特别好，来看一下2️⃣方案:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfilePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"profile-page"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ProfileDetails</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ProfileTimeline</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>2️⃣方案是没有 Suspense 之前最好的方式，ProfileDetails 负责加载用户信息，ProfileTimeline 负责加载时间线，两者并发执行，互不干扰。</p><p>但是它也是有缺点：页面加载是会有两个<code>加载指示符</code>, 能不能合并？有可能 ProfileTimeline 先完成了，这时候 ProfileDetails 还在转圈，页面会很怪…</p><p><br></p><p>现在有请方案 3️⃣: <code>Suspense</code> 🎉</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resource = fetchProfileData();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfilePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;h1&gt;Loading profile...&lt;<span class="regexp">/h1&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ProfileDetails /</span>&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;h1&gt;Loading posts...&lt;<span class="regexp">/h1&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ProfileTimeline /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfileDetails</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = resource.user.read();</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;user.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfileTimeline</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> posts = resource.posts.read();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;posts.map(<span class="function"><span class="params">post</span> =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;post.id&#125;&gt;&#123;post.text&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p><br></p><p>当 React 渲染 ProfilePage 时, 它会返回 ProfileDetails 和 ProfileTimeline。</p><p>首先渲染 ProfileDetails 这时候资源未加载完毕，抛出 promise 异常，中断 ProfileDetails 的渲染。</p><p>接着 React 尝试渲染 ProfileTimeline, 同样抛出promise异常。</p><p>最后 React 找到 ProfileDetails 最近的Suspense，显示 Loading Profile…</p><p>和方案2️⃣一样，Suspense 支持并发发起请求，另外它解决了方案 2️⃣ 的一些缺陷: 加载指示符只有一个，而且如果 ProfileTimeline 率先完成，也不会显示出来。</p><p>不止于此，下文会介绍更为灵活的 Suspense 加载状态的显示策略。</p><p><br><br><br></p><h2 id="处理竞态"><a href="#处理竞态" class="headerlink" title="处理竞态"></a>处理竞态</h2><p><strong>就算 Javascript 是单线程的, 也可能需要处理竞争状态，主要是因为异步操作的时序是无法被保证的</strong>。</p><p>少卖关子，讲个实例。有这样一个组件，它依赖外部传递进来的 id 来异步获取数据:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">&#123;id&#125;: &#123;id: string&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState&lt;User|<span class="literal">undefined</span>&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 监听id变化并发起请求</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fetchUserInfo().then(<span class="function"><span class="params">user</span> =&gt;</span> setUser(user))</span><br><span class="line">  &#125;, [id])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> user == <span class="literal">null</span> ? <span class="xml"><span class="tag">&lt;<span class="name">Loading</span> /&gt;</span> : renderUser(user)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>上面的代码有什么问题呢？假设id变化了多次，这里会发起多个请求，但是这些请求完成的顺序没办法保证，这就会导致竞态，先发起的请求可能最后才完成，这就导致页面呈现错误的数据。</p><p><br></p><p>怎么解决？也比较好解决，利用类似<strong>乐观锁</strong>的机制。我们可以保存本次请求的id，如果请求结束时 id 不一致，就说明已经有新的请求发起了:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">&#123;id&#125;: &#123;id: string&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = setState&lt;User|<span class="literal">undefined</span>&gt;()</span><br><span class="line">  <span class="keyword">const</span> currentId = useRef&lt;string&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 监听id变化并发起请求</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    currentId.current = id</span><br><span class="line">    fetchUserInfo().then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// id 不一致，说明已经有新的请求发起了, 放弃</span></span><br><span class="line">      <span class="keyword">if</span> (id !== currentId.current) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      setUser(user)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [id])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> user == <span class="literal">null</span> ? <span class="xml"><span class="tag">&lt;<span class="name">Loading</span> /&gt;</span> : renderUser(user)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>Suspense 下面不存在竞态问题，上面的代码用 Suspense 实现如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">&#123;resource&#125;: &#123;resource: Resource&lt;User&gt;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = resource.read()</span><br><span class="line">  <span class="keyword">return</span> renderUser(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>我靠, 这么简洁！传递给 UserInfo 的就是一个简单的对象, 没有竞态. </p><p>那它的上级组件呢?</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createUserResource</span>(<span class="params">id: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    info: createResource(<span class="function"><span class="params">()</span> =&gt;</span> fecthUserInfo(id)),</span><br><span class="line">    timeline: createResource(<span class="function"><span class="params">()</span> =&gt;</span> fecthTimeline(id)),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserPage</span>(<span class="params">&#123;id&#125;: &#123;id: string&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [resource, setResource] = useState(<span class="function"><span class="params">()</span> =&gt;</span> createUserResource(id))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 将id的监听迁移到了这里</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 重新设置resource</span></span><br><span class="line">    setResource(createUserResource(id))</span><br><span class="line">  &#125;, [id])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"user-page"</span>&gt;</span></span></span><br><span class="line">    &lt;Suspense loading="Loading User..."&gt;</span><br><span class="line">      &lt;UserInfo resource=&#123;resource.info&#125; /&gt;</span><br><span class="line">      &lt;Timeline resource=&#123;resource.timeline&#125; /&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">  &lt;/div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>异步请求被转换成了’资源对象’，在这里只不过是一个普通的对象, 通过 Props 传递, 完美解决了异步请求的竞态问题…</p><p><br></p><blockquote><p><strong>另外 Suspense 还解决一个问题</strong>：在执行完异步操作后，我们的页面可能已经切换了，这时候通过 setState 设置组件状态，React就会抛出异常: <code>Can&#39;t perform a React state update on an unmounted component.</code>, 现在这个问题自然也解决了</p></blockquote><p><br><br><br></p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>如果异步请求异常了怎么解决？ 我们在上文 Suspense 实现原理一节已经说了，如果异步请求失败，React 会抛出异常，我们可以通过 ErrorBoundary 机制将其捕获。</p><p>我们写一个高阶组件来简化 Suspense 和 异常处理的过程:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">sup</span>&lt;<span class="title">P</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fallback: NonNullable&lt;React.ReactNode&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  catcher: (err: any</span>) =&gt; <span class="title">NonNullable</span>&lt;<span class="title">React</span>.<span class="title">ReactNode</span>&gt;,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">Comp: React.ComponentType&lt;P&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">    interface State &#123;</span><br><span class="line">      error?: any</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Sup</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">P</span>, <span class="title">State</span>&gt; </span>&#123;</span><br><span class="line">      state: State = &#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 捕获异常</span></span><br><span class="line">      <span class="keyword">static</span> getDerivedStateFromError(error: any) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; error &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          &lt;Suspense fallback=&#123;fallback&#125;&gt;</span><br><span class="line">            &#123;<span class="keyword">this</span>.state.error ? catcher(<span class="keyword">this</span>.state.error) : <span class="xml"><span class="tag">&lt;<span class="name">Comp</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Sup</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>用起来:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UserInfo.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UserInfo: FC&lt;UserInfoProps&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sup(</span><br><span class="line">  &lt;Loading text=<span class="string">"用户加载中..."</span>/&gt;,</span><br><span class="line">  (err) =&gt; <span class="xml"><span class="tag">&lt;<span class="name">ErrorMessage</span> <span class="attr">error</span>=<span class="string">&#123;err&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">)(UserInfo)</span></span><br></pre></td></tr></table></figure><p><br></p><p>减少了一些样板代码，还算比较简洁吧?。</p><p><br><br><br></p><h2 id="suspense-编排"><a href="#suspense-编排" class="headerlink" title="Suspense 编排"></a>Suspense 编排</h2><p>如果页面上有很多 Suspense, 那么多个圈在转，用户体验并不好。</p><p>但是我们又不好直接将它们合并，因为每一块加载优先级、生命周期都不一样，强行绑到一个 Suspense 也不好。例如:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserPage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">"loading..."</span>&gt;</span></span></span><br><span class="line">    &lt;UserInfo resource=&#123;infoResource&#125; /&gt;</span><br><span class="line">    &lt;UserPost resource=&#123;postResource&#125; /&gt;</span><br><span class="line">  &lt;/Suspense&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设 UserPost 需要进行分页，每次点击下一页都会导致整个 <code>UserPage</code> loading… 这肯定无法接受…</p><p><br></p><p><strong>因此 Concurrent 模式引入了一个新的API <code>SuspenseList</code>, 用来对多个 Suspense 的加载状态进行编排。我们可以根据实际的场景选择加载状态的显示策略</strong>。例如</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Page</span>(<span class="params">&#123; resource &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;SuspenseList revealOrder=<span class="string">"forwards"</span>&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;h2&gt;Loading Foo...&lt;<span class="regexp">/h2&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Foo resource=&#123;resource&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Suspense fallback=&#123;&lt;h2&gt;Loading Bar...&lt;/</span>h2&gt;&#125;&gt;</span><br><span class="line">        &lt;Bar resource=&#123;resource&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>SuspenseList&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>假设 <code>Foo</code> 加载时间是 <code>5s</code>，而 <code>Bar</code> 加载完成时间是 <code>2s</code>。SuspenseList 的各种编排组合的效果如下:</p><p><img src="/images/concurrent-mode/suspense-list.gif" alt><br><i>可以通过这个 <a href="https://codesandbox.io/s/react-suspenselist-sk3rj?fontsize=14" target="_blank" rel="noopener">CodeSandbox 示例</a> 体验 </i></p><p><br></p><p><code>revealOrder</code> 表示显示的顺序，它目前有三个可选值: <code>forwards</code>, <code>backwards</code>, <code>together</code></p><ul><li><code>forwards</code> - 由前到后显示。也就说前面的没有加载完成，后面的也不会显示. 即使后面的 Suspense 提前完成异步操作，也需要等待前面的执行完成</li><li><code>backwards</code> - 和forwards相反, 由后到前依次显示.</li><li><code>together</code> - 等所有Suspense 加载完成后一起显示</li></ul><p><br></p><p>除此之外 <code>SuspenseList</code> 还有另外一个属性 <code>tail</code>, 用来控制是否要折叠这些 Suspense，它有三个值 <code>默认值</code>, <code>collapsed</code>, <code>hidden</code></p><ul><li>默认值 - 全部显示</li><li><code>collapsed</code> - 折叠，只显示第一个正在加载的Suspense</li><li><code>hidden</code> - 不显示任何加载状态</li></ul><p><br></p><p>另外 SuspenseList 是可组合的，SuspenseList 下级可以包含其他 SuspenseList.</p><p><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文的主角是 <code>Suspense</code>, 如果说 <code>React Hooks</code> 是React提供的逻辑复用原语，ErrorBoundary 是异常捕获原语，那么 Suspense 将是 React 的异步操作原语。通过Suspense + ErrorBoundary，简化了手动去处理加载状态和异常状态。</p><p>Suspense 可以理解为中断渲染、或者暂停渲染的意思。我们简单探讨了 Suspense 的实现原理，它不过是利用了 ErrorBoundary 的异常抛出机制来中断渲染，配合 Suspense 组件在异步操作完结后恢复组件的渲染。</p><p>不过组件在重新渲染(重入)时，所有状态都丢失了，无法在组件本地保存异步处理的状态，所以得向外求，将异步处理的状态缓存在全局或者上级组件。</p><p>有人会说 React 已经不纯了、不够函数式了。我不敢擅作评论，我不是虔诚的函数式编程爱好者，我觉得只要能更好的解决问题，哪种编程范式无所谓。自从 React Hooks 出来后，就没有所谓的纯函数式组件了。对于 Suspense 来说，createResource 模式也可以让一个组件的行为变得可被预测和测试。关于其他的痛点，还是要进一步实践和验证。</p><p>Suspense 让人非常兴奋，它不仅解决了一些以往异步处理的问题，还带来了新的开发方式。心急的同学可以在自己的实验项目中尝试它。</p><p><br><br><br></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://reactjs.org/docs/concurrent-mode-suspense.html" target="_blank" rel="noopener">Suspense for Data Fetching (Experimental)</a></li><li><a href="https://www.youtube.com/watch?v=ByBPyMBTzM0" target="_blank" rel="noopener">Concurrent Rendering in React - Andrew Clark and Brian Vaughn - React Conf 2018</a></li><li><a href="https://zhuanlan.zhihu.com/p/34210780" target="_blank" rel="noopener">React：Suspense的实现与探讨</a></li><li><a href="https://github.com/facebook/react/blob/master/packages/react-cache/src/ReactCache.js" target="_blank" rel="noopener">react-cache</a></li></ul><p><br></p><p><img src="/images/sponsor.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;2019.10.24&lt;/strong&gt;, 在 &lt;a href=&quot;https://www.youtube.com/channel/UCz5vTaEhvh7dOHEyd1efcaQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React Co
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>这可能是最通俗的 React Fiber 打开方式</title>
    <link href="https://bobi.ink/2019/10/18/react-fiber/"/>
    <id>https://bobi.ink/2019/10/18/react-fiber/</id>
    <published>2019-10-17T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.330Z</updated>
    
    <content type="html"><![CDATA[<p>写一篇关于 React Fiber 的文章， 这个 Flag 立了很久，这也是今年的目标之一. 最近的在掘金的文章获得很多关注和鼓励，给了我很多动力，所以下定决心好好把它写出来。 我会以最通俗的方式将它讲透, 因此这算是一篇科普式的文章。不管你是使用React、还是Vue，这里面的思想值得学习学习!</p><p><br></p><p><img src="/images/react-fiber/react-conf.png" alt></p><p><br></p><p>一年一度的 React 春晚: <a href="https://conf.reactjs.org/schedule.html" target="_blank" rel="noopener">React Conf</a> 即将到来，不知道今年会不会有什么惊喜，去年是 React Hooks，前年是 React Fiber…<br>我得赶在 React Conf 之前发布这篇文章:</p><ul><li><p>😲 <strong>React Fiber 已经出来这么久了， 这文章是老酒装新瓶吧</strong>? <em>对于我来说，通过这篇文章我重新认识了 React Fiber，它不是一个新东西, 它也是老酒装新瓶，不信你就看吧…</em></p></li><li><p>🆕 <strong>React Fiber 不是一个新的东西，但在前端领域是第一次广为认知的应用</strong>。</p></li><li><p>😦 <strong>了解它有啥用</strong>? <em>React Fiber 代码很复杂，门槛很高，你不了解它，后面 React 新出的 Killer Feature 你可能就更不能理解了</em></p></li><li><p>🤥 <strong>我不是升到React v16了吗? 没什么出奇的啊</strong>? <em>真正要体会到 React Fiber 重构效果，可能下个月、可能要等到 v17。v16 只是一个过渡版本，也就是说，现在的React 还是同步渲染的，一直在跳票、不是说今年第二季度就出来了吗</em>？</p></li><li><p>😁 <strong>不好意思，一不小心又写得有点长，你就当小说看吧, 代码都是伪代码</strong></p></li></ul><p><br></p><p><strong>以下文章大纲</strong></p><ul><li><a href="#单处理进程调度-fiber-不是一个新的东西">单处理进程调度: Fiber 不是一个新的东西</a></li><li><a href="#类比浏览器javascript执行环境">类比浏览器JavaScript执行环境</a></li><li><a href="#何为-fiber">何为 Fiber</a><ul><li><a href="#1-一种流程控制原语">1. 一种流程控制原语</a></li><li><a href="#2-一个执行单元">2. 一个执行单元</a></li></ul></li><li><a href="#react-的fiber改造">React 的Fiber改造</a><ul><li><a href="#1-数据结构的调整">1. 数据结构的调整</a></li><li><a href="#2-两个阶段的拆分">2. 两个阶段的拆分</a></li><li><a href="#3-reconcilation">3. Reconcilation</a></li><li><a href="#4-双缓冲">4. 双缓冲</a></li><li><a href="#5-副作用的收集和提交">5. 副作用的收集和提交</a></li></ul></li><li><a href="#⚠️-未展开部分-🚧----中断和恢复">⚠️ 未展开部分 🚧 – 中断和恢复</a></li><li><a href="#凌波微步">凌波微步</a></li><li><a href="#站在巨人的肩膀上">站在巨人的肩膀上</a></li></ul><p><br><br><br></p><h2 id="单处理进程调度-fiber-不是一个新的东西"><a href="#单处理进程调度-fiber-不是一个新的东西" class="headerlink" title="单处理进程调度: Fiber 不是一个新的东西"></a>单处理进程调度: Fiber 不是一个新的东西</h2><p><br></p><p><img src="/images/react-fiber/dos.jpg" alt><br><i>这个黑乎乎的界面应该就是微软的 <code>DOS</code> 操作系统</i></p><p><br></p><p>微软 <a href="https://zh.wikipedia.org/zh-cn/DOS" target="_blank" rel="noopener"><code>DOS</code></a> 是一个<code>单任务操作系统</code>, 也称为’单工操作系统‘. 这种操作系统同一个时间只允许运行一个程序. <a href="https://www.zhihu.com/people/s.invalid" target="_blank" rel="noopener">invalid s</a>在<a href="https://www.zhihu.com/question/319595914/answer/683541635" target="_blank" rel="noopener">《在没有GUI的时代(只有一个文本界面），人们是怎么运行多个程序的？》</a> 的回答中将其称为: ‘<strong>一种压根没有任务调度的“残疾”操作系统</strong>‘.</p><p>在这种系统中，你想执行多个任务，只能等待前一个进程退出，然后再载入一个新的进程。</p><p>直到 Windows 3.x，它才有了真正意义的进程调度器，实现了多进程并发执行。</p><blockquote><p>注意并发和并行不是同一个概念。</p></blockquote><p><br></p><p>现代操作系统都是<strong>多任务操作系统</strong>. 进程的调度策略如果按照CPU核心数来划分，可以分为<strong>单处理器调度</strong>和<strong>多处理器调度</strong>。本文只关注的是单处理器调度，因为它可以类比JavaScript的运行机制。</p><p><strong>🔴说白了，为了实现进程的并发，操作系统会按照一定的调度策略，将CPU的执行权分配给多个进程，多个进程都有被执行的机会，让它们交替执行，形成一种“同时在运行”假象, 因为CPU速度太快，人类根本感觉不到。实际上在单核的物理环境下同时只能有一个程序在运行</strong>。</p><brk><p><img src="/images/react-fiber/longzhu.jpg" alt></p><p><br></p><p>这让我想起了“龙珠”中的分身术(小时候看过，说错了别喷)，实质上是一个人，只不过是他运动速度太快，看起来就像分身了. 这就是所谓的<strong>并发(Concurrent)</strong>(单处理器)。</p><p><br></p><p><img src="/images/react-fiber/naruto.jpg" alt></p><p><br></p><p>相比而言, 火影忍者中的分身术，是物理存在的，他们可以真正实现同时处理多个任务，这就是<strong>并行</strong>(严格地讲这是<code>Master-Slave</code>架构，分身虽然物理存在，但应该没有独立的意志)。</p><p>所以说<strong>🔴并行可以是并发，而并发不一定是并行，两种不能划等号, 并行一般需要物理层面的支持</strong>。 关于并发和并行，Go 之父 Rob Pike 有一个非常著名的演讲<a href="https://blog.golang.org/concurrency-is-not-parallelism" target="_blank" rel="noopener">Concurrency is not parallelism</a></p><p><br></p><p>扯远了，接下来进程怎么调度就是教科书的内容了。如果读者在大学认真学过<strong>操作系统原理</strong>, 你可以很快理解以下几种单处理器进程<strong>调度策略</strong>(我就随便科普一下，算送的, 如果你很熟悉这块，可以跳过)：</p><p><br></p><p><strong>0️⃣ 先到先得(First-Come-First-Served, FCFS)</strong></p><p>这是最简单的调度策略, 简单说就是<strong>没有调度</strong>。谁先来谁就先执行，执行完毕后就执行下一个。不过如果中间某些进程因为I/O阻塞了，这些进程会挂起移回就绪队列(说白了就是重新排队).</p><p><code>FCFS</code> 上面 <code>DOS</code> 的单任务操作系统没有太大的区别。所以非常好理解，因为生活中到处是这样的例子:。</p><ul><li><p><strong>FCFS 对<code>短进程</code>不利</strong>。 短进程即执行时间非常短的进程，可以用饭堂排队来比喻: <em>在饭堂排队打饭的时候，最烦那些一个人打包好好几份的人，这些人就像<code>长进程</code>一样，霸占着CPU资源，后面排队只打一份的人会觉得很吃亏，打一份的人会觉得他们优先级应该更高，毕竟他们花的时间很短，反正你打包那么多份再等一会也是可以的，何必让后面那么多人等这么久…</em></p></li><li><p><strong>FCFS 对<code>I/O密集</code>不利</strong>。I/O密集型进程(这里特指同步I/O)在进行I/O操作时，会阻塞休眠，这会导致进程重新被放入就绪队列，等待下一次被宠幸。 可以类比ZF部门办业务: <em>假设 CPU 一个窗口、I/O 一个窗口。在CPU窗口好不容易排到你了，这时候发现一个不符合条件或者漏办了, 需要去I/O搞一下，Ok 去 I/O窗口排队，I/O执行完了，到CPU窗口又得重新排队。对于这些丢三落四的人很不公平…</em></p></li></ul><p>所以 FCFS 这种原始的策略在单处理器进程调度中并不受欢迎。</p><p><br></p><p><strong>1️⃣ 轮转</strong></p><p>这是一种基于时钟的<strong>抢占策略</strong>，这也是抢占策略中最简单的一种: <strong>公平地给每一个进程一定的执行时间，当时间消耗完毕或阻塞，操作系统就会调度其他进程，将执行权抢占过来</strong>。</p><blockquote><p><strong>决策模式</strong>: <code>抢占策略</code>相对应的有<code>非抢占策略</code>，非抢占策略指的是让进程运行直到结束、阻塞(如I/O或睡眠)、或者主动让出控制权；抢占策略支持中断正在运行的进程，将主动权掌握在操作系统这里，不过通常开销会比较大。</p></blockquote><p>这种调度策略的要点是<strong>确定合适的时间片长度</strong>: 太长了，长进程霸占太久资源，其他进程会得不到响应(等待执行时间过长)，这时候就跟上述的 <code>FCFS</code> 没什么区别了;  太短了也不好，因为进程抢占和切换都是需要成本的, 而且成本不低，时间片太短，时间可能都浪费在上下文切换上了，导致进程干不了什么实事。</p><p>因此<strong>时间片的长度最好符合大部分进程完成一次典型交互所需的时间</strong>.</p><p>轮转策略非常容易理解，只不过确定时间片长度需要伤点脑筋；另外和<code>FCFS</code>一样，轮转策略对I/O进程还是不公平。</p><p><br></p><p><strong>2️⃣ 最短进程优先(Shortest Process Next, SPN)</strong></p><p>上面说了<code>先到先得</code>策略对<code>短进程</code>不公平，<code>最短进程优先</code>索性就让’最短’的进程优先执行，也就是说: <strong>按照进程的预估执行时间对进程进行优先级排序，先执行完短进程，后执行长进程。这是一种非抢占策略</strong>。</p><p>这样可以让短进程能得到较快的响应。但是怎么获取或者<strong>评估进程执行时间</strong>呢？一是让程序的提供者提供，这不太靠谱；二是由操作系统来收集进程运行数据，并对它们进程统计分析。例如最简单的是计算它们的平均运行时间。不管怎么说都比上面两种策略要复杂一点。</p><p><code>SPN</code> 的缺陷是: 如果系统有大量的短进程，那么长进程可能会饥饿得不到响应。</p><p>另外因为它不是抢占性策略, 尽管现在短进程可以得到更多的执行机会，但是还是没有解决 <code>FCFS</code> 的问题: 一旦长进程得到CPU资源，得等它执行完，导致后面的进程得不到响应。</p><p><br></p><p><strong>3️⃣ 最短剩余时间(Shortest Remaining Time, SRT)</strong></p><p><strong>SRT 进一步优化了SPN，增加了抢占机制</strong>。在 SPN 的基础上，当一个进程添加到就绪队列时，操作系统会比较<em>刚添加的新进程</em>和<em>当前正在执行的老进程</em>的‘剩余时间’，如果新进程剩余时间更短，新进程就会抢占老进程。</p><p>相比轮转的抢占，SRT 没有中断处理的开销。但是在 SPN 的基础上，操作系统需要记录进程的历史执行时间，这是新增的开销。<strong>另外长进程饥饿问题还是没有解决</strong>。</p><p><br></p><p><strong>4️⃣ 最高响应比优先(HRRN)</strong></p><p><strong>为了解决长进程饥饿问题，同时提高进程的响应速率</strong>。还有一种<code>最高响应比优先的</code>策略，首先了解什么是响应比:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">响应比 = （等待执行时间 + 进程执行时间） / 进程执行时间</span><br></pre></td></tr></table></figure><p><strong>这种策略会选择响应比最高的进程优先执行</strong>：</p><ul><li>对于短进程来说，因为执行时间很短，分母很小，所以响应比比较高，会被优先执行</li><li>对于长进程来说，执行时间长，一开始响应比小，但是随着等待时间增长，它的优先级会越来越高，最终可以被执行</li></ul><p><br></p><p><strong>5️⃣ 反馈法</strong></p><p>SPN、SRT、HRRN都需要对进程时间进行评估和统计，实现比较复杂且需要一定开销。而反馈法采取的是<strong>事后反馈</strong>的方式。这种策略下: <strong>每个进程一开始都有相同的优先级，每次被抢占(需要配合其他抢占策略使用，如轮转)，优先级就会降低一级。因此通常它会根据优先级划分多个队列</strong>。</p><p>举个例子: </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">队列1</span><br><span class="line">队列2</span><br><span class="line">...</span><br><span class="line">队列N</span><br></pre></td></tr></table></figure><p>新增的任务会推入<code>队列1</code>，<code>队列1</code>会按照<code>轮转策略</code>以一个时间片为单位进行调度。短进程可以很快得到响应，而对于长进程可能一个时间片处理不完，就会被抢占，放入<code>队列2</code>。</p><p><code>队列2</code>会在<code>队列1</code>任务清空后被执行，有时候低优先级队列可能会等待很久才被执行，所以一般会给予一定的补偿，例如增加执行时间，所以<code>队列2</code>的轮转时间片长度是2。</p><p>反馈法仍然可能导致长进程饥饿，所以操作系统可以统计长进程的等待时间，当等待时间超过一定的阈值，可以选择提高它们的优先级。</p><p><br><br><br></p><p><img src="/images/react-fiber/process-schedule.png" alt></p><p>没有一种调度策略是万能的, 它需要考虑很多因素:</p><ul><li>响应速率。进程等待被执行的时间</li><li>公平性。兼顾短进程、长进程、I/O进程</li></ul><p>这两者在某些情况下是对立的，提高了响应，可能会减低公平性，导致饥饿。短进程、长进程、I/O进程之间要取得平衡也非常难。</p><p>上面这些知识对本文来说已经足够了，现实世界操作系统的进程调度算法比教科书上说的要复杂的多，有兴趣读者可以去研究一下 <code>Linux</code> 相关的进程调度算法，这方面的资料也非常多, 例如<a href="https://blog.csdn.net/gatieme/article/details/51456569" target="_blank" rel="noopener">《Linux进程调度策略的发展和演变》</a>。</p><p><br><br><br></p><h2 id="类比浏览器javascript执行环境"><a href="#类比浏览器javascript执行环境" class="headerlink" title="类比浏览器JavaScript执行环境"></a>类比浏览器JavaScript执行环境</h2><p><br></p><p><img src="/images/react-fiber/singleroad.jpg" alt><br><i>JavaScript 就像单行道</i></p><p><br></p><p>JavaScript 是<a href="https://juejin.im/post/5a6547d0f265da3e283a1df7" target="_blank" rel="noopener">单线程运行</a>的，而且在浏览器环境屁事非常多，它要负责页面的JS解析和执行、绘制、事件处理、静态资源加载和处理, 这些任务可以类比上面’进程‘。</p><blockquote><p>这里特指Javascript 引擎是单线程运行的。 严格来说，Javascript 引擎和页面渲染引擎在同一个渲染线程，GUI 渲染和 Javascript执行 两者是互斥的. 另外异步 I/O 操作底层实际上可能是多线程的在驱动。</p></blockquote><p><img src="/images/react-fiber/frame-full.jpg" alt><br><i>图片来源: <a href="https://developers.google.com/web/fundamentals/performance/rendering" target="_blank" rel="noopener">Rendering Performance</a></i></p><p><strong>它只是一个’JavaScript’，同时只能做一件事情，这个和 <code>DOS</code> 的单任务操作系统一样的，事情只能一件一件的干。要是前面有一个傻叉任务长期霸占CPU，后面什么事情都干不了，浏览器会呈现卡死的状态，这样的用户体验就会非常差</strong>。</p><p><br></p><p><strong>对于’前端框架‘来说，解决这种问题有三个方向</strong>:</p><ul><li>1️⃣ 优化每个任务，让它有多快就多快。挤压CPU运算量</li><li>2️⃣ 快速响应用户，让用户觉得够快，不能阻塞用户的交互</li><li>3️⃣ 尝试 Worker 多线程</li></ul><p>Vue 选择的是第1️⃣, 因为对于Vue来说，使用<code>模板</code>让它有了很多优化的空间，配合响应式机制可以让Vue可以精确地进行节点更新, 读者可以去看一下<a href="https://www.yuque.com/vueconf/2019/gwn1z0" target="_blank" rel="noopener">今年Vue Conf 尤雨溪的演讲</a>，非常棒!；而 React 选择了2️⃣ 。对于Worker 多线程渲染方案也有人尝试，要保证状态和视图的一致性相当麻烦。</p><p><br></p><p>React 为什么要引入 Fiber 架构？ 看看下面的火焰图，这是React V15 下面的一个列表渲染资源消耗情况。整个渲染花费了130ms, <strong>🔴在这里面 React 会递归比对VirtualDOM树，找出需要变动的节点，然后同步更新它们, 一气呵成。这个过程 React 称为 <code>Reconcilation</code>(中文可以译为<code>协调</code>)</strong>.</p><p><br></p><p><img src="/images/react-fiber/perf.png" alt></p><p><br></p><p>在 Reconcilation 期间，React 会霸占着浏览器资源，一则会导致用户触发的事件得不到响应, 二则会导致掉帧，用户可以感知到这些卡顿。</p><p>这样说，你可能没办法体会到，通过下面两个图片来体会一下(<em>图片来源于：<a href="https://twitter.com/dan_abramov" target="_blank" rel="noopener">Dan Abramov</a> 的 <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" target="_blank" rel="noopener">Beyond React 16</a> 演讲, 推荐看一下👍. 另外非常感谢<a href="https://www.zhihu.com/people/BlackGanglion/activities" target="_blank" rel="noopener">淡苍</a> 将一个<a href="https://codesandbox.io/s/koyz664q35" target="_blank" rel="noopener">类似的DEMO 分享在了 CodeSandbox</a>上🎉，大家自行体验</em>):</p><p><br></p><p>同步模式下的 React:</p><p><img src="/images/react-fiber/sync-mode.gif" alt></p><p><br></p><p>优化后的 <code>Concurrent</code> 模式下的 React:</p><p><img src="/images/react-fiber/concurrent-mode.gif" alt></p><p><br></p><p>React 的 Reconcilation 是CPU密集型的操作, 它就相当于我们上面说的’长进程‘。所以初衷和进程调度一样，我们要让高优先级的进程或者短进程优先运行，不能让长进程长期霸占资源。</p><p>所以React 是怎么优化的？ 划重点， <strong>🔴为了给用户制造一种应用很快的’假象’，我们不能让一个程序长期霸占着资源. 你可以将浏览器的渲染、布局、绘制、资源加载(例如HTML解析)、事件响应、脚本执行视作操作系统的’进程’，我们需要通过某些调度策略合理地分配CPU资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率</strong>。</p><p><br></p><p><strong>🔴所以 React 通过Fiber 架构，让自己的Reconcilation 过程变成可被中断。 ‘适时’地让出CPU执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处</strong>:</p><ul><li>与其一次性操作大量 DOM 节点相比, 分批延时对DOM进行操作，可以得到更好的用户体验。这个在<a href="https://juejin.im/post/5d76f469f265da039a28aff7#heading-1" target="_blank" rel="noopener">《「前端进阶」高性能渲染十万条数据(时间分片)》</a> 以及司徒正美的<a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener">《React Fiber架构》</a> 都做了相关实验</li><li>司徒正美在<a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener">《React Fiber架构》</a> 也提到：<strong>🔴给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对reflow进行修正</strong>.</li></ul><p><br></p><p>这就是为什么React 需要 Fiber 😏。</p><p><br></p><h2 id="何为-fiber"><a href="#何为-fiber" class="headerlink" title="何为 Fiber"></a>何为 Fiber</h2><p>对于 React 来说，Fiber 可以从两个角度理解:</p><p><br></p><h3 id="1-一种流程控制原语"><a href="#1-一种流程控制原语" class="headerlink" title="1. 一种流程控制原语"></a>1. 一种流程控制原语</h3><p>Fiber 也称<a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272" target="_blank" rel="noopener">协程</a>、或者纤程。 笔者第一次接触这个概念是在学习 Ruby 的时候，Ruby就将协程称为 Fiber。后来发现很多语言都有类似的机制，例如Lua 的<code>Coroutine</code>, 还有前端开发者比较熟悉的 <code>ES6</code> 新增的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="noopener"><code>Generator</code></a>。</p><blockquote><p>本文不纠结 <a href="https://stackoverflow.com/questions/3324643/processes-threads-green-threads-protothreads-fibers-coroutines-whats-the/16375591#16375591" target="_blank" rel="noopener">Processes, threads, green threads, protothreads, fibers, coroutines: what’s the difference?</a></p></blockquote><p><strong>🔴 其实协程和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制</strong>。要理解协程，你得和普通函数一起来看, 以Generator为例:</p><p>普通函数执行的过程中无法<strong>被中断和恢复</strong>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task</span><br><span class="line">  <span class="keyword">while</span> (task = tasks.shift()) &#123;</span><br><span class="line">    execute(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>而 <code>Generator</code> 可以:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (task = tasks.shift()) &#123;</span><br><span class="line">    <span class="comment">// 🔴 判断是否有高优先级事件需要处理, 有的话让出控制权</span></span><br><span class="line">    <span class="keyword">if</span> (hasHighPriorityEvent()) &#123;</span><br><span class="line">      <span class="keyword">yield</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完高优先级事件后，恢复函数调用栈，继续执行...</span></span><br><span class="line">    execute(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>React Fiber 的思想和协程的概念是契合的: <strong>🔴React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染</strong>。</p><p><br></p><p>那么现在你应该有以下疑问:</p><ul><li>1️⃣ 浏览器没有抢占的条件, 所以React只能用让出机制?</li><li>2️⃣ 怎么确定有高优先任务要处理，即什么时候让出？</li><li>3️⃣ React 那为什么不使用 Generator？</li></ul><p><br><br><br></p><p><strong>答1️⃣: 没错, 主动让出机制</strong></p><p>一是浏览器中没有类似进程的概念，’任务‘之间的界限很模糊，没有上下文，所以不具备中断/恢复的条件。二是没有抢占的机制，我们无法中断一个正在执行的程序。</p><p>所以我们只能采用类似协程这样控制权让出机制。这个和上文提到的进程调度策略都不同，它有更一个专业的名词：<a href="https://juejin.im/post/5d12c907f265da1b6d4033c5#heading-7" target="_blank" rel="noopener"><strong>合作式调度(Cooperative Scheduling)</strong></a>, 相对应的有<strong>抢占式调度(Preemptive Scheduling)</strong></p><p><strong>这是一种’契约‘调度，要求我们的程序和浏览器紧密结合，互相信任</strong>。比如可以由浏览器给我们分配执行时间片(通过<code>requestIdleCallback</code>实现, 下文会介绍)，我们要按照约定在这个时间内执行完毕，并将控制权还给浏览器。</p><p><img src="/images/react-fiber/cs.png" alt></p><p><br></p><p>这种调度方式很有趣，你会发现<strong>这是一种身份的对调</strong>，以前我们是老子，想怎么执行就怎么执行，执行多久就执行多久; 现在为了我们共同的用户体验统一了战线, 一切听由浏览器指挥调度，浏览器是老子，我们要跟浏览器申请执行权，而且这个执行权有期限，借了后要按照约定归还给浏览器。</p><p>当然你超时不还浏览器也拿你没办法 🤷‍… 合作式调度的缺点就在于此，全凭自律，用户要挖大坑，谁都拦不住。</p><p><br></p><hr><p><br></p><p><strong>答2️⃣: requestIdleCallback API</strong></p><p>上面代码示例中的 <code>hasHighPriorityEvent()</code> 在目前浏览器中是无法实现的，我们没办法判断当前是否有更高优先级的任务等待被执行。</p><p>只能换一种思路，通过<strong>超时检查的机制来让出控制权</strong>。解决办法是: <em>确定一个合理的运行时长，然后在合适的检查点检测是否超时(比如每执行一个小任务)，如果超时就停止执行，将控制权交换给浏览器</em>。</p><p>举个例子，为了让视图流畅地运行，可以按照人类能感知到最低限度每秒60帧的频率划分时间片，这样每个时间片就是 16ms。</p><p>其实浏览器提供了相关的接口 —— <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noopener"><code>requestIdleCallback</code></a> API：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestIdleCallback(</span><br><span class="line">  callback: <span class="function">(<span class="params">dealine: IdleDeadline</span>) =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">  option?: &#123;timeout: <span class="built_in">number</span>&#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p><br></p><p><code>IdleDeadline</code>的接口如下：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IdleDealine &#123;</span><br><span class="line">  didTimeout: <span class="built_in">boolean</span> <span class="comment">// 表示任务执行是否超过约定时间</span></span><br><span class="line">  timeRemaining(): DOMHighResTimeStamp <span class="comment">// 任务可供执行的剩余时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单从名字上理解的话, <code>requestIdleCallback</code>的意思是<strong>让浏览器在’有空’的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行, 为了不耽误事，我们最好在这个时间范围内执行完毕</strong>。</p><p><br></p><p><strong>那浏览器什么时候有空？</strong></p><p>我们先来看一下浏览器在一帧(Frame，可以认为事件循环的一次循环)内可能会做什么事情:</p><p><img src="/images/react-fiber/frame.png" alt><br><i>你可以打开 Chrome 开发者工具的Performance标签，这里可以详细看到Javascript的每一帧都执行了什么任务(Task), 花费了多少时间。</i></p><p><br></p><p><img src="/images/react-fiber/frame-life.png" alt><br><i>图片来源: <a href="https://juejin.im/post/5ad71f39f265da239f07e862" target="_blank" rel="noopener">你应该知道的requestIdleCallback</a></i></p><p>浏览器在一帧内可能会做执行下列任务，而且它们的执行顺序基本是固定的:</p><ul><li>处理用户输入事件</li><li>Javascript执行</li><li>requestAnimation 调用</li><li>布局 Layout</li><li>绘制 Paint</li></ul><p><br></p><p>上面说理想的一帧时间是 <code>16ms</code> (1000ms / 60)，如果浏览器处理完上述的任务(布局和绘制之后)，还有盈余时间，浏览器就会调用 <code>requestIdleCallback</code> 的回调。例如</p><p><br></p><p><img src="/images/react-fiber/ric.png" alt></p><p><br></p><p><strong>但是在浏览器繁忙的时候，可能不会有盈余时间，这时候<code>requestIdleCallback</code>回调可能就不会被执行。 为了避免饿死，可以通过requestIdleCallback的第二个参数指定一个超时时间</strong>。</p><blockquote><p>另外不建议在<code>requestIdleCallback</code>中进行<code>DOM</code>操作，因为这可能导致样式重新计算或重新布局(比如操作DOM后马上调用 <code>getBoundingClientRect</code>)，这些时间很难预估的，很有可能导致回调执行超时，从而掉帧。</p></blockquote><p><br></p><p>目前 <code>requestIdleCallback</code> 目前只有Chrome支持。所以目前 React <a href="https://github.com/facebook/react/blob/master/packages/scheduler/src/forks/SchedulerHostConfig.default.js" target="_blank" rel="noopener">自己实现了一个</a>。它利用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel" target="_blank" rel="noopener"><code>MessageChannel</code></a> 模拟将回调延迟到’绘制操作’之后执行:</p><p><br></p><p><img src="/images/react-fiber/mc.png" alt></p><p><br></p><details><br><summary>简单看一下代码</summary><br><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>)</span><br><span class="line"><span class="keyword">const</span> ch = <span class="keyword">new</span> MessageChannel()</span><br><span class="line"><span class="keyword">let</span> pendingCallback</span><br><span class="line"><span class="keyword">let</span> startTime</span><br><span class="line"><span class="keyword">let</span> timeout</span><br><span class="line"></span><br><span class="line">ch.port2.onmessage = <span class="function"><span class="keyword">function</span> <span class="title">work</span>(<span class="params"></span>)  </span>&#123;</span><br><span class="line">  <span class="comment">// 在绘制之后被执行</span></span><br><span class="line">  <span class="keyword">if</span> (pendingCallback) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = performance.now()</span><br><span class="line">    <span class="comment">// 通过now - startTime可以计算出requestAnimationFrame到绘制结束的执行时间</span></span><br><span class="line">    <span class="comment">// 通过这些数据来计算剩余时间</span></span><br><span class="line">    <span class="comment">// 另外还要处理超时(timeout)，避免任务被饿死</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (hasRemain &amp;&amp; noTimeout) &#123;</span><br><span class="line">      pendingCallback(deadline)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleRequestIdleCallback</span>(<span class="params">callback, timeout</span>) </span>&#123;</span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">animation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在绘制之前被执行</span></span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    startTime = performance.now()</span><br><span class="line">    timeout = timeout</span><br><span class="line">    dosomething()</span><br><span class="line">    <span class="comment">// 调度回调到绘制结束后执行</span></span><br><span class="line">    pendingCallback = callback</span><br><span class="line">    ch.port1.postMessage(<span class="string">'hello'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details><p><br></p><p><strong>任务优先级</strong></p><p>上面说了，为了避免任务被饿死，可以设置一个超时时间. <strong>这个超时时间不是死的，低优先级的可以慢慢等待, 高优先级的任务应该率先被执行</strong>. 目前 React 预定义了 5 个优先级, 这个我在[《谈谈React事件机制和未来(react-events)》]中也介绍过:</p><ul><li><code>Immediate</code>(-1) - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断</li><li><code>UserBlocking</code>(250ms) 这些任务一般是用户交互的结果, 需要即时得到反馈</li><li><code>Normal</code> (5s) 应对哪些不需要立即感受到的任务，例如网络请求</li><li><code>Low</code> (10s) 这些任务可以放后，但是最终应该得到执行. 例如分析通知</li><li><code>Idle</code> (没有超时时间) 一些没有必要做的任务 (e.g. 比如隐藏的内容), 可能会被饿死</li></ul><p><br></p><hr><p><br></p><p><strong>答3️⃣: 太麻烦</strong></p><p>官方在<a href="https://github.com/facebook/react/issues/7942" target="_blank" rel="noopener">《Fiber Principles: Contributing To Fiber》</a> 也作出了解答。主要有两个原因：</p><ol><li>Generator 不能在栈中间让出。比如你想在嵌套的函数调用中间让出, 首先你需要将这些函数都包装成Generator，另外这种栈中间的让出处理起来也比较麻烦，难以理解。除了语法开销，现有的生成器实现开销比较大，所以不如不用。</li><li>Generator 是有状态的, 很难在中间恢复这些状态。</li></ol><blockquote><p>上面理解可能有出入，建议看一下原文</p></blockquote><p>可能都没看懂，简单就是 React 尝试过用 Generator 实现，后来发现很麻烦，就放弃了。</p><p><br><br><br></p><h3 id="2-一个执行单元"><a href="#2-一个执行单元" class="headerlink" title="2. 一个执行单元"></a>2. 一个执行单元</h3><p>Fiber的另外一种解读是’纤维‘: <strong>这是一种数据结构或者说执行单元</strong>。我们暂且不管这个数据结构长什么样，<strong>🔴将它视作一个执行单元，每次执行完一个’执行单元’,  React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去</strong>.</p><p><br></p><p>上文说了，React 没有使用 Generator 这些语言/语法层面的让出机制，而是实现了自己的调度让出机制。这个机制就是基于’Fiber‘这个执行单元的，它的过程如下：</p><p>假设用户调用 <code>setState</code> 更新组件, 这个待更新的任务会先放入队列中, 然后通过 <code>requestIdleCallback</code> 请求浏览器调度：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">updateQueue.push(updateTask);</span><br><span class="line">requestIdleCallback(performWork, &#123;timeout&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p>现在浏览器有空闲或者超时了就会调用<code>performWork</code>来执行任务：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1️⃣ performWork 会拿到一个Deadline，表示剩余时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performWork</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2️⃣ 循环取出updateQueue中的任务</span></span><br><span class="line">  <span class="keyword">while</span> (updateQueue.length &gt; <span class="number">0</span> &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123;</span><br><span class="line">    workLoop(deadline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3️⃣ 如果在本次执行中，未能将所有任务执行完毕，那就再请求浏览器调度</span></span><br><span class="line">  <span class="keyword">if</span> (updateQueue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    requestIdleCallback(performWork);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong><code>workLoop</code> 的工作大概猜到了，它会从更新队列(updateQueue)中弹出更新任务来执行，每执行完一个‘<code>执行单元</code>‘，就检查一下剩余时间是否充足，如果充足就进行执行下一个<code>执行单元</code>，反之则停止执行，保存现场，等下一次有执行权时恢复</strong>:</p><p><br></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存当前的处理现场</span></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork: Fiber | <span class="literal">undefined</span> <span class="comment">// 保存下一个需要处理的工作单元</span></span><br><span class="line"><span class="keyword">let</span> topWork: Fiber | <span class="literal">undefined</span>        <span class="comment">// 保存第一个工作单元</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline: IdleDeadline</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// updateQueue中获取下一个或者恢复上一次中断的执行单元</span></span><br><span class="line">  <span class="keyword">if</span> (nextUnitOfWork == <span class="literal">null</span>) &#123;</span><br><span class="line">    nextUnitOfWork = topWork = getNextUnitOfWork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴 每执行完一个执行单元，检查一次剩余时间</span></span><br><span class="line">  <span class="comment">// 如果被中断，下一次执行还是从 nextUnitOfWork 开始处理</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123;</span><br><span class="line">    <span class="comment">// 下文我们再看performUnitOfWork</span></span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork, topWork);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交工作，下文会介绍</span></span><br><span class="line">  <span class="keyword">if</span> (pendingCommit) &#123;</span><br><span class="line">    commitAllWork(pendingCommit);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画个流程图吧！</p><p><br></p><p><img src="/images/react-fiber/workloop.png" alt></p><p><br><br><br></p><h2 id="react-的fiber改造"><a href="#react-的fiber改造" class="headerlink" title="React 的Fiber改造"></a>React 的Fiber改造</h2><p>Fiber 的核心内容已经介绍完了，现在来进一步看看React 为 Fiber 架构做了哪些改造, 如果你对这部分内容不感兴趣可以跳过。</p><p><br></p><h3 id="1-数据结构的调整"><a href="#1-数据结构的调整" class="headerlink" title="1. 数据结构的调整"></a>1. 数据结构的调整</h3><p><img src="/images/react-fiber/diff.png" alt><br><i>左侧是Virtual DOM，右侧可以看作diff的递归调用栈</i></p><p><br></p><p>上文中提到 React 16 之前，Reconcilation 是同步的、递归执行的。也就是说这是基于函数’调用栈‘的Reconcilation算法，因此通常也称它为<code>Stack Reconcilation</code>. 你可以通过这篇文章<a href="https://juejin.im/post/5cfa29e151882539c33e4f5e" target="_blank" rel="noopener">《从Preact中了解React组件和hooks基本原理》</a> 来回顾一下历史。</p><p><br></p><p>栈挺好的，代码量少，递归容易理解, 至少比现在的 React Fiber架构好理解😂, 递归非常适合树这种嵌套数据结构的处理。</p><p>只不过这种依赖于调用栈的方式不能随意中断、也很难被恢复, 不利于异步处理。 这种调用栈，不是程序所能控制的， 如果你要恢复递归现场，可能需要从头开始, 恢复到之前的调用栈。</p><p>因此<strong>首先我们需要对React现有的数据结构进行调整，<a href="https://zhuanlan.zhihu.com/p/36425839" target="_blank" rel="noopener"><code>模拟函数调用栈</code></a>, 将之前需要递归进行处理的事情分解成增量的执行单元，将递归转换成迭代</strong>.</p><p><br></p><p>React 目前的做法是使用<code>链表</code>, 每个 VirtualDOM 节点内部现在使用 <code>Fiber</code>表示, 它的结构大概如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type Fiber = &#123;</span><br><span class="line">  <span class="comment">// Fiber 类型信息</span></span><br><span class="line">  type: any,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 链表结构</span></span><br><span class="line">  <span class="comment">// 指向父节点，或者render该节点的组件</span></span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向第一个子节点</span></span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向下一个兄弟节点</span></span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>用图片来展示这种关系会更直观一些：</p><p><img src="/images/react-fiber/fiber-node.png" alt></p><p><br></p><p><strong>使用链表结构只是一个结果，而不是目的，React 开发者一开始的目的是冲着模拟调用栈去的</strong>。这个很多关于Fiber 的文章都有提及, 关于调用栈的详细定义参见<a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank" rel="noopener">Wiki</a>：</p><p><img src="/images/react-fiber/callstack.png" alt></p><blockquote><p>调用栈最经常被用于存放子程序的<strong>返回地址</strong>。在调用任何子程序时，主程序都必须暂存子程序运行完毕后应该返回到的地址。因此，如果被调用的子程序还要调用其他的子程序，其自身的返回地址就必须存入调用栈，在其自身运行完毕后再行取回。除了返回地址，还会保存<code>本地变量</code>、<code>函数参数</code>、<code>环境传递</code>(Scope?)</p></blockquote><p><br></p><p>React Fiber 也被称为虚拟栈帧(Virtual Stack Frame), 你可以拿它和函数调用栈类比一下, 两者结构非常像:</p><table><thead><tr><th></th><th>函数调用栈</th><th>Fiber</th></tr></thead><tbody><tr><td>基本单位</td><td>函数</td><td>Virtual DOM 节点</td></tr><tr><td>输入</td><td>函数参数</td><td>Props</td></tr><tr><td>本地状态</td><td>本地变量</td><td>State</td></tr><tr><td>输出</td><td>函数返回值</td><td>React Element</td></tr><tr><td>下级</td><td>嵌套函数调用</td><td>子节点(child)</td></tr><tr><td>上级引用</td><td>返回地址</td><td>父节点(return)</td></tr></tbody></table><p><br></p><p>Fiber 和调用栈帧一样, 保存了节点处理的上下文信息，因为是手动实现的，所以更为可控，我们可以保存在内存中，随时中断和恢复。</p><p><br></p><p>有了这个数据结构调整，现在可以以迭代的方式来处理这些节点了。来看看 <code>performUnitOfWork</code> 的实现, 它其实就是一个深度优先的遍历：</p><p><br></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @params fiber 当前需要处理的节点</span></span><br><span class="line"><span class="comment"> * @params topWork 本次更新的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber: Fiber, topWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对该节点进行处理</span></span><br><span class="line">  beginWork(fiber);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在子节点，那么下一个待处理的就是子节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有子节点了，上溯查找兄弟节点</span></span><br><span class="line">  <span class="keyword">let</span> temp = fiber;</span><br><span class="line">  <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">    completeWork(temp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到顶层节点了, 退出</span></span><br><span class="line">    <span class="keyword">if</span> (temp === topWork) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到，下一个要处理的就是兄弟节点</span></span><br><span class="line">    <span class="keyword">if</span> (temp.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> temp.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有, 继续上溯</span></span><br><span class="line">    temp = temp.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>你可以配合上文的 <code>workLoop</code> 一起看，<strong>Fiber 就是我们所说的工作单元，<code>performUnitOfWork</code> 负责对 <code>Fiber</code> 进行操作，并按照深度遍历的顺序返回下一个 Fiber</strong>。</p><p><strong>因为使用了链表结构，即使处理流程被中断了，我们随时可以从上次未处理完的<code>Fiber</code>继续遍历下去</strong>。</p><p>整个迭代顺序和之前递归的一样, 下图假设在 <code>div.app</code> 进行了更新：</p><p><br></p><p><img src="/images/react-fiber/work-order.png" alt><br><i>比如你在<code>text(hello)</code>中断了，那么下一次就会从 <code>p</code> 节点开始处理</i></p><p><br></p><p>这个数据结构调整还有一个好处，就是某些节点异常时，我们可以打印出完整的’节点栈‘，只需要沿着节点的<code>return</code>回溯即可。</p><p><br><br><br></p><h3 id="2-两个阶段的拆分"><a href="#2-两个阶段的拆分" class="headerlink" title="2. 两个阶段的拆分"></a>2. 两个阶段的拆分</h3><p><br></p><p><img src="/images/react-fiber/fiber-reconciler.png" alt></p><p><br></p><p>如果你现在使用最新的 React 版本(v16), 使用 Chrome 的 Performance 工具，可以很清晰地看到每次渲染有两个阶段：<code>Reconciliation</code>(协调阶段) 和 <code>Commit</code>(提交阶段).</p><blockquote><p>我在之前的多篇文章中都有提及: <a href="https://juejin.im/post/5d8395646fb9a06ad16faa57" target="_blank" rel="noopener">《自己写个React渲染器: 以 Remax 为例(用React写小程序)》</a></p></blockquote><p>除了Fiber 工作单元的拆分，两阶段的拆分也是一个非常重要的改造，在此之前都是一边Diff一边提交的。先来看看这两者的区别:</p><ul><li><p><strong>⚛️ 协调阶段</strong>: 可以认为是 Diff 阶段, <strong>这个阶段可以被中断</strong>, 这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等, 这些变更React 称之为’<code>副作用</code>(Effect)’ . 以下生命周期钩子会在协调阶段被调用：</p><ul><li><code>constructor</code></li><li><code>componentWillMount</code> 废弃</li><li><code>componentWillReceiveProps</code> 废弃</li><li><code>static getDerivedStateFromProps</code></li><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code> 废弃</li><li><code>render</code></li></ul></li><li><p><strong>⚛️ 提交阶段</strong>: 将上一个阶段计算出来的需要处理的<strong>副作用(Effects)</strong>一次性执行了。<strong>这个阶段必须同步执行，不能被打断</strong>. 这些生命周期钩子在提交阶段被执行:</p><ul><li><code>getSnapshotBeforeUpdate()</code> 严格来说，这个是在进入 commit 阶段前调用</li><li><code>componentDidMount</code></li><li><code>componentDidUpdate</code></li><li><code>componentWillUnmount</code></li></ul></li></ul><p><br></p><p>也就是说，在协调阶段如果时间片用完，React就会选择让出控制权。因为协调阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题。</p><p>需要注意的是：因为协调阶段可能被中断、恢复，甚至重做，<strong>⚠️React 协调阶段的生命周期钩子可能会被调用多次!</strong>, 例如 <code>componentWillMount</code> 可能会被调用两次。 </p><p>因此建议 <strong>协调阶段的生命周期钩子不要包含副作用</strong>. 索性 React 就废弃了这部分可能包含副作用的生命周期方法，例如<code>componentWillMount</code>、<code>componentWillUpdate</code>. v17后我们就不能再用它们了, 所以现有的应用应该尽快迁移.</p><p><br></p><p>现在你应该知道为什么’提交阶段’必须同步执行，不能中断的吧？ 因为我们要正确地处理各种副作用，包括DOM变更、还有你在<code>componentDidMount</code>中发起的异步请求、useEffect 中定义的副作用… 因为有副作用，所以必须保证按照次序只调用一次，况且会有用户可以察觉到的变更, 不容差池。</p><p>关于为什么要拆分两个阶段，<a href="https://github.com/facebook/react/issues/13186#issuecomment-403959161" target="_blank" rel="noopener">这里</a>有更详细的解释。</p><p><br><br><br></p><h3 id="3-reconcilation"><a href="#3-reconcilation" class="headerlink" title="3. Reconcilation"></a>3. Reconcilation</h3><p>接下来就是就是我们熟知的<code>Reconcilation</code>(为了方便理解，本文不区分Diff和Reconcilation, 两者是同一个东西)阶段了. <strong>思路和 Fiber 重构之前差别不大, 只不过这里不会再递归去比对、而且不会马上提交变更</strong>。</p><p>首先再进一步看一下<code>Fiber</code>的结构:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Fiber &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 节点的类型信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 标记 Fiber 类型, 例如函数组件、类组件、宿主组件</span></span><br><span class="line">  tag: WorkTag,</span><br><span class="line">  <span class="comment">// 节点元素类型, 是具体的类组件、函数组件、宿主组件(字符串)</span></span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">any</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 结构信息</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 子节点的唯一键, 即我们渲染列表传入的key属性</span></span><br><span class="line">  key: <span class="literal">null</span> | <span class="built_in">string</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 节点的状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 节点实例(状态)：</span></span><br><span class="line">  <span class="comment">//        对于宿主组件，这里保存宿主组件的实例, 例如DOM节点。</span></span><br><span class="line">  <span class="comment">//        对于类组件来说，这里保存类组件的实例</span></span><br><span class="line">  <span class="comment">//        对于函数组件说，这里为空，因为函数组件没有实例</span></span><br><span class="line">  stateNode: <span class="built_in">any</span>,</span><br><span class="line">  <span class="comment">// 新的、待处理的props</span></span><br><span class="line">  pendingProps: <span class="built_in">any</span>,</span><br><span class="line">  <span class="comment">// 上一次渲染的props</span></span><br><span class="line">  memoizedProps: <span class="built_in">any</span>, <span class="comment">// The props used to create the output.</span></span><br><span class="line">  <span class="comment">// 上一次渲染的组件状态</span></span><br><span class="line">  memoizedState: <span class="built_in">any</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 副作用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 当前节点的副作用类型，例如节点更新、删除、移动</span></span><br><span class="line">  effectTag: SideEffectTag,</span><br><span class="line">  <span class="comment">// 和节点关系一样，React 同样使用链表来将所有有副作用的Fiber连接起来</span></span><br><span class="line">  nextEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 替身</span></span><br><span class="line"><span class="comment">   * 指向旧树中的节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  alternate: Fiber | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>Fiber 包含的属性可以划分为 5 个部分:</p><ul><li><strong>🆕 结构信息</strong> - 这个上文我们已经见过了，Fiber 使用链表的形式来表示节点在树中的定位</li><li><strong>节点类型信息</strong> - 这个也容易理解，tag表示节点的分类、type 保存具体的类型值，如div、MyComp</li><li><strong>节点的状态</strong> - 节点的组件实例、props、state等，它们将影响组件的输出</li><li><p><strong>🆕 副作用</strong> - 这个也是新东西. 在 Reconciliation 过程中发现的’副作用’(变更需求)就保存在节点的<code>effectTag</code> 中(想象为打上一个标记).<br>那么怎么将本次渲染的所有节点副作用都收集起来呢？ 这里也使用了链表结构，在遍历过程中React会将所有有‘副作用’的节点都通过<code>nextEffect</code>连接起来</p></li><li><p><strong>🆕 替身</strong> - React 在 Reconciliation 过程中会构建一颗新的树(官方称为workInProgress tree，<strong>WIP树</strong>)，可以认为是一颗表示当前工作进度的树。还有一颗表示已渲染界面的<strong>旧树</strong>，React就是一边和旧树比对，一边构建WIP树的。 alternate 指向旧树的同等节点。</p></li></ul><p><br></p><p>现在可以放大看看<code>beginWork</code>  是如何对 Fiber 进行比对的:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">fiber: Fiber</span>): <span class="title">Fiber</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fiber.tag === WorkTag.HostComponent) &#123;</span><br><span class="line">    <span class="comment">// 宿主节点diff</span></span><br><span class="line">    diffHostComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.ClassComponent) &#123;</span><br><span class="line">    <span class="comment">// 类组件节点diff</span></span><br><span class="line">    diffClassComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.FunctionComponent) &#123;</span><br><span class="line">    <span class="comment">// 函数组件节点diff</span></span><br><span class="line">    diffFunctionalComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他类型节点，省略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>宿主节点比对:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffHostComponent</span>(<span class="params">fiber: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新增节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.stateNode == <span class="literal">null</span>) &#123;</span><br><span class="line">    fiber.stateNode = createHostComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateHostComponent(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newChildren = fiber.pendingProps.children;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比对子节点</span></span><br><span class="line">  diffChildren(fiber, newChildren);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>类组件节点比对也差不多:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffClassComponent</span>(<span class="params">fiber: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.stateNode == <span class="literal">null</span>) &#123;</span><br><span class="line">    fiber.stateNode = createInstance(fiber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.hasMounted) &#123;</span><br><span class="line">    <span class="comment">// 调用更新前生命周期钩子</span></span><br><span class="line">    applybeforeUpdateHooks(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 调用挂载前生命周期钩子</span></span><br><span class="line">    applybeforeMountHooks(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染新节点</span></span><br><span class="line">  <span class="keyword">const</span> newChildren = fiber.stateNode.render();</span><br><span class="line">  <span class="comment">// 比对子节点</span></span><br><span class="line">  diffChildren(fiber, newChildren);</span><br><span class="line"></span><br><span class="line">  fiber.memoizedState = fiber.stateNode.state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>子节点比对:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">fiber: Fiber, newChildren: React.ReactNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldFiber = fiber.alternate ? fiber.alternate.child : <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 全新节点，直接挂载</span></span><br><span class="line">  <span class="keyword">if</span> (oldFiber == <span class="literal">null</span>) &#123;</span><br><span class="line">    mountChildFibers(fiber, newChildren)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 新子节点</span></span><br><span class="line">  <span class="keyword">const</span> elements = extraElements(newChildren)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比对子元素</span></span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length || oldFiber != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevFiber = newFiber;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index]</span><br><span class="line">    <span class="keyword">const</span> sameType = isSameType(element, oldFiber)</span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">      newFiber = cloneFiber(oldFiber, element)</span><br><span class="line">      <span class="comment">// 更新关系</span></span><br><span class="line">      newFiber.alternate = oldFiber</span><br><span class="line">      <span class="comment">// 打上Tag</span></span><br><span class="line">      newFiber.effectTag = UPDATE</span><br><span class="line">      newFiber.return = fiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新节点</span></span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">      newFiber = createFiber(element)</span><br><span class="line">      newFiber.effectTag = PLACEMENT</span><br><span class="line">      newFiber.return = fiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除旧节点</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">      oldFiber.effectTag = DELETION;</span><br><span class="line">      oldFiber.nextEffect = fiber.nextEffect</span><br><span class="line">      fiber.nextEffect = oldFiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldFiber) &#123;</span><br><span class="line">      oldFiber = oldFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">      fiber.child = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevFiber &amp;&amp; element) &#123;</span><br><span class="line">      prevFiber.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>上面的代码很粗糙地还原了 Reconciliation 的过程, 但是对于我们理解React的基本原理已经足够了.</p><p><br></p><p>这里引用一下<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">Youtube: Lin Clark presentation in ReactConf 2017</a> 的Slide，来还原 Reconciliation 的过程. Lin Clark 这个演讲太经典了，几乎所有介绍 React Fiber 的文章都会引用它的Slide. 偷个懒，我也用下:</p><blockquote><p>这篇文章<a href="https://juejin.im/post/5ab7b3a2f265da2378403e57" target="_blank" rel="noopener">《React Fiber》</a> 用文字版解释了Link Clark Slide.</p></blockquote><p><img src="/images/react-fiber/effect-tag.png" alt></p><p><br></p><p>上图是 Reconciliation 完成后的状态，左边是旧树，右边是WIP树。对于需要变更的节点，都打上了’标签’。 在提交阶段，React 就会将这些打上标签的节点应用变更。</p><p><br><br><br></p><h3 id="4-双缓冲"><a href="#4-双缓冲" class="headerlink" title="4. 双缓冲"></a>4. 双缓冲</h3><p><code>WIP 树</code>构建这种技术类似于图形化领域的’<strong>双缓存(Double Buffering)</strong>‘技术, 图形绘制引擎一般会使用双缓冲技术，先将图片绘制到一个缓冲区，再一次性传递给屏幕进行显示，这样可以防止屏幕抖动，优化渲染性能。</p><p>放到React 中，WIP树就是一个缓冲，它在Reconciliation 完毕后一次性提交给浏览器进行渲染。它可以减少内存分配和垃圾回收，WIP 的节点不完全是新的，比如某颗子树不需要变动，React会克隆复用旧树中的子树。</p><p>双缓存技术还有另外一个重要的场景就是异常的处理，比如当一个节点抛出异常，仍然可以继续沿用旧树的节点，避免整棵树挂掉。</p><p>Dan 在 <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" target="_blank" rel="noopener">Beyond React 16</a> 演讲中用了一个非常恰当的比喻，那就是Git 功能分支，<strong>你可以将 WIP 树想象成从旧树中 Fork 出来的功能分支，你在这新分支中添加或移除特性，即使是操作失误也不会影响旧的分支。当你这个分支经过了测试和完善，就可以合并到旧分支，将其替换掉. 这或许就是’提交(commit)阶段‘的提交一词的来源吧？</strong>:</p><p><br></p><p><img src="/images/react-fiber/gitbranch.png" alt></p><p><br><br><br></p><h3 id="5-副作用的收集和提交"><a href="#5-副作用的收集和提交" class="headerlink" title="5. 副作用的收集和提交"></a>5. 副作用的收集和提交</h3><p>接下来就是将所有打了 Effect 标记的节点串联起来，这个可以在<code>completeWork</code>中做, 例如:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parent = fiber.return</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 到达顶端</span></span><br><span class="line">  <span class="keyword">if</span> (parent == <span class="literal">null</span> || fiber === topWork) &#123;</span><br><span class="line">    pendingCommit = fiber</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.effectTag != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.nextEffect) &#123;</span><br><span class="line">      parent.nextEffect.nextEffect = fiber</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parent.nextEffect = fiber</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.nextEffect) &#123;</span><br><span class="line">    parent.nextEffect = fiber.nextEffect</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>最后了，将所有副作用提交了:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> next = fiber</span><br><span class="line">  <span class="keyword">while</span>(next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fiber.effectTag) &#123;</span><br><span class="line">      <span class="comment">// 提交，偷一下懒，这里就不展开了</span></span><br><span class="line">      commitWork(fiber)</span><br><span class="line">    &#125;</span><br><span class="line">    next = fiber.nextEffect</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清理现场</span></span><br><span class="line">  pendingCommit = nextUnitOfWork = topWork = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="⚠️-未展开部分-🚧-–-中断和恢复"><a href="#⚠️-未展开部分-🚧-–-中断和恢复" class="headerlink" title="⚠️ 未展开部分 🚧 – 中断和恢复"></a>⚠️ 未展开部分 🚧 – 中断和恢复</h2><p>上文只是介绍了简单的中断和恢复机制，我们从哪里跌倒就从哪里站起来，在哪个节点中断就从哪个节点继续处理下去。 也就是说，到目前为止：<strong>⚠️更新任务还是串行执行的，我们只是将整个过程碎片化了. 对于那些需要优先处理的更新任务还是会被阻塞</strong>。我个人觉得这才是 React Fiber 中最难处理的一部分。</p><p><strong>实际情况是，在 React 得到控制权后，应该优先处理高优先级的任务</strong>。也就是说中断时正在处理的任务，在恢复时会让位给高优先级任务，原本中断的任务可能会被放弃或者重做。</p><p><strong>但是如果不按顺序执行任务，可能会导致前后的状态不一致</strong>。 比如低优先级任务将 <code>a</code> 设置为0，而高优先级任务将 <code>a</code> 递增1, 两个任务的执行顺序会影响最终的渲染结果。因此<strong>要让高优先级任务插队, 首先要保证状态更新的时序</strong>。</p><p><br></p><p>解决办法是: <strong>所有更新任务按照顺序插入一个队列, 状态必须按照插入顺序进行计算，但任务可以按优先级顺序执行</strong>, 例如：</p><p><br></p><p><img src="/images/react-fiber/resume-1.png" alt></p><p><br></p><p>红色表示高优先级任务。要计算它的状态必须基于前序任务计算出来的状态, 从而保证<strong>状态的最终一致性</strong>：</p><p><br></p><p><img src="/images/react-fiber/resume-2.png" alt></p><p>最终红色的高优先级任务 <code>C</code> 执行时的状态值是<code>a=5,b=3</code>. 在恢复控制权时，会按照优先级先执行 <code>C</code>, 前面的<code>A</code>、 <code>B</code>暂时跳过</p><p><br></p><p><img src="/images/react-fiber/resume-3.png" alt></p><p><br></p><p>上面被跳过任务不会被移除，在执行完高优先级任务后它们还是会被执行的。因为不同的更新任务影响的节点树范围可能是不一样的，举个例子 <code>a</code>、<code>b</code> 可能会影响 <code>Foo</code> 组件树，而 <code>c</code> 会影响 <code>Bar</code> 组件树。所以为了保证<strong>视图的最终一致性</strong>, 所有更新任务都要被执行。</p><p><br></p><p><img src="/images/react-fiber/resume-4.png" alt></p><p>首先 <code>C</code> 先被执行，它更新了 <code>Foo</code> 组件</p><p>接着执行 <code>A</code> 任务，它更新了<code>Foo</code> 和 <code>Bar</code> 组件，由于 <code>C</code> 已经以最终状态<code>a=5, b=3</code>更新了<code>Foo</code>组件，这里可以做一下性能优化，直接复用C的更新结果， 不必触发重新渲染。因此 <code>A</code> 仅需更新 <code>Bar</code> 组件即可。</p><p>接着执行 <code>B</code>，同理可以复用 Foo 更新结果。</p><p><br></p><p>道理讲起来都很简单，React Fiber 实际上非常复杂，不管执行的过程怎样拆分、以什么顺序执行，最重要的是保证<strong>状态的一致性</strong>和<strong>视图的一致性</strong>，这给了 React 团队很大的考验，以致于现在都没有正式release出来。</p><p><br><br><br></p><h2 id="凌波微步"><a href="#凌波微步" class="headerlink" title="凌波微步"></a>凌波微步</h2><p><img src="/images/react-fiber/new-frame.jpg" alt><br><i>同样来自Link Clark 的 Slider</i></p><p>前面说了一大堆，从操作系统进程调度、到浏览器原理、再到合作式调度、最后谈了React的基本改造工作, 地老天荒… 就是为了上面的小人可以在练就凌波微步, 它脚下的坑是浏览器的调用栈。</p><p>React 开启 <code>Concurrent Mode</code> 之后就不会挖大坑了，而是一小坑一坑的挖，挖一下休息一下，有紧急任务就优先去做。</p><p><br></p><p><img src="/images/react-fiber/benifit.png" alt><br><i>来源：<a href="https://www.youtube.com/watch?v=V1Ly-8Z1wQA&t=207s" target="_blank" rel="noopener">Flarnie Marchan - Ready for Concurrent Mode?</a></i></p><p><br></p><p>开启 <code>Concurrent Mode</code> 后，我们可以得到以下好处(详见<a href="https://www.youtube.com/watch?v=ByBPyMBTzM0" target="_blank" rel="noopener">Concurrent Rendering in React</a>):</p><ul><li>快速响应用户操作和输入，提升用户交互体验</li><li>让动画更加流畅，通过调度，可以让应用保持高帧率</li><li>利用好I/O 操作空闲期或者CPU空闲期，进行一些预渲染。 比如离屏(offscreen)不可见的内容，优先级最低，可以让 React 等到CPU空闲时才去渲染这部分内容。这和浏览器的preload等预加载技术差不多。</li><li>用<code>Suspense</code> 降低加载状态(load state)的优先级，减少闪屏。 比如数据很快返回时，可以不必显示加载状态，而是直接显示出来，避免闪屏；如果超时没有返回才显式加载状态。</li></ul><p><br></p><p>但是它肯定不是完美的，因为浏览器无法实现抢占式调度，无法阻止开发者做傻事的，开发者可以随心所欲，想挖多大的坑，就挖多大的坑。</p><p>为了共同创造美好的世界，我们要严律于己，该做的优化还需要做: 纯组件、虚表、简化组件、缓存…</p><p>尤雨溪在今年的<a href="https://www.yuque.com/vueconf/2019" target="_blank" rel="noopener">Vue Conf</a>一个观点让我印象深刻：<strong>如果我们可以把更新做得足够快的话，理论上就不需要时间分片了</strong>。</p><p><strong>时间分片并没有降低整体的工作量，该做的还是要做</strong>, 因此React 也在考虑利用CPU空闲或者I/O空闲期间做一些预渲染。所以跟尤雨溪说的一样：React Fiber 本质上是为了解决 React 更新低效率的问题，<strong>不要期望 Fiber 能给你现有应用带来质的提升, 如果性能问题是自己造成的，自己的锅还是得自己背</strong>.</p><p><br><br><br></p><h2 id="站在巨人的肩膀上"><a href="#站在巨人的肩膀上" class="headerlink" title="站在巨人的肩膀上"></a>站在巨人的肩膀上</h2><p><br></p><p>本文之所以能成文，离不开社区上优质的开源项目和资料。</p><p><strong>迷你 Fiber 实现</strong>:</p><p>React 现在的代码库太复杂了! 而且一直在变动和推翻自己，<a href="https://www.zhihu.com/people/he-shi-jun" target="_blank" rel="noopener">Hax</a> 在 <a href="https://www.zhihu.com/question/270428598/answer/354017709" target="_blank" rel="noopener">《为什么社区里那些类 React 库至今没有选择实现 Fiber 架构？》 </a> 就开玩笑说: Fiber 性价比略低… 到了这个阶段，竞品太多，facebook 就搞一个 fiber 来作为护城河……</p><p>这种工程量不是一般团队能Hold住的， 如果你只是想了解 Fiber，去读 React 的源码性价比也很低，不妨看看这些 Mini 版实现, 感受其精髓，不求甚解:</p><ul><li><a href="https://github.com/RubyLouvre/anu" target="_blank" rel="noopener">anu</a> <a href="https://github.com/RubyLouvre" target="_blank" rel="noopener">司徒正美</a> 开发的类React框架</li><li><a href="https://github.com/132yse/fre" target="_blank" rel="noopener">Fre</a> <a href="https://www.zhihu.com/people/132yse" target="_blank" rel="noopener">伊撒尔</a> 开发的类React框架，代码很精简⁉️</li><li><a href="https://github.com/Foveluy/Luy" target="_blank" rel="noopener">Luy</a></li><li><a href="https://github.com/pomber/didact" target="_blank" rel="noopener">didact</a></li></ul><p><br></p><p><strong>优秀的文章 &amp; 演讲</strong></p><p>本文只是对React Fiber进行了简单的科普，实际上React 的实现比本文复杂的多，如果你想深入理解React Fiber的，下面这些文章不容错过:</p><ul><li><a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017 👍🎦</a> React Fiber 启蒙，YouTube</li><li><a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" target="_blank" rel="noopener">Beyond React 16 - Dan Abramov 👍🎦</a></li><li><a href="https://www.youtube.com/watch?v=ByBPyMBTzM0&amp;t=151s" target="_blank" rel="noopener">Concurrent Rendering in React - Andrew Clark and Brian Vaughn 👍🎦</a></li><li><a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener">司徒正美: React Fiber架构 👍</a> 看不如写</li><li><a href="https://www.zhihu.com/people/NE_SmallTown/posts" target="_blank" rel="noopener">展望 React 17，回顾 React 往事 👍</a> 看完 <a href="https://www.zhihu.com/people/NE_SmallTown" target="_blank" rel="noopener">Heaven</a> 的相关文章，会觉得你了解的React 知识真的只是<a href="https://zhuanlan.zhihu.com/jheaven" target="_blank" rel="noopener">冰山一角</a>，我们都没资格说我们懂 React。</li><li><a href="https://zhuanlan.zhihu.com/p/36425839" target="_blank" rel="noopener">浅入 React16/fiber 系列 👍</a> 同样来自 Heaven</li><li><a href="https://www.zhihu.com/search?type=content&amp;q=requestIdleCallback" target="_blank" rel="noopener">淡苍：深入剖析 React Concurrent 👍</a></li><li><a href="https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec" target="_blank" rel="noopener">Didact Fiber: Incremental reconciliation  👍</a> 实现了简单的 React Fiber</li><li><a href="https://zhuanlan.zhihu.com/p/26027085" target="_blank" rel="noopener">程墨: React Fiber是什么</a></li><li><a href="https://zhuanlan.zhihu.com/p/57346388" target="_blank" rel="noopener">译 深入React fiber架构及源码</a></li><li><a href="http://www.ayqy.net/blog/dive-into-react-fiber/" target="_blank" rel="noopener">黯羽轻扬: 完全理解React Fiber</a></li><li><a href="https://github.com/facebook/react/issues/7942" target="_blank" rel="noopener">Fiber Principles: Contributing To Fiber</a></li><li><a href="https://philippspiess.com/scheduling-in-react/" target="_blank" rel="noopener">Scheduling in React</a></li><li><a href="https://juejin.im/post/5d12c907f265da1b6d4033c5" target="_blank" rel="noopener">桃翁: Deep In React 之浅谈 React Fiber 架构（一）</a></li><li><a href="https://juejin.im/post/5b028db26fb9a07ac162ba68#heading-12" target="_blank" rel="noopener">为 Luy 实现 React Fiber 架构</a></li><li><a href="https://juejin.im/post/5ab7b3a2f265da2378403e57" target="_blank" rel="noopener">妖僧风月: React Fiber</a></li><li><a href="https://www.youtube.com/watch?v=V1Ly-8Z1wQA&amp;t=207s" target="_blank" rel="noopener">Flarnie Marchan - Ready for Concurrent Mode? 🎦</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/rendering" target="_blank" rel="noopener">Web Fundamentals &gt; Performance</a></li><li><a href="https://juejin.im/post/5ad71f39f265da239f07e862" target="_blank" rel="noopener">你应该知道的requestIdleCallback</a></li><li><a href="https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering/" target="_blank" rel="noopener">深入探究 eventloop 与浏览器渲染的时序问题</a></li><li><a href="https://nolanlawson.com/2018/09/25/accurately-measuring-layout-on-the-web/" target="_blank" rel="noopener">Accurately measuring layout on the web</a></li></ul><p><br></p><p><strong>自荐React 相关文章</strong></p><p>回顾一下今年写的关于 React 的相关文章</p><p>Concurrent模式预览（推荐）:</p><ul><li><a href="https://juejin.im/post/5db65d87518825648f2ef899#comment" target="_blank" rel="noopener">React Concurrent 模式抢先预览上篇: Suspense the world</a></li><li><a href="https://juejin.im/post/5dbee8e7e51d4558040f0830" target="_blank" rel="noopener">React Concurrent 模式抢先预览下篇: useTransition 的平行世界</a></li></ul><p><br></p><p>往期文章:</p><ul><li><a href="https://juejin.im/post/5cd7f2c4e51d453a7d63b715" target="_blank" rel="noopener">React组件设计实践总结 系列 共5篇</a></li><li><a href="https://juejin.im/post/5d8395646fb9a06ad16faa57" target="_blank" rel="noopener">自己写个React渲染器: 以 Remax 为例(用React写小程序)</a></li><li><a href="https://juejin.im/post/5d44e3745188255d5861d654" target="_blank" rel="noopener">谈谈React事件机制和未来(react-events)</a></li><li><a href="https://juejin.im/post/5d594ea5518825041301bbcb" target="_blank" rel="noopener">2019年了，整理了N个实用案例帮你快速迁移到React Hooks</a></li><li><a href="https://juejin.im/post/5d045350f265da1b695d5bf2" target="_blank" rel="noopener">浅谈React性能优化的方向</a></li><li><a href="https://juejin.im/post/5cfa29e151882539c33e4f5e" target="_blank" rel="noopener">从Preact中了解React组件和hooks基本原理</a></li><li><a href="https://juejin.im/post/5d06bf0a51882528194a9736" target="_blank" rel="noopener">React性能测量和分析</a></li></ul><p><br></p><p>本文讲了 React 如何优化 CPU 问题，React 野心远不在于此, I/O 方向的优化也在实践，例如 Suspend…  还有很多没讲完，后面的文章见！</p><p><br></p><p>问卷调查，你觉得这种文章风格怎样？</p><ul><li>A. 事无巨细，太啰嗦了</li><li>B. 娓娓道来，深入浅出我喜欢</li><li>C. 内容不够深入</li><li>D. 文章篇幅太长，可以拆分</li></ul><p>多选，下方评论，👍点赞走起</p><blockquote><p><strong>改了一个正经一点的网名：_sx_(傻叉) -&gt; 荒山 ⛰</strong></p></blockquote><p><br></p><p><img src="/images/sponsor.jpg" alt></p><p><br></p></brk>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写一篇关于 React Fiber 的文章， 这个 Flag 立了很久，这也是今年的目标之一. 最近的在掘金的文章获得很多关注和鼓励，给了我很多动力，所以下定决心好好把它写出来。 我会以最通俗的方式将它讲透, 因此这算是一篇科普式的文章。不管你是使用React、还是Vue，
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
</feed>
