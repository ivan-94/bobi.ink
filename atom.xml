<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bobi.ink</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bobi.ink/"/>
  <updated>2023-06-21T10:28:32.450Z</updated>
  <id>https://bobi.ink/</id>
  
  <author>
    <name>Ivan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序员的快乐与苦恼</title>
    <link href="https://bobi.ink/2023/06/21/happiness/"/>
    <id>https://bobi.ink/2023/06/21/happiness/</id>
    <published>2023-06-20T16:00:00.000Z</published>
    <updated>2023-06-21T10:28:32.450Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/happiness/Untitled.jpeg" alt="Universe"></p><blockquote><p>“<strong>我们朝九晚五上班下班，就是为了有朝一日去探索宇宙的</strong>”<br>    —— 宇宙探索编辑部</p></blockquote><p>随着大环境的下行，互联网行业也受到一定的冲击，哀鸿遍野。</p><p>笔者也没有幸免，培养起来的人马陆续被优化，留下一丢光杆司令，我也回到的业务一线，心里很不是滋味。留下来的人，也不知道这艘船什么时候会沉没… 为了活命而拼命挣扎（内卷）</p><p>负面情绪和焦虑不停侵扰，以至于怀疑，当初选的这条路是不是正确的。</p><p>捡起买了多年，但是一直没看的<code>《人月神话》</code>,  开篇就讲了程序员这个职业的乐趣和苦恼，颇有共鸣，所以拿出来给大家分享</p><p>不管过去多少年，不管你的程序载体是纸带、还是 JavaScript，不管程序跑在高对比(high contract)的终端、还是 iPhone，程序员的快乐和烦恼并没有变化。</p><p>尽管国内软件行业看起来不是那么健康。我相信很多人真正热爱的是编程，而不仅仅是一份工作，就是那种纯粹的热爱。你有没有：</p><ul><li>为了修改一个 Bug，茶饭不思</li><li>为了一个 idea，可以凌晨爬起来，决战到天亮</li><li>我们享受没有人打扰的午后</li><li>梦想着参与到一个伟大的开源项目</li><li>有强烈的分享欲，希望我们的作品可以帮助到更多人, 希望能得到用户的反馈，即使是一个点赞</li><li>…</li></ul><p><br><br><br></p><h2 id="我们的快乐"><a href="#我们的快乐" class="headerlink" title="我们的快乐"></a>我们的快乐</h2><blockquote><p>《人月神话》：</p><p>首先，<strong>这种快乐是一种创建事物的纯粹快乐</strong>。如同小孩在玩泥巴时感到快乐一样，成年人喜欢创建事物，特别是自己进行设计。我想这种快乐是上帝创造世界的折射，一种呈现在每片独特的、崭新的树叶和雪花上的喜悦。<br><br><br>其次，<strong>这种快乐来自于开发对他人有用的东西</strong>。内心深处，我们期望我们的劳动成果能够被他人使用，并能对他们有所帮助。从这一角度而言，这同小孩用粘士为“爸爸的办公室”捏制铅笔盒没有任何本质的区别。<br><br><br>第三，<strong>快乐来自于整个过程体现出的一股强大的魅力——将相互啮合的零部件组装在一起，看到它们以精妙的方式运行着，并收到了预期的效果。</strong>比起弹球游戏机或自动电唱机所具有的迷人魅力，程序化的计算机毫不逊色。<br><br><br>第四，<strong>这种快乐是持续学习的快乐，它来自于这项工作的非重复特性</strong>。人们所面临的问题总有这样那样的不同，因而解决问题的人可以从中学习新的事物，有时是实践上的，有时是理论上的，或者兼而有之。<br><br><br>最后，<strong>这种快乐还来自于在易于驾驭的介质上工作</strong>。程序员，就像诗人一样，几乎仅仅在单纯的思考中工作。程序员凭空地运用自己的想象，来建造自己的“城堡”。很少有创造介质如此灵活，如此易于精炼和重建，如此容易实现概念上的设想(不过我们将会看到，容易驾驭的特性也有它自己的问题)。<br><br><br>然而程序毕竞同诗歌不同，它是实实在在的东西;它可以移动和运行，能独立产生可见的输出;它能打印结果，绘制图形，发出声音，移动支架。神话和传说中的魔术在我们的时代已变成现实。在键盘上键入正确的咒语，屏幕会活动、变幻，显示出前所未有的也不可能存在的事物。</p></blockquote><p><br></p><p>编程就是一种纯粹创造的快乐，而且它的成本很低，我们只需要一台电脑，一个趁手的编辑器，一段不被人打扰的整块时间，然后进入心流状态，脑海中的想法转换成屏幕上闪烁的字符。<br>这是多巴胺带给我们的快乐。</p><p><img src="/images/happiness/Untitled.png" alt="飞机引擎"></p><p><br><br><br></p><p>我们也有「<code>机械崇拜</code>」，软件不亚于传统的机械的复杂构造。 它远比外界想象的要复杂和苛刻，而我们享受将无数零部件有机组合起来，点击——成功运行的快感。</p><p>我们享受复杂的问题，被抽象、拆解成一个个简单的问题， 认真描绘分层的弧线以及每个模块轮廓，谨慎设计它的每个锯齿和接口。</p><p>我们崇尚有序，赞赏清晰的边界， 为的就是我们创造的世界能够稳定发展。</p><p><br></p><p>我们认为懒惰是我们的优点，我们也崇拜自动化，享受我们数据通过我们建设的管道在不同模块、系统或者机器中传递和加工；享受程序像多米诺骨牌一样，自动构建、测试、发布、部署、分发到每个用户的手中，优雅地跑起来。</p><p>因为懒，我们时常追求创造出能够取代自己的工具，让我们能腾出时间在新的世界探索。比如可以制造出我们的 <a href="https://baike.baidu.com/item/MOSS/23288071?fr=aladdin" target="_blank" rel="noopener">Moss</a>，帮我们治理让每个程序的生命周期，让它们优雅地死去又重生。</p><p><br></p><p>我们是一群乐于分享和学习的群体，有繁荣的技术社区、各种技术大会、技术群…</p><p>不管是分享还是编程本身，其实都是希望我们的作品能被其他人用到，能产生价值：</p><ul><li>我们都有开源梦，多少人梦想着能参与那些广为人知开源项目。很少有哪个行业，有这么一群人,  能够自我组织，用爱发电、完全透明地做出一个个伟大的作品。</li><li>我们总会怀揣着乐观的设想，基于这种设想，我们会趋向打造更完美的作品，想象未来各种高并发、极端的场景，我们的程序能够游刃有余。</li><li>我们总是不满足于现有的东西，乐于不停地改进，造出更多的轮子，甚至不惜代价推翻重来</li><li>我们更会懊恼，自己投入大量精力的项目，无人问津，甚至胎死腹中。</li></ul><p><br></p><p>看着它们，从简单到繁杂，这是一种迭代的快乐。</p><p><br><br><br><br><br></p><h2 id="我们的苦恼"><a href="#我们的苦恼" class="headerlink" title="我们的苦恼"></a>我们的苦恼</h2><blockquote><p>《人月神话》<br>然而这个过程并不全都是快乐的。我们只有事先了解一些编程固有的苦恼，这样，当它们真的出现时，才能更加坦然地面对。<br><br><br>首先，<strong>苦恼来自追求完美</strong>。因为计算机是以这样的方式来变戏法的: 如果咒语中的一个字符、一个停顿，没有与正确的形式一致，魔术就不会出现(现实中，很少有人类活动会要求如此完美，所以人类对它本来就不习惯)。实际上，我认为，学习编程最困难的部分，是将做事的方式向追求完美的方向调整”。</p><p><br><br>其次，<strong>苦恼来自由他人来设定目标、供给资源和提供信息</strong>。编程人员很少能控制工作环境和工作目标。用管理的术语来说，个人的权威和他所承担的责任是不相配的。不过，似乎在所有的领域中，对要完成的工作，很少能提供与责任相一致的正式权威。而现实情况中，实际(相对于形式)的权威来自于每次任务的完成。</p><p><strong>对于系统编程人员而言，对其他人的依赖是一件非常痛苦的事情</strong>。他依靠其他人的程序，而这些程序往往设计得并不合理、实现拙劣、发布不完整(没有源代码或测试用例)或者文档记录得很糟。所以，系统编程人员不得不花费时间去研究和修改，而它们在理想情况下本应该是可拿的、完整的。</p><p><br><br>下一个苦恼 —— <strong>概念性设计是有趣的，但寻找琐碎的bug却是一项重复性的活动</strong>。伴随着创造性活动的，往往是枯燥沉闷的时间和艰苦的劳动。程序编制工作也不例外。</p><p><br><br>另<strong>外，人们发现调试和查错往往是线性收敛的，或者更糟糕的是，具有二次方的复杂度</strong>。结果，测试一拖再拖，寻找最后一个错误比第一个错误将花费更多的时间。</p><p><br><br>最后一个苦恼，有时也是一种无奈 —— <strong>当投入了大量辛苦的劳动，产品在即将完成或者终于完成的时候，却己显得陈旧过时</strong>。可能是同事和竞争对手己在追逐新的、更好的构思;也许替代方案不仅仅是在构思，而且己经在安排了。<br><br></p></blockquote><p>前阵子读到了 @<a href="https://www.zhihu.com/people/doodlewind" target="_blank" rel="noopener">doodlewind</a> 的 <a href="https://zhuanlan.zhihu.com/p/595759878" target="_blank" rel="noopener">全职开源，出海创业：我的 2022</a>，说的是他 all in 去做 AFFiNE 。我眼里只有羡慕啊，能够找到 all in 的事业…</p><p><br><br><br></p><p>这些年 OKR 也很火，我们公司也跟风了一年; 后面又回到了 KPI，轰轰烈烈搞全员KPI, 抓着每个人,  要定自己的全年KPI;  后年裁员，KPI 就不再提起了…</p><p>这三个阶段的演变很有意思，第一个阶段，期望通过 OKR 上下打通，将目标捆在一起，让团队自己驱动自己。实际上实施起来很难，让团队和个人自我驱动起来并不是一件容易的事情，虽然用的是 OKR，但内核还是 KPI，或者说 OKR 变成了领导的 OKR。<br>后面就变成了 KPI, 限定团队要承担多少销售额，交付多少项目；<br>再后来 KPI 都没有了，换成要求每个人设定自己工作日历，不能空转，哪里项目缺资源，就调配到哪里，彻底沦为了人矿…</p><p>能让我们 all in 的事情，首先得是我们认同的事情，其次我们能在这件事情上深度参与和发挥价值，并获得预期的回报。这才能实现「自我驱动」</p><p>对于大部分人来说，很少有这种工作机会，唯一值得 all in的，恐怕就只有自己了。</p><p><br><br><br></p><p>所以程序员的苦恼很多，虽然编程是一个创造性的工作，但是我们的工作是由其他人来设定目标和提供资源的。</p><p>也就是说我们只不过是困在敏捷循环里面的一颗螺丝钉，每天在早会上机械复读着：昨天干了什么，今天要干什么。<br>企业总会想法设法量化我们的工作，最好是像流水线一样透明、可预测。</p><p><br></p><p>培训机构四个月就能将高中生打造成可以上岗敲代码的程序员。我们这个行业已经不存在我们想象中高门槛。程序员可能就是新时代的蓝领工人，如果我们的工作是重复的、可预见的，那本质上就没什么区别了。</p><hr><p><br></p><p>追求完美是好事，也是坏事。苛刻的编译器会提高开发的门槛，但同样可以降低我们犯错的概率。</p><p>计算机几乎不会犯错的，只是我们不懂它，而人经常会犯错。相比苛刻的计算机，人更加可怕：</p><ul><li>应付领导或产品拍脑袋的需求</li><li>接手屎山代码</li><li>浪费时间的会议</li><li>狼性文化</li><li>…</li></ul><p><br><br><br></p><hr><p><br></p><p>还有一个苦恼是技术的发展实在太快了，时尚的项目生命周期太短，而程序员又是一群喜新厌旧的群体。</p><p>比如在前端，可能两三年前的项目就可以被定义为”老古董”了，上下文切换到这种项目会比较痛苦。不幸的是，这些老古董可能会因为某些程序员的偏见，出现破窗效应，慢慢沦为屎山。</p><p>我们虽然苦恼于项目的腐败，而大多数情况我们也是推手。</p><p><br></p><p>我们还有很多苦恼：</p><ul><li>35 岁危机，继续做技术还是转管理</li><li>面试的八股文</li><li>内卷</li><li>被 AI 取代</li><li>…</li></ul><p><br><br><br></p><p>对于读者来说，是快乐多一些呢？还是苦恼多一些呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/happiness/Untitled.jpeg&quot; alt=&quot;Universe&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“&lt;strong&gt;我们朝九晚五上班下班，就是为了有朝一日去探索宇宙的&lt;/strong&gt;”&lt;br&gt;    —— 宇宙探
      
    
    </summary>
    
      <category term="程序人生" scheme="https://bobi.ink/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>前端如何破解 CRUD 的循环</title>
    <link href="https://bobi.ink/2023/06/16/crud/"/>
    <id>https://bobi.ink/2023/06/16/crud/</id>
    <published>2023-06-15T16:00:00.000Z</published>
    <updated>2023-06-16T02:05:00.408Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/crud/Untitled.jpeg" alt="Untitled"></p><p>据说，西西弗斯是一个非常聪明的国王，但他也非常自负和狂妄。他甚至敢欺骗神灵，并把死者带回人间。为此，他被宙斯（Zeus）惩罚，被迫每天推着一块巨石上山，但在接近山顶时，巨石总是会滚落下来，他不得不重新开始推石头，永远困在这个循环中…</p><p>很多开发工作也如此单调而乏味，比如今天要讲的中后台开发的场景。中后台业务基本上就是一些数据的增删改查、图表，技术含量不高，比较容易范式化。</p><p>前端如何破除 CRUD 的单调循环呢？</p><p><br><br><br><br><br></p><h2 id="低代码"><a href="#低代码" class="headerlink" title="低代码"></a>低代码</h2><p>过去几年前端的低代码很火，这些<code>低代码平台</code>通常支持创建<code>数据模型</code>后，一键生成对应的增删改查页面：</p><p><br></p><p><img src="/images/crud/Untitled.png" alt="Untitled"></p><p><br></p><aside><br>💡 本文提及的低代码是<code>狭义</code>的<code>低代码</code>，你可以认为就是<code>可视化搭建平台</code>。<br><br></aside><p><br></p><p>低代码在过去几年就是 「雷声大，雨点小」，跟现在的 AI 颇为相似。</p><p>不管是大厂还是小厂都在搞低代码，包括笔者也参与过几个低代码项目，但是小厂支撑不起来这样的资源投入，最后都胎死腹中。我相信很多读者也经历过这种情况。<br>大部分公司只是尾随市场营销噱头，盲目跟风，压根就没有做这种低代码平台资源准备和沉淀。</p><p>作为前端，能参与到低代码项目的开发是一件非常兴奋的事情，毕竟是少数前端能主导的项目，架构、组件设计、编辑器的实现可玩性很高，可以跟同行吹很久。</p><p>作为用户(开发者)呢？可能会<a href="https://www.zhihu.com/question/561025857" target="_blank" rel="noopener">排斥和质疑</a>，不管怎么说，它并没有发挥市场所期望的价值。</p><p><br></p><p>最主要的原因是：<strong>它解决不了复杂的问题</strong>。</p><p><br></p><p>低代码直观、门槛低， 前期开发确实很爽，可视化数据建模、拖拉拽生成页面、流程编排，很快就可以把一些简单的业务开发出来。</p><p>然而软件编码本身占用研发流程的比例，据 <code>ChatGPT</code> 估算大约只有 20% ~ 30%。而且业务持续变化，代码也需要持续迭代。试想一下如何在这些低代码平台上进行重构和检索？</p><p><br><br><br></p><p>总的来说，有一些缺点：</p><ul><li><p><strong>复杂的业务逻辑用低代码可能会更加复杂。</strong>低代码应该是特定领域问题的简化和抽象，如果只是单纯将原有的编码工作转换为 GUI 的模式，并没有多大意义。</p><p>  例如流程编排，若要用它从零搭建一个复杂的流程，如果照搬<code>技术语言</code>去表达它，那有可能是个地狱：</p><p>  <img src="/images/crud/Untitled%201.png" alt="Untitled"></p><p>  理想的<strong>流程编排的节点应该是抽象程度更高的、内聚的<code>业务节点</code>，来表达<code>业务流程</code>的流转。然而</strong>这些节点的设计和开发其实是一件非常有挑战性的事情。</p></li><li><p><strong>软件工程是持续演进的，在可维护性方面，目前市面上的低代码平台并不能提供可靠的辅助和验证。</strong>因此企业很难将核心的稳态业务交给这些平台。</p></li><li>还有很多… 平台锁定，缺乏标准，性能问题、复用、扩展性、安全问题、黑盒，可迁移性，研发成本高，可预测性/可调试性差，高可用，版本管理，不能自动化…</li></ul><p><br><br><br></p><p>当然，低代码有低代码的适用场景，比如解决特定领域问题(营销活动页面，海报，数据大屏，表单引擎、商城装修、主页)，POC 验证。<strong>即一些临时的/非核心的敏态业务</strong>。</p><aside><br>💡 目前有些低代码平台也有「出码能力」，让二开有了一定的可行性。<br><br></aside><aside><br>💡 AI 增强后的低代码可能会更加强大。但笔者依旧保持观望的态度，毕竟准确地描述软件需求，本身就是就是软件研发的难题之一，不然我们也不需要 DDD中的各种方法论，开各种拉通会，或许也不需要需求分析师，产品…<br><br>非专业用户直接描述需求来产出软件，大多是不切实际的臆想<br></aside><p><br><br><br><br><br></p><h2 id="中间形态"><a href="#中间形态" class="headerlink" title="中间形态"></a>中间形态</h2><p>有没有介于可视化低代码平台和专业代码之间的中间形态？既能保持像低代码平台易用性，同时维持代码的灵活性和可维护性。</p><p>我想那就是 DSL(<code>domain-specific language</code>) 吧? <strong>DSL 背后体现的是对特定领域问题的抽象，其形式和语法倒是次要的。</strong></p><aside><br>💡 DSL 的形式有很多，可以创建一门新的微语言(比如 SQL, GraphQL)；可以是一个 JSON 或者 YAML 形式；也可以基于一门现有的<code>元语言</code>(比如 Ruby、Groovy，Rust…)来创建，这些元语言，提供的元编程能力，可以简洁优雅地表达领域问题，同时能够复用<code>元语言</code> 本身的语言能力和基础设施。<br><br></aside><p><strong>严格上可视化低代码平台也是一种‘可视化’ 的 DSL，笔者认为它的局限性更多还是来源‘可视化’，相对的，它优点也大多来源’可视化‘</strong>。</p><blockquote><p>这又牵扯到了持续了半个多世纪的： GUI vs CLI（程序化/文本化） 之争。这个在《UNIX 编程艺术》中有深入的探讨。命令行和命令语言比起可视化接口来说，更具表达力，尤其是针对复杂的任务。另外命令行接口具有高度脚本化的能力。缺点就是需要费劲地记忆，易用性差，透明度低。当问题规模变大、程序的行为日趋单一、过程化和重复时， CLI 也常能发挥作用。<br><br><br>如果按照<code>友好度</code>和问题域的<code>复杂度/规模</code>两个维度来划分，可以拉出以下曲线：<br><br><br><img src="/images/crud/Untitled%202.png" alt="Untitled"></p><p>中间会出现一个交叉点，在这个交叉点之后，命令行的简要行和表达力变得要比避免记忆负担更有价值。</p><p>《反 Mac 接口》一书中也进行了总结：可视化接口在处理小数量物体简单行为的情况下，工作的很好，但是当行为或物体的数量增加是，直接操作很快就编程机械重复的苦差…</p></blockquote><p><strong>也就是说，DSL 的形式会约束 DSL 本身的表达能力。</strong></p><p><br></p><p>正如前文说的，如果‘低代码’仅仅是将原本的编码工作转换为 GUI 形式，其实并没有多大意义，因为没有抽象。</p><p>反例：</p><p><img src="/images/crud/Untitled%203.png" alt="JSON GUI vs  JSON"></p><p>JSON GUI vs JSON</p><p><br><br><br></p><p>正例： VSCode 案例</p><p><img src="/images/crud/Untitled%204.png" alt="Untitled"></p><p><img src="/images/crud/Untitled%205.png" alt="Untitled"></p><p>充分利用 GUI 的优势，提供更好的目录组织、文本提示、数据录入的约束和校验。</p><p><br><br><br></p><p>我们可能会说 GUI 形式用户体验更好，门槛低更低，不用关心底层的细节。<strong>其实并不一定是 GUI 带来的，而是抽象后的结果。GUI 只不过是一种接口形式</strong>。</p><p><br></p><p>回到正题，为了摆脱管理后台 CRUD 的 「西西弗斯之石」： 我们可以创建一个 DSL，这个 DSL 抽象了管理端的各种场景，将繁琐的实现细节、重复的工作封装起来，暴露简洁而优雅的用户接口(User Interface)。</p><aside><br>💡 小结。DSL 是可视化低代码与 pro code 之间的中间中间形态，权衡了易用性/灵活性和实现成本。DSL 的形式会直接影响它的表达能力，但比形式更重要的是 DSL 对特定问题域的抽象。<br><br>我们不必重新发明一门语言，而是复用元语言的能力和生态，这基本上是零成本。<br></aside><p><br><br><br><br><br><br><br></p><h2 id="抽象过程"><a href="#抽象过程" class="headerlink" title="抽象过程"></a>抽象过程</h2><p>典型的增删改查页面：</p><p><img src="/images/crud/Untitled%206.png" alt="Untitled"></p><p>分析过程：</p><ol><li>后端增删改查主要由两大组件组成: <code>表单</code>和<code>表格</code>。</li><li>而表单和表格又由更原子的’<code>字段</code>’组成。字段的类型决定了存储类型、录入方式、和展示方式</li><li>字段有两种形态：<code>编辑态</code>和<code>预览态</code>。表格列、详情页通常是预览态，而表单和表格筛选则使用编辑态。</li></ol><p><br></p><p><img src="/images/crud/Untitled%207.png" alt="Untitled"></p><p>借鉴低代码平台的<code>组件库</code>/<code>节点库</code>，我们可以将这些‘字段’ 提取出来， 作为表单和表格的‘原子’单位， 这里我们给它取个名字，就叫<code>原件</code>(<code>Atomic</code>)吧。</p><p><img src="/images/crud/Untitled%208.png" alt="Untitled"></p><p><code>原件</code>将取代组件库里面的<code>表单组件</code>，作为我们 <code>CRUD</code> 页面的<strong>最小组成单位</strong>。它有且只有职责：</p><p><img src="/images/crud/Untitled%209.png" alt="Untitled"></p><ul><li>数据类型和校验。原件代表的是一种数据类型，可以是<code>基础类型</code>，比如数字、字符串、布尔值、枚举；也可以是基础类型上加了一些约束和交互，比如邮件、手机号码、链接；甚至可能有<code>业务属性</code>，比如用户，商品，订单，二维码。</li><li>数据的预览。</li><li>数据的录入，严格约束为 <code>value</code>/<code>onChange</code> 协议。好处是方便进行状态管理，可能保证原件实现的统一性。</li></ul><p><br><br><br></p><p>接着组合原件来实现表单和表格组件，满足 CRUD 场景：</p><p><img src="/images/crud/Untitled%2010.png" alt="Untitled"></p><p>理想状态下，我们仅需声明式地指定表格的列和原件类型，其余的技术细节应该隐藏起来。表格伪代码示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建包含 名称、创建时间、状态三列的表格，其中可以搜索名称和创建时间</span></span><br><span class="line">Table(</span><br><span class="line">  columns(</span><br><span class="line">    column(名称，name, queryable=<span class="literal">true</span>)</span><br><span class="line">    column(创建时间, created, data-range, queryable=<span class="literal">true</span>)</span><br><span class="line">    column(状态, status, select, options=[&#123;label: 启用，value: 1, &#123;label: 禁用， value: 0&#125;&#125;])</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br></p><p>表单伪代码示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建包含 名称、状态、地址的表单</span></span><br><span class="line">Form(</span><br><span class="line">  item(名称，name, required=<span class="literal">true</span>)</span><br><span class="line">  item(状态，status, select, options=[&#123;label: 启用，value: 1, &#123;label: 禁用， value: 0&#125;&#125;])</span><br><span class="line">  item(地址, address, address)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br></p><p>如上所示，本质上，开发者就应该只关注业务数据本身，而应该忽略掉前端技术实现的噪音(比如状态管理、展示风格、分页、异常处理等等)。</p><p><br><br><br></p><p>表格和表单为了适应不同的需求，还会衍生出不同的展现形式：</p><p><img src="/images/crud/Untitled%2011.png" alt="Untitled"></p><p><code>原件</code> + <code>核心的表单/表格能力</code> + <code>场景/展示形式</code>，一套「组合拳」下来，基本就可以满足常见的后台 CRUD 需求了。</p><p><br><br><br><br><br></p><h2 id="约定大于配置"><a href="#约定大于配置" class="headerlink" title="约定大于配置"></a>约定大于配置</h2><p>前端的在研发流程中相对下游，如果上游的产品定义，UI 设计，后端协议没有保持一致性，就会苦于应付各种混乱的差异，复用性将无从谈起。</p><p>为了最小化样板代码和沟通成本，实现开箱即用的效果。我们最好拉通上下游，将相关的规范确定下来，前端开发者应该扮演好串联的角色。</p><p><br></p><p>这些规范包含但不限于：</p><ul><li>页面的布局</li><li>UI 风格</li><li>提示语</li><li>验证规则</li><li>数据的存储格式</li><li>通用的接口(比如文件上传，导入导出)</li><li>…</li></ul><p><img src="/images/crud/Untitled%2012.png" alt="Untitled"></p><p>组件库可以内置这些约定，或者提供全局的配置方式。这些规范固化后，我们就享受开箱即用的快感了。</p><p><br><br><br><br><br></p><h2 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h2><p>基于上述思想，我们开发了一套<a href="https://wakeadmin.wakedata.com/components-doc/" target="_blank" rel="noopener">组件库</a>(基于 Vue 和 element-ui)，配合一套简洁的 DSL，来快速开发 CRUD 页面。</p><p><br></p><aside><br>💡 <strong><em>这套组件库耦合了我们自己的约定</em></strong>。因此可能不适用于外部通用的场景。本文的意义更多是想启发读者，去构建适合自己的一套解决方案。<br><br></aside><p><strong>列表页定义：</strong></p><p><img src="/images/crud/Untitled%2013.png" alt="Untitled"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; defineFatTable &#125; from &apos;@wakeadmin/components&apos;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 表格项类型</span><br><span class="line"> */</span><br><span class="line">export interface Item &#123;</span><br><span class="line">  id: number</span><br><span class="line">  name: string</span><br><span class="line">  createDate: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const MyTable = defineFatTable&lt;Item&gt;((&#123; column &#125;) =&gt; &#123;</span><br><span class="line">  // 可以在这里放置 Vue hooks</span><br><span class="line">  return () =&gt; (&#123;</span><br><span class="line">    async request(params) &#123;</span><br><span class="line">      /* 数据获取，自动处理异常和加载状态 */</span><br><span class="line">    &#125;,</span><br><span class="line">    // 删除操作</span><br><span class="line">    async remove(list, ids) &#123;</span><br><span class="line">      /*列删除*/</span><br><span class="line">    &#125;,</span><br><span class="line">    // 表格列</span><br><span class="line">    columns: [</span><br><span class="line">      // queryable 标记为查询字段</span><br><span class="line">      column(&#123; prop: &apos;name&apos;, label: &apos;名称&apos;, queryable: true &#125;),</span><br><span class="line">      column(&#123; prop: &apos;createDate&apos;, valueType: &apos;date-range&apos;, label: &apos;创建时间&apos;, queryable: true &#125;),</span><br><span class="line">      column(&#123;</span><br><span class="line">        type: &apos;actions&apos;,</span><br><span class="line">        label: &apos;操作&apos;,</span><br><span class="line">        actions: [&#123; name: &apos;编辑&apos; &#125;, &#123; name: &apos;删除&apos;, onClick: (table, row) =&gt; table.remove(row) &#125;],</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>语法类似于 Vue defineComponent，传入一个’setup’, 。这个 setup 中可以放置一些逻辑和状态或者 Vue hooks，就和 Vue defineComponent 定义一样灵活。</p><p>返回关于表格结构的”声明”。最优的情况下，开发者只需要定义表格结构和后端接口，其余的交由组件库处理。</p><p>当然复杂的定制场景也能满足，这里可以使用 JSX，监听事件，传递组件支持的任意 props 和 slots。</p><p><br><br><br></p><p><strong>表单页示例:</strong></p><p><img src="/images/crud/Untitled%2014.png" alt="Untitled"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; defineFatForm &#125; from &apos;@wakeadmin/components&apos;</span><br><span class="line">import &#123; ElMessageBox &#125; from &apos;element-plus&apos;</span><br><span class="line"></span><br><span class="line">export default defineFatForm&lt;&#123;</span><br><span class="line">  // 🔴 这里的泛型变量可以定义表单数据结构</span><br><span class="line">  name: string</span><br><span class="line">  nickName: string</span><br><span class="line">&#125;&gt;((&#123; item, form, consumer, group &#125;) =&gt; &#123;</span><br><span class="line">  // 🔴 这里可以放置 Vue Hooks</span><br><span class="line"></span><br><span class="line">  // 返回表单定义</span><br><span class="line">  return () =&gt; (&#123;</span><br><span class="line">    // FatForm props 定义</span><br><span class="line">    initialValue: &#123;</span><br><span class="line">      name: &apos;ivan&apos;,</span><br><span class="line">      nickName: &apos;狗蛋&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    submit: async (values) =&gt; &#123;</span><br><span class="line">      await ElMessageBox.confirm(&apos;确认保存&apos;)</span><br><span class="line">      console.log(&apos;保存成功&apos;, values)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // 🔴 子节点</span><br><span class="line">    children: [</span><br><span class="line">      item(&#123; prop: &apos;name&apos;, label: &apos;账号名&apos; &#125;),</span><br><span class="line">      item(&#123;</span><br><span class="line">        prop: &apos;nickName&apos;,</span><br><span class="line">        label: &apos;昵称&apos;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><aside><br>💡 和 tailwind 配合食用更香。我们假设整体的页面是符合UI规范的，细微的调整使用 tw 会很方便<br><br></aside><p><br><br><br></p><p><strong>全局配置：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; provideFatConfigurable &#125; from &apos;@wakeadmin/components&apos;</span><br><span class="line">import &#123; Message &#125; from &apos;element-ui&apos;</span><br><span class="line"></span><br><span class="line">export function injectFatConfigurations() &#123;</span><br><span class="line">  provideFatConfigurable(&#123;</span><br><span class="line">    // ...</span><br><span class="line">    // 统一处理 images 原件上传</span><br><span class="line">    aImagesProps: &#123;</span><br><span class="line">      action: &apos;/upload&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    // 统一 date-range 原件属性</span><br><span class="line">    aDateRangeProps: &#123;</span><br><span class="line">      rangeSeparator: &apos;至&apos;,</span><br><span class="line">      startPlaceholder: &apos;开始日期&apos;,</span><br><span class="line">      endPlaceholder: &apos;结束日期&apos;,</span><br><span class="line">      valueFormat: &apos;yyyy-MM-dd&apos;,</span><br><span class="line">      shortcuts: [</span><br><span class="line">        &#123;</span><br><span class="line">          text: &apos;最近一周&apos;,</span><br><span class="line">          onClick(picker: any) &#123;</span><br><span class="line">            picker.$emit(&apos;pick&apos;, getTime(7))</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          text: &apos;最近一个月&apos;,</span><br><span class="line">          onClick(picker: any) &#123;</span><br><span class="line">            picker.$emit(&apos;pick&apos;, getTime(30))</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          text: &apos;最近三个月&apos;,</span><br><span class="line">          onClick(picker: any) &#123;</span><br><span class="line">            picker.$emit(&apos;pick&apos;, getTime(90))</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>更多示例和深入讲解见<a href="https://wakeadmin.wakedata.com/components-doc/" target="_blank" rel="noopener">这里</a>。</p><p><br><br><br><br><br></p><h2 id="更多实现"><a href="#更多实现" class="headerlink" title="更多实现"></a>更多实现</h2><p>前端社区有很多类似的产品，比如：</p><ul><li><a href="https://xrender.fun/" target="_blank" rel="noopener">XRender</a>。中后台「表单/表格/图表」开箱即用解决方案</li><li><a href="https://procomponents.ant.design/docs/intro" target="_blank" rel="noopener">Antd ProComponents</a>。ProComponents 是基于 Ant Design 而开发的模板组件，提供了更高级别的抽象支持，开箱即用。可以显著的提升制作 CRUD 页面的效率，更加专注于页面</li><li><a href="https://github.com/baidu/amis" target="_blank" rel="noopener">百度 Amis</a> 。 用 JSON 作为 DSL，来描述界面</li></ul><p>读者不妨多参考参考。</p><p><br><br><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单来说，我们就是从提供「<strong>毛坯房</strong>」升级到了「<strong>精装房</strong>」，精装房的设计基于我们对市场需求的充分调研和预判。目的是对于 80% 的用户场景，可以实现拎包入住，当然也允许用户在约束的范围内改装。</p><p>本文主要阐述的观点：</p><ul><li>低代码平台的高效和易用大多来源于抽象，而不一定是 GUI，GUI ≠ 低代码。</li><li>摆脱「西西弗斯之石」 考验的是开发者的抽象能力，识别代码中固化/重复的逻辑。将模式提取出来，同时封装掉底层的实现细节。最终的目的是让开发者将注意力关注到业务本身，而不是技术实现细节。</li><li>用声明式、精简、高度抽象 DSL 描述业务 。DSL 的形式会约束他的表达能力，我们并不一定要创建一门新的语言，最简单的是复用元语言的生态和能力。</li><li>约定大于配置。设计风格、交互流程、数据存储等保持一致性，才能保证抽象收益的最大化。因此规范很重要。这需要我们和设计、产品、后端深入沟通，达成一致。</li><li>沉淀原件。低代码平台的效率取决于平台提供的组件能力、数量和粒度。比如前端的组件库，亦或者流程引擎的节点，都属于原件的范畴。</li><li>要求不要太高，这并不是一个万精油方案，我们期望能满足 80% 常见的场景，这已经是一个很好的成绩。至于那 20% 的个性需求，还是从毛坯房搞起吧。</li></ul><p><br><br><br><br><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://github.com/ascoders/weekly/issues/319" target="_blank" rel="noopener">精读《低代码逻辑编排》</a></li><li>UNIX 编程艺术</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/crud/Untitled.jpeg&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;据说，西西弗斯是一个非常聪明的国王，但他也非常自负和狂妄。他甚至敢欺骗神灵，并把死者带回人间。为此，他被宙斯（Zeus）惩罚，被迫每天推着一块巨石上山，
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>如何实现支持跨 Vue 2/3 的组件库</title>
    <link href="https://bobi.ink/2023/06/11/component-for-vue2-3/"/>
    <id>https://bobi.ink/2023/06/11/component-for-vue2-3/</id>
    <published>2023-06-10T16:00:00.000Z</published>
    <updated>2023-06-11T14:21:51.353Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><p><img src="/images/component-for-vue2-3/Untitled.jpeg" alt="Untitled"></p><p>Vue 3 已经<a href="https://vue-js.com/topic/5f65624c96b2cb0032c38550" target="_blank" rel="noopener">发布</a>三年，我们有较多项目还停留在 Vue 2。Vue 3 的升级是比较割裂的。</p><p>我们主要做的是 <code>2B</code> 业务，项目、模块、分支都非常多，升级的成本和风险都比较高。</p><p>我们目前的策略是 “新旧并存，渐进式升级”， 旧的项目就尽量不变了，新的项目强制使用新的技术栈。利用<code>微前端</code>架构，新旧应用可以灵活地组合起来。</p><p>因此我们的业务组件库、工具库之类需要考虑兼容旧的 Vue 2 项目。这篇文章，就向大家展示我们开发跨版本组件库，其中的决策和实现过程。</p><p><br><br><br></p><h2 id="方案决策"><a href="#方案决策" class="headerlink" title="方案决策"></a>方案决策</h2><p>实现跨版本的组件都多种方案，下面列举分析几种主要方案：</p><p><br></p><p><strong>方案一：使用 Vue SFC / 模板</strong></p><p>单纯从外观上看 Vue 2 / 3 在模板的语法上<a href="https://v3-migration.vuejs.org/zh/breaking-changes/v-model.html" target="_blank" rel="noopener">差别并不大</a>。在 <a href="https://blog.vuejs.org/posts/vue-2-7-naruto" target="_blank" rel="noopener">Vue 2.7</a> 开始内置了对 <code>script setup</code> 也有了较好的支持。</p><p>理论上，我们可以编写一份代码，然后分别针对 2 / 3 编译两份输出。</p><p><img src="/images/component-for-vue2-3/Untitled.png" alt="总体流程如上"></p><p>总体流程如上</p><p><strong>笔者提供了一个简单的 DEMO 来验证了这个方案的可行性，详见<a href="https://github.com/wakeadmin/cvv-sfc-demo" target="_blank" rel="noopener">这里</a>。</strong></p><ul><li>优点<ul><li>模板是 Vue 的第一公民，不需要为了兼容不同版本改变原有的开发习惯。学习成本比较低</li><li>支持静态编译，比如可以针对不同的版本进行条件编译，<strong>优化包体积</strong>。另外可以<strong>保留<a href="https://cn.vuejs.org/guide/extras/rendering-mechanism.html#compiler-informed-virtual-dom" target="_blank" rel="noopener">Vue 模板编译优化</a>机制</strong>。</li><li>使用公开标准语法，不需要 hack 或者关心太多框架底层的差异。</li></ul></li><li>缺点<ul><li>构建相对复杂，需要两份代码输出。</li><li>灵活性较差。模板语法差异很小，但不以为着没有差异，当需要处理某些跨版本差异时可能会比较棘手。比如<a href="https://v3-migration.vuejs.org/zh/breaking-changes/render-function-api.html" target="_blank" rel="noopener">向下透传事件、props 或者 slots</a> , <a href="https://v3-migration.vuejs.org/zh/breaking-changes/v-bind.html" target="_blank" rel="noopener">v-bind.sync 废弃了</a> 、<a href="https://v3-migration.vuejs.org/zh/breaking-changes/key-attribute.html" target="_blank" rel="noopener">template v-for key</a> <strong>、</strong>v-model 协议变化。</li><li>⚠️ 语法固化，为了兼容 Vue 2，template 语法需要停留在 Vue 3.0，这意味着后续发布的新特性可能无法使用，比如 <code>defineModel</code>，<code>defineOptions</code>。</li></ul></li></ul><p><br><br><br><br><br></p><p><strong>方案 2： 渲染函数</strong></p><p>Vue 2 和 Vue 3 都支持渲染函数，但是两者之间有非常大的差异。<strong>详细的差异对比可以看笔者整理的这篇文档： <a href="https://www.notion.so/Vue-2-3-302cbe0e37794345bbfbd89e32d617db?pvs=21" target="_blank" rel="noopener">Vue 2/3 渲染函数差异以及兼容方案</a></strong></p><p><br></p><p><strong>那 Vue 官方的 JSX 插件呢？</strong></p><p>Vue 2/3 JSX Babel (<strong><a href="https://github.com/vuejs/jsx-vue2" target="_blank" rel="noopener">jsx-vue2</a>、<a href="https://github.com/vuejs/babel-plugin-jsx" target="_blank" rel="noopener">babel-plugin-jsx</a></strong>)插件加了一些语法糖，来简化渲染函数的编写，但是这两个插件的语法完全是两个东西。</p><p>因此这个方案不在我们的考虑之列。</p><p><br><br><br><br><br></p><p><strong>方案 3：标准的 JSX</strong></p><p>那为什么不用标准的 <code>JSX</code> 呢？使用统一的 JSX 语法，转换为不同版本的渲染函数。</p><p><img src="/images/component-for-vue2-3/Untitled%201.png" alt="Untitled"></p><p>使用标准的 JSX 语法，意味着：</p><ul><li><p>不需要任何 <code>Babel</code> 插件，能够被市面上主流的编译器(如 tsc， swc，esbuild)直接处理。<br>例如 Typescript</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">/** tsconfig.json */</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"jsx"</span>: <span class="string">"react-jsx"</span>,</span><br><span class="line">    <span class="attr">"jsxImportSource"</span>: <span class="string">"JSX 运行时名称"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<strong>运行时</strong>转换到对应版本的渲染函数。</p></li><li>Typescript friendly。纯 TSX，不需要额外插件(比如 <code>Volar</code>)辅助。</li><li><p>使用习惯上接近 <code>React</code>。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">/** 🔴 1. 事件订阅  **/</span><br><span class="line">// 🤮</span><br><span class="line"><span class="deletion">- &lt;input vOn:click=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;input vOn:click_stop_prevent=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line">// 👍 使用 on* 注册时间</span><br><span class="line"><span class="addition">+ &lt;input onClick=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line"></span><br><span class="line">/** 🔴 2. 没有指令  **/</span><br><span class="line">// 🤮</span><br><span class="line"><span class="deletion">- &lt;input v-show=&#123;this.visible&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;input vModel=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;input vModel_trim=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;A v-model=&#123;[val, "argument", ["modifier"]]&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;a v-loading=&#123;val&#125; /&gt;;</span></span><br><span class="line"></span><br><span class="line">// 👍 没有语法糖</span><br><span class="line"><span class="addition">+ &lt;input modelValue=&#123;val&#125; onUpdate:modelValue=&#123;handleValChange&#125; /&gt;</span></span><br><span class="line"><span class="addition">+ &lt;input style=&#123;&#123;display: this.visible ? 'block' : 'none' &#125;&#125; /&gt;</span></span><br><span class="line"><span class="addition">+ &lt;a &#123;...withDirectives([[vLoading, val]])&#125;&gt;</span></span><br><span class="line"></span><br><span class="line">/** 🔴 3. slots  **/</span><br><span class="line">// 🤮</span><br><span class="line"><span class="deletion">- &lt;MyComponent&gt;</span></span><br><span class="line"><span class="deletion">-   &lt;header slot="header"&gt;header&lt;/header&gt;</span></span><br><span class="line"><span class="deletion">-   &lt;footer slot="footer"&gt;footer&lt;/footer&gt;</span></span><br><span class="line"><span class="deletion">- &lt;/MyComponent&gt;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">- const scopedSlots = &#123;</span></span><br><span class="line"><span class="deletion">-   header: () =&gt; &lt;header&gt;header&lt;/header&gt;,</span></span><br><span class="line"><span class="deletion">-   footer: () =&gt; &lt;footer&gt;footer&lt;/footer&gt;</span></span><br><span class="line"><span class="deletion">- &#125;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">- &lt;MyComponent scopedSlots=&#123;scopedSlots&#125; /&gt;</span></span><br><span class="line"></span><br><span class="line">// 👍 对齐 vue 3</span><br><span class="line"><span class="addition">+ const App = &#123;</span></span><br><span class="line"><span class="addition">+   setup() &#123;</span></span><br><span class="line"><span class="addition">+     const slots = &#123;</span></span><br><span class="line"><span class="addition">+       bar: () =&gt; &lt;span&gt;B&lt;/span&gt;,</span></span><br><span class="line"><span class="addition">+     &#125;;</span></span><br><span class="line"><span class="addition">+     return () =&gt; (</span></span><br><span class="line"><span class="addition">+       &lt;A v-slots=&#123;slots&#125;&gt;</span></span><br><span class="line"><span class="addition">+         &lt;div&gt;A&lt;/div&gt;</span></span><br><span class="line"><span class="addition">+       &lt;/A&gt;</span></span><br><span class="line"><span class="addition">+     );</span></span><br><span class="line"><span class="addition">+   &#125;,</span></span><br><span class="line"><span class="addition">+ &#125;;</span></span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><ul><li><p>优点</p><ul><li>构建很简单，使用标准的 JSX 只需构建一次。不需要引入特定的编译器，使用 <code>Typescript CLI</code>，<code>esbuild</code> 就可以直接编译。</li><li>Typescript Friendly, 另外相比 <code>vue-tsc</code> 编译结果会好一点。</li><li>灵活性。毋庸置疑，<code>JSX</code> 的灵活性，可操行性太强了。</li><li>相对模板编译来说，可控一点(Hackable)。</li><li>可以替换官方的 JSX 库，除了本文介绍的<code>跨版本组件库</code>场景，在日常 Vue 2/3 应用开发中也可以使用啊。</li></ul></li><li><p>缺点</p><ul><li>使用 <code>JSX</code> 则意味着放弃<a href="https://cn.vuejs.org/guide/extras/rendering-mechanism.html#compiler-informed-virtual-dom" target="_blank" rel="noopener">模板编译优化</a>的机会，比如动态节点标注，预字符串化，缓存，静态提升等等。</li><li>为了抹平版本之间的差异，多了一层抽象转换(主要是 Vue 2 上)，会有一些性能损耗。</li><li>实现上需要熟知两个版本之间的差异性。比较 hack</li><li>可读性较差，相比 <code>React</code> 简洁的 Api，Vue 上的一些特殊的框架特性，还是会让代码有些不太优雅，比如指令、Slot</li></ul></li></ul><p>后面我们选择了 <code>JSX</code> 方案，因为实现起来更简单，方案更加可控，尤其是应对后续的版本更新。</p><p><br><br><br><br><br></p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>构建跨版本的组件库，需要考虑的不仅仅是组件语法问题。Vue 2/3 从底层的 API 到渲染函数、再到应用层的组件库、路由、多语言等等，都出现了割裂。我们得兼顾这些变化。</p><p><br></p><ol><li><strong>分层策略</strong></li></ol><p><img src="/images/component-for-vue2-3/Untitled%202.png" alt="Untitled"></p><p>我们按照引用关系进行分层：</p><ul><li><strong><code>API 层</code></strong>。好在 Vue 3 大部分特性(主要是 <code>Composition API</code> 和 <code>defineComponent</code>) 已经下放到了 Vue 2，我们只需要使用 <a href="https://github.com/vueuse/vue-demi" target="_blank" rel="noopener">vue-demi</a> 就可以无缝使用这些核心的 API。<br>相对应的，上层的组件库、适配器代码禁止直接导入 ‘vue’</li><li><strong><code>视图语法层</code></strong>。就如上文说的，我们会封装一个 jsx-runtime, 抹平 Vue 2/3 在渲染函数上的差异。</li><li><strong><code>适配器层</code></strong>。应用层的各种类库的适配。比如我们公司主要使用 element-ui, 新旧版本的差异会在 element-adapter 中处理，并暴露统一接口。</li><li><strong><code>组件库层</code></strong>。最后我们的组件库基于下层提供的抽象能力，实现跨版本。</li><li><strong><code>应用</code></strong>。上层的 Vue 2 / 3 应用。下层的适配器，会根据应用使用的 Vue 版本，动态切换适配。</li></ul><p><br><br><br></p><p><strong>2) 新版本优先策略</strong></p><p>在封装适配器 或者 jsx-runtime 时，当新旧版本出现差异时，我们如何抉择？</p><p>这里采用的是“新版本优先”的策略，举一些例子：</p><ul><li>JSX 的语法对齐 Vue 3 的渲染函数。</li><li>只使用 Composition API</li><li>只使用 defineComponent</li></ul><p>换句话说，如果情况允许，我们始终以 Vue 3 为基准。</p><p><br><br><br></p><p><strong>3) 短板优先策略</strong></p><p>短板对齐是实现兼容的基础策略，主要分两个方面：</p><ul><li>削头: 并不是所有 Vue 3 的特性都能下放到 Vue 2, 比如 <code>Fragment</code>、<code>Teleport</code>、<code>Suspense</code>/<code>await setup</code>。我们只能放弃这些功能。</li><li>补尾：针对一些 Vue 2 的短板，需要一些额外的工作，比如 <a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">Vue 2 响应式系统的局限性</a>。</li></ul><p><br><br><br></p><p><strong>4) 回退策略</strong></p><p>对于一些无法抹平的差异，可以按照不同的版本特殊处理。可以使用 vue-demi 的 <code>isVue2</code> 来分条件处理。</p><p><br><br><br><br><br></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="api-兼容：vue-demi"><a href="#api-兼容：vue-demi" class="headerlink" title="API 兼容：vue demi"></a>API 兼容：vue demi</h3><p><a href="https://github.com/vueuse/vue-demi" target="_blank" rel="noopener">vue-demi</a> 为实现跨 Vue 版本的库提供基础的支持。它的主要策略：</p><ul><li><code>&lt;=2.6</code>: 导出  <code>vue</code> + <code>@vue/composition-api</code>.</li><li><code>2.7</code>: 导出  <code>vue</code> ( Vue 2.7 内置支持 Composition API).</li><li><code>&gt;=3.0</code>: 导出  <code>vue</code>, 模拟了 Vue 2 的<code>set</code> 、 <code>del</code> API.</li></ul><p>vue-demi 的实现很简单，就是在 npm 的 <code>postinstall</code> 钩子中，判断当前环境安装的 vue 库版本，决定导入的库。</p><p>在我们的场景中，除了 Composition API 和一些基础类型信息还不够，我们 Fork 了 vue-demi 来扩充了一些填充物，进一步抹平一些差异。</p><p><br><br><br><br><br></p><h3 id="渲染语法：jsx-runtime-的实现"><a href="#渲染语法：jsx-runtime-的实现" class="headerlink" title="渲染语法：JSX runtime 的实现"></a>渲染语法：JSX runtime 的实现</h3><p>JSX runtime 的实现并不涉及太复杂的技术，主要还是处理渲染函数的繁琐 API 差异。</p><p>文章篇幅有限，这里我就不展开讲细节了。<strong>⚠️ 完整的差异对比和应对方式可以看这里</strong>：</p><p><br></p><p><a href="https://www.notion.so/Vue-2-3-302cbe0e37794345bbfbd89e32d617db?pvs=21" target="_blank" rel="noopener">🎉Vue 2 / 3 渲染函数的差异 🎉</a></p><p><br></p><p>简单来说，我们的 JSX 语法以 Vue 3 为基准，主要涉及事件订阅、slots、指令的转换。</p><p><br></p><p><img src="/images/component-for-vue2-3/Untitled%203.png" alt="Untitled"></p><p>具体实现可以看<a href="https://github.com/wakeadmin/tools/tree/main/packages/h" target="_blank" rel="noopener">这里</a></p><p><br><br><br><br><br></p><h3 id="组件定义与-typescript-支持"><a href="#组件定义与-typescript-支持" class="headerlink" title="组件定义与 Typescript 支持"></a>组件定义与 Typescript 支持</h3><p>Typescript + Volar 就是一门玄学，类型‘体操’几乎占据了开发的三分之一时间。主要问题：</p><ul><li>Vue 2/3 类型定义和导出有细微的差别。我们的 jsx-runtime 要求一致的类型。</li><li>JSX 的 slots 不支持类型检查。渲染函数毕竟不是 Vue 的第一公民，slots 在 JSX 下无法类型检查。</li><li>为了兼容 options API, <code>defineComponent</code> 类型定义和推导比较<a href="https://github.com/vuejs/core/blob/a95e612b252ae59eaf56e0b8ddba66948d4ac20e/packages/runtime-core/src/apiDefineComponent.ts#L44" target="_blank" rel="noopener">复杂</a>。</li><li>泛型组件实现比较复杂，Volar 泛型的支持也比较玄学。</li></ul><p><br><br><br></p><p>为了能够更好地定义跨版本的组件，提供更好的类型支持，我们打算简化 <code>defineComponent</code>。为了避免命名冲突，尚且命名为 <code>declareComponent</code> 吧, 这个函数有以下职责：</p><ul><li>为实现跨版本支持提供必要约束。<code>declareComponent</code> 裁剪掉了 <code>Options API</code>, 只保留 setup、props、render 等属性。强制走 <code>Composition API</code>。</li><li>为 JSX (比如 v-slots 属性)提供更好类型检查支持</li><li>同时兼容 vue template 的类型检查 (<code>volar</code>)。</li><li>在运行时抹平一些跨版本的差异。绝大部分差异，Vue 2.7 在 <code>defineComponent</code> 方法内部已经抹平了。还有一些 <code>inheritAttrs</code> 带来的<a href="https://www.notion.so/Vue-2-3-302cbe0e37794345bbfbd89e32d617db?pvs=21" target="_blank" rel="noopener">隐式差异</a>，<strong>declareComponent 直接关闭了 <code>inheritAttrs</code></strong> 。</li><li>补全短板，并且向下保持兼容。Vue 2 已经不更新了，我们想要支持一些新的特性，比如泛型。</li></ul><p><br></p><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Counter = declareComponent(&#123;</span><br><span class="line">  name: &apos;Counter&apos;,</span><br><span class="line">  // 定义 props</span><br><span class="line">  props: declareProps&lt;&#123;</span><br><span class="line">    initialValue: number</span><br><span class="line">  &#125;&gt;(</span><br><span class="line">    // ⚠️ 和 defineComponent 一样，我们还是需要显式定义 props, 否则会被当做 attrs</span><br><span class="line">    [&apos;initialValue&apos;]</span><br><span class="line">  ),</span><br><span class="line"></span><br><span class="line">  // 定义事件</span><br><span class="line">  emits: declareEmits&lt;&#123; change: (value: number) =&gt; void &#125;&gt;(),</span><br><span class="line"></span><br><span class="line">  // 定义插槽</span><br><span class="line">  // slots: declareSlots&lt;&#123; foo: &#123; a: number &#125; &#125;&gt;(),</span><br><span class="line"></span><br><span class="line">  // setup</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    const count = ref(props.initialValue)</span><br><span class="line">    const handleClick = () =&gt; &#123;</span><br><span class="line">      count.value++</span><br><span class="line"></span><br><span class="line">      emit(&apos;change&apos;, count.value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return () =&gt; (</span><br><span class="line">      &lt;div title=&quot;count&quot; onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">        count: &#123;count.value&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>为了实现这个目标，我们先来看下 <code>Volar</code> 是如何推断组件的类型：</p><p><br></p><p>大致的推导过程如下, 其次可以参考 <code>vue-tsc</code> 的编译输出或者 Vue <code>defineComponent</code> 的类型声明。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// https://github.com/vuejs/language-tools/blob/71240c78f1a205605f4c079a299b2701250ef9be/packages/vue-component-type-helpers/index.d.ts#L5</span><br><span class="line">export type ComponentProps&lt;T&gt; = T extends new () =&gt; &#123; $props: infer P &#125;</span><br><span class="line">  ? NonNullable&lt;P&gt;</span><br><span class="line">  : T extends (props: infer P, ...args: any) =&gt; any</span><br><span class="line">  ? P</span><br><span class="line">  : &#123;&#125;</span><br><span class="line"></span><br><span class="line">export type ComponentSlots&lt;T&gt; = T extends new () =&gt; &#123; $slots: infer S &#125;</span><br><span class="line">  ? NonNullable&lt;S&gt;</span><br><span class="line">  : T extends (props: any, ctx: &#123; slots: infer S &#125;, ...args: any) =&gt; any</span><br><span class="line">  ? NonNullable&lt;S&gt;</span><br><span class="line">  : &#123;&#125;</span><br><span class="line"></span><br><span class="line">export type ComponentEmit&lt;T&gt; = T extends new () =&gt; &#123; $emit: infer E &#125;</span><br><span class="line">  ? NonNullable&lt;E&gt;</span><br><span class="line">  : T extends (props: any, ctx: &#123; emit: infer E &#125;, ...args: any) =&gt; any</span><br><span class="line">  ? NonNullable&lt;E&gt;</span><br><span class="line">  : &#123;&#125;</span><br><span class="line"></span><br><span class="line">export type ComponentExposed&lt;T&gt; = T extends new () =&gt; infer E</span><br><span class="line">  ? E</span><br><span class="line">  : T extends (props: any, ctx: &#123; expose(exposed: infer E): any &#125;, ...args: any) =&gt; any</span><br><span class="line">  ? NonNullable&lt;E&gt;</span><br><span class="line">  : &#123;&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Vue 2.x</span><br><span class="line"> */</span><br><span class="line">export type Vue2ComponentSlots&lt;T&gt; = T extends new () =&gt; &#123; $scopedSlots: infer S &#125;</span><br><span class="line">  ? NonNullable&lt;S&gt;</span><br><span class="line">  : T extends (props: any, ctx: &#123; slots: infer S &#125;, ...args: any) =&gt; any</span><br><span class="line">  ? NonNullable&lt;S&gt;</span><br><span class="line">  : &#123;&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>简单来说 <code>defineComponent</code> 方法最终输出的组件的类型外观长这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type YourComponent = new (...args: any[]): &#123;</span><br><span class="line">  $props: Props 类型</span><br><span class="line">  $emit: 事件类型</span><br><span class="line">  $slots: 插槽类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>💡 那 Typescript 的 JSX 怎么对组件进行类型检查呢？这个可以参考 Typescript 的 <a href="https://www.typescriptlang.org/docs/handbook/jsx.html" target="_blank" rel="noopener">JSX 文档</a>，还有 Vue 的 JSX <a href="https://github.com/vuejs/core/blob/a95e612b252ae59eaf56e0b8ddba66948d4ac20e/packages/vue/jsx.d.ts#L3" target="_blank" rel="noopener">类型定义</a>。简单说也是从上述的 <code>$props</code> 中推导的。</p></blockquote><p><br><br><br></p><p>我们的 <code>declareComponent</code> 只要保持和上面的类型兼容，就可以让 <code>volar</code> 在 vue template 下进行类型检查了。</p><p><br></p><p>因为刨除掉了不必要的 Options API, 相比 defineComponent, 类型定义可以简化很多:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function declareComponent&lt;</span><br><span class="line">  Props extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Emit extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Slots extends &#123;&#125; = &#123;&#125;</span><br><span class="line">&gt;(</span><br><span class="line">  options: SimpleComponentOptions&lt;Props, Emit, Expose, Slots&gt;</span><br><span class="line">): DefineComponent&lt;Props, Emit, Expose, Slots&gt; &#123;</span><br><span class="line">  /// .. 实现忽略，简单封装 defineComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 简化 defineComponent API, 只保留 Composition API</span><br><span class="line">export type SimpleComponentOptions&lt;</span><br><span class="line">  Props extends &#123;&#125;,</span><br><span class="line">  Emit extends &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125;,</span><br><span class="line">  Slots extends &#123;&#125;</span><br><span class="line">&gt; = &#123;</span><br><span class="line">  name?: string</span><br><span class="line">  props?: Props</span><br><span class="line">  emits?: Emit</span><br><span class="line">  slots?: Slots</span><br><span class="line">  expose?: Expose</span><br><span class="line">  setup: (</span><br><span class="line">    props: Props,</span><br><span class="line">    ctx: SetupContext&lt;Emit, DefaultSlots &amp; Slots, Expose, Data&gt;</span><br><span class="line">  ) =&gt; Promise&lt;RenderFunction | void&gt; | RenderFunction | void</span><br><span class="line">  inheritAttrs?: boolean</span><br><span class="line">  serverPrefetch?(): Promise&lt;any&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export interface ComponentInstance&lt;</span><br><span class="line">  Props extends &#123;&#125;,</span><br><span class="line">  Emit extends &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125;,</span><br><span class="line">  Slots extends &#123;&#125;</span><br><span class="line">&gt; &#123;</span><br><span class="line">  // props 定义</span><br><span class="line">  $props: Props &amp;</span><br><span class="line">    // 🔴 将 emit 转换为 on* 形式，方便 JSX 场景使用</span><br><span class="line">    EmitsToProps&lt;Emit&gt; &amp; &#123; &apos;v-slots&apos;?: Partial&lt;VSlotType&lt;Slots&gt;&gt; &#125; &amp; &#123;</span><br><span class="line">      // 🔴 扩展了 v-slots 的定义，方便 JSX 场景使用</span><br><span class="line">      &apos;v-children&apos;?: VChildrenType&lt;Slots&gt;</span><br><span class="line">    &#125; &amp; &#123;</span><br><span class="line">      ref?: RefType&lt;Expose | Expose[]&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  // 🔴 支持 volar 推断 slots</span><br><span class="line">  $slots: VSlotType&lt;Slots&gt;</span><br><span class="line">  // 🔴 支持 volar 推断 事件</span><br><span class="line">  $emit: EmitFn&lt;Emit&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以对比 Vue 的 DefineComponent 看看</span><br><span class="line">export interface DefineComponent&lt;</span><br><span class="line">  Props extends &#123;&#125;,</span><br><span class="line">  Emit extends &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125;,</span><br><span class="line">  Slots extends &#123;&#125;</span><br><span class="line">&gt; &#123;</span><br><span class="line">  new (...args: any[]): ComponentInstance&lt;Props, Emit, Expose, Slots&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>那怎么支持泛型组件吗？</strong></p><p><br><br><br><br><br></p><h3 id="泛型组件"><a href="#泛型组件" class="headerlink" title="泛型组件"></a><strong>泛型组件</strong></h3><blockquote><p>Volar 需要升级到最新版本。</p></blockquote><blockquote><p>Volar 的泛型支持比较玄学，我建议不要随意尝试！</p></blockquote><p>Vue 3.3 官方正式支持了<a href="https://blog.vuejs.org/posts/vue-3-3" target="_blank" rel="noopener">泛型 SFC</a> 和 defineComponent, 笔者实测 Volar 这块支持还有待改进。但是不妨碍我们进行初步的尝试。</p><p>上文的 <code>declareComponent</code> 写法是不支持泛型组件的。有两种方式可以实现泛型组件的声明，先来看一个比较简单的：</p><ol><li><p><strong>类型断言</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 🔴 使用泛型定义 props、emit 和 expose 等类型</span><br><span class="line">interface Props&lt;T&gt; &#123;</span><br><span class="line">  list: T[]</span><br><span class="line">  filter: (item: T) =&gt; boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 📢 这里要用 type</span><br><span class="line">type Emit&lt;T&gt; = &#123;</span><br><span class="line">  add: (item: T) =&gt; void</span><br><span class="line">  change: (list: T[]) =&gt; void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Expose&lt;T&gt; = &#123;</span><br><span class="line">  open: (item: T) =&gt; void</span><br><span class="line">  list: T[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Slots&lt;T&gt; = &#123;</span><br><span class="line">  foo: (list: T[]) =&gt; any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const GenericBar = declareComponent(&#123;</span><br><span class="line">  props: declareProps&lt;Props&lt;any&gt;&gt;([]),</span><br><span class="line">  emits: declareEmits&lt;Emit&lt;any&gt;&gt;(),</span><br><span class="line">  expose: declareExpose&lt;Expose&lt;any&gt;&gt;(),</span><br><span class="line">  slots: declareSlots&lt;Slots&lt;any&gt;&gt;(),</span><br><span class="line">  setup(props, ctx) &#123;</span><br><span class="line">    expectType&lt;any[]&gt;(props.list)</span><br><span class="line">    ctx.emit(&apos;change&apos;, [])</span><br><span class="line">    ctx.slots.foo?.([])</span><br><span class="line">    ctx.expose(&#123;</span><br><span class="line">      list: [],</span><br><span class="line">      open() &#123;</span><br><span class="line">        // ignore</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    return &#123;&#125; as any</span><br><span class="line">  &#125;,</span><br><span class="line">  // 🔴 重新断言，支持 泛型</span><br><span class="line">&#125;) as new &lt;T&gt;(...args: any[]) =&gt; ComponentInstance&lt;Props&lt;T&gt;, Emit&lt;T&gt;, Expose&lt;T&gt;, Slots&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">;&lt;GenericBar</span><br><span class="line">  list=&#123;[1, 2]&#125;</span><br><span class="line">  filter=&#123;(i) =&gt; &#123;</span><br><span class="line">    expectType&lt;number&gt;(i)</span><br><span class="line">    return true</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  onAdd=&#123;(i) =&gt; &#123;</span><br><span class="line">    expectType&lt;number&gt;(i)</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  onChange=&#123;(i) =&gt; &#123;</span><br><span class="line">    expectType&lt;number[]&gt;(i)</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  v-slots=&#123;&#123;</span><br><span class="line">    foo(i) &#123;</span><br><span class="line">      expectType&lt;number[]&gt;(i)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;&lt;/GenericBar&gt;</span><br></pre></td></tr></table></figure><p> <br></p><p>上面的方式在 JSX 表现正常，<strong>但是目前 Volar 在 vue template 并不支持。</strong></p><blockquote><p>💡 <strong>这里也有一些冷知识。</strong>假设 目标类型约束了 <code>Index Signature</code>, 比如 <code>{[key: string]: Function }</code>, 那么 <code>interface</code> 是无法赋值给它的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; interface Indexed &#123;</span><br><span class="line">&gt;   [key: string]: Function</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; interface Foo &#123;</span><br><span class="line">&gt;   hello: () =&gt; void</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; declare let a: Indexed</span><br><span class="line">&gt; declare let b: Foo</span><br><span class="line">&gt;</span><br><span class="line">&gt; a = b // 🚨 Index signature for type &apos;string&apos; is missing in type &apos;Foo&apos;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>如果使用 <code>type</code> 创建类型就可以:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; type Bar = &#123;</span><br><span class="line">&gt;   hello: () =&gt; void</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; declare let c: Bar</span><br><span class="line">&gt; a = c // it&apos;s work</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>笔者推测，应该<strong>是 interface 允许 <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces" target="_blank" rel="noopener">合并</a>，不是静态的，因此不能安全地满足 Index Signature 的约束</strong>。</p><p>了解更多：</p><p><a href="https://stackoverflow.com/questions/60697214/how-to-fix-index-signature-is-missing-in-type-error" target="_blank" rel="noopener">How to fix “Index signature is missing in type” error?</a></p></blockquote><p> <br><br> <br></p></li><li><p><strong>函数形式</strong></p><p>Vue 3.3 的 <code>defineComponent</code> 新增了一种<a href="https://cn.vuejs.org/api/general.html#definecomponent" target="_blank" rel="noopener">函数签名形式</a>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Comp = defineComponent(</span><br><span class="line">  &lt;T extends string | number&gt;(props: &#123; msg: T; list: T[] &#125;) =&gt; &#123;</span><br><span class="line">    // 就像在 &lt;script setup&gt; 中一样使用组合式 API</span><br><span class="line">    const count = ref(0)</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      // 渲染函数或 JSX</span><br><span class="line">      return &lt;div&gt;&#123;count.value&#125;&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 去掉注释，泛型会失效</span><br><span class="line">  // 目前仍然需要手动声明运行时的 props</span><br><span class="line">  // &#123;</span><br><span class="line">  //  props: [&apos;msg&apos;, &apos;list&apos;]</span><br><span class="line">  /// &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>尴尬的是，Vue 组件必须显式定义 props 参数，不然会被当做 attrs 处理。所以，当你将上面的<strong>props 参数注释去掉时，泛型就会失效了 😀</strong> 。</p><p>另外一件尴尬的事情是，截止目前为止，用上面语法创建的组件，在 Volar 上并不能得到很好的支持(只能正确推断 props)。</p><p><br></p><p>但使用 <a href="https://cn.vuejs.org/api/sfc-script-setup.html#generics" target="_blank" rel="noopener">SFC 泛型语法</a> 则会表现好一点。SFC 有什么特殊？</p><p>我使用 vue-tsc 将组件编译了一下，大概结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare const _default: &lt;T&gt;(</span><br><span class="line">  // 🔴 props 类型</span><br><span class="line">  __VLS_props: &#123;</span><br><span class="line">    list: T[]</span><br><span class="line">    filter: (item: T) =&gt; boolean</span><br><span class="line">  &#125; &amp; VNodeProps &amp;</span><br><span class="line">    AllowedComponentProps &amp;</span><br><span class="line">    ComponentCustomProps,</span><br><span class="line"></span><br><span class="line">  // 🔴 context 类型</span><br><span class="line">  __VLS_ctx?:</span><br><span class="line">    | Pick&lt;</span><br><span class="line">        &#123;</span><br><span class="line">          props: &#123;</span><br><span class="line">            list: T[]</span><br><span class="line">            filter: (item: T) =&gt; boolean</span><br><span class="line">          &#125;</span><br><span class="line">          expose(exposed: &#123; data: Ref&lt;T[] | null | undefined&gt; &#125;): void</span><br><span class="line">          attrs: any</span><br><span class="line">          slots: &#123;</span><br><span class="line">            foo: (scope: &#123; list: T[] &#125;) =&gt; any</span><br><span class="line">          &#125;</span><br><span class="line">          emit: &#123;</span><br><span class="line">            change: [T[]]</span><br><span class="line">            foo: [T, number]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;attrs&apos; | &apos;emit&apos; | &apos;slots&apos;</span><br><span class="line">      &gt;</span><br><span class="line">    | undefined</span><br><span class="line">) =&gt; // 🔴 返回值</span><br><span class="line">VNode &amp; &#123;</span><br><span class="line">  __ctx?:</span><br><span class="line">    | &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">          list: T[]</span><br><span class="line">          filter: (item: T) =&gt; boolean</span><br><span class="line">        &#125;</span><br><span class="line">        expose(exposed: &#123; data: Ref&lt;T[] | null | undefined&gt; &#125;): void</span><br><span class="line">        attrs: any</span><br><span class="line">        slots: &#123;</span><br><span class="line">          foo: (scope: &#123; list: T[] &#125;) =&gt; any</span><br><span class="line">        &#125;</span><br><span class="line">        emit: &#123;</span><br><span class="line">          change: [T[]]</span><br><span class="line">          foo: [T, number]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    | undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SFC 的编译结果多出了 <code>__ctx</code> 字段，实际上 Volar 就是从 __ctx 中提取了相关类型。</p><aside><br>💡 __ctx 应该是 volar 的内部实现细节，不排除后面会变动<br><br></aside><p>那我们现在就模仿它，重构一下 <code>declareComponent</code> 的签名:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface DefineComponentContext&lt;</span><br><span class="line">  Emit extends ObjectEmitsOptions = &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Slots extends &#123; [key: string]: Function &#125; = &#123;&#125;,</span><br><span class="line">  Attrs extends &#123;&#125; = &#123;&#125;</span><br><span class="line">&gt; &#123;</span><br><span class="line">  attrs: Attrs</span><br><span class="line">  slots: Slots</span><br><span class="line">  emit: EmitFn&lt;Emit&gt;</span><br><span class="line">  expose: ExposeFn&lt;Expose&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function declareComponent&lt;</span><br><span class="line">  Props extends &#123;&#125;,</span><br><span class="line">  Emit extends ObjectEmitsOptions = &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Slots extends &#123; [key: string]: Function &#125; = &#123;&#125;,</span><br><span class="line">  Attrs extends &#123;&#125; = &#123;&#125;</span><br><span class="line">&gt;(</span><br><span class="line">  setup: (</span><br><span class="line">    props: Props,</span><br><span class="line">    ctx: DefineComponentContext&lt;Emit, Expose, Slots, Attrs&gt;</span><br><span class="line">  ) =&gt; Promise&lt;RenderFunction | void&gt; | RenderFunction | void,</span><br><span class="line">  options?: &#123;</span><br><span class="line">    props?: Array&lt;keyof Props&gt; | ComponentObjectPropsOptions&lt;Partial&lt;Props&gt;&gt;</span><br><span class="line">    name?: string</span><br><span class="line">    inheritAttrs?: boolean</span><br><span class="line">    serverPrefetch?(): Promise&lt;any&gt;</span><br><span class="line">  &#125;</span><br><span class="line">): (</span><br><span class="line">  props: PropsType&lt;Props, Emit, Slots, Expose&gt;,</span><br><span class="line">  ctx: DefineComponentContext&lt;Emit, Expose, Slots, Attrs&gt;</span><br><span class="line">) =&gt; VNode &amp; &#123;</span><br><span class="line">  // 🛑</span><br><span class="line">  __ctx: &#123;</span><br><span class="line">    emit: EmitFn&lt;Emit&gt;</span><br><span class="line">    slots: Slots</span><br><span class="line">    expose: ExposeFn&lt;Expose&gt;</span><br><span class="line">    attrs: Attrs</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo&lt;T&gt;(</span><br><span class="line">  props: &#123; list: T[]; filter: (item: T) =&gt; boolean &#125;,</span><br><span class="line">  ctx: DefineComponentContext&lt;</span><br><span class="line">    &#123; change: (list: T[]) =&gt; void; add: (item: T) =&gt; void &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      open: (item: T) =&gt; void</span><br><span class="line">      list: T[]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      foo: (list: T[]) =&gt; any</span><br><span class="line">    &#125;</span><br><span class="line">  &gt;</span><br><span class="line">) &#123;</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    // render</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ⚠️ props 还是要定义</span><br><span class="line">Foo.props = [&apos;list&apos;, &apos;filter&apos;]</span><br><span class="line"></span><br><span class="line">export default declareComponent(Foo)</span><br></pre></td></tr></table></figure><p>目前 Volar 在泛型的支持上还有不少的坑。比如上面的示例中事件处理器的泛型变量会推断为 unknown。让子弹再飞一会吧。</p></li></ol><p><br><br><br><br><br> </p><h3 id="element-adapter"><a href="#element-adapter" class="headerlink" title="element-adapter"></a>element-adapter</h3><p>实现的原理和 vue-demi 类似，在 postinstall 时决定使用哪个版本。项目的结构如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scripts/             <span class="comment"># 和 vue-demi 一样，实现了 postinstall 和切换 CLI</span></span><br><span class="line">  postinstall.mjs</span><br><span class="line">  switch-cli.mjs</span><br><span class="line">src/</span><br><span class="line">  shared/</span><br><span class="line">  v2/                <span class="comment"># element-ui 导出</span></span><br><span class="line">    components/</span><br><span class="line">      Table.js</span><br><span class="line">      Slide.js</span><br><span class="line">      ...</span><br><span class="line">  v3/                <span class="comment"># element-plus 导出</span></span><br><span class="line">    components/</span><br><span class="line">      ...</span><br><span class="line">types/               <span class="comment"># 重新声明组件的类型信息。</span></span><br><span class="line">  alert.d.ts</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p><br> </p><p>大部分组件不需要特殊处理，重新导出就行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> &#123; Button &#125; from <span class="string">'element-ui'</span>;</span><br></pre></td></tr></table></figure><p><br> </p><p>有一些组件参数名称发生了变化，则以 element-plus 为基准做一下调整：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; TimePicker as ElTimePicker &#125; from &apos;element-ui&apos;</span><br><span class="line">import &#123; h &#125; from &apos;@wakeadmin/h&apos;</span><br><span class="line"></span><br><span class="line">import &#123; normalizeDateFormat &#125; from &apos;../../shared/date-format&apos;</span><br><span class="line"></span><br><span class="line">export const TimePicker = &#123;</span><br><span class="line">  functional: true,</span><br><span class="line">  render(_, context) &#123;</span><br><span class="line">    const &#123; format, selectableRange, valueFormat, ...other &#125; = context.props</span><br><span class="line"></span><br><span class="line">    // vue3 pickerOptions 提取到了全局</span><br><span class="line">    other.pickerOptions = &#123;</span><br><span class="line">      ...other.pickerOptions,</span><br><span class="line">      format: format &amp;&amp; normalizeDateFormat(format),</span><br><span class="line">      selectableRange,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (valueFormat) &#123;</span><br><span class="line">      other.valueFormat = normalizeDateFormat(valueFormat)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return h(</span><br><span class="line">      ElTimePicker,</span><br><span class="line">      Object.assign(&#123;&#125;, context.data, &#123; props: other, attrs: undefined &#125;),</span><br><span class="line">      context.slots()</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br> </p><p>另外，我们也会移植一些 element-plus 的新组件，比如 <code>TreeSelect</code>。</p><p>对于 icon 这类差异比较大，我们直接放弃了。可以使用外部图标库或者 SVG 组件库（参考这个<a href="https://github.com/wakeadmin/tools/tree/main/packages/icons" target="_blank" rel="noopener">实现</a>跨版本的 SVG 图标库）。</p><p><br><br><br><br><br> </p><h3 id="router-adapter"><a href="#router-adapter" class="headerlink" title="router-adapter"></a>router-adapter</h3><p>我们的组件库是可能会涉及到路由的订阅和操作。因为 vue-router API 差异并不大，处理起来会简单很多。</p><p>不管是 vue 2 还是 3，vue-router 都会在组件实例上挂载相关的 API, 我们直接获取就行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface RouteLike &#123;</span><br><span class="line">  query: Record&lt;string, any&gt;</span><br><span class="line">  params: Record&lt;string, any&gt;</span><br><span class="line">  hash: string</span><br><span class="line">  path: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export type RouteLocation =</span><br><span class="line">  | string</span><br><span class="line">  | &#123;</span><br><span class="line">      query?: Record&lt;string, any&gt;</span><br><span class="line">      hash?: string</span><br><span class="line">      path?: string</span><br><span class="line">      name?: string</span><br><span class="line">      params?: Record&lt;string, any&gt;</span><br><span class="line">      replace?: boolean</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">export interface RouterLike &#123;</span><br><span class="line">  push(to: RouteLocation): Promise&lt;any&gt;</span><br><span class="line">  replace(to: RouteLocation): Promise&lt;any&gt;</span><br><span class="line">  back(): void</span><br><span class="line">  forward(): void</span><br><span class="line">  go(delta: number): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function useRouter() &#123;</span><br><span class="line">  const instance = getCurrentInstance()</span><br><span class="line"></span><br><span class="line">  if (isVue2) &#123;</span><br><span class="line">    return (instance?.proxy?.$root as &#123; $router: RouterLike &#125; | undefined)?.$router</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return (instance?.root?.proxy as unknown as &#123; $router: RouterLike &#125;)?.$router</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ... useRoute 同理</span><br></pre></td></tr></table></figure><p><br> </p><p>其他的库可以采取类似的策略。</p><p><br><br><br><br><br> </p><h3 id="🎉-开源-🎉"><a href="#🎉-开源-🎉" class="headerlink" title="🎉 开源 🎉"></a>🎉 开源 🎉</h3><p>借着这篇文章，我们也将相关的<a href="https://github.com/wakeadmin" target="_blank" rel="noopener">程序开源了</a>! 希望能帮助到大家！</p><ul><li><a href="https://github.com/wakeadmin/tools/tree/main/packages/h" target="_blank" rel="noopener">jsx-runtime 实现</a></li><li><a href="https://github.com/wakeadmin/components" target="_blank" rel="noopener">组件库实现</a></li></ul><p>欢迎 Fork Star PR</p><p><br><br><br><br><br> </p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://www.notion.so/Vue-2-3-302cbe0e37794345bbfbd89e32d617db?pvs=21" target="_blank" rel="noopener">Vue 2/3 渲染函数差异以及兼容方案</a></li><li><a href="https://github.com/vuejs/core/pull/7963" target="_blank" rel="noopener">feat(types): <code>defineComponent()</code> with generics support</a></li><li><a href="https://cn.vitejs.dev/config/" target="_blank" rel="noopener">vitejs</a></li><li><a href="https://github.com/vitejs/vite-plugin-vue" target="_blank" rel="noopener">https://github.com/vitejs/vite-plugin-vue</a></li><li><a href="https://github.com/vitejs/vite-plugin-vue2" target="_blank" rel="noopener">https://github.com/vitejs/vite-plugin-vue2</a></li><li><a href="https://github.com/vuejs/babel-plugin-jsx" target="_blank" rel="noopener">https://github.com/vuejs/babel-plugin-jsx</a></li><li><a href="https://github.com/vuejs/jsx-vue2" target="_blank" rel="noopener">https://github.com/vuejs/jsx-vue2</a></li><li><a href="https://github.com/vuejs/language-tools" target="_blank" rel="noopener">https://github.com/vuejs/language-tools</a></li><li><a href="https://github.com/vuejs/vue-loader/" target="_blank" rel="noopener">https://github.com/vuejs/vue-loader/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/component-for-vue2-3/Untitled.jpeg&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;Vue 3 已经&lt;a href=&quot;https://vue-js.com/topic/5f6562
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>现代前端框架的渲染模式</title>
    <link href="https://bobi.ink/2023/06/05/render-patterns/"/>
    <id>https://bobi.ink/2023/06/05/render-patterns/</id>
    <published>2023-06-04T16:00:00.000Z</published>
    <updated>2023-06-05T03:25:04.885Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要参考的内容来源是<a href="https://www.patterns.dev/" target="_blank" rel="noopener">patterns.dev</a>。这个网站收录了许多实用的前端设计模式，大家赶紧收藏起来！</p></blockquote><p><br></p><p>React 发布已经十年了，笔者接触前端差不多也有十年时间了。说实话，如果没有 <a href="https://search.douban.com/book/subject_search?search_text=head+first&amp;cat=1001" target="_blank" rel="noopener">Head First 系列图书</a>，我可能都没有走上编程这条道路。</p><p><br></p><p><img src="/images/render-patterns/Untitled.png" alt="Head first"><br>Head first</p><p><br></p><p>尽管现在看来这系列图书内容可能过时了。</p><p>Head First 系列图书让我知道，原来编程也可以这么通俗易懂的，对于刚接触这个领域的同学来说，从这里可以获得很多信心和成就感。<br>这种风格也一直影响着我，学习和工作、传道授业过程中，我会努力把复杂的事情简化、通俗化，提炼本质。</p><p><br><br><br></p><p>这十年，前端渲染方式一直在演进，我觉得大概可以分为以下三个阶段：</p><p><img src="/images/render-patterns/Untitled%201.png" alt="Untitled"></p><ul><li>传统 SSR: 那时候前端还没有分离，在 JSP、ASP、Ruby on Rails、Django 这些 MVC 框架下，通过模板来渲染页面。jQuery 是这个阶段的主角</li><li>前后端分离：从 Node.js 发布，到目前为止，是前端发展最迅速的 10 年。<br>前后端分离的典型代表是 Angular 和 React、Vue 等框架，我觉得，促进前后端分离的主要原因还是<strong>随着需求的复杂化，分工精细化了</strong>。 前端可以专注于 UI 的设计和交互逻辑。后端只需要提供 API，不需要关心前端的具体实现。</li><li>同构前端：这几年前端框架的发展进入的深水区，随着云原生、容器技术、Serverless、边缘计算等底层技术设施的普及，也让‘前端’生存范围延展到服务端。前端开始寻求 <code>UX</code> 和 <code>DX</code> 的平衡点</li></ul><p><br><br><br><br><br></p><p>通过这篇文章，你就可以知道近些年前端渲染模式的演变。</p><p>废话不多说，直接开始吧。</p><p><br><br><br><br><br></p><h2 id="csr-客户端渲染"><a href="#csr-客户端渲染" class="headerlink" title="CSR - 客户端渲染"></a>CSR - 客户端渲染</h2><p><img src="/images/render-patterns/Untitled%202.png" alt="Untitled"></p><p>这个我们再熟悉不过了， 即前端页面在浏览器中渲染，服务端仅仅是静态资源服务器(比如 nginx)。</p><p>初始的 HTML 文件只是一个空壳，我们需要等待 JavaScript 包加载和执行完毕，才能进行交互，白屏时间比较长。</p><ul><li>优点<ul><li>部署简单</li><li>页面过渡、功能交互友好</li><li>适合复杂交互型应用程序开发</li></ul></li><li>缺点<ul><li><code>SEO</code> 不友好</li><li>白屏时间长</li><li>可能需要复杂的状态管理。时至今日，状态管理方面的轮子还在不停地造</li></ul></li></ul><p><br><br><br><br><br></p><h2 id="ssr-服务端渲染"><a href="#ssr-服务端渲染" class="headerlink" title="SSR - 服务端渲染"></a>SSR - 服务端渲染</h2><p><img src="/images/render-patterns/Untitled%203.png" alt="Untitled"></p><p>为了解决 SEO 和白屏问题，各大框架开始支持在服务端渲染 HTML 字符串。</p><p>SSR 把数据拉取放到了服务端，因为离数据源比较近，数据拉取的速度会快一点。但这也不是完全没有副作用，因为需要在服务端等待数据就绪, <code>TTFB(Time to First Byte)</code> 相比 CSR 会长一点。</p><p>SSR 只是给我们准备好了初始的数据和 HTML, 实际上和 CSR 一样，我们还是需要加载完整的<code>客户端程序</code>，然后在浏览器端重新渲染一遍(更专业的说是 <code>Hydration  水合/注水</code>)，才能让 DOM 有交互能力。</p><p><strong>也就说， <code>FCP(First Contentful Paint)</code> 相比 CSR 提前了, 但是 <code>TTI(Time to Interactive)</code> 并没有太多差别。只是用户可以更快地看到内容了。</strong></p><blockquote><p>hydration 的主要目的是挂载事件处理器、触发副作用等等</p></blockquote><p>优点</p><ul><li>SEO 友好</li><li>用户可以更快看到内容了</li></ul><p>缺点</p><ul><li>部署环境要求。需要 Nodejs 等 JavaScript 服务端运行环境</li><li>需要包含完整的 JavaScript 客户端渲染程序，<code>TTI</code> 还有改善空间</li></ul><p><br><br><br><br><br><br><br></p><h2 id="ssg-静态生成"><a href="#ssg-静态生成" class="headerlink" title="SSG - 静态生成"></a>SSG - 静态生成</h2><p><img src="/images/render-patterns/Untitled%204.png" alt="Untitled"></p><p>对于完全静态的页面，比如博客，公司主页等等，也可以使用 SSG 静态渲染。</p><p>和 SSR 的区别是，SSG 是在<code>构建时</code>渲染的。</p><p>和 CSR 一样，因为是静态的，所以在服务端不需要渲染运行时，部署在静态服务器就行了。</p><p>VuePress、VitePress、Gatsby、Docusaurus 这些框架都属于 SSG 的范畴。</p><p><br><br><br></p><p>优点</p><ul><li>相比 SSR, 因为不需要服务端运行时、数据拉取，TTFB/FCP 等都会提前。</li></ul><p>缺点</p><ul><li>和 SSR 一样，也有客户端渲染程序、需要进行 Hydrate。<br>对于<code>内容为中心</code>的站点来说，实际上并不需要太多交互，客户端程序还有较大压缩的空间。</li><li>在构建时渲染，如果内容变更，需要重新构建，比较麻烦</li></ul><p><br><br><br><br><br><br><br></p><h2 id="isg-增量静态生成"><a href="#isg-增量静态生成" class="headerlink" title="ISG - 增量静态生成"></a>ISG - 增量静态生成</h2><p><img src="/images/render-patterns/Untitled%205.png" alt="Untitled"></p><p>ISG 是 SSG 的升级版。解决 SSG 内容变更繁琐问题。</p><p>ISG 依旧会在构建时预渲染页面，但是这里多出了一个<code>服务端运行时</code>，这个运行时会按照一定的过期/刷新策略(通常会使用 <strong><a href="https://web.dev/stale-while-revalidate/" target="_blank" rel="noopener">stale-while-revalidate</a></strong> )来重新生成页面。</p><p><br><br><br><br><br><br><br></p><h2 id="progressive-hydration-渐进水合"><a href="#progressive-hydration-渐进水合" class="headerlink" title="Progressive Hydration - 渐进水合"></a>Progressive Hydration - 渐进水合</h2><p><img src="/images/render-patterns/Untitled%206.png" alt="Untitled"></p><p>上文提到，常规的 SSR 通常需要完整加载客户端程序(上图的 bundle.js)，水合之后才能得到可交互页面，这就导致 <code>TTI</code> 会偏晚。</p><p>最直接的解决办法就是压缩客户端程序的体积。那么自然会想到使用<code>代码分割</code>(code splitting)技术。<br><code>渐进式水合 （Progressive Hydration ）</code> 就是这么来的。</p><p>如上图，我们使用<code>代码分割</code>的方式，将 Foo、Bar 抽取为<code>异步组件</code>，抽取后<code>主包</code>的体积下降了，<code>TTI</code> 就可以提前了。</p><p>而 Foo、Bar 可以按照一定的策略来按需加载和水合，比如在视口可见时、浏览器空闲时，或者交给 <code>React Concurrent Mode</code> 根据交互的优先级来加载。</p><p>React 18 官方支持了渐进式水合（官方叫 <code>Selective Hydration</code>）。</p><p>要深入了解 Progress Hydration, 可以看这个<a href="https://www.youtube.com/watch?v=k-A2VfuUROg&amp;t=960s" target="_blank" rel="noopener">视频</a>。</p><p><br><br><br><br><br></p><h2 id="ssr-with-streaming-流式-ssr"><a href="#ssr-with-streaming-流式-ssr" class="headerlink" title="SSR with streaming - 流式 SSR"></a>SSR with streaming - 流式 SSR</h2><p><img src="/images/render-patterns/Untitled%207.png" alt="Untitled"></p><p>这个很好理解。尤其是在最近 <code>ChatGPT</code> 这么火。ChatGPT API 有两种响应模式：普通响应、流式响应</p><ul><li><a href="https://react.dev/reference/react-dom/server/renderToString" target="_blank" rel="noopener">renderToString</a> → 普通响应。即 SSR 会等待完整的 HTML 渲染完毕后，才给客户端发送第一个字节。</li><li><a href="https://react.dev/reference/react-dom/server/renderToNodeStream" target="_blank" rel="noopener">renderToNodeStream</a> → 流式响应。渲染多少，就发送多少。就像 ChatGPT 聊天消息一样，一个字一个字的蹦，尽管接收完整消息的时间可能差不多，用户体验却相差甚远。</li></ul><p>浏览器能够很好地处理 HTML 流，快速地将内容呈现给用户，而不是白屏干等。</p><p>下面这张图可以更直观感受两者区别：</p><p><img src="/images/render-patterns/Untitled%208.png" alt="来源：[https://mxstbr.com/thoughts/streaming-ssr/](https://mxstbr.com/thoughts/streaming-ssr/)"></p><p>来源：<a href="https://mxstbr.com/thoughts/streaming-ssr/" target="_blank" rel="noopener">https://mxstbr.com/thoughts/streaming-ssr/</a></p><p>对于常规的流式 SSR，优化效果可能没有我们想象的那么明显。<strong>因为框架还是得等数据拉取完成之后才能开始渲染</strong>。因此，除非是比较复杂、长序列的 HTML 树，至上而下需要较长时间的渲染，否则效果并不明显。</p><p><br><br><br></p><p>优点</p><ul><li>相比普通响应，流式响应可以提前 TTFB 和 FCP, 浏览器不用空转等待，可以连续绘制。</li></ul><p>缺点</p><ul><li><strong>数据拉取是 TTFB/FCP 的主要阻塞原因。为了解决这个问题，下文的 <code>Selective Hydration</code> 如何巧妙地解决这个问题。</strong></li></ul><p><br><br><br><br><br></p><h2 id="selective-hydration-选择性水合"><a href="#selective-hydration-选择性水合" class="headerlink" title="Selective Hydration - 选择性水合"></a>Selective Hydration - 选择性水合</h2><p><img src="/images/render-patterns/Untitled%209.png" alt="Untitled"></p><p><code>选择性水合（Progressive Hydration）</code> 是 <code>渐进式水合(Progressive Hydration)</code> 和 <code>流式SSR(SSR with Streaming)</code> 的升级版。<strong>主要通过选择性地跳过‘<code>慢组件</code>’，避免阻塞，来实现更快的 HTML 输出， 从而让流式响应发挥应有的作用。</strong></p><blockquote><p><code>慢组件</code>通常指的是：需要异步获取数据、体积较大、或者是计算量比较复杂的组件。</p></blockquote><p>比较典型的<code>慢组件</code>是异步数据获取的组件, 如下图，未开启 Selective Hydration 的情况，会等待所有异步任务完成后才开始输出，而 Selective Hydration 可以跳过这些组件，等待它们就绪后，继续输出。</p><p><img src="/images/render-patterns/Untitled%2010.png" alt="Untitled"></p><p>我们可以在最新的 Next.js(当前是 13.4) 演示一下。</p><details><br> <summary>没有开启 Selective Hydration 的 Demo:</summary><br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function delay(time: number) &#123;</span><br><span class="line">  return new Promise((resolve) =&gt; setTimeout(resolve, time))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取关键数据</span><br><span class="line"> */</span><br><span class="line">function getCrucialData() &#123;</span><br><span class="line">  return delay(1000).then(() =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      data: Math.random(),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getData(time: number) &#123;</span><br><span class="line">  return delay(time).then(() =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      data: Math.random(),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Foo = async () =&gt; &#123;</span><br><span class="line">  const data = await getData(1000)</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;foo: &#123;data.data&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Bar = async () =&gt; &#123;</span><br><span class="line">  const data = await getData(2000)</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;bar: &#123;data.data&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 页面 🔴</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">export default async function WithoutSelective() &#123;</span><br><span class="line">  // 获取关键数据</span><br><span class="line">  const crucialData = await getCrucialData()</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Without Selective&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;This page is rendered without Selective Hydration.&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;crucial data: &#123;crucialData.data&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Foo&gt;&lt;/Foo&gt;</span><br><span class="line">      &lt;Bar&gt;&lt;/Bar&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>运行结果：浏览器等待响应的时间为 3s<br><img src="/images/render-patterns/Untitled%2011.png" alt="Untitled"><br>即所有<code>服务端组件（Server Component）</code> 就绪后才会有实际的内容输出。<br><br></details><p><br><br><br></p><p>开启 Selective Hydration 很简单，我们只需要用 Suspend 包裹起来，提示 React 这可能是一个‘慢组件’，可以跳过他：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default async function WithoutSelective() &#123;</span><br><span class="line">  // 获取关键数据</span><br><span class="line">  const crucialData = await getCrucialData()</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Without Selective&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;This page is rendered without Selective Hydration.&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;crucial data: &#123;crucialData.data&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Suspense fallback=&quot;foo loading&quot;&gt;</span><br><span class="line">        &lt;Foo&gt;&lt;/Foo&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">      &lt;Suspense fallback=&quot;bar loading&quot;&gt;</span><br><span class="line">        &lt;Bar&gt;&lt;/Bar&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>现在来看运行结果：</p><p><img src="/images/render-patterns/Untitled%2012.png" alt="Untitled"></p><p>明显 TTFB 提前了！但是完整的请求时间没变。</p><p><br></p><p>当 Foo 和 Bar 就绪后，Next.js 会将渲染结果写入流中。怎么做到的？</p><p><br></p><p>看一眼 HTML 就知道了：</p><p><img src="/images/render-patterns/Untitled%2013.png" alt="Untitled"></p><p>对于<code>慢组件</code>，React 会先渲染 Suspend 的 fallback 内容，并留一个插槽。</p><p>继续往下看，可以看到 Foo、Bar 的渲染结果：</p><p><img src="/images/render-patterns/Untitled%2014.png" alt="Untitled"></p><p>接着将渲染结果替换掉插槽。用于后续的水合。</p><p><br><br><br><br><br></p><p>总之，在服务端，Selective Hydration 在 SSR With Streaming 的基础上，通过选择性地跳过一些低优先级的慢组件来优化了 TTFB(主要的，相对于 FCP 等指标也优化了)，更快地向用户呈现页面。</p><p>在客户端 Selective Hydration 的运行过程同 Progressive Hydration 。</p><p>关于 Selective Hydration 细节，可以阅读以下文章：</p><ul><li><a href="https://github.com/reactwg/react-18/discussions/130" target="_blank" rel="noopener">New in 18: Selective Hydration</a></li><li><a href="https://github.com/reactwg/react-18/discussions/37" target="_blank" rel="noopener">New Suspense SSR Architecture in React 18</a></li></ul><p><br><br><br><br><br><br><br></p><h2 id="islands-architecture-岛屿架构"><a href="#islands-architecture-岛屿架构" class="headerlink" title="Islands Architecture - 岛屿架构"></a>Islands Architecture - 岛屿架构</h2><p><img src="/images/render-patterns/Untitled%2015.png" alt="Untitled"></p><p>近两年，<strong>去 JavaScript 成为一波小趋势</strong>，这其中的典型代表是 <code>Islands Architecture</code> (岛屿架构)和 <code>React Server Component</code>(RSC, React 服务端组件)。</p><p>它们主张是：<strong>在服务端渲染，然后去掉不必要 JavaScript</strong></p><p>岛屿架构的主要代表是 <code>Astro</code>。如上图，Astro 在服务端渲染后，<strong>默认情况下，在客户端侧没有客户端程序和水合的过程。而对于需要 JavaScript 增强，实现动态交互的组件，需要显式标记为岛屿。</strong></p><p><br></p><p>这有点类似 Progressive Hydration 的意思。但是还是有很大的差别：</p><ul><li>岛屿是在<code>去 JavaScript</code> 这个背景下的交互增强手段。按 Astro 解释是： 你可以将‘岛屿’想象成在一片由<em>静态（不可交互）的 HTML</em> 页面中的<em>动态岛屿</em></li><li>每个岛屿都是独立加载、局部水合。而 Progressive Hydration 是整棵树水合的分支，只不过延后了。</li><li>岛屿可以框架无关。</li></ul><p><br></p><p>去 JavaScript 后，可以缓解典型的 SSR <code>TTI</code> 问题。<strong>但是岛屿架构并不能通吃所有的场景，最擅长的是”内容为中心“的站点，即当静态的页面比重远高于动态比重时，去 JavaScript 的收益才是显著的。</strong></p><p><br><br><br><br><br></p><h2 id="react-server-component-react-服务端组件"><a href="#react-server-component-react-服务端组件" class="headerlink" title="React Server Component - React 服务端组件"></a>React Server Component - React 服务端组件</h2><p><img src="/images/render-patterns/Untitled%2016.png" alt="Untitled"></p><p>在笔者看来，<code>React Server Component(RSC)</code> 本质上和岛屿架构的目的是一样的，都是去 JavaScript。只是实现的手段不同。</p><p><br></p><p>这是 Next.js 官方文档的示例图：和岛屿架构类似，对于静态的内容推荐使用 <code>Server Component (SC),</code> 而需要交互增强的，可以使用 <code>Client Component (CC)</code>。</p><p><img src="/images/render-patterns/Untitled%2017.png" alt="Untitled"></p><p><br></p><p>顾名思义，RSC <strong>就是只能在服务端运行的组件</strong>。下面简单对比一下两者的区别：</p><table><thead><tr><th></th><th>Server Component</th><th>Client Component</th></tr></thead><tbody><tr><td>运行环境</td><td>服务端</td><td>- 服务端 + 客户端</td></tr><tr><td>- 仅客户端</td></tr><tr><td>JavaScript</td><td>服务端组件依赖的相关程序对客户端不可见。</td></tr><tr><td>在这里实现了 ‘去 JavaScript’</td><td>需要打包分发给客户端</td></tr><tr><td>水合</td><td>不需要水合</td><td>需要水合</td></tr><tr><td>支持 async</td><td>Y</td><td>N</td></tr><tr><td>支持状态(state, context)</td><td>N</td><td>Y</td></tr><tr><td>支持事件、副作用</td><td>N</td><td>Y</td></tr></tbody></table><blockquote><p>RSC 优点类似 React Hooks 出来之前的<a href="https://web.archive.org/web/20170621181013/https://facebook.github.io/react/docs/components-and-props.html" target="_blank" rel="noopener">函数组件</a>: 就是一个普通的函数，不能使用 hooks，没有状态，只会被调用一次。</p></blockquote><p>你可以通过 <a href="https://nextjs.org/docs/getting-started/react-essentials" target="_blank" rel="noopener">Next.js 的文档</a>，深入学习 RSC。React 官方的<a href="https://github.com/reactwg/server-components/discussions" target="_blank" rel="noopener">讨论组</a>也是不错的一手学习场地。</p><p><br><br><br></p><p><strong>那么相比岛屿架构呢？</strong></p><p>优点</p><ul><li>Server Component 和 Client Component 都是 React 框架的组件，尽管有些区别，但是心智模型是统一的。</li><li>React Server Component 是 React 框架下一体化的原生解决方案，支持和 Selective Hydration 配合使用。岛屿架构只是一个架构模式。</li><li>可以进行更细粒度和更灵活的组合。</li></ul><p>缺点</p><ul><li>Server Component 和 Client Component 还是有较大差别，在组合、通信上也有较多限制，需要开发者规划好服务端和客户端的边界。初期有一定上手门槛。<br>当然，Islands 可能也有类似的问题。</li></ul><p><br><br><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文篇幅较长，我给大家整理了这些渲染模式的发展历程和关系脉络</p><p><img src="/images/render-patterns/Untitled%2018.png" alt="Untitled"></p><p>任何技术的迭代都是有其动机和脉络。不推荐大家面向热度编程，大部分情况下，做到‘知其然，也知其所以然’，就足够了。</p><p><br><br><br><br><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://www.patterns.dev/posts/react-selective-hydration" target="_blank" rel="noopener">Pattern dev</a></li><li><a href="https://nextjs.org/docs/getting-started/react-essentials" target="_blank" rel="noopener">Next.js</a></li><li><a href="https://nextjs.org/docs/pages/building-your-application/data-fetching/incremental-static-regeneration" target="_blank" rel="noopener">Next.js Incremental Static RegenerationExamples</a></li><li><a href="https://github.com/reactwg/server-components/discussions" target="_blank" rel="noopener">reactwg/<strong>server-components</strong></a></li><li><strong><a href="https://dev.to/this-is-learning/is-0kb-of-javascript-in-your-future-48og" target="_blank" rel="noopener">Is 0kb of JavaScript in your Future?</a></strong></li><li><a href="https://jasonformat.com/islands-architecture/" target="_blank" rel="noopener">Islands Architecture</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文主要参考的内容来源是&lt;a href=&quot;https://www.patterns.dev/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;patterns.dev&lt;/a&gt;。这个网站收录了许多实用的前端设计模式，大家赶紧收藏起来！
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>岛屿架构</title>
    <link href="https://bobi.ink/2023/06/01/island-pattern/"/>
    <id>https://bobi.ink/2023/06/01/island-pattern/</id>
    <published>2023-05-31T16:00:00.000Z</published>
    <updated>2023-06-01T10:07:58.113Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1516091877740-fde016699f2c?ixlib=rb-4.0.3&amp;q=85&amp;fm=jpg&amp;crop=entropy&amp;cs=srgb&amp;w=6000" alt="https://images.unsplash.com/photo-1516091877740-fde016699f2c?ixlib=rb-4.0.3&amp;q=85&amp;fm=jpg&amp;crop=entropy&amp;cs=srgb&amp;w=6000"></p><p>好久没跟大家见面了。这两三年一直专注于公司的开发工作，做了很多事情，但回头看看，感觉这两年一直在吃 ’老本‘，前端相关的技术也没怎么追了。</p><p>现在重新捡起笔吧！补补课，记录一些最近学到的新东西，以及过去几年总结。</p><p>首先从岛屿架构开始吧。</p><h2 id="岛屿架构"><a href="#岛屿架构" class="headerlink" title="岛屿架构"></a>岛屿架构</h2><p>岛屿架构(<a href="https://www.patterns.dev/posts/islands-architecture" target="_blank" rel="noopener">Islands Architecture</a>) 如今已经不是新鲜的概念了，社区上已经有了较多成熟的方案。</p><p>概览图：</p><p><img src="/images/island-pattern/Untitled.png" alt="Untitled"></p><p><br><br><br><br><br></p><p>这其中的典型代表是 <a href="https://docs.astro.build/zh-cn/concepts/islands/" target="_blank" rel="noopener">Astro</a>。Astro 对岛屿架构的解释，也非常直观：</p><blockquote><p>“Astro 群岛“指的是<code>静态 HTML</code> 中的<code>交互性的 UI 组件</code>。一个页面上可以有多个岛屿，并且每个岛屿都被<code>独立呈现</code>。<strong>你可以将它们想象成在一片由静态（不可交互）的 HTML 页面中的动态岛屿</strong>。</p></blockquote><p>从上面这句话的定义中可以提炼一些要点：</p><ul><li>静态 HTML。</li><li>交互性的 UI 组件。</li><li>多个岛屿，支持独立呈现。</li></ul><p><br><br><br></p><p>为了解析这些要点，我们还是得简单了解一下 Astro 这个框架的特性。</p><p>Astro 宣称自己是 ‘<strong><code>zero-JS frontend architecture</code></strong>’，即 Astro 在服务端渲染静态 HTML，客户端中不需要加载额外的 JS 就能完整呈现内容。</p><p><br><br><br><br><br><br><br></p><hr><p>写一个简单 DEMO 试试：</p><p>React 组件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; useState &#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">export const Counter = () =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0)</span><br><span class="line"></span><br><span class="line">  return &lt;div onClick=&#123;() =&gt; setCount((i) =&gt; i + 1)&#125;&gt;click me to increment: &#123;count&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Astro 文件：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">import Layout from '../layouts/Layout.astro';</span><br><span class="line">import Card from '../components/Card.astro';</span><br><span class="line">import &#123; Counter &#125; from '../components/Counter';</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Layout</span> <span class="attr">title</span>=<span class="string">"Welcome to Astro."</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">role</span>=<span class="string">"list"</span> <span class="attr">class</span>=<span class="string">"link-card-grid"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Card</span></span></span><br><span class="line"><span class="tag">        <span class="attr">href</span>=<span class="string">"https://docs.astro.build/"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">title</span>=<span class="string">"Documentation"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">body</span>=<span class="string">"Learn how Astro works and explore the official API docs."</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Card</span></span></span><br><span class="line"><span class="tag">        <span class="attr">href</span>=<span class="string">"https://astro.build/integrations/"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">title</span>=<span class="string">"Integrations"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">body</span>=<span class="string">"Supercharge your project with new frameworks and libraries."</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  ...;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这语法，astro 集大家之所长，吸取了 Vue SFC 和 React 的 JSX, 还有 MDX。</p><p><img src="/images/island-pattern/Untitled%201.png" alt="Untitled"></p><p>运行后， 服务端直出 HTML，除了 HMR ，没有引入额外的 JavaScript。真 Zero JS!</p><p><br><br><br><br><br></p><hr><p>然而，这个有别于典型的 SSR 框架。SSR 也是在服务端渲染完整 HTML 树，但是在客户端依然需要加载完整的视图框架代码，然后进行水合(Hydration)，才能让页面变得可交互:</p><p><img src="/images/island-pattern/Untitled%202.png" alt="Untitled"></p><p>那 Astro 没有 JS，显然是无法与用户进行动态交互的。Astro 的解决办法就是 <code>岛屿架构</code>, 我们只需将需要动态交互的页面模块声明为岛屿，如下图，页头和图片轮播就是可交互的岛屿。</p><p><img src="/images/island-pattern/Untitled%203.png" width="400px"></p><p>来源：astro 文档</p><p><br><br><br><br><br><br><br></p><hr><p>现在将 React 组件声明为岛屿：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">---</span></span><br><span class="line">import Layout from '../layouts/Layout.astro';</span><br><span class="line">import Card from '../components/Card.astro';</span><br><span class="line">import &#123; Counter &#125; from '../components/Counter';</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"></span><br><span class="line">&lt;Layout title="Welcome to Astro."&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line"><span class="deletion">-    &lt;Counter/&gt;</span></span><br><span class="line"><span class="addition">+    &lt;Counter client:load /&gt;</span></span><br><span class="line">    &lt;ul role="list" class="link-card-grid"&gt;</span><br><span class="line">      &lt;Card</span><br><span class="line">        href="https://docs.astro.build/"</span><br><span class="line">        title="Documentation"</span><br><span class="line">        body="Learn how Astro works and explore the official API docs."</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Card</span><br><span class="line">        href="https://astro.build/integrations/"</span><br><span class="line">        title="Integrations"</span><br><span class="line">        body="Supercharge your project with new frameworks and libraries."</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">&lt;/Layout&gt;</span><br></pre></td></tr></table></figure><p>我们只需将对应的 React 组件加上 <code>client:load</code> 指令，Astro 就是将其识别为岛屿，该 React 组件的代码及其相关依赖会被打包到一起，在客户端端加载和水合。</p><p><img src="/images/island-pattern/Untitled%204.png" alt="Untitled"></p><p>现在我们的 Counter 组件在客户端就是一个可交互的状态了。Astro 基本上没有什么上手门槛，建议读者自己玩一下。有机会再展开讲一下它的实现原理。</p><hr><p><br><br><br><br><br></p><p>有了‘岛屿’赋能的 Astro 架构：</p><p><img src="/images/island-pattern/Untitled%205.png" alt="Untitled"></p><p>Astro 在服务端渲染完整的 HTML 树，然后在客户端中按需加载岛屿代码，并进行水合。看起来有点像微前端、或者 iframe 这样的机制。</p><p>现在来回顾一下开头提到的 <code>‘要点’</code>：</p><table><thead><tr><th></th><th>岛屿架构</th><th>SSR + CSR</th><th>CSR</th></tr></thead><tbody><tr><td>静态 HTML</td><td>静态 HTML 优先，无 JavaScript</td><td>服务端渲染 HTML 初始内容, 包含完整的客户端副本</td><td>完全在客户端加载渲染</td></tr><tr><td>交互性的 UI 组件</td><td>默认完全静态，通过岛屿局部增强可交互性</td><td>全局可交互</td><td>全局可交互</td></tr><tr><td>多个岛屿，支持独立呈现</td><td>岛屿之间互相独立，可以独立加载和交互</td><td>完整加载。可以通过代码分块 + <a href="https://www.patterns.dev/posts/progressive-hydration" target="_blank" rel="noopener">https://www.patterns.dev/posts/progressive-hydration</a> 实现按需加载</td><td>完整加载。可以通过代码分块实现按需加载</td></tr></tbody></table><p><br><br><br><br><br></p><h2 id="岛屿架构的优势"><a href="#岛屿架构的优势" class="headerlink" title="岛屿架构的优势"></a>岛屿架构的优势</h2><p>岛屿架构非常适合<code>以内容为中心</code>的网站，比如博客，文档网站，新闻网站等等。在 Astro 的定位非常清晰，它把站点类型分为两种：</p><ul><li>内容为中心 → 也称为 网站 → Astro 擅长</li><li>交互为中心的 → 也称为 Web 应用程序 → 应该使用 Next.js 或者 Nuxt.js 这样的框架</li></ul><p>在岛屿架构擅长的场景中，Astro 给出了比较：</p><ul><li><a href="https://twitter.com/t3dotgg/status/1437195415439360003" target="_blank" rel="noopener">Astro vs. SPA (Next.js)</a> - 94% less JavaScript</li><li><a href="https://twitter.com/jlengstorf/status/1442707241627385860?lang=en" target="_blank" rel="noopener">Astro vs. SPA (Next.js)</a> - 34% 更快地加载</li><li><a href="https://vanntile.com/blog/next-to-astro" target="_blank" rel="noopener">Astro vs. SPA (Next.js)</a> – 65% 网络使用减少</li><li><a href="https://www.youtube.com/watch?v=2ZEMb_H-LYE&amp;t=8163s" target="_blank" rel="noopener">Astro vs. SPA (Remix, SvelteKit)</a> - “这令人置信的 Google Lighthouse 分数”</li><li><a href="https://www.youtube.com/watch?v=2ZEMb_H-LYE&amp;t=8504s" target="_blank" rel="noopener">Astro vs. Qwik</a> - 43% 更快的 TTI</li></ul><p><br><br><br><br><br></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>岛屿架构本身概念并不复杂，是前端框架和工程化发展的一个阶段性质变结果。</p><p>前后端分离(分工上)还是不变的趋势，相比传统的 MPA ，岛屿架构更加现代化，拥有更好的开发体验。</p><p>相比 SPA，岛屿架构在<code>以内容为中心</code>的场景下，优势也非常明显。</p><p><br><br><br><br><br></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.patterns.dev/posts/islands-architecture" target="_blank" rel="noopener">Islands Architecture</a></li><li><a href="https://jasonformat.com/islands-architecture/" target="_blank" rel="noopener">Islands Architecture</a></li><li><a href="https://www.youtube.com/watch?v=k-A2VfuUROg" target="_blank" rel="noopener">Rendering on the Web: Performance Implications of Application Architecture</a></li><li><a href="https://dev.to/this-is-learning/is-0kb-of-javascript-in-your-future-48og" target="_blank" rel="noopener">Is 0kb of JavaScript in your Future?</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1516091877740-fde016699f2c?ixlib=rb-4.0.3&amp;amp;q=85&amp;amp;fm=jpg&amp;amp;crop=entropy&amp;amp;cs=srgb&amp;am
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Electron 低延迟视频流播放方案探索</title>
    <link href="https://bobi.ink/2020/04/05/video-stream/"/>
    <id>https://bobi.ink/2020/04/05/video-stream/</id>
    <published>2020-04-04T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.331Z</updated>
    
    <content type="html"><![CDATA[<p>好久不见，接近四个月没更新博客了! </p><p>去年<a href="https://juejin.im/post/5e0010866fb9a015fd69c645#comment" target="_blank" rel="noopener">最后一篇</a>文章介绍了我们的 Electron 桌面客户端的一些优化措施，这篇文章也跟我们正在开发的 Electron 客户端有一定关系。最近我们正在预研在 Electron 页面中实时播放会议视频流的方案。</p><p><br></p><p><img src="/images/video-push/conf.jpeg" alt></p><p><br></p><p>视频会议界面是最后一块没有被 Web 取代的页面, 它完全用原生开发的，所以开发效率比较低，比如要做一些动画效果开发很痛苦，难以响应多变的产品需求。所以我们在想: <strong>能不能将 Web 页面端来播放底层库 WebRTC 接收到的视频流</strong>? <strong>或者为什么不直接通过浏览器的 WebRTC API 来进行通讯呢</strong>？</p><p>先回答后者，因为我们视频会议这块的逻辑处理、音视频处理已经被抽取成独立的、跨平台的模块，统一进行维护；另外浏览器的 WebRTC API 提供的接口非常高级，就像一个黑盒一样，无法定制化、扩展，遇到问题也很难诊断和处理, 受限于浏览器。最大的原因还是变动有点大，时间上不允许。</p><p>因此目前只能选前者，即底层库给 Electron 页面推送视频流，在页面实时播放。 再此之前，笔者几乎没有接触过音视频开发，我能想到的是通过类似直播的方式，底层库作为”主播端”, Web 页面作为”观众端”。</p><p><img src="/images/video-push/overall.png" alt></p><p><br></p><p>因为视频流只是在本地进行转发，所以我们不需要考虑各种复杂的网络情况、带宽限制。唯一的要求是低延迟，低资源消耗：</p><ul><li>我们视频会议语音和视频是分离的。 只有一路混合语音，通过 SIP 传输。而会议视频则可能存在多路，使用 WebRTC 进行传输。我们不需要处理语音(由底层库直接播放), 这就要求我们的视频播放延迟不能太高, 出现语音和视频不同步。</li><li>不需要考虑浏览器兼容性。Electron 浏览器版本为 Chrome 80</li><li>本地转发，不需要考虑网络情况、带宽限制</li></ul><p><br><br><br></p><p><strong>最近因为工作需要才有机会接触到音视频相关的知识，我知道的只是皮毛，所以文章肯定存在不少问题，敬请斧正</strong>。下面，跟着音视频小白的我，一起探索探索有哪些方案。</p><p><br><br><br></p><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#①-典型的web直播方案">① 典型的Web直播方案</a><ul><li><a href="#rtmp-推流">RTMP 推流</a></li><li><a href="#rtmp-拉流">RTMP 拉流</a></li><li><a href="#rtmp-低延迟优化">RTMP 低延迟优化</a></li></ul></li><li><a href="#②-jsmpeg--broadwayjs">② JSMpeg &amp; BroadwayJS</a><ul><li><a href="#relay-服务器">Relay 服务器</a></li><li><a href="#推送">推送</a></li><li><a href="#视频播放">视频播放</a></li><li><a href="#多进程优化">多进程优化</a></li><li><a href="#简单说一下-broadwayjs">简单说一下 Broadway.js</a></li></ul></li><li><a href="#③-直接渲染-yuv">③ 直接渲染 YUV</a></li><li><a href="#扩展阅读">扩展阅读</a></li></ul><!-- /TOC --><p><br><br><br></p><h2 id="①-典型的web直播方案"><a href="#①-典型的web直播方案" class="headerlink" title="① 典型的Web直播方案"></a>① 典型的Web直播方案</h2><p>Web 直播有很多方案(参考这篇文章：<a href="https://imweb.io/topic/5a542e43a192c3b460fce3a8" target="_blank" rel="noopener">《Web 直播，你需要先知道这些》</a>):</p><ul><li><strong>RTMP (Real Time Messaging Protocol)</strong> 属于 Adobe。延时低，实时性较好。不过浏览器需要借助 Flash 才能播放; 但是我们也可以转换成 HTTP/Websocket 流喂给 <a href="https://github.com/bilibili/flv.js/tree/master/docs" target="_blank" rel="noopener"><code>flv.js</code></a> 实现播放。</li><li><strong>RTP (Real-time Transport Protocol)</strong> <a href="https://www.jianshu.com/p/17997567d828" target="_blank" rel="noopener">WebRTC 底层就基于 RTP/RTCP</a>。实时性非常好，适用于视频监控、视频会议、IP 电话。</li><li><strong>HLS (Http Live Streaming)</strong> 苹果提出的基于 HTTP 的流媒体传输协议。Safari 支持较好，高版本 Chrome 也支持，也有一些比较成熟的第三方方案。</li></ul><p><br></p><p>HLS 延迟太高，不符合我们的要求，所以一开始就放弃了。搜了很多资料，很多都是介绍 RTMP 的，可见 RTMP 在国内采用有多广泛, 因此我们打算试试:</p><p><br></p><p>首先是搭建 RMTP 服务器，可以直接基于 <a href="https://github.com/illuspas/Node-Media-Server" target="_blank" rel="noopener">Node-Media-Server</a>，代码很简单:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NodeMediaServer = <span class="built_in">require</span>(<span class="string">'node-media-server'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// RMTP 服务器, 用于RTMP 推流和拉流</span></span><br><span class="line">  rtmp: &#123;</span><br><span class="line">    port: <span class="number">1935</span>, <span class="comment">// 1935 是RTMP的标准端口</span></span><br><span class="line">    chunk_size: <span class="number">0</span>,</span><br><span class="line">    gop_cache: <span class="literal">false</span>,</span><br><span class="line">    ping: <span class="number">30</span>,</span><br><span class="line">    ping_timeout: <span class="number">60</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// HTTP / WebSocket 流，暴露给 flv.js</span></span><br><span class="line">  http: &#123;</span><br><span class="line">    port: <span class="number">8000</span>,</span><br><span class="line">    allow_origin: <span class="string">'*'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nms = <span class="keyword">new</span> NodeMediaServer(config)</span><br><span class="line">nms.run()</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="rtmp-推流"><a href="#rtmp-推流" class="headerlink" title="RTMP 推流"></a>RTMP 推流</h3><p><a href="http://www.ffmpeg.org" target="_blank" rel="noopener"><code>ffmpeg</code></a> 是音视频开发的必备神器，本文将通过它来捕获摄像头，进行各种转换和处理，最后进行视频流推送。 下面看看怎么用 ffmpeg 进行 RTMP 推流。</p><p>首先进行视频采集，下面命令列举所有支持的设备类型：</p><blockquote><p>本文的所有命令都在 macOS 下面执行, 其他平台用法差不多，自行搜索</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -devices</span></span><br><span class="line">Devices:</span><br><span class="line"> D. = Demuxing supported</span><br><span class="line"> .E = Muxing supported</span><br><span class="line"> --</span><br><span class="line"> D  avfoundation    AVFoundation input device</span><br><span class="line"> D  lavfi           Libavfilter virtual input device</span><br><span class="line">  E sdl,sdl2        SDL2 output device</span><br></pre></td></tr></table></figure><p><br></p><p><code>macOS</code> 下通常使用 <code>avfoundation</code> 进行设备采集, 下面列举当前终端所有支持的输入设备:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> fmpeg -f avfoundation -list_devices <span class="literal">true</span> -i <span class="string">""</span></span></span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] AVFoundation video devices:</span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] [0] FaceTime HD Camera</span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] [1] Capture screen 0</span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] AVFoundation audio devices:</span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] [0] Built-in Microphone</span><br><span class="line">[AVFoundation input device @ 0x7f8487425400] [1] Boom2Device</span><br></pre></td></tr></table></figure><p><br></p><p>我们将使用 <code>FaceTime HD Camera</code> 这个输入设备来采集视频，并推送 RTMP 流：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -r 30 -i <span class="string">"FaceTime HD Camera"</span> -c:v libx264 -preset superfast -tune zerolatency -an -f flv rtmp://localhost/live/<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p><br></p><p>稍微解释一下上面的命令:</p><ul><li><code>-f avfoundation -r 30 -i &quot;FaceTime HD Camera&quot;</code> 表示从 <code>FaceTime HD Camera</code> 中以 30 fps 的帧率采集视频</li><li><code>-c:v libx264</code> 输出视频的编码格式是 H.264,  RTMP 通常采用H.264 编码</li><li><code>-f flv</code> 指的视频的封包格式, RTMP 一般采用 flv 封包格式。</li><li><code>-an</code> 忽略音频流</li><li><code>-preset superfast -tune zerolatency</code> H.264 的转码预设参数和调优参数。会影响视频质量和压缩率</li></ul><p><br></p><blockquote><p><strong>封包格式(format)</strong>和<strong>编码(codec)</strong>是音视频开发中最基础的概念。<br><br><br><strong>封包格式</strong>: 相当于一种储存视频信息的容器，将编码好的音频、视频、或者是字幕、脚本之类的文件根据相应的规范组合在一起，从而生成一个封装格式的文件。常见的封包格式有 avi、mpeg、flv、mov 等<br><br><br><strong>编码格式</strong>: 编码主要的目的是为了压缩。从设备采集到的音视频流称为裸码流(rawvideo 格式, 即没有经过编码压缩处理的数据)。举例：一个 720p，30fps，60min 的电影，裸流大小为：12Bx1280x720x30x60x100 = 1.9T。这不管在文件系统上存储、还是在网络上传输，成本都太高了，所以我们需要编码压缩。 H264 是目前最常见的编码格式之一。</p></blockquote><p><br><br><br></p><h3 id="rtmp-拉流"><a href="#rtmp-拉流" class="headerlink" title="RTMP 拉流"></a>RTMP 拉流</h3><p>最简单的，我们可以使用 <a href="http://www.ffmpeg.org/ffplay.html" target="_blank" rel="noopener"><code>ffplay</code></a> (ffmpeg 提供的工具套件之一) 播放器来测试推流和拉流是否正常:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffplay rtmp://localhost/live/<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p><br></p><p>Flash 已经过时， 为了在 Web 页面中实现 RTMP 流播放，我们还要借助 <a href="https://github.com/bilibili/flv.js" target="_blank" rel="noopener"><code>flv.js</code></a>。 flvjs 估计大家都很熟悉(花边：如何看待哔哩哔哩的 flv.js 作者月薪不到 5000 元？)，它是 B 站开源的 flv 播放器。按照官方的介绍：</p><blockquote><p>flv.js works by transmuxing FLV file stream into ISO BMFF (Fragmented MP4) segments, followed by feeding mp4 segments into an HTML5 <code>&lt;video&gt;</code> element through <code>Media Source Extensions API</code>.</p></blockquote><p><br></p><p>上面提到，flv(Flash Video) 是一个视频封包格式，<code>flvjs</code> 做的就是<strong>把 flv 转换成 Fragmented MP4(ISO BMFF) 封包格式</strong>，然后喂给<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Media_Source_Extensions_API" target="_blank" rel="noopener">Media Source Extension API, MSE</a>, 接着我们将 MSE 挂载到 <code>&lt;video&gt;</code> 就可以直接播放了, 它的架构如下:</p><p><br></p><p><img src="/images/video-push/flv-arch.png" alt></p><p><br><br><br></p><p>flvjs 支持通过 HTTP Streaming、 WebSocket 或者自定义数据源等多种形式拉取二进制视频流。下面示例通过 flvjs 来拉取 <code>node-media-server</code> 的视频流:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/flv.js/1.5.0/flv.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;video id=<span class="string">"video"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span></span><br><span class="line">&lt;button id=<span class="string">"play"</span>&gt;play&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  if (flvjs.isSupported()) &#123;</span></span><br><span class="line"><span class="regexp">    const videoElement = document.getElementById('video');</span></span><br><span class="line"><span class="regexp">    const play = document.getElementById('play');</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    const flvPlayer = flvjs.createPlayer(</span></span><br><span class="line"><span class="regexp">      &#123;</span></span><br><span class="line"><span class="regexp">        type: 'flv',</span></span><br><span class="line"><span class="regexp">        isLive: true,</span></span><br><span class="line"><span class="regexp">        hasAudio: false,</span></span><br><span class="line"><span class="regexp">        url: 'ws:/</span><span class="regexp">/localhost:8000/</span>live/test.flv<span class="string">',</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        enableStashBuffer: true,</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    flvPlayer.attachMediaElement(videoElement);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    play.onclick = () =&gt; &#123;</span></span><br><span class="line"><span class="string">      flvPlayer.load();</span></span><br><span class="line"><span class="string">      flvPlayer.play();</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>完整示例代码在<a href="https://github.com/ivan-94/video-push/tree/master/rtmp" target="_blank" rel="noopener">这里</a></p></blockquote><p><br><br><br></p><h3 id="rtmp-低延迟优化"><a href="#rtmp-低延迟优化" class="headerlink" title="RTMP 低延迟优化"></a>RTMP 低延迟优化</h3><p><strong>推流端</strong></p><p><code>ffmpeg</code> 推流端可以通过一些控制参数来降低推流的延迟，主要优化方向是提高编码的效率、减少缓冲大小，当然有时候要牺牲一些代码质量和带宽。 这篇文章 <a href="https://blog.csdn.net/fireroll/article/details/51902018" target="_blank" rel="noopener">ffmpeg 的转码延时测试与设置优化</a> 总结了一些优化措施可以参考一下:</p><ul><li>关闭 sync-lookahead</li><li>降低 rc-lookahead，但别小于 10,默认是-1</li><li>降低 threads(比如从 12 降到 6)</li><li>禁用 rc-lookahead</li><li>禁用 b-frames</li><li>缩小 GOP</li><li>开启 x264 的 -preset fast/faster/verfast/superfast/ultrafast 参数</li><li>使用-tune zerolatency 参数</li></ul><p><br></p><p><strong>node-media-server</strong></p><p>NMS 也可以通过降低缓冲大小和<a href="https://github.com/ossrs/srs/wiki/v1_CN_LowLatency" target="_blank" rel="noopener">关闭 GOP Cache</a> 来优化延迟。</p><p><br></p><p><strong>flvjs 端</strong></p><p>flvjs 可以开启 <code>enableStashBuffer</code> 来提高实时性。 实际测试中，flvjs 可能会出现’累积延迟’现象，可以通过<a href="https://github.com/bilibili/flv.js/issues/258" target="_blank" rel="noopener">手动 seek</a>来纠正。</p><p><br><br><br></p><p>经过一番折腾，优化到最好的延迟是 400ms，往下就束手无策了(对这块熟悉的同学可以请教一下)。而且在对接到底层库实际推送时，播放效果并不理想，出现各种卡顿、延迟。由于时间和知识有限，我们很难定位到具体的问题在哪， 所以我们暂时放弃了这个方案。</p><p><br><br><br></p><h2 id="②-jsmpeg-amp-broadwayjs"><a href="#②-jsmpeg-amp-broadwayjs" class="headerlink" title="② JSMpeg &amp; BroadwayJS"></a>② JSMpeg &amp; BroadwayJS</h2><p>Jerry Qu 写得 <a href="https://imququ.com/post/html5-live-player-2.html" target="_blank" rel="noopener">《HTML5 视频直播（二）》</a> 给了我不少启发，得知了 <a href="https://github.com/phoboslab/jsmpeg" target="_blank" rel="noopener"><code>JSMpeg</code></a> 和 <a href="https://github.com/mbebenita/Broadway" target="_blank" rel="noopener"><code>Broadwayjs</code></a> 这些方案</p><p><strong>这两个库不依赖于浏览器的 video 的播放机制，使用纯 JS/WASM 实现视频解码器，然后直接通过 Canvas2d 或 WebGL 绘制出来</strong>。Broadwayjs 目前不支持语音，JSMpeg 支持语音(基于 WebAudio)。</p><p><br></p><p>经过简单的测试, 相比 RTMP， JSMpeg 和 BroadwayJS 延迟都非常低，基本符合我们的要求。下面简单介绍一下 JSMpeg 用法。Broadwayjs 用法差不多, 下文会简单带过。它们的基本处理过程如下：</p><p><br></p><p><img src="/images/video-push/jsmpeg.png" alt></p><p><br></p><h3 id="relay-服务器"><a href="#relay-服务器" class="headerlink" title="Relay 服务器"></a>Relay 服务器</h3><p>因为 ffmpeg 无法向 Web 直接推流，因此我们还是需要创建一个中转（relay）服务器来接收视频推流，再通过 WebSocket 转发给页面播放器。</p><p>ffmpeg 支持 HTTP、TCP、UDP 等各种推流方式。HTTP 推流更方便我们处理, 因为是本地环境，这些网络协议不会有明显的性能差别。</p><p>下面创建一个 HTTP 服务器来接收推流，推送路径是 <code>/push/:id</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.server = http</span><br><span class="line">  .createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = req.url || <span class="string">'/'</span></span><br><span class="line">    <span class="keyword">if</span> (!url.startsWith(<span class="string">'/push/'</span>)) &#123;</span><br><span class="line">      res.statusCode = <span class="number">404</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> id = url.slice(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止超时</span></span><br><span class="line">    res.connection.setTimeout(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转发出去</span></span><br><span class="line">    req.on(<span class="string">'data'</span>, (c) =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.broadcast(id, c)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    req.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(port)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>接着通过 <code>WebSocket</code> 将流转发出去, 页面可以通过 <code>ws://localhost:PORT/pull/{id}</code> 拉取视频流:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 webSocket 拉取流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">this</span>.wss = <span class="keyword">new</span> ws.Server(&#123;</span><br><span class="line">  server: <span class="keyword">this</span>.server,</span><br><span class="line">  <span class="comment">// 通过 /pull/&#123;id&#125; 拉流</span></span><br><span class="line">  verifyClient: <span class="function">(<span class="params">info, cb</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (info.req.url &amp;&amp; info.req.url.startsWith(<span class="string">'/pull'</span>)) &#123;</span><br><span class="line">      cb(<span class="literal">true</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cb(<span class="literal">false</span>, <span class="literal">undefined</span>, <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.wss.on(<span class="string">'connection'</span>, (client, req) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> url = req.url</span><br><span class="line">  <span class="keyword">const</span> id = url.slice(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;prefix&#125;</span>new player attached: <span class="subst">$&#123;id&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> buzy = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> listener = &#123;</span><br><span class="line">    id,</span><br><span class="line">    onMessage: <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 推送</span></span><br><span class="line">      <span class="keyword">if</span> (buzy) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      buzy = <span class="literal">true</span></span><br><span class="line">      client.send(data, &#123; <span class="attr">binary</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span> <span class="title">ack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        buzy = <span class="literal">false</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.attachListener(listener)</span><br><span class="line"></span><br><span class="line">  client.on(<span class="string">'close'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;prefix&#125;</span> player dettached: <span class="subst">$&#123;id&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">this</span>.detachListener(listener)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p>这里同样使用 ffmpeg 作为推送示例:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -r 30 -i <span class="string">"FaceTime HD Camera"</span> -f mpegts -codec:v mpeg1video -an  -bf 0 -b:v 1500k -maxrate 2500k http://localhost:9999/push/<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p>稍微解释一下 ffmpeg 命令</p><ul><li><code>-f mpegts -codec:v mpeg1video -an</code> 指定使用 MPEG-TS 封包格式， 并使用 mpeg1 视频编码，忽略音频</li><li><code>-bf 0</code> JSMpeg 解码器暂时不能正确地处理 B 帧。所以这些将 B 帧禁用。关于什么是 I/B/P 帧, 参考这篇<a href="https://www.jianshu.com/p/b3d1004229db" target="_blank" rel="noopener">文章</a></li><li><code>-b:v 1500k -maxrate 2500k</code> 设置推流的平均码率和最大码率。经过测试，JSMpeg 码率过高容易出现花屏和数组越界崩溃。</li></ul><p>另外 JSMpeg 还要求，视频的宽度必须是 2 的倍数。ffmpeg 可以通过滤镜(filter)或设置视频尺寸(-s)来解决这个问题, 不过多余转换都要消耗一定 CPU 资源的：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i in.mp4 -f mpeg1video -vf "crop=iw-mod(iw\,2):ih-mod(ih\,2)" -bf 0 out.mpg</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"video-canvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jsmpeg.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'video-canvas'</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> url = <span class="string">'ws://localhost:9999/pull/test'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> player = <span class="keyword">new</span> JSMpeg.Player(url, &#123;</span></span><br><span class="line"><span class="undefined">    canvas: canvas,</span></span><br><span class="line"><span class="javascript">    audio: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">    pauseWhenHidden: <span class="literal">false</span>,</span></span><br><span class="line"><span class="undefined">    videoBufferSize: 8 * 1024 * 1024,</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>API 很简单，上面我们传递一个画布给 JSMpeg，禁用了 Audio, 并设置了一个较大的缓冲区大小, 来应对一些码率波动。</p><p><br></p><blockquote><p>完整代码见<a href="https://github.com/ivan-94/video-push/tree/master/jsmpeg" target="_blank" rel="noopener">这里</a></p></blockquote><p><br><br><br></p><h3 id="多进程优化"><a href="#多进程优化" class="headerlink" title="多进程优化"></a>多进程优化</h3><p>实际测试下来，JSMpeg 视频延迟在 100ms - 200ms 之间。当然这还取决于视频的质量、终端的性能等因素。</p><p>受限于终端性能以及解码器效率, 对于平均码率(笔者粗略测试大概为 2000k)较高的视频流，JSMpeg 有很大概率会出现花屏或者内存访问越界问题(memory access out of bounds)。</p><p><img src="/images/video-push/jsmpeg-problems.png" alt></p><p><br></p><p>因此我们不得不通过压缩视频的质量、降低视频分辨率等手段来降低视频码率。然而这并不能根本解决问题，这是使用 JSMpeg 的痛点之一。详见<a href="https://github.com/phoboslab/jsmpeg#performance-considerations" target="_blank" rel="noopener">JSMpeg 的性能说明</a></p><p><br></p><p>因为解码本身是一个 CPU 密集型的操作，且由浏览器来执行，CPU 占用还是挺高的(笔者机器单个页面单个播放器, CPU 占用率在 16%左右)，而且 JSMpeg 播放器一旦异常崩溃会难以恢复。</p><p>在我们的实际应用场景中，一个页面可能会播放多路视频, 如果所有视频都在浏览器主进程中进行解码渲染，页面操作体验会很差。 所以最好是将 JSMpeg 分离到 Worker 中, <strong>一来保证主进程可以响应用户的交互，二来 JSMpeg 崩溃不会连累主进程</strong>。</p><p>好在将 JSMpeg 放在 Worker 中执行容易: Worker 中支持独立 WebSocket 请求，另外 Canvas 通过 <code>transferControlToOffscreen()</code> 方法创建 <code>OffscreenCanvas</code> 对象并传递给 Worker，实现 canvas 离屏渲染。</p><p>先来看看 <code>worker.js</code>, 和上面的代码差不多，主要是新增了 worker 通讯:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">importScripts(<span class="string">'./jsmpeg.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.window = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'message'</span>, (evt) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = evt.data</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (data.type) &#123;</span><br><span class="line">    <span class="comment">// 创建播放器</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'create'</span>:</span><br><span class="line">      <span class="keyword">const</span> &#123; url, canvas, ...config &#125; = data.data</span><br><span class="line">      <span class="keyword">this</span>.id = url</span><br><span class="line">      <span class="keyword">this</span>.player = <span class="keyword">new</span> JSMpeg.Player(url, &#123;</span><br><span class="line">        canvas,</span><br><span class="line">        audio: <span class="literal">false</span>,</span><br><span class="line">        pauseWhenHidden: <span class="literal">false</span>,</span><br><span class="line">        videoBufferSize: <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>,</span><br><span class="line">        ...config,</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁播放器</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'destroy'</span>:</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.player) &#123;</span><br><span class="line">          <span class="keyword">this</span>.player.destroy()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.postMessage(&#123; <span class="attr">type</span>: <span class="string">'destroyed'</span> &#125;)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(LOGGER_FREFIX + <span class="string">'销毁失败: '</span>, global.id, err)</span><br><span class="line">        <span class="keyword">this</span>.postMessage(&#123;</span><br><span class="line">          type: <span class="string">'fatal'</span>,</span><br><span class="line">          data: err,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就绪</span></span><br><span class="line"><span class="keyword">this</span>.postMessage(&#123; <span class="attr">type</span>: <span class="string">'ready'</span>, <span class="attr">data</span>: &#123;&#125; &#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>再来看看主进程, 通过 <code>transferControlToOffscreen()</code> 生成离屏渲染画布，让 JSMpeg 可以无缝迁移到 Worker:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.getElementById(<span class="string">'video'</span>)</span><br><span class="line"><span class="keyword">const</span> wk = <span class="keyword">new</span> Worker(<span class="string">'./jsmpeg.worker.js'</span>)</span><br><span class="line"></span><br><span class="line">wk.onmessage = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> data = evt.data</span><br><span class="line">  <span class="keyword">switch</span> (data.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ready'</span>:</span><br><span class="line">      <span class="comment">// 创建 OffscreenCanvas 对象</span></span><br><span class="line">      <span class="keyword">const</span> oc = video.transferControlToOffscreen()</span><br><span class="line"></span><br><span class="line">      wk.postMessage(</span><br><span class="line">        &#123;</span><br><span class="line">          type: <span class="string">'create'</span>,</span><br><span class="line">          data: &#123;</span><br><span class="line">            canvas: oc,</span><br><span class="line">            url: <span class="string">'ws://localhost:9999/pull/test'</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        [oc] <span class="comment">// 注意这里</span></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="简单说一下-broadway-js"><a href="#简单说一下-broadway-js" class="headerlink" title="简单说一下 Broadway.js"></a>简单说一下 Broadway.js</h3><p>还有一个类似 JSMpeg 的解决方案 ———— <a href="https://github.com/mbebenita/Broadway" target="_blank" rel="noopener">Broadwayjs</a>。 它是一个 <code>H.264</code> 解码器, 通过 <a href="https://github.com/emscripten-core/emscripten" target="_blank" rel="noopener"><code>Emscripten</code></a> 工具从 Android 的 H.264 解码器转化而成。它支持接收 H.264 裸流，不过也有一些限制：不支持 <a href="https://github.com/mbebenita/Broadway#encoding-video" target="_blank" rel="noopener"><code>weighted prediction for P-frames</code> &amp; <code>CABAC entropy encoding</code></a>。</p><p><br></p><p>推送示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation  -r 30 -i <span class="string">"FaceTime HD Camera"</span>  -f rawvideo -c:v libx264 -pix_fmt yuv420p -vprofile baseline -tune zerolatency -coder 0 -bf 0 -flags -loop -wpredp 0 -an  http://localhost:9999/push/<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p><br><br><br></p><p>客户端示例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.getElementById(<span class="string">'video'</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="string">`ws://localhost:9999/pull/test`</span></span><br><span class="line"><span class="keyword">const</span> player = <span class="keyword">new</span> Player(&#123;</span><br><span class="line">  canvas: video,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(url)</span><br><span class="line">ws.binaryType = <span class="string">'arraybuffer'</span></span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = evt.data</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data !== <span class="string">'string'</span>) &#123;</span><br><span class="line">    player.decode(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(data))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get command from server: '</span>, data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>完整代码看<a href="https://github.com/ivan-94/video-push/tree/master/broadway" target="_blank" rel="noopener">这里</a></p></blockquote><p>经过测试，同等质量和尺寸的视频流 JSMpeg 和 Broadway CPU 消耗差不多。但是 Broadway 视频流不受码率限制，没有花屏和崩溃现象。当然, 对于高质量视频, ffmpeg 转换和 Broadway 播放, 资源消耗都非常惊人。</p><p><br></p><p>其他类似的方案:</p><ul><li><a href="https://github.com/ChihChengYang/wfs.js" target="_blank" rel="noopener">wfs</a> html5 player for raw h.264 streams.</li></ul><p><br><br><br></p><h2 id="③-直接渲染-yuv"><a href="#③-直接渲染-yuv" class="headerlink" title="③ 直接渲染 YUV"></a>③ 直接渲染 YUV</h2><p><strong>回到文章开始，其实底层库从 WebRTC 中拿到的是 YUV 的原始视频流, 也就是没有经过编码压缩的一帧一帧的图像。上文介绍的方案都有额外的解封包、解编码的过程，最终输出的也是 YUV 格式的视频帧，它们的最后一步都是将这些 YUV 格式视频帧转换成 RGB 格式，渲染到 Canvas 中</strong>。</p><p><strong>那能不能将原始的 YUV 视频帧直接转发过来，直接在 Cavans 上渲染不就得了</strong>？ 将去掉中间的解编码过程, 效果怎样？试一试。</p><p><br></p><blockquote><p>此前已经有文章做过这方面的尝试: <a href="https://juejin.im/post/5de29d7be51d455f9b335efa" target="_blank" rel="noopener">《IVWEB 玩转 WASM 系列-WEBGL YUV 渲染图像实践》</a>。我们参考它搞一个。</p></blockquote><p>至于什么是 <code>YUV</code>，我就不科普, 自行搜索。 YUV 帧的大小可以根据这个公式计算出来： <code>(width * height * 3) &gt;&gt; 1</code>,<br><strong>即 <code>YUV420p</code> 的每个像素占用 1.5 bytes</strong>。</p><p>因此我们只需要知道视频的大小, 就可以切割视频流，将视频帧分离出来了。 下面新建一个中转服务器来接收推流, 在这里将 YUV 裸流切割成一帧一帧图像数据，下发给浏览器：</p><p><br></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> parsed = <span class="keyword">new</span> URL(<span class="string">'http://host'</span> + url)</span><br><span class="line">  <span class="keyword">let</span> id = parsed.searchParams.get(<span class="string">'id'</span>),</span><br><span class="line">    width = parsed.searchParams.get(<span class="string">'width'</span>),</span><br><span class="line">    height = parsed.searchParams.get(<span class="string">'height'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nwidth = <span class="built_in">parseInt</span>(width)</span><br><span class="line">  <span class="keyword">const</span> nheight = <span class="built_in">parseInt</span>(height)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> frameSize = (nwidth * nheight * <span class="number">3</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按照字节大小切割流</span></span><br><span class="line">  <span class="keyword">const</span> stream = req.pipe(<span class="keyword">new</span> Splitter(frameSize))</span><br><span class="line"></span><br><span class="line">  stream.on(<span class="string">'data'</span>, (c) =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.broadcast(id, c)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/ivan-94/video-push/blob/master/yuv/size-split.js" target="_blank" rel="noopener"><code>Splitter</code></a> 根据固定字节大小切割 Buffer。 </p><p><br></p><p>如果渲染 YUV ？ 可以参考 <a href="https://github.com/phoboslab/jsmpeg/blob/master/src/webgl.js" target="_blank" rel="noopener">JSMpeg WebGL 渲染器</a>, <a href="https://github.com/mbebenita/Broadway/blob/master/Player/YUVCanvas.js" target="_blank" rel="noopener">Broadway.js WebGL 渲染器</a>。 具体如何渲染就不展开了， 下面直接将 Broadway.js 的 <a href="https://github.com/mbebenita/Broadway/blob/master/Player/YUVCanvas.js" target="_blank" rel="noopener"><code>YUVCanvas.js</code></a> 直接拿过来用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> YUVCanvas(&#123;</span><br><span class="line">  canvas: video,</span><br><span class="line">  type: <span class="string">'yuv420'</span>,</span><br><span class="line">  width: width,</span><br><span class="line">  height: height,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 WebSocket 接收 YUV 帧. 并抽取出 YUV 分量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ylen = width * height</span><br><span class="line">  <span class="keyword">const</span> uvlen = (width / <span class="number">2</span>) * (height / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  renderer.render(</span><br><span class="line">    buff.subarray(<span class="number">0</span>, ylen),</span><br><span class="line">    buff.subarray(ylen, ylen + uvlen),</span><br><span class="line">    buff.subarray(ylen + uvlen, ylen + uvlen + uvlen),</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><blockquote><p>需要注意的是：JSMpeg 和 Broadway 的 Canvas 渲染都要求视频的宽度必须是 8 的倍数。不符合这个要求的会报错，<a href="https://juejin.im/post/5de29d7be51d455f9b335efa" target="_blank" rel="noopener">《IVWEB 玩转 WASM 系列-WEBGL YUV 渲染图像实践》</a> 处理了这个问题。</p></blockquote><p><br></p><p>最后看看 ffmpeg 推送示例:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -r 30 -i <span class="string">"FaceTime HD Camera"</span> -f rawvideo -c:v rawvideo -pix_fmt yuv420p <span class="string">"http://localhost:9999/push?id=test&amp;width=320&amp;height=240"</span></span></span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>完整代码看<a href="https://github.com/ivan-94/video-push/tree/master/yuv" target="_blank" rel="noopener">这里</a></p></blockquote><p><br><br><br></p><p>下面看看简单资源消耗对比。 笔者设备是 15 款 Macboook pro, 视频源采集自摄像头，分辨率 320x240、像素格式 uyvy422、帧率 30。</p><p><em>下表 <code>J</code> 表示 <code>JSMpeg</code>、<code>B</code> 表示 <code>Broadway</code>、<code>Y</code> 表示 <code>YUV</code></em></p><table><thead><tr><th></th><th>CPU (J/B/Y)</th><th>内存 (J/B/Y)</th><th>平均码率 (J/B/Y)</th></tr></thead><tbody><tr><td>ffmpeg</td><td>9% / 9% / 5%</td><td>12MB / 12MB / 9MB</td><td>1600k / 200k / 27000k</td></tr><tr><td>服务器</td><td>0.6% / 0.6% /1.4%</td><td>18MB / 18MB / 42MB</td><td>N/A</td></tr><tr><td>播放器</td><td>16% / 13% / 8%</td><td>70MB / 200MB / 50MB</td><td>N/A</td></tr></tbody></table><p><br></p><p>从结果来看，直接渲染 YUV 综合占用的资源最少。因为没有经过压缩，码率也是非常高的，不过本地环境不受带宽限制，这个问题也不大。我们还可以利用<code>requestAnimationFrame</code> 由浏览器来调度播放的速率，丢掉积累的帧，保持低延迟播放。</p><p><br><br><br></p><p>本文完</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://juejin.im/post/5ab851b6f265da23826df601" target="_blank" rel="noopener">直播原理与 web 直播实战</a></li><li><a href="https://juejin.im/post/5de29d7be51d455f9b335efa" target="_blank" rel="noopener">IVWEB 玩转 WASM 系列-WEBGL YUV 渲染图像实践</a></li><li><a href="https://github.com/ossrs/srs/wiki/v1_CN_LowLatency" target="_blank" rel="noopener">低延时直播应用</a></li><li><a href="https://zhuanlan.zhihu.com/p/100519553" target="_blank" rel="noopener">基于 H5 的直播协议和视频监控方案</a></li><li><a href="https://imququ.com/post/html5-live-player-2.html" target="_blank" rel="noopener">HTML5 视频直播（二）</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久不见，接近四个月没更新博客了! &lt;/p&gt;
&lt;p&gt;去年&lt;a href=&quot;https://juejin.im/post/5e0010866fb9a015fd69c645#comment&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最后一篇&lt;/a&gt;文章介绍
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>分享这半年的 Electron 应用开发和优化经验</title>
    <link href="https://bobi.ink/2019/12/16/electron/"/>
    <id>https://bobi.ink/2019/12/16/electron/</id>
    <published>2019-12-15T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>2019 年最后一发，谈谈这半年 Electron 应用开发和优化心得。干货也挺多，希望能给你带来一点启发。</p><p>下半年可以拿出来说一说的项目，估计就是我们用 Electron 重构了一个桌面端应用。这个应用类似于<code>钉钉</code>或者<code>企业微信</code>，主要功能有即时通信、语音/视频、会议，基本功能和交互体验和 PC 端微信差不多(其实就是模仿)，具体细节就不展开了, 这些对本文不重要。如下图</p><p><br></p><p><img src="/images/electron/mygzb.jpeg" alt></p><p><br></p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#为什么选择-electron">为什么选择 Electron?</a></li><li><a href="#进程模型">进程模型</a></li><li><a href="#技术选型与代码组织">技术选型与代码组织</a></li><li><a href="#性能优化硬货">性能优化(硬货)</a><ul><li><a href="#1-性能分析">1. 性能分析</a></li><li><a href="#2-优化策略">2. 优化策略</a><ul><li><a href="#21-继续和白屏作斗争">2.1 继续和白屏作斗争</a></li><li><a href="#22-追赶原生的交互体验">2.2 追赶原生的交互体验</a></li><li><a href="#23-优化进程通信">2.3 优化进程通信</a></li></ul></li></ul></li><li><a href="#坑还是会有的">坑还是会有的</a></li><li><a href="#扩展资料">扩展资料</a></li></ul><!-- /TOC --><p><br></p><h2 id="为什么选择-electron"><a href="#为什么选择-electron" class="headerlink" title="为什么选择 Electron?"></a>为什么选择 Electron?</h2><p>原因也很简单: <strong>我们的应用要兼容多个平台，原生开发效率低，我们没有资源</strong>。</p><p>说了跟白说一样，大部分选择 Electron 框架的动机都是差不多的，无非就是穷，尤其是在夹缝中生存的企业。</p><p>为了优化客户端开发资源，<strong>‘混合化’成为了我们今年客户端重构的主题</strong>。</p><p>先来看一下我们现在的客户端基本架构:</p><p><img src="/images/electron/client-arch.png" alt></p><p><br></p><p>混合化对我们来说有两层意思:</p><ol><li>我们的应用架构’混合’了多种技术。通用底层 C/C++, 平台原生(iOS, Android, PC, MacOS)，Web 技术</li><li>跨平台</li></ol><p><br></p><p>基于我们原有的客户端基础和情况，混合化重构自然而然分化为了两个方向:</p><ol><li><strong>业务下沉</strong>。将通用的、核心的业务下沉。例如消息处理、语音/视频、会议、数据存储等核心模块, 核心协议是 XMPP、SIP。这些模块变动频率较低、对性能要求也比较高，而且有跨平台需求，因此适合用 C/C++ 来实现。</li><li><strong>UI 混合</strong>。视图层混合化目前也有较多的解决方案，例如 Electron、React Native、Flutter、或者是 HTML Hybrid。我们选择先从 Electron 开始，因为它在桌面端开发中已经有非常成熟的表现，市场上也有很多大型的 Electron 应用，例如 VSCode、Atom、Slack。在移动端，我们对 React Native 和 Flutter 还比较保守，后续可能会进行尝试。</li></ol><p><br></p><p>理解了我们的动机，现在再看上面的图, 应该就好理解多了, 这是典型的三层结构, 和 MVC 非常相似：</p><ul><li><strong>M – 通用混合层</strong>。 C/C++ 封装核心、通用的业务模块以及业务数据存储。</li><li><strong>V – UI 层</strong>。视图层，使用跨平台视图解决方案，对于性能要求较高的部分使用原生实现。比如 Electron</li><li><strong>C – 平台桥接层</strong>。介于 M 和 V 之间，桥接<code>通用混合层</code>接口，同时也为 UI 层暴露一些<strong>平台相关</strong>的特性。比如在桌面端，这里会通过 Node 原生模块桥接通用混合层, 同时也补充一些 Electron 缺失或不完美的功能。</li></ul><p><br><br><br></p><h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><p>Electron 的主从进程模型是基本的常识。每个 Electron 应用有且只要一个主进程(Main Process)、以及一个或多个渲染进程(Renderer Process), 对应多个 Web 页面。除此之外还有 GPU 进程、扩展进程等等。可以通过 <a href="https://electronjs.org/docs/tutorial/application-architecture#main-and-renderer-processes" target="_blank" rel="noopener">Electron Application Architecture</a> 了解 Electron 的基本架构。</p><p>主进程负责创建页面窗口、协调进程间通信、事件分发。为了安全考虑，原生 GUI 相关的 API 是无法在渲染进程直接访问的，它们必须通过 IPC 调用主进程。<strong>这种主从进程模型缺点也非常明显，即主进程单点故障。主进程崩溃或者阻塞，会影响整个应用的响应</strong>。比如主进程跑长时间的 CPU 任务，将阻塞渲染进程的用户交互事件。</p><p><br></p><p>对我们的应用来说，目前有以下进程, 以及它们的职责:</p><p><strong>① 主进程</strong></p><ul><li>进程间通信、窗口管理</li><li>全局通用服务。</li><li>一些只能或适合在主进程做的事情。例如浏览器下载、全局快捷键处理、托盘、session。</li><li>维护一些必要的全局状态</li><li>上面说的<code>通用混合层</code>也跑在这个进程。通过 Node C++ 插件暴露接口。</li></ul><p><br></p><p><strong>② 渲染进程</strong></p><p>负责 Web 页面的渲染, 具体页面的业务处理。</p><p><br></p><p><strong>③ Service Worker</strong></p><p>负责静态资源缓存。缓存一些网络图片、音频。保证静态资源的稳定加载。</p><p><br><br><br></p><h2 id="技术选型与代码组织"><a href="#技术选型与代码组织" class="headerlink" title="技术选型与代码组织"></a>技术选型与代码组织</h2><p>说说我们的技术选型。</p><ul><li>UI 框架 - <code>React</code></li><li>状态管理 - <code>Mobx</code></li><li>国际化 - <code>i18next</code></li><li>打包 - <code>自研 CLI</code></li></ul><p><br></p><p>源码组织</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bridge/                  # 桥接层代码</span><br><span class="line">resources/               # 构建资源，以及第三方DLL</span><br><span class="line">src/</span><br><span class="line"></span><br><span class="line">  main/                  # 🔴主进程代码</span><br><span class="line">    services/            # 📡**通过 RPC 暴露给渲染进程的全局服务**</span><br><span class="line">      tray.ts            # 托盘状态管理</span><br><span class="line">      shortcut.ts        # 全局快捷键分发</span><br><span class="line">      preferences.ts     # 用户配置管理</span><br><span class="line">      windows.ts         # 窗口管理</span><br><span class="line">      screen-capture.ts  # 截屏</span><br><span class="line">      bridge.ts          # 桥接层接口封装</span><br><span class="line">      context-menu.ts    # 右键菜单</span><br><span class="line">      state.ts           # 全局状态管理, 保存一些必要的全局状态，例如主题、当前语言、当前用户</span><br><span class="line">      ...</span><br><span class="line">    lib/                 # 封装库</span><br><span class="line">      bridge.ts          # 桥接层API 分装</span><br><span class="line">      logger.ts          # 日志</span><br><span class="line">      ...</span><br><span class="line">    bootstrap.ts         # 启动程序</span><br><span class="line">    index.ts             # 🔴入口文件</span><br><span class="line"></span><br><span class="line">  renderer/              # 🔴渲染进程</span><br><span class="line">    services/            # 📡主进程的全局服务的客户端</span><br><span class="line">      windows.ts         # 窗口管理客户端</span><br><span class="line">      tray.ts</span><br><span class="line">      ...</span><br><span class="line">    assets/              # 静态资源</span><br><span class="line">    hooks/               # React Hooks</span><br><span class="line">    components/          # 通用组件</span><br><span class="line">      Webview</span><br><span class="line">      Editor</span><br><span class="line">      toast</span><br><span class="line">      ...</span><br><span class="line">    pages/               # 🔴页面</span><br><span class="line">      Home</span><br><span class="line">        ui/              # 🔴视图代码，由前端团队维护</span><br><span class="line">        store/           # 🔴状态代码，由客户端团队维护，前端Store的公开状态</span><br><span class="line">        translation/     # 国际化翻译文件</span><br><span class="line">        index.tsx        # 页面入口</span><br><span class="line">      Settings</span><br><span class="line">      Login</span><br><span class="line">    page.json            # 🔴声明所有页面及页面配置。类似小程序</span><br></pre></td></tr></table></figure><p><br></p><p>眼尖的读者会发现每个页面下有 <code>ui</code> 和 <code>store</code> 目录，分别对应视图和状态。为什么这么划分？</p><p>首先这是因为这个项目由两个团队共同来开发的，即原有的原生客户端团队和我们的前端团队。分离视图和状态有两个好处:</p><ul><li>前端前期不需要关心客户端底层业务，而客户端也不需要关心前端的页面实现。职责明确，各自干好自己事情。</li><li>降低学习成本。我们状态管理选用了 Mobx，对于客户端同学，只需要掌握少量的 Typescript 语言知识就可以马上上手。如果熟悉 Java、C# 那就更没什么问题了。每个 Store 只是一个简单的类：</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> CounterStore <span class="keyword">extends</span> MobxStore &#123;</span><br><span class="line">  <span class="meta">@observable</span></span><br><span class="line">  <span class="keyword">public</span> count: <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@action</span></span><br><span class="line">  <span class="keyword">public</span> incr = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.count++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> pageReady() &#123;</span><br><span class="line">    <span class="comment">// 页面就绪，可以在这里做一些准备工作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件监听</span></span><br><span class="line">    <span class="comment">// addDisposer 将释放函数添加到队列中，在页面退出时释放</span></span><br><span class="line">    <span class="keyword">this</span>.addDisposer(</span><br><span class="line">      addListener(<span class="string">'someevent'</span>, <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.dosomething(evt)</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.initial()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> pageWillClose() &#123;</span><br><span class="line">    <span class="comment">// 页面释放，可以在这里做一些资源释放</span></span><br><span class="line">    releaseSomeResource()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>使用 Mobx 作为状态管理，相比 Redux，面向对象思想对他们更好理解。在这种场景，简单才是真理；</p><p>分离了状态和业务逻辑，前端页面实现也简化了，视图只是状态的映射，这让我们的页面和组件更好被维护和复用。</p><p><br><br><br></p><h2 id="性能优化-硬货"><a href="#性能优化-硬货" class="headerlink" title="性能优化(硬货)"></a>性能优化(硬货)</h2><p>前戏完了，关于 Electron 的一些性能优化才是本篇文章的重头戏。</p><p>Electron 不是银弹，鱼和熊掌不可兼得。Electron 带来开发效率的提升，其本身也有很多硬伤，譬如常被人吐槽的内存占用高，和原生客户端性能差异等等。为了优化 Electron 应用，我们也做了很多工作。</p><p>性能优化一般都分两步走：</p><ul><li>① 分析、找出问题。参考<a href="https://juejin.im/post/5d06bf0a51882528194a9736" target="_blank" rel="noopener">《React 性能测量和分析》</a></li><li>② 针对问题解决问题。无外乎三个方向, 参考 <a href="https://juejin.im/post/5d045350f265da1b695d5bf2" target="_blank" rel="noopener">《浅谈 React 性能优化的方向》</a></li></ul><p><br></p><h3 id="1-性能分析"><a href="#1-性能分析" class="headerlink" title="1. 性能分析"></a>1. 性能分析</h3><p>最好的分析工具是 Chrome 开发者工具的 <code>Performance</code>。通过火焰图, JavaScript 执行过程的任何蛛丝马迹都可以直观的看到。</p><p><img src="/images/electron/chrome-perf.png" alt></p><p><br></p><p>对于主进程，开启调试后也可以通过 <code>Profile</code> 工具收集 JavaScript 执行信息。</p><p>如果你要分析某段代码的执行过程，也可以通过下面命令生成分析文件，然后导入到 Chrome Performance 中分析:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出 cpu 和 堆分析文件</span></span><br><span class="line">node --cpu-prof --heap-prof -e "require('request’)”“</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="2-优化策略"><a href="#2-优化策略" class="headerlink" title="2. 优化策略"></a>2. 优化策略</h3><h4 id="2-1-继续和白屏作斗争"><a href="#2-1-继续和白屏作斗争" class="headerlink" title="2.1 继续和白屏作斗争"></a>2.1 继续和白屏作斗争</h4><p>即使 Electron 通常从本地文件系统加载 JavaScript 代码，没有网络加载延迟，我们还是需要继续和页面白屏做斗争，因为 JavaScript 等资源的加载、解析和执行还是有相当大的代价(参考<a href="https://v8.dev/blog/cost-of-javascript-2019" target="_blank" rel="noopener">The cost of JavaScript in 2019</a>)。作为一个桌面端应用，细微的白屏延迟用户都可以感觉的到。我们要尽量让用户感觉不到这是一个 Web 页面。</p><p><strong>影响 Electron 白屏的主要因素有：页面窗口的创建、静态资源的加载、JavaScript 解析和执行</strong>。</p><p>见招拆招，针对页面白屏我们做了这些优化:</p><p><br></p><p><strong>① 骨架屏</strong></p><p>最简单的方式。在资源未加载完毕之前，先展示页面的骨架。避免用户看到白茫茫的屏幕。</p><p>另外需要设置背景色或者延迟显示窗口，来避免闪烁。</p><p><img src="/images/electron/shell.png" alt><br><em>VSCode骨架屏</em></p><p><br></p><p><strong>② 惰性加载</strong></p><p>优先加载核心的功能，保证初次加载效率，让用户可以尽快进行交互。</p><p><br></p><p><img src="/images/electron/load-order.gif" alt></p><p><br></p><ul><li><strong>代码分割 + 预加载</strong>： 代码分割是最常见优化方式。我们把隐藏的内容、或者次优先级的模块拆分出去，启动模块中只保留关键路径。我们也可以在浏览器空闲时预加载这些模块。</li><li><p><strong>延后加载 Node 模块</strong>： Nodejs 模块的加载和执行需要花费较大的代价, 例如模块查找、模块文件读取、接着才是模块解析和执行。这些操作都是同步了，别忘了，node_modules 黑洞，某块模块可能会引用大量的依赖….</p><p>Node 应用和 Electron 应用不太一样，通常 Node 服务器应用都会将模块放置在文件顶部, 然后同步加载进来。这个放到 Electron 用户界面上就无法忍受了。 用户界面的启动速度和交互阻塞, 用户是可以感知到的，而且忍耐程度会较低。</p><p>所以要充分评估模块的大小和依赖。或者可以选择使用打包工具优化和合并 Node 模块。</p></li><li><p><strong>划分加载优先级</strong>：既然我们没办法一开始将所有东西都加载出来，那就按照优先级渐进式地将在它们。举个例子，当我们使用 VSCode 打开一个文件时，VScode 会先展示代码面板、接着是目录树、侧边栏、代码高亮、问题面板、初始化各种插件…</p></li></ul><p><br></p><p><strong>③ 使用现代的 JavaScript/CSS 代码</strong></p><p>Electron 每个版本都会预装当时最新的 Chrome，对于前端来说，这是最爽的一件事情:</p><ul><li>没有负担地使用最新的 JavaScript 特性</li><li>没有 Polyfill、没有 runtime-helper。相比老旧浏览器，代码量更少，性能也更好</li><li>我们需要主动抛弃一些老旧的依赖。保持使用最新的库</li></ul><p><br></p><p><strong>④ 打包优化</strong></p><p>即使使用最新最牛逼的浏览器，打包工具还是很有用。</p><ul><li><strong>减少代码体积</strong>: 现代打包工具有非常多优化手段，例如 Webpack 支持作用域提升、摇树，还有代码压缩、预执行… 这可以合并代码、压缩代码体积，裁剪多余的代码, 减少运行时负担。</li><li><strong>优化I/O</strong>: 我们将模块合并之后，可以减少模块查找和加载的I/O往返。</li></ul><p><br></p><p><strong>⑤ <a href="https://v8project.blogspot.it/2015/09/custom-startup-snapshots.html" target="_blank" rel="noopener">v8 Snapshot</a> or <a href="https://v8.dev/blog/code-caching" target="_blank" rel="noopener">v8 Code Cache</a></strong></p><p>Atom 有很多优质的文章，分享了他们优化Atom的经历。例如它们使用了 <a href="https://blog.atom.io/2017/04/18/improving-startup-time.html" target="_blank" rel="noopener">V8 的snapshot 来优化启动时间</a>。</p><p>这是一种 <code>AOT</code> 优化策略，简单说 Snapshot 是堆快照，你可以认为它是 JavaScript 代码在V8中的内存表示形态。</p><p>它有两个好处: 一是相比普通 JavaScript 加载更快，二是它是二进制的，如果你为了‘安全’考虑，可以将模块转换成snapshot，这样更难被‘破解’。</p><p>不过它也有较多限制。对架构的影响比较大。比如要求在初始化的过程中不要有‘副作用’，例如DOM访问。因为在‘编译时‘这些东西不存在。</p><p>这篇文章详细介绍了如何在 Electron 中应用 v8 snapshot: <a href="https://flight-manual.atom.io/behind-atom/sections/how-atom-uses-chromium-snapshots/" target="_blank" rel="noopener">How Atom Uses Chromium Snapshots</a></p><p><br></p><p>还有一个更加广泛使用的方案是 <a href="https://v8.dev/blog/code-caching" target="_blank" rel="noopener">v8 Code Cache</a>。NodeJS 12 <a href="https://www.yuque.com/egg/nodejs/nodejs-12#2e3ceb28" target="_blank" rel="noopener">开始</a>在构建时提前为内置库生成代码缓存，从而提升 30% 的启动耗时。</p><p>通过这些文章，深入了解 Code Cache 扩展阅读:</p><ul><li><a href="https://v8.dev/blog/code-caching-for-devs" target="_blank" rel="noopener">Code caching for JavaScript developers</a></li><li><a href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201" target="_blank" rel="noopener">JavaScript Start-up Performance</a></li><li><a href="https://v8.dev/blog/improved-code-caching" target="_blank" rel="noopener">Improved code caching</a></li><li><a href="https://fed.taobao.org/blog/taofed/do71ct/speed-node-start-time/" target="_blank" rel="noopener">如何加快 Node.js 应用的启动速度</a></li></ul><p><br><br><br></p><p><strong>⑥ 窗口预热 与 窗口池、窗口常驻</strong></p><p>为了追赶原生窗口的打开和展示速度，我们运用了很多技巧，用空间来换取时间。</p><p>例如我们的应用首页，用户在打开登录页面时，我们就会在<strong>后台预热</strong>，将该加载的资源都准备好，在登录成功后，就可以立即渲染显示。窗口打开的延时很短，基本接近原生的窗口体验。</p><p>这里用到了一些 Hack 手段，我们将这些窗口放到了屏幕之外，并设置 <code>skipTaskBar</code> 来实现隐藏或者关闭的效果。</p><p><br></p><p>对于频繁开启/关闭的窗口，也可以使用<strong>窗口池</strong>来优化。比如 Webview 页面，打开的一个 Webview 页面时，会优先从窗口池中选取，当窗口池为空时才创建新的窗口, 后面页面关闭后会再放回窗口池中，方便后续复用。</p><p>另外，对于业务无关的、通用的窗口，也可以采用<strong>常驻模式</strong>，例如通知，图片查看器。这些窗口一旦创建就不会释放，打开效果会更好。</p><p><br></p><p><strong>⑦ 跟进 Electron 最新版本</strong></p><p>保持版本的更新。</p><p><br></p><h4 id="2-2-追赶原生的交互体验"><a href="#2-2-追赶原生的交互体验" class="headerlink" title="2.2 追赶原生的交互体验"></a>2.2 追赶原生的交互体验</h4><p>白屏时间的优化只是一个开始，应用使用过程中的交互体验也是一个非常重要的部分。下面讲讲我们的一些优化手段：</p><p><br></p><p><strong>① 静态资源缓存</strong></p><p>对于一些网络资源，我们采取了一些缓存手段，保证它们展示的速度。我们目前采用的是 Service-Worker + Workbox 的方式，利用 Service-Worker 可以拦截多个页面的网络请求，从而实现跨页面的静态资源缓存，这种方式实现比较简单。</p><p>除了 Service Worker，也可以通过协议拦截方式来实现。详见: <a href="https://electronjs.org/docs/api/protocol" target="_blank" rel="noopener">protocol</a>。后面有时间再尝试一下，看效果怎么样。</p><p><br></p><p><strong>② 预加载机制</strong></p><p>如果你看过我的 <a href="https://juejin.im/post/5dadc6045188255a270a0f85" target="_blank" rel="noopener">《这可能是最通俗的 React Fiber(时间分片) 打开方式》</a>, 应该见识到 <code>requestIdleCallback</code> 的强大，React 利用它来调度一些渲染任务，保证浏览器响应用户的交互。</p><p>这个 API 对于我们的应用优化也有重要的意义。通过它我们可以知道浏览器的资源利用情况，利用浏览器空闲时间来预执行一些低优先级的任务。比如：</p><ul><li>渲染隐藏的 Tab</li><li>延后加载的模块代码</li><li>惰性加载的图片</li><li>未激活的会话</li><li>执行低优先级的任务</li><li>…</li></ul><p><br></p><p>例如 React 代码分割：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">lazy</span>(<span class="params">factory, Fallback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Comp = l(factory)</span><br><span class="line">  <span class="comment">// 预加载调度</span></span><br><span class="line">  scheduleIdle(&#123;</span><br><span class="line">    name: <span class="string">'LazyComponent'</span>,</span><br><span class="line">    size: TaskSize.Heavy,</span><br><span class="line">    task: factory,</span><br><span class="line">    timeout: <span class="number">2000</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">LazyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Suspense fallback=&#123;Fallback ? <span class="xml"><span class="tag">&lt;<span class="name">Fallback</span> /&gt;</span> : null&#125;&gt;</span></span><br><span class="line">        &lt;Comp &#123;...props&#125; /&gt;</span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">    )</span></span><br><span class="line"><span class="xml">  &#125; as typeof Comp</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>使用:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> List = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./List'</span>))</span><br></pre></td></tr></table></figure><p><br></p><p><strong>③ 避免同步操作</strong></p><p>Electron 可以通过 NodeJS 进行 I/O 操作，但是我们一定要尽量避免同步 I/O。例如同步的文件操作、同步的进程间通信。它们会阻塞页面的渲染和事件交互。</p><p><br></p><p><strong>④ 减少主进程负荷</strong></p><p>Electron 的主进程非常重要。它是所有窗口的父进程，它负责调度各种资源。如果主进程被阻塞，将影响整个应用响应性能。</p><p>你可以做一个简单的实验，在主进程上打一个断点，你会发现所有的页面窗口都会失去响应，尽管它们在各自不同的进程。这是因为所有用户交互都是由主进程分发给渲染进程的，主进程阻塞了，渲染进程当然无法接收用户事件啦。</p><p>所以不要让主进程干脏活累活，能在渲染进程做的，就在渲染进程做。<strong>千万避免在主进程中跑计算密集任务和同步I/O</strong>。</p><p><br></p><p><strong>⑤ 分离CPU密集型操作到单独进程或Worker, 避免阻塞UI</strong></p><p><br></p><p><strong>⑥ React 优化</strong></p><p>见 <a href="https://juejin.im/post/5d045350f265da1b695d5bf2" target="_blank" rel="noopener">《React 性能优化的方向》</a></p><p><br></p><p><strong>⑦ 放弃CSS-in-js</strong></p><p>我们为了压缩运行时性能，能在编译时做的就在编译时做，放弃了 CSS-in-js 方案，使用纯 CSS + BEM 来编写样式。主要有两个原因:</p><ul><li>Electron 使用较新的 Chrome，现代 CSS 已经很强大</li><li>我们使用了窗口预热机制，可以率先解析这部分 CSS 代码。而 CSS-in-js 方案则是组件渲染时，动态生成的。</li></ul><p><br></p><p><strong>⑧ 没有退路了，那就只能上 Node 原生模块了</strong></p><p>真好，还有退路</p><p><br><br><br></p><h4 id="2-3-优化进程通信"><a href="#2-3-优化进程通信" class="headerlink" title="2.3 优化进程通信"></a>2.3 优化进程通信</h4><p>涉及到多页面/窗口的 Electron 应用，IPC 会非常频繁，搞不好会成为性能瓶颈。</p><p><br></p><p><strong>① 巨坑 remote</strong></p><p><a href="https://electronjs.org/docs/api/remote" target="_blank" rel="noopener">remote</a> 提供了一种简便的、无侵入的形式来访问主进程的API和数据。<strong>其底层基于同步的 IPC</strong>。你可以通过我<a href="https://juejin.im/post/5d4b79a3e51d4561b072dcb0" target="_blank" rel="noopener">这篇文章</a>来了解它的原理。</p><p>坑在哪里呢？</p><p>① 它是同步的<br>② 属性动态获取。为了确保你能够获取到最新的值，remote底层并不会进行缓存，而是每次获取一个属性就动态到主进程中取。</p><p>比如获取一个主进程中的对象:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主进程</span></span><br><span class="line">global.foo = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: &#123;</span><br><span class="line">    baz: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染进程访问:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;remote&#125; <span class="keyword">from</span> <span class="string">'electron'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(remote.getGlobal(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure><p>这里会触发 4 次 同步 IPC: getGlobal、foo、bar、bar.baz。对于复杂的数据，这个消耗就很难忍受了。</p><p>不要使用 remote，除非你知道你自己在干什么。</p><p><br><br><br></p><p><strong>② 封装IPC 库</strong></p><p>为了优化 IPC 通信，我们自己基于Electron 的IPC接口, 封装了自己的一套 RPC 库。主要特征有:</p><ul><li>异步的。没有同步的选项。避免干蠢事</li><li>消息合并。合并事件推送，批量传递</li><li>序列化。直接传递 JSON 字符串，不让 Electron 干涉序列化。Electron 内部序列化稍微有点复杂，比如会处理 Buffer 等特殊类型。</li><li>一致化的、简单易用的 API。使用一样在接口支持主进程与渲染进程，以及渲染进程与渲染进程之间双向通信。</li></ul><p>举个例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rpc <span class="keyword">from</span> <span class="string">'myrpc'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册方法</span></span><br><span class="line">rpc.registerHandler(<span class="string">'echo'</span>, <span class="keyword">async</span> data =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line">rpc.on(<span class="string">'some-event'</span>, (data, source) =&gt; &#123;</span><br><span class="line">  <span class="comment">// dosomething</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>客户端:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rpc <span class="keyword">from</span> <span class="string">'myrpc'</span></span><br><span class="line"></span><br><span class="line">rpc.emit(target, <span class="string">'some-event'</span>) <span class="comment">// target 为接收的窗口或者主进程。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法调用</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> rpc.callHandler(target, <span class="string">'echo'</span>, <span class="string">'hello-world'</span>)</span><br></pre></td></tr></table></figure><p><br></p><p>还不够，我们还在优化，后续再分享给大家。</p><p><br><br><br></p><h2 id="坑还是会有的"><a href="#坑还是会有的" class="headerlink" title="坑还是会有的"></a>坑还是会有的</h2><p>一路走来也遇到很多坑。痛并快乐着。</p><ul><li>窗口阴影、圆角</li><li>剪切板不够强大</li><li>remote 巨坑</li><li>一些兼容问题</li><li>主进程崩溃，渲染进程不会退出，导致进程‘溢出’</li><li>截屏。刚开始用 Electron 实现，效果不好，现在是原生实现</li><li>…</li></ul><p><br><br><br></p><h2 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/96041706" target="_blank" rel="noopener">从 VSCode 看大型 IDE 技术架构</a></li><li><a href="https://electronjs.org/docs/tutorial/performance" target="_blank" rel="noopener">Electron Performance</a></li><li><a href="https://www.youtube.com/watch?v=r0OeHRUCCb4" target="_blank" rel="noopener">CovalenceConf 2019: Visual Studio Code – The First Second</a></li><li><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/" target="_blank" rel="noopener">Get Started With Analyzing Runtime Performance</a></li><li><a href="https://github.com/atom/electron-link" target="_blank" rel="noopener">electron-link</a></li><li><a href="http://peterforgacs.github.io/2018/09/12/How-to-create-a-V8-snapshot-of-your-javascript-file/" target="_blank" rel="noopener">How to Create a V8 Heap Snapshot of a Javascript File and Use It in Electron</a></li><li><a href="https://blog.atom.io/2018/01/10/the-state-of-atoms-performance.html" target="_blank" rel="noopener">The State of Atom’s Performance</a></li><li><a href="https://blog.atom.io/2017/04/18/improving-startup-time.html" target="_blank" rel="noopener">Improving Startup Time</a></li></ul><p><br><br><br></p><p><img src="/images/group.jpeg" alt><br><em>回复: <code>ivan</code> 进群</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019 年最后一发，谈谈这半年 Electron 应用开发和优化心得。干货也挺多，希望能给你带来一点启发。&lt;/p&gt;
&lt;p&gt;下半年可以拿出来说一说的项目，估计就是我们用 Electron 重构了一个桌面端应用。这个应用类似于&lt;code&gt;钉钉&lt;/code&gt;或者&lt;code&gt;企业
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>if 我是前端Leader，谈谈前端框架体系建设</title>
    <link href="https://bobi.ink/2019/12/06/fe-framework/"/>
    <id>https://bobi.ink/2019/12/06/fe-framework/</id>
    <published>2019-12-05T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>这期来聊一聊前端框架。</p><p>“if 我是前端 Leader” 是我的一个文章系列，说说我人在其位，欲谋其职的一些点点滴滴感悟。跟前端 Leader 只有那么一丢丢关系，干货不多，但老少皆宜，不要被标题给唬住了。</p><p><br></p><p><strong>文章大纲</strong></p><p><br></p><!-- TOC --><ul><li><a href="#什么是框架">什么是框架?</a></li><li><a href="#前端框架的发展历程">前端‘框架’的发展历程</a><ul><li><a href="#前端框架启蒙阶段">前端框架启蒙阶段</a></li><li><a href="#野蛮生长期">野蛮生长期</a></li><li><a href="#前端框架整合期">前端框架整合期</a></li></ul></li><li><a href="#现有的框架都有什么">现有的框架都有什么？</a></li><li><a href="#谈谈前端团队框架体系的建设">谈谈前端团队框架体系的建设</a><ul><li><a href="#第一阶段-前端工程化--基础设施">第一阶段: 前端工程化 / 基础设施</a></li><li><a href="#第二阶段-应用开发方案整合">第二阶段: 应用开发方案整合</a></li><li><a href="#第三阶段-组件体系">第三阶段: 组件体系</a></li><li><a href="#第四阶段打通上下游">第四阶段：打通上下游</a></li><li><a href="#未来-ai">未来: AI?</a></li></ul></li><li><a href="#扩展资料">扩展资料</a></li></ul><!-- /TOC --><p><br><br><br></p><h2 id="什么是框架"><a href="#什么是框架" class="headerlink" title="什么是框架?"></a>什么是框架?</h2><p>这应该不是我第一次谈‘框架‘了。React 是一个框架吗？ Vue 是一个框架吗？ 严格来说不是，它们只是一个视图解决方案，这里面算得上是框架的估计只有 Angular。</p><p>如果说后端框架围绕着<code>数据存储</code>建立起来，那么前端框架的基础就是视图库，毕竟前端的本质工作就是视图。这是为什么前端生态圈一般是围绕着视图库展开的。所以说，<strong>前端框架的基础是‘视图’库</strong>。</p><p>如果跟后端框架比起来，成熟的前端框架其实不多。</p><p><br></p><p><strong>什么是框架？</strong></p><p><br></p><p>看个例子。打开 <a href="https://umijs.org" target="_blank" rel="noopener">UmiJS</a>, 它对自己的描述是:</p><blockquote><p><strong>可插拔的企业级 react 应用框架</strong></p></blockquote><p>关键字是<strong>企业级</strong>。什么是企业级，我自己也说不清楚。我只知道 React 没有说自己是企业级，Koa、Express 也没有，然而 <a href="https://eggjs.org" target="_blank" rel="noopener">Eggjs</a> 和 <a href="https://umijs.org" target="_blank" rel="noopener">Umijs</a> 都说它们是<strong>企业级框架</strong>；Angular 通常也常常跟企业级这个概念联系在一起；语言层面有 Java。</p><p>对比一下他们就知道了，我觉得企业级表示它是 <strong>面向企业生产，目的是提高企业的生产力</strong>。总结一下有以下特点：</p><p><br></p><ul><li>是高效 + 成熟方案的整合</li><li>关注生产的整个链路，而不是某个环节</li><li>有更强的约束和限制</li><li>更严苛的要求。性能、可扩展性(以应对不同的需求)、健壮性、稳定性、可用性、安全性</li><li>标准化</li><li>经过生产环境验证, 有较多用例保证</li></ul><p><br></p><p>归根到底还是成本问题，框架最本质的目的就是要减低各类成本。让更少的人可以做更多的事情、且能保证质量、降低维护成本，且能保证不断优化和演进。</p><p><br></p><p><strong>给个定义吧。</strong></p><p><br></p><p><strong>前端框架体系的建立离不开前端工程化成熟和‘最佳实践‘的沉淀’。你可以认为框架就是一个整合的方案，提供一个前端‘最佳‘的组合配置。开发者需要做的就是在这个框架约束下填充自己业务代码。</strong></p><p><br></p><p>好处：</p><ul><li>效率提升。让开发者关注业务开发</li><li>学习成本降低。框架封装了很多底层复杂性</li><li>更强的约束。所有动作必须按照框架规定的执行, 避免干坏事、蠢事。更强的约束也意味着框架集成度更高、框架内部可以做更多事情，但灵活性也更低。</li><li>产品质量。框架内部会自动处理很多事情，例如性能优化、安全性处理</li><li>可维护性。所有项目都按照一致的、标准化的规范开发，升级迭代方便。这一点对团队项目的可维护性很重要。</li></ul><p><br></p><p>坏处:</p><ul><li>灵活性。不能满足所有人的需求，最佳实践这种东西有点武断</li><li>滞后性。具体方案可能会滞后。</li><li>大而全。对于某些项目可能过重。</li></ul><p><br><br><br></p><h2 id="前端‘框架’的发展历程"><a href="#前端‘框架’的发展历程" class="headerlink" title="前端‘框架’的发展历程"></a>前端‘框架’的发展历程</h2><h3 id="前端框架启蒙阶段"><a href="#前端框架启蒙阶段" class="headerlink" title="前端框架启蒙阶段"></a>前端框架启蒙阶段</h3><p>在 React、Vue 流行之前已经有许多‘前端框架‘，例如 Angular、Ember、Backbone…</p><p>它们大部分都受到后端框架的启发，因为当年也正是后端框架最火的时候，例如 Rails。所以在它们身上会看到很多后端框架的影子。</p><p>但是很多后端的开发模式，在前端有点吃不开。更本质的原因是前端工程化还不成熟，基础相对薄弱，难以支撑上层建筑的发展。</p><p><br><br><br></p><h3 id="野蛮生长期"><a href="#野蛮生长期" class="headerlink" title="野蛮生长期"></a>野蛮生长期</h3><p>随着 NodeJS 的普及、JavaScript 语言日益强大，前端工程化逐步深化。 React 这类视图库出来后，很多东西被打碎重构, 正所谓百花齐放，欣欣向荣。</p><p>围绕着三大视图库各种各样的库百花齐放，前端也拓展到了浏览器以外的领域。人们都乐于造轮子，使用最新的技术。</p><p>由于发展得太快，所谓的框架/最佳实践很难被广泛接受，或者很容易就过时了，每个人每个团队更热衷于创造自己的组合方案，往往也只限于团队内部。</p><p><br><br><br></p><h3 id="前端框架整合期"><a href="#前端框架整合期" class="headerlink" title="前端框架整合期"></a>前端框架整合期</h3><p>几乎每个团队都会重复走这样的路子：<em>稳定技术栈、工程化建设、基础库/组件库建设、沉淀自己的最佳实践</em>。</p><p>团队没有一定的工程能力和资源其实是很难将这些零散的实践体系化、有机地粘合起来, 长期有效的维护更新更是一件难事, 半途而废的居多。</p><p>现在前端发展开始进入平稳阶段。所以大一统的前端‘框架’再一次进入人们的视野。就像 Umi 的作者 <a href="https://www.zhihu.com/people/chenchengpro/activities" target="_blank" rel="noopener">云谦</a> 说的: <em>现在是工业化时代, 框架像是一个魔法球，把各种技术栈吸到一起，加工后吐给用户，以此来支撑业务</em>。</p><p><img src="/images/fe-framework/bigfish.jpg" alt><br><em>上图来源于&lt;蚂蚁前端研发最佳实践&gt; PPT</em></p><p><br></p><p>框架就是将各种技术栈方案、基础设施整合起来, 暴露标准的、一致性的接口, 让开发者专注业务开发。</p><p><br><br><br></p><h2 id="现有的框架都有什么？"><a href="#现有的框架都有什么？" class="headerlink" title="现有的框架都有什么？"></a>现有的框架都有什么？</h2><p><strong>一个前端开发框架应该涵盖前端开发链路的各个环节。为约束和简化业务开发、提供有用的指导</strong>。</p><p>看看现有‘前端框架‘吧，现在社区上比较流行的‘框架’有 Angular、Next.js、Nuxt、Umi。我们横向对比一下它们的一些特性，发现基本上包含这些东西：</p><p><img src="/images/fe-framework/framework-content.png" alt></p><p><br></p><p>跟衣服的标准码一样。社区开源的都是通用类型框架，可以预知的是它们没有办法满足所有团队的要求。我们往往需要根据自己业务情况量身定制框架。</p><p>为了应对这些需求，不同的框架也有不同的应对策略:</p><ul><li><strong>更开放</strong>。框架只提供核心功能，附加几乎什么事情都能干的<strong>插件机制</strong>。插件可以干预框架的整个生命周期，不满足的需求可以自己定制自己的插件</li><li><strong>更决断</strong>。我给你提供的就是最好的，能满足你的尽量满足你，其他的你不要管太多，也没有必要管, 专注你的业务。</li></ul><p><br></p><p>我们也有自己的选择策略:</p><ul><li>自己搞。例如大厂团队，有资源、有丰富的实践经验。他们有能力将自己的‘最佳实践’体系化。他们会选择创建自己的框架。同时他们也乐于将经验分享出来，也可以利用社区完善自己的作品。个人，基于学习和折腾的目的, 也可以搞一套。</li><li>基于开源框架扩展。可以将开源框架作为基础，根据自己团队情况进行扩展开发。</li><li>完全使用开源框架。开源框架可以满足许多通用的需求, 适合简单的应用场景。<strong>我们选择一个框架主要有两个原因：① 我们要提高工作效率；② 我们需要一个标准</strong>。 为了标准，其实可妥协一些事情。更重要的是这些框架是在不断发展和演进的, 从而我们团队的技术也可以免费地跟随他们演进和发展。将开源框架的默认最佳实践开发视为标准。</li></ul><p><br></p><p>我一直坚信<strong>专业的人做专业的事。要善于将事情外包出去，腾空自己去做重要的事情</strong>。大厂有专门的团队在做工具、建设基础设施，社区上开源的框架也由一大帮牛人在维护，而且通常开发迭代很活跃。所以说社区已经有的方案，可以直接拿来用，不要自己去造轮子，因为你一般没那么多精力。</p><p><br><br><br></p><h2 id="谈谈前端团队框架体系的建设"><a href="#谈谈前端团队框架体系的建设" class="headerlink" title="谈谈前端团队框架体系的建设"></a>谈谈前端团队框架体系的建设</h2><p>前端开发的时间都花在了哪里?</p><p><img src="/images/fe-framework/time.jpg" alt><br><em>上图来源于&lt;蚂蚁前端研发最佳实践&gt; PPT</em></p><p><br></p><p>对于前端团队来说，开源前端框架只是一个基础，只是涉及前端开发的某个很小的部分，它就像一艘船。你要航线穿越大西洋，还有做很多工作、需要紧密高效的协作、可靠的后勤保障、目标和方向、坚定的领导… 路还很长。</p><p><strong>现在来聊聊‘广义的‘框架体系，它集成自身业务，涉及前端开发完整链路，关注点从前端应用上升到了前端团队研发体系</strong>。</p><p><br></p><p><img src="/images/fe-framework/framework-order.png" alt></p><p><br></p><p>九层之台，起于累土。 前端团队框架体系的建设是一个渐进式的过程，首先从基础设施开始、接着就是应用开发技术栈组合，再到组件体系，后面是上层的业务开发方案… 上层以下层为基础，共同构建出完整的框架体系。</p><p>我觉得前端团队可以按照这样的分层结构，分阶段来完成这些建设任务。</p><p><br></p><h3 id="第一阶段-前端工程化-基础设施"><a href="#第一阶段-前端工程化-基础设施" class="headerlink" title="第一阶段: 前端工程化 / 基础设施"></a>第一阶段: 前端工程化 / 基础设施</h3><p>最基础的阶段，关注前端的基础设施建设。这个阶段已经比较成熟，社区上有很多开箱即用的方案，例如 Umi、Next.js、Vue-CLI、Create-React-App 等等。主要内容有:</p><p><img src="/images/fe-framework/base.png" alt></p><p><br></p><h3 id="第二阶段-应用开发方案整合"><a href="#第二阶段-应用开发方案整合" class="headerlink" title="第二阶段: 应用开发方案整合"></a>第二阶段: 应用开发方案整合</h3><p>在完善基础设施的同时，团队的应用开发技术栈组合方案也应该稳定下来，成为框架的一部分。这些组合也非常重要，它会影响上层的组件建设和业务开发。主要内容有:</p><p><img src="/images/fe-framework/app-dev.png" alt></p><p><br></p><h3 id="第三阶段-组件体系"><a href="#第三阶段-组件体系" class="headerlink" title="第三阶段: 组件体系"></a>第三阶段: 组件体系</h3><p>组件化现在是前端主流开发模式，这里还有很多工作可以做，还有很大的提效空间。</p><p>整个组件体系也是一个分层式的结构：</p><p><img src="/images/fe-framework/component.png" alt></p><ul><li>基础组件。越底层，就说明可复用的程度越高、越通用。Ant-Design、Element-UI、iView、Material-UI 这些就属于基础组件库，有能力的团队也可以开发一套符合自己设计风格的组件库。</li><li>业务组件。在基础组件之上封装的、耦合自己业务的组件。它们一般从重复的业务场景中抽象出来。</li><li>区块。再往上，就很难用模块化的组件去组织了。于是有人(阿里前端)提出了‘区块’的概念，<strong>你可以认为‘区块’是：代码片段、代码示例、代码模板…</strong> 这么看来，这并不是一种新的概念? 还没完! <strong>区块还要配套‘区块市场’才能展现它的用处。区块市场是一个代码片段分享平台，维护着大量的区块，试图覆盖大部分常见的使用场景。对于开发者来说就是找到尽量匹配自己场景的区块，拷贝过来，稍微改改就行了。这是一种 ‘Ctrl+C，Ctrl+V’ 编程哲学的完美实践啊</strong>。</li><li>页面。和区块差不多，快速生成页面和路由。约定式的路由可以给页面自动化创建带来一些便利。</li><li>布局。例如后台的整体布局。</li><li>项目。项目的整体结构。可以通过‘脚手架‘ 来快速生成项目模板。</li></ul><p><br></p><p><img src="/images/fe-framework/icework.png" alt></p><p><br></p><p>像区块、页面生成这些操作需要一些工具辅助。例如：</p><ul><li>生成器。生成不同级别的元件<ul><li>项目(项目模板)。 俗称脚手架, 支持不同的项目类型：应用、组件库、程序库、 插件</li><li>页面/路由</li><li>区块</li><li>组件</li><li>数据模型</li></ul></li><li>可视化工具。可视化的项目编排工具, 如飞冰。</li></ul><p><br></p><h3 id="第四阶段：打通上下游"><a href="#第四阶段：打通上下游" class="headerlink" title="第四阶段：打通上下游"></a>第四阶段：打通上下游</h3><p>前端只是研发流程的一环，只是前端自嗨，上下游没有资源支持，是很难走远的。</p><p>对于前端来说，通常上游指的是 UI、下游指的是后端。</p><p>对于 UI。上面说的组件体系，其实是建立在稳定的、一致的、统一的 UI 设计语言之上的。否则一切都是空谈。所以我们要求 UI 设计团队要有良好的设计规范、能和前端组件体系绑定并良性迭代。</p><p>对于 后端。可以促进建立更标准的接口范式、封装通用的服务(有利于业务组件复用)、更深的有业务中台、BFF…</p><p>上下游的打通，对前端生产力的解放也有非常大的促进作用。</p><p><br></p><h3 id="未来-ai"><a href="#未来-ai" class="headerlink" title="未来: AI?"></a>未来: AI?</h3><p>AI 自动生成前端代码？ 太高大上了，还是把话筒交给它吧： <a href="https://mp.weixin.qq.com/s/EktHbvCnghkywZE8rOvMhw" target="_blank" rel="noopener">《双 11 模块 79.34% 的代码是怎样智能生成的？》</a>， 溜了</p><p><br><br><br></p><h2 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/94949118" target="_blank" rel="noopener">《蚂蚁前端研发最佳实践》文字稿</a> 好文</li><li><a href="https://mp.weixin.qq.com/s/EktHbvCnghkywZE8rOvMhw" target="_blank" rel="noopener">双 11 模块 79.34% 的代码是怎样智能生成的？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这期来聊一聊前端框架。&lt;/p&gt;
&lt;p&gt;“if 我是前端 Leader” 是我的一个文章系列，说说我人在其位，欲谋其职的一些点点滴滴感悟。跟前端 Leader 只有那么一丢丢关系，干货不多，但老少皆宜，不要被标题给唬住了。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>JSX AS DSL? 写个 Mock API 服务器看看</title>
    <link href="https://bobi.ink/2019/11/29/jsx-as-dsl/"/>
    <id>https://bobi.ink/2019/11/29/jsx-as-dsl/</id>
    <published>2019-11-28T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.329Z</updated>
    
    <content type="html"><![CDATA[<p>这几天打算写一个简单的 API Mock 服务器，老生常谈哈？其实我是想讲 JSX, Mock 服务器只是一个幌子。我在寻找一种更简洁、方便、同时又可以灵活扩展的、和别人不太一样的方式，来定义各种 Mock API。后来我发现了 JSX 在领域问题描述的优势和潜力，当然这可不是空谈，我们会实际写一个项目来证实这个判断。</p><p><br></p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#1-领域问题的描述">1. 领域问题的描述</a><ul><li><a href="#11-配置文件形式">1.1 配置文件形式</a></li><li><a href="#12-编程语言与内部-dsl">1.2 编程语言与内部 DSL</a></li></ul></li><li><a href="#2-javascript-内部-dsl">2. JavaScript 内部 DSL</a><ul><li><a href="#21-对象形式">2.1 对象形式</a></li><li><a href="#22-链式调用形式">2.2 链式调用形式</a></li><li><a href="#23-es2015-template-tag">2.3 ES2015 Template Tag</a></li><li><a href="#24-要不试试-jsx">2.4 要不试试 JSX？</a></li></ul></li><li><a href="#3-jsx-入门">3. JSX 入门</a><ul><li><a href="#31-自定义工厂">3.1 自定义工厂</a></li><li><a href="#32-host-component-vs-custom-component">3.2 Host Component vs Custom Component</a></li><li><a href="#33-简单实现-createelement-工厂方法">3.3 简单实现 createElement 工厂方法</a></li></ul></li><li><a href="#4-基础组件的设计">4. 基础组件的设计</a><ul><li><a href="#41-来源于-koa-的灵感">4.1 来源于 Koa 的灵感</a></li><li><a href="#42-use-基础组件">4.2 use 基础组件</a></li><li><a href="#43-高层组件的封装">4.3 高层组件的封装</a></li></ul></li><li><a href="#5-浅谈实现原理">5. 浅谈实现原理</a><ul><li><a href="#51-渲染">5.1 ‘渲染’</a></li><li><a href="#52-运行">5.2 运行</a></li></ul></li><li><a href="#6-总结终于完事了">6. 总结，终于完事了</a></li><li><a href="#7-扩展">7. 扩展</a></li></ul><!-- /TOC --><p><br></p><h2 id="1-领域问题的描述"><a href="#1-领域问题的描述" class="headerlink" title="1. 领域问题的描述"></a>1. 领域问题的描述</h2><p>一上来就说这么抽象的名词，’领域问题’ 是什么鬼？什么是领域，Wiki 上解释的非常好，<strong>领域就是指某一专业或事物方面范围的涵盖</strong>。那么所谓领域问题就可以理解为，我们需要通过程序或者其他方式去解决的需求。</p><p>比如提到 API Mock 服务器，我们需要解决的就是请求匹配和数据模拟这些问题；Nginx 解决的资源伺服和代理问题；HTML + CSS 解决的是页面 UI 展示问题…</p><p>我们这里重点关注’<strong>描述</strong>‘。<strong>这些描述是提供给领域专家的‘前端‘ 或者 用户界面(UI)</strong>。举个例子：</p><p><br></p><p><img src="/images/jsx-as-dsl/dq-fe.png" alt></p><p><br></p><p>描述的形式有很多，例如配置文件、编程语言、图形界面。 先来看看现在常见的工具是怎么做的：</p><p><br></p><h3 id="1-1-配置文件形式"><a href="#1-1-配置文件形式" class="headerlink" title="1.1 配置文件形式"></a>1.1 配置文件形式</h3><p><strong>JSON?</strong></p><p>JSON 是一种非常简单的数据表述, 没有任何学习成本，解析也非常方便。但是它有非常多致命的缺陷，比如不支持注释、冗余、数据结构单一。</p><p><strong>YAML?</strong></p><p>相比 JSON 语法要简洁很多、可读性也比较强。作为一个配置文件形式非常优秀</p><p><strong>还是其他配置文件形式…</strong></p><p>通常这些配置文件都是语言无关的，因此不会包含特定语言的元素。换句话说配置文件形式数据是相对静态的, 所以灵活性、扩展性比较差。只适合简单的配置场景。</p><p>举个例子，这些配置文件不支持函数。我们的 Mock 服务器可能需要通过一个函数来动态处理请求，所以配置文件在这里并不适用。</p><blockquote><p>当然你可以通过其他方式来取代‘函数’，例如模板、或者脚本支持</p></blockquote><p><br><br><br></p><h3 id="1-2-编程语言与内部-dsl"><a href="#1-2-编程语言与内部-dsl" class="headerlink" title="1.2 编程语言与内部 DSL"></a>1.2 编程语言与内部 DSL</h3><p>我们需要回到编程语言本身，利用它的编程能力，实现配置文件无法实现的更强大的功能。</p><p>不过单纯使用通用类型编程语言，命令式的过程描述可能过于繁琐。<strong>我们最好针对具体领域问题进行简化和抽象，给用户提供一个友好的用户界面，让他们声明式地描述他们的领域问题。我们要尽可能减少用户对底层细节的依赖，与此同时最好能保持灵活的扩展能力</strong>。</p><p>我说的可能就是<a href="https://zh.wikipedia.org/wiki/领域特定语言" target="_blank" rel="noopener"><strong>DSL(Domain-specific languages)</strong></a>:</p><blockquote><p>DSL 是一种用于描述特定应用领域的计算机语言。DSL 在计算机领域有非常广泛的应用，例如描述 Web 页面的 HTML、数据库查询语言 SQL、正则表达式。<br>相对应的是<strong>通用类型语言</strong>(GPL, General-Purpose Language)，例如 Java、C++、JavaScript。它们可以用于描述任意的领域逻辑，它们通常是<a href="https://en.wikipedia.org/wiki/Turing_completeness" target="_blank" rel="noopener">图灵完备</a>的。<br>可以这么认为，虽然不严谨：除了通用类型语言、其他语言都算是 DSL。</p></blockquote><p><br></p><p><strong>怎么创建 DSL？</strong></p><p>从头开发一门新语言？No! 成本太高了</p><p>一种更优雅的方式是在通用编程语言的基础上进行减法或者封装抽象。当然不是所有类型语言都有这个’能力’, 比如 Java、C/C++ 就不行，它们的语法太 Verbose 或者工具链太重了。但是 Groovy、Ruby、Scala、还有 Elixir 这些语言就可以方便地创建出‘DSL’, 而且它们大部分是动态语言。</p><p>它们有的借助宏、有的天生语法就非常适合作为 DSL、有的具备非常强的动态编程能力… 这些因素促就了它们适合作为 DSL 的母体(宿主)。</p><p><strong>我们通常也将这种 DSL 称为 <code>Embedded DSL(嵌入式 DSL)</code> 或者 <code>内部 DSL</code>，因为它们寄生在通用类型编程语言中。而独立的 DSL，如 JSON、HTML，称为<code>外部DSL</code></strong>。</p><p>内部 DSL 好处是省去了实现一门语言的复杂性(Parse-&gt;Transform-&gt;Generate)。</p><p><br></p><p>举两个非常典型的例子:</p><p>Java 开发者常用的 <a href="https://gradle.org" target="_blank" rel="noopener">Gradle</a>，基于 Groovy:</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'java-library'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    api <span class="string">'org.apache.commons:commons-math3:3.6.1'</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">'com.google.guava:guava:27.0.1-jre'</span></span><br><span class="line"></span><br><span class="line">    testImplementation <span class="string">'junit:junit:4.12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>还有 CocoaPods, 基于 Ruby:</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">source <span class="string">'http://source.git'</span></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">'8.0'</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'Demo'</span> <span class="keyword">do</span></span><br><span class="line">    pod <span class="string">'AFNetworking'</span></span><br><span class="line">    pod <span class="string">'SDWebImage'</span></span><br><span class="line">    pod <span class="string">'Masonry'</span></span><br><span class="line">    pod <span class="string">"Typeset"</span></span><br><span class="line">    pod <span class="string">'BlocksKit'</span></span><br><span class="line">    pod <span class="string">'Mantle'</span></span><br><span class="line">    pod <span class="string">'IQKeyboardManager'</span></span><br><span class="line">    pod <span class="string">'IQDropDownTextField'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><br></p><p>具体的实现细节不在本文的范围之内，还是聊回 JavaScript。</p><p><br></p><p><strong>我个人要求 DSL 应该具备这些特性</strong>：</p><ul><li><strong>专注于特定领域</strong>。也就是说它的目的非常明确，因此比通用类型语言要简单很多，但是它的边界有时候并不好把握。</li><li><strong>组织性</strong>。它应该方便组织和描述领域问题, <strong>或者说这是一种约束能力</strong>。配置文件组织性就非常好，比如 JSON，它可以很容易地描述数据结构，没有什么心智负担。另一个典型的例子是单元测试框架(例如 jest)，它们使用 describe、it、expect 这些元件，让单元测试更好的组织起来。</li><li><strong>可读性</strong>。它必须是人类可读的、容易理解的。</li><li><strong>声明式</strong>。声明式优于过程式、描述 What 而不是 How。</li><li><strong>扩展性</strong>。很多 DSL 一开始并不关注这一点，因为一开始问题可能并不复杂。<strong>问题的领域不是静态不变的，它可能会变大，这时候 DSL 的扩展能力就很关键了</strong>。 就比如 HTML，随着前端开发越来越复杂，原有的元素和功能集合已经无法满足需求，所以衍生除了很多组件或者自定义元素方案。如果原本的 DSL 无法扩展，可以在这个基础之上再套一层 DSL，CSS vs SASS、HTML vs React 就是这样的例子。</li></ul><p><br><br><br></p><h2 id="2-javascript-内部-dsl"><a href="#2-javascript-内部-dsl" class="headerlink" title="2. JavaScript 内部 DSL"></a>2. JavaScript 内部 DSL</h2><p>上节提到了 Groovy、Ruby ‘适合‘ 用作 DSL 母体，并不代表一定要用它们实现，这只是说明它们天生具备的一些语言特性让实现更加便捷，或者说外观更加简洁。</p><p>Google 一把 ‘JavaScript DSL‘ 匹配的有效资料很少。 如果你觉得困惑那就应该回到问题本身, 最重要的是解决领域问题，至于怎么组织和描述则是相对次要的。所以不要去纠结 JavaScript 适不适合。</p><p><br></p><p>那我们就针对 Mock Server 这个具体领域，聊一聊 JavaScript 内部 DSL 的典型组织方式:</p><p><br></p><h3 id="2-1-对象形式"><a href="#2-1-对象形式" class="headerlink" title="2.1 对象形式"></a>2.1 对象形式</h3><p>最简单的方式是直接基于对象或者数组进行声明，实现简单又保持组织性。例如 <a href="https://umijs.org/zh/guide/mock-data.html#使用-umi-的-mock-功能" target="_blank" rel="noopener">Umi Mock</a> 还有 <a href="https://ice.work" target="_blank" rel="noopener">飞冰</a> Mock, 就是基于对象组织的:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 支持值为 Object 和 Array</span></span><br><span class="line">  <span class="string">'GET /api/users'</span>: &#123; <span class="attr">users</span>: [<span class="number">1</span>, <span class="number">2</span>] &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// GET POST 可省略</span></span><br><span class="line">  <span class="string">'/api/users/1'</span>: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 支持自定义函数，API 参考 express@4</span></span><br><span class="line">  <span class="string">'POST /api/users/create'</span>: <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">'OK'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 mockjs 等三方库</span></span><br><span class="line">  <span class="string">'GET /api/tags'</span>: mockjs.mock(&#123;</span><br><span class="line">    <span class="string">'list|100'</span>: [&#123; <span class="attr">name</span>: <span class="string">'@city'</span>, <span class="string">'value|1-100'</span>: <span class="number">50</span>, <span class="string">'type|0-2'</span>: <span class="number">1</span> &#125;],</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>和配置文件差不多, 实现和使用都非常简单 ，简单的 API Mock 场景开箱即用，对于复杂的用法和 API 协议，也可以通过自定义函数进一步封装。<strong>但是有时候我们希望库可以承担多一点事情</strong>。</p><p><br><br><br></p><h3 id="2-2-链式调用形式"><a href="#2-2-链式调用形式" class="headerlink" title="2.2 链式调用形式"></a>2.2 链式调用形式</h3><p>JavaScript 作为内部 DSL 的另外一种典型的形式是链式调用。</p><p>其中最出名的是 JQuery, 它让链式调用这种模式广为人知。相比啰嗦的原生 DOM 操作代码，JQuery 确实让人眼前一亮, 它暴露精简的 API, 帮我们屏蔽了许多底层 DOM 操作细节，抚平平台差异，同时还能保持灵活性和扩展性。这才是它真正流行的原因，大众喜闻乐见的都是简单的东西。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'.awesome'</span>)</span><br><span class="line">  .addClass(<span class="string">'flash'</span>)</span><br><span class="line">  .draggable()</span><br><span class="line">  .css(<span class="string">'color'</span>, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><p><br></p><p>JQuery 这种 API 模式也影响到了其他领域，比如 Iot 领域的 <a href="https://ruff.io/zh-cn/docs/getting-started.html" target="_blank" rel="noopener"><code>Ruff</code></a>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ready(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点亮灯</span></span><br><span class="line">  $(<span class="string">'#led-r'</span>).turnOn()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>jest</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(z).not.toBeNull()</span><br><span class="line">expect(z).toBeDefined()</span><br><span class="line">expect(value).toBeGreaterThan(<span class="number">3</span>)</span><br><span class="line">expect(value).toBeGreaterThanOrEqual(<span class="number">3.5</span>)</span><br></pre></td></tr></table></figure><p><br></p><p>API Mock 服务器领域也有两个这样的例子:</p><p><a href="https://github.com/nock/nock" target="_blank" rel="noopener">Nock</a>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scope = nock(<span class="string">'http://myapp.iriscouch.com'</span>)</span><br><span class="line">  .get(<span class="string">'/users/1'</span>)</span><br><span class="line">  .reply(<span class="number">404</span>)</span><br><span class="line">  .post(<span class="string">'/users'</span>, &#123;</span><br><span class="line">    username: <span class="string">'pgte'</span>,</span><br><span class="line">    email: <span class="string">'pedro.teixeira@gmail.com'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .reply(<span class="number">201</span>, &#123;</span><br><span class="line">    ok: <span class="literal">true</span>,</span><br><span class="line">    id: <span class="string">'123ABC'</span>,</span><br><span class="line">    rev: <span class="string">'946B7D1C'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .get(<span class="string">'/users/123ABC'</span>)</span><br><span class="line">  .reply(<span class="number">200</span>, &#123;</span><br><span class="line">    _id: <span class="string">'123ABC'</span>,</span><br><span class="line">    _rev: <span class="string">'946B7D1C'</span>,</span><br><span class="line">    username: <span class="string">'pgte'</span>,</span><br><span class="line">    email: <span class="string">'pedro.teixeira@gmail.com'</span>,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>还有网易云团队的 <a href="https://docs.svrx.io/zh/guide/route.html" target="_blank" rel="noopener">Srvx</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span>('/handle(.*)').to.handle(ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'handle'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">get</span>('/blog(.*)').to.json(&#123; code: <span class="number">200</span> &#125;)</span><br><span class="line"><span class="keyword">get</span>('/code(.*)').to.send('code', 201)</span><br><span class="line"><span class="keyword">get</span>('/json(.*)').to.send(&#123; json: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="keyword">get</span>('/text(.*)').to.send('haha')</span><br><span class="line"><span class="keyword">get</span>('/html(.*)').to.send('&lt;html&gt;haha&lt;/html&gt;')</span><br><span class="line"><span class="keyword">get</span>('/rewrite:path(.*)').to.rewrite('/query&#123;path&#125;<span class="string">')</span></span><br><span class="line"><span class="string">get('</span>/redirect:path(.*)<span class="string">').to.redirect('</span>localhost:<span class="number">9002</span>/proxy&#123;path&#125;<span class="string">')</span></span><br><span class="line"><span class="string">get('</span>/api(.*)<span class="string">').to.proxy('</span>http:<span class="comment">//mock.server.com/')</span></span><br><span class="line"><span class="keyword">get</span>('/test(.*)').to.proxy('http://mock.server.com/', &#123;</span><br><span class="line">  secure: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">get</span>('/test/:id').to.proxy('http://&#123;id&#125;.dynamic.server.com/<span class="string">')</span></span><br><span class="line"><span class="string">get('</span>/query(.*)<span class="string">').to.handle(ctx =&gt; &#123;</span></span><br><span class="line"><span class="string">  ctx.body = ctx.query</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">get('</span>/header(.*)<span class="string">')</span></span><br><span class="line"><span class="string">  .to.header(&#123; '</span>X-From<span class="string">': '</span>svrx<span class="string">' &#125;)</span></span><br><span class="line"><span class="string">  .json(&#123; user: '</span>svrx<span class="string">' &#125;)</span></span><br><span class="line"><span class="string">get('</span>/user<span class="string">').to.json(&#123; user: '</span>svrx<span class="string">' &#125;)</span></span><br><span class="line"><span class="string">get('</span>/sendFile/:path(.*)<span class="string">').to.sendFile('</span>./&#123;path&#125;<span class="string">')</span></span><br></pre></td></tr></table></figure><p><br></p><p>链式调用模式目前是主流的 JavaScript 内部 DSL 形式。而且实现也比较简单，<strong>更重要的是它接近自然语言</strong>。</p><p><br><br><br></p><h3 id="2-3-es2015-template-tag"><a href="#2-3-es2015-template-tag" class="headerlink" title="2.3 ES2015 Template Tag"></a>2.3 ES2015 Template Tag</h3><p>近年基于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings" target="_blank" rel="noopener">ES6 Template Tag</a> 特性引入‘新语言‘到 JavaScript 的库层出不穷。</p><p><strong>不过因为 ES6 Template Tag 本质上是字符串，所以需要解析和转换，因此更像是外部 DSL。别忘了 Compiler as Framework! 通常我们可以利用 Babel 插件在编译时提前将它们转换为 JavaScript 代码。</strong></p><p><br></p><p>举几个流行的例子:</p><p><a href="https://github.com/modernserf/zebu" target="_blank" rel="noopener">Zebu</a>: 这是一个专门用于解析 Template Tag 的小型编译器, 看看它的一些内置例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 范围</span></span><br><span class="line">range<span class="string">`1,3 ... (10)`</span> <span class="comment">// [1, 3, 5, 7, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态机, 牛逼</span></span><br><span class="line"><span class="keyword">const</span> traffic = machine<span class="string">`</span></span><br><span class="line"><span class="string">  initState: #green</span></span><br><span class="line"><span class="string">  states: #green | #yellow | #red</span></span><br><span class="line"><span class="string">  events: #timer</span></span><br><span class="line"><span class="string">  onTransition: <span class="subst">$&#123;state =&gt; <span class="built_in">console</span>.log(state)&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  #green  @ #timer -&gt; #yellow</span></span><br><span class="line"><span class="string">  #yellow @ #timer -&gt; #red</span></span><br><span class="line"><span class="string">  #red    @ #timer -&gt; #green</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">traffic.start() <span class="comment">// log &#123; type: "green" &#125;</span></span><br><span class="line">traffic.send(&#123; <span class="attr">type</span>: <span class="string">'timer'</span> &#125;) <span class="comment">// log &#123; type: "yellow" &#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>Jest 表格测试:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe.each<span class="string">`</span></span><br><span class="line"><span class="string">  a    | b    | expected</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;<span class="number">1</span>&#125;</span> | <span class="subst">$&#123;<span class="number">1</span>&#125;</span> | <span class="subst">$&#123;<span class="number">2</span>&#125;</span></span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;<span class="number">1</span>&#125;</span> | <span class="subst">$&#123;<span class="number">2</span>&#125;</span> | <span class="subst">$&#123;<span class="number">3</span>&#125;</span></span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;<span class="number">2</span>&#125;</span> | <span class="subst">$&#123;<span class="number">1</span>&#125;</span> | <span class="subst">$&#123;<span class="number">3</span>&#125;</span></span></span><br><span class="line"><span class="string">`</span>(<span class="string">'$a + $b'</span>, (&#123; a, b, expected &#125;) =&gt; &#123;</span><br><span class="line">  test(<span class="string">`returns <span class="subst">$&#123;expected&#125;</span>`</span>, () =&gt; &#123;</span><br><span class="line">    expect(a + b).toBe(expected)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  test(<span class="string">`returned value not be greater than <span class="subst">$&#123;expected&#125;</span>`</span>, () =&gt; &#123;</span><br><span class="line">    expect(a + b).not.toBeGreaterThan(expected)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  test(<span class="string">`returned value not be less than <span class="subst">$&#123;expected&#125;</span>`</span>, () =&gt; &#123;</span><br><span class="line">    expect(a + b).not.toBeLessThan(expected)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>除此之外还有:</p><ul><li><a href="https://github.com/developit/htm" target="_blank" rel="noopener">htm</a></li><li><a href="https://github.com/apollographql/graphql-tag" target="_blank" rel="noopener">graphql-tag</a></li><li><a href="http://styled-components.com" target="_blank" rel="noopener">styled-components</a></li></ul><p><br></p><p>Template Tag 这些方案给我们开了很多脑洞。尽管如此，它也带来了一些复杂性，就像开头说的，它们是字符串，需要解析、语法检查和转换，且 JavaScript 本身的语言机制并没有给它们带来多少便利(如语法高亮、类型检查)。</p><p><br><br><br></p><h3 id="2-4-要不试试-jsx？"><a href="#2-4-要不试试-jsx？" class="headerlink" title="2.4 要不试试 JSX？"></a>2.4 要不试试 JSX？</h3><p>铺垫了这么多，只是前戏。上面提到这些方案，要么过于简单、要么过于复杂、要么平淡无奇。我将目光投向了 JSX，我发现它可以满足我的大部分需求。</p><p>先来看看一下我们的 Mock 服务器的原型设计:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Get, Post, mock &#125; <span class="keyword">from</span> <span class="string">'jsxmock'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (</span><br><span class="line">  &lt;server port=<span class="string">"4321"</span>&gt;</span><br><span class="line">    &#123;<span class="comment">/* 首页 */</span>&#125;</span><br><span class="line">    &lt;Get&gt;hello world&lt;<span class="regexp">/Get&gt;</span></span><br><span class="line"><span class="regexp">    &#123;/</span>* 登录 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">    &lt;Post path="/</span>login<span class="string">"&gt;login success&lt;/Post&gt;</span></span><br><span class="line"><span class="string">    &#123;/* 返回 JSON */&#125;</span></span><br><span class="line"><span class="string">    &lt;Get path="</span>/json<span class="string">"&gt;&#123;&#123; id: 1 &#125;&#125;&lt;/Get&gt;</span></span><br><span class="line"><span class="string">    &#123;/* mockjs */&#125;</span></span><br><span class="line"><span class="string">    &lt;Get path="</span>/mockjs<span class="string">"&gt;&#123;mock(&#123; 'id|+1': 1, name: '@name' &#125;)&#125;&lt;/Get&gt;</span></span><br><span class="line"><span class="string">    &#123;/*自定义逻辑*/&#125;</span></span><br><span class="line"><span class="string">    &lt;Get path="</span>/user/:id<span class="string">"&gt;&#123;(req, res) =&gt; res.send('hello')&#125;&lt;/Get&gt;</span></span><br><span class="line"><span class="string">  &lt;/server&gt;</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure><p><br></p><p>嵌套匹配场景</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (</span><br><span class="line">  &lt;server&gt;</span><br><span class="line">    &lt;Get path=<span class="string">"/api"</span>&gt;</span><br><span class="line">      &#123;<span class="comment">/* 匹配 /api?method=foo */</span>&#125;</span><br><span class="line">      &lt;MatchBySearch key=<span class="string">"method"</span> value=<span class="string">"foo"</span>&gt;</span><br><span class="line">        foo</span><br><span class="line">      &lt;<span class="regexp">/MatchBySearch&gt;</span></span><br><span class="line"><span class="regexp">      &#123;/</span>* 匹配 /api?method=bar *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">      &lt;MatchBySearch key="method" value="bar"&gt;</span></span><br><span class="line"><span class="regexp">        bar</span></span><br><span class="line"><span class="regexp">      &lt;/</span>MatchBySearch&gt;</span><br><span class="line">      &lt;BlackHole&gt;我会吃掉任何请求&lt;<span class="regexp">/BlackHole&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Get&gt;</span><br><span class="line">  &lt;<span class="regexp">/server&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p><br></p><p>有点 Verbose? 进一步封装组件:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyAwesomeAPI = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; path = <span class="string">'/api'</span>, children &#125; = props</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Get path=&#123;path&#125;&gt;</span><br><span class="line">      &#123;<span class="built_in">Object</span>.keys(children).map(<span class="function"><span class="params">name</span> =&gt;</span> (</span><br><span class="line">        &lt;MatchBySearch key=<span class="string">"method"</span> value=&#123;name&#125;&gt;</span><br><span class="line">          &#123;children[name]&#125;</span><br><span class="line">        &lt;<span class="regexp">/MatchBySearch&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Get&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (</span><br><span class="line">  &lt;server&gt;</span><br><span class="line">    &lt;MyAwesomeAPI&gt;&#123;&#123; <span class="attr">foo</span>: <span class="string">'foo'</span>, <span class="attr">bar</span>: <span class="string">'bar'</span> &#125;&#125;&lt;<span class="regexp">/MyAwesomeAPI&gt;</span></span><br><span class="line"><span class="regexp">    &lt;MyAwesomeAPI path="/</span>api<span class="number">-2</span><span class="string">"&gt;&#123;&#123; hello: 'foo', world: 'bar' &#125;&#125;&lt;/MyAwesomeAPI&gt;</span></span><br><span class="line"><span class="string">  &lt;/server&gt;</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure><p><br></p><p>看起来不错哈？我们看到了 JSX 作为 DSL 的潜力，也把 React 的组件思维搬到了 GUI 之外的领域。</p><p><br></p><hr><p><br></p><p>你知道我的风格，篇幅较长 ☕️ 休息一会，再往下看。</p><p><br><br><br></p><h2 id="3-jsx-入门"><a href="#3-jsx-入门" class="headerlink" title="3. JSX 入门"></a>3. JSX 入门</h2><p>如果你是 React 的开发者，JSX 应该再熟悉不过了。它不过是一个语法糖，但是它目前不是 JavaScript 标准的一部分。Babel、Typescript 都支持转译 JSX。</p><p>例如</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jsx = (</span><br><span class="line">  &lt;div foo=<span class="string">"bar"</span>&gt;</span><br><span class="line">    &lt;span&gt;<span class="number">1</span>&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span&gt;2&lt;/</span>span&gt;</span><br><span class="line">    &lt;Custom&gt;custom element&lt;<span class="regexp">/Custom&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>会转译为:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jsx = React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    foo: <span class="string">'bar'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  React.createElement(<span class="string">'span'</span>, <span class="literal">null</span>, <span class="string">'1'</span>),</span><br><span class="line">  React.createElement(<span class="string">'span'</span>, <span class="literal">null</span>, <span class="string">'2'</span>),</span><br><span class="line">  React.createElement(Custom, <span class="literal">null</span>, <span class="string">'custom element'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-1-自定义工厂"><a href="#3-1-自定义工厂" class="headerlink" title="3.1 自定义工厂"></a>3.1 自定义工厂</h3><p>JSX 需要一个<strong>工厂方法</strong>来创建创建’节点实例’。默认是 <code>React.createElement</code>。我们可以通过注释配置来提示转译插件。按照习惯，自定义工厂都命名为 <code>h</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* @jsx h */</span></span><br><span class="line"><span class="comment">/* @jsxFrag 'fragment' */</span></span><br><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">'somelib'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jsx = (</span><br><span class="line">  &lt;div foo=<span class="string">"bar"</span>&gt;</span><br><span class="line">    &lt;span&gt;<span class="number">1</span>&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span&gt;2&lt;/</span>span&gt;</span><br><span class="line">    &lt;&gt;fragement&lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>将转译为:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">'somelib'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jsx = h(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    foo: <span class="string">'bar'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  h(<span class="string">'span'</span>, <span class="literal">null</span>, <span class="string">'1'</span>),</span><br><span class="line">  h(<span class="string">'span'</span>, <span class="literal">null</span>, <span class="string">'2'</span>),</span><br><span class="line">  h(<span class="string">'fragment'</span>, <span class="literal">null</span>, <span class="string">'fragement'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-2-host-component-vs-custom-component"><a href="#3-2-host-component-vs-custom-component" class="headerlink" title="3.2 Host Component vs Custom Component"></a>3.2 Host Component vs Custom Component</h3><p>JSX 会区分两种组件类型。小写开头的为内置组件，它们以字符串的形式传入 createElement; 大写开头的表示自定义组件, 作用域内必须存在该变量, 否则会报错。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内置组件</span></span><br><span class="line">;<span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span></span><br><span class="line"><span class="xml">// 自定义组件</span></span><br><span class="line"><span class="xml">;<span class="tag">&lt;<span class="name">Custom</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-3-简单实现-createelement-工厂方法"><a href="#3-3-简单实现-createelement-工厂方法" class="headerlink" title="3.3 简单实现 createElement 工厂方法"></a>3.3 简单实现 createElement 工厂方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> copy = &#123; ...(props || EMPTY_OBJECT) &#125;</span><br><span class="line">  copy.children = copy.children || (children.length &gt; <span class="number">1</span> ? children : children[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    _vnode: <span class="literal">true</span>,</span><br><span class="line">    type,</span><br><span class="line">    props: copy,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="4-基础组件的设计"><a href="#4-基础组件的设计" class="headerlink" title="4. 基础组件的设计"></a>4. 基础组件的设计</h2><h3 id="4-1-来源于-koa-的灵感"><a href="#4-1-来源于-koa-的灵感" class="headerlink" title="4.1 来源于 Koa 的灵感"></a>4.1 来源于 Koa 的灵感</h3><p>大家应该比较熟悉 koa 中间件机制。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// logger</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  <span class="keyword">const</span> rt = ctx.response.get(<span class="string">'X-Response-Time'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;rt&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// x-response-time</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="built_in">Date</span>.now() - start</span><br><span class="line">  ctx.set(<span class="string">'X-Response-Time'</span>, <span class="string">`<span class="subst">$&#123;ms&#125;</span>ms`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// response</span></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'Hello World'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>形象的说，它就是一个洋葱模型:</p><p><img src="/images/jsx-as-dsl/koa.png" alt></p><p><br></p><p>中间件调用 next，就会进入下一级。 如果把函数的边界打破。它的样子确实像洋葱:</p><p><img src="/images/jsx-as-dsl/koa-2.png" alt></p><p><br></p><p>✨<strong>我发现使用 JSX 可以更直观地表示这种洋葱结构</strong></p><p><br></p><p><img src="/images/jsx-as-dsl/koa-3.png" alt></p><p><br><br><br></p><h3 id="4-2-use-基础组件"><a href="#4-2-use-基础组件" class="headerlink" title="4.2 use 基础组件"></a>4.2 use 基础组件</h3><p>于是乎，有了 <code>&lt;use /&gt;</code> 这个基础组件。它类似于 Koa 的 <code>app.use</code>, 用于拦截请求，可以进行响应, 也可以选择进入下一层。</p><p><strong>① 来看看整体设计</strong>。</p><p>use 正是基于上面说的，使用 JSX 来描述中间件包裹层次的基础组件。因为使用的是一种树状结构，所以要区分<strong>兄弟中间件</strong>和<strong>子中间件</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;server&gt;</span><br><span class="line">  &lt;use m=&#123;A&#125;&gt;</span><br><span class="line">    &lt;use m=&#123;Aa&#125; /&gt;</span><br><span class="line">    &lt;use m=&#123;Ab&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">  &lt;use m=&#123;B&#125; /</span>&gt;</span><br><span class="line">  &lt;use m=&#123;C&#125; /&gt;</span><br><span class="line">&lt;<span class="regexp">/server&gt;</span></span><br></pre></td></tr></table></figure><p>其中 <code>Aa</code>、<code>Ab</code> 就是 <code>A</code> 的<strong>子中间件</strong>。在 A 中可以调用类似 koa 的 <code>next</code> 函数，进入下级中间件。</p><p><code>A</code>、<code>B</code>、<code>C</code>之间就是<strong>兄弟中间件</strong>。当前继中间件未匹配时，就会执行下一个相邻中间件。</p><p>乍一看，这就是 koa 和 express 的结合啊!</p><p><br></p><p><strong>② 再看看 Props 设计</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface UseProps &#123;</span><br><span class="line">  m: <span class="function">(<span class="params">req, res, recurse: (</span>) =&gt;</span> <span class="built_in">Promise</span>&lt;boolean&gt;) =&gt; <span class="built_in">Promise</span>&lt;boolean&gt;;</span><br><span class="line">  skip?: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>m</code></p><ul><li><p><code>req</code>、<code>res</code>：Express 的请求对象和响应对象</p></li><li><p><code>recurse</code>：递归执行子级中间件, 类似 koa 的 next。返回一个<code>Promise&lt;boolean&gt;</code>, 它将在下级中间件执行完成后 resolve，boolean 表示下级中间件是否匹配拦截了请求。</p></li><li><p>返回值：返回一个 <code>Promise&lt;boolean&gt;</code> 表示当前中间件是否匹配(拦截请求)。如果匹配，后续的兄弟中间件将不会被执行。</p></li></ul></li><li><p><code>skip</code>：强制跳过，我们在开发时可能会临时跳过匹配请求，这个有点像单元测试中的 skip</p></li></ul><p><br></p><p><strong>③ 看一下运行实例</strong></p><p>假设代码为:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cb = <span class="function"><span class="params">name</span> =&gt;</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (</span><br><span class="line">  &lt;server&gt;</span><br><span class="line">    &lt;use</span><br><span class="line">      m=&#123;<span class="keyword">async</span> (req, res, rec) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'A'</span>)</span><br><span class="line">        <span class="keyword">if</span> (req.path === <span class="string">'/user'</span>) <span class="keyword">await</span> rec() <span class="comment">// 如果匹配，则放行，让其递归进入内部</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'end A'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;use m=&#123;cb(<span class="string">'A-1'</span>)&#125;&gt;如果父级匹配，则这里会被执行&lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">      &lt;use m=&#123;cb('A-2')&#125;&gt;...&lt;/u</span>se&gt;</span><br><span class="line">    &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">    &lt;use m=&#123;cb('B')&#125; /</span>&gt;</span><br><span class="line">    &lt;use m=&#123;cb(<span class="string">'C'</span>)&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/server&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>如果请求的是 ‘/‘，那么打印的是 <code>A -&gt; end A -&gt; B -&gt; C</code>；<br>如果请求为 ‘/user’, 那么打印的是 <code>A -&gt; A-1 -&gt; A-2 -&gt; end A -&gt; B -&gt; C</code></p><p><br></p><p>我们的基础组件和 Koa / Express 一样，核心保持非常小而简洁，当然它也比较低级，这样能够保证灵活性。</p><p><strong>这个简单的基础组件设计就是整个框架的‘基石’</strong>。 如果你了解 Koa 和 Express，这里没有新的东西。只是换了一种表现方式。</p><p><br><br><br></p><h3 id="4-3-高层组件的封装"><a href="#4-3-高层组件的封装" class="headerlink" title="4.3 高层组件的封装"></a>4.3 高层组件的封装</h3><p>Ok, 有了 <code>use</code> 这个基础原语, 我可以做很多有意思的事情，使用组件化的思维封装出更高级的 API。</p><p><br></p><p><strong>① <code>&lt;Log&gt;</code>：打日志</strong></p><p>封装一个最简单的组件:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Log: Component = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;use</span><br><span class="line">      m=&#123;<span class="keyword">async</span> (req, res, rec) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">        <span class="comment">// 进入下一级</span></span><br><span class="line">        <span class="keyword">const</span> rtn = <span class="keyword">await</span> rec()</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">          <span class="string">`<span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;req.path&#125;</span>: <span class="subst">$&#123;<span class="built_in">Date</span>.now() - start&#125;</span>ms`</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> rtn</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>用法:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;server&gt;</span><br><span class="line">  &lt;Log&gt;</span><br><span class="line">    &lt;Get&gt;hello world&lt;<span class="regexp">/Get&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Post path="/</span>login<span class="string">"&gt;login sucess&lt;/Post&gt;</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">  &lt;/Log&gt;</span></span><br><span class="line"><span class="string">&lt;/server&gt;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><p><strong>② <code>&lt;NotFound&gt;</code>: 404</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NotFound = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; children &#125; = props</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;use</span><br><span class="line">      m=&#123;<span class="keyword">async</span> (req, res, rec) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> found = <span class="keyword">await</span> rec()</span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">          <span class="comment">// 下级未匹配</span></span><br><span class="line">          res.status(<span class="number">404</span>)</span><br><span class="line">          res.send(<span class="string">'Not Found'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>用法和 Log 一样。<code>recurse</code> 返回 false 时，表示下级没有匹配到请求。</p><p><br><br><br></p><p><strong>③ <code>&lt;Catch&gt;</code>: 异常处理</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Catch: Component = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;use</span><br><span class="line">      m=&#123;<span class="keyword">async</span> (req, res, rec) =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">await</span> rec()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          res.status(<span class="number">500</span>)</span><br><span class="line">          res.send(err.message)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>用法和 Log 一样。捕获下级中间件的异常。</p><p><br><br><br></p><p><strong>④ <code>&lt;Match&gt;</code>: 请求匹配</strong></p><p>Match 组件也是一个非常基础的组件，其他高层组件都是基于它来实现。它用于匹配请求，并作出响应。先来看看 Props 设计：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type CustomResponder =</span><br><span class="line">  | MiddlewareMatcher</span><br><span class="line">  | MockType</span><br><span class="line">  | boolean</span><br><span class="line">  | string</span><br><span class="line">  | number</span><br><span class="line">  | object</span><br><span class="line">  | <span class="literal">null</span></span><br><span class="line">  | <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface MatchProps &#123;</span><br><span class="line">  match?: <span class="function">(<span class="params">req: Request, res: Response</span>) =&gt;</span> boolean <span class="comment">// 请求匹配</span></span><br><span class="line">  headers?: StringRecord <span class="comment">// 默认响应报头</span></span><br><span class="line">  code?: number | string <span class="comment">// 默认响应码</span></span><br><span class="line">  <span class="comment">// children 类型则比较复杂, 可以是原始类型、对象、Mock对象、自定义响应函数，以及下级中间件</span></span><br><span class="line">  children?: ComponentChildren | CustomResponder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>Match 组件主体:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Match = <span class="function">(<span class="params">props: MatchProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; match, skip, children &#125; = props</span><br><span class="line">  <span class="comment">// 对 children 进行转换</span></span><br><span class="line">  <span class="keyword">let</span> response = generateCustomResponder(children, props)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;use</span><br><span class="line">      skip=&#123;skip&#125;</span><br><span class="line">      m=&#123;<span class="keyword">async</span> (req, res, rec) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 检查是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (match ? match(req, res) : <span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (response) &#123;</span><br><span class="line">            <span class="keyword">return</span> response(req, res, rec)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果没有响应器，则将控制权交给下级组件</span></span><br><span class="line">          <span class="keyword">return</span> rec()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>限于篇幅，Match 的具体细节可以看<a href="https://github.com/ivan-94/jsxmock/blob/master/src/components/Match.tsx" target="_blank" rel="noopener">这里</a></p><p>前进，前进。 <code>Get</code>、<code>Post</code>、<code>Delete</code>、<code>MatchByJSON</code>、<code>MatchBySearch</code> 都是在 <code>Match</code> 基础上封装了，这里就不展开了。</p><p><br><br><br></p><p><strong>⑤ <code>&lt;Delay&gt;</code>: 延迟响应</strong></p><p>太兴奋了，一不小心又写得老长，我可以去写小册了。Ok, 最后一个例子, 在 Mock API 会有模拟延迟响应的场景, 实现很简单:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Delay = <span class="function">(<span class="params">props: DelayProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; timeout = <span class="number">3000</span>, ...other &#125; = props</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;use</span><br><span class="line">      m=&#123;<span class="keyword">async</span> (req, res, rec) =&gt; &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> setTimeout(res, timeout))</span><br><span class="line">        <span class="keyword">return</span> rec()</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;Match &#123;...other&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/use&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>用法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Get path=<span class="string">"/delay"</span>&gt;</span><br><span class="line">  &#123;<span class="comment">/* 延迟 5s 返回 */</span>&#125;</span><br><span class="line">  &lt;Delay timeout=&#123;<span class="number">5000</span>&#125;&gt;Delay Delay...&lt;<span class="regexp">/Delay&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Get&gt;</span><br></pre></td></tr></table></figure><p>更多使用案例，请看 <a href="https://github.com/ivan-94/jsxmock" target="_blank" rel="noopener">jsxmock 文档</a>)</p><p>坚持到这里不容易，你对它的原理可能感兴趣，那不妨继续看下去。</p><p><br><br><br></p><h2 id="5-浅谈实现原理"><a href="#5-浅谈实现原理" class="headerlink" title="5. 浅谈实现原理"></a>5. 浅谈实现原理</h2><p>简单看一下实现。如果了解过 React 或者 Virtual-DOM 的实现原理。这一切就很好理解了。</p><p><br></p><h3 id="5-1-‘渲染’"><a href="#5-1-‘渲染’" class="headerlink" title="5.1 ‘渲染’"></a>5.1 ‘渲染’</h3><p>这是打了引号的’渲染’。这只是一种习惯的称谓，并不是指它会渲染成 GUI。它用来展开整颗 JSX 树。对于我们来说很简单，我们没有所谓的更新或者 UI 渲染相关的东西。只需递归这个树、收集我们需要的东西即可。</p><p>我们的目的是收集到所有的中间件，以及它们的嵌套关系。我们用 MiddlewareNode 这个树形数据结构来存储它们：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type Middleware = (</span><br><span class="line">  req: Request,</span><br><span class="line">  res: Response,</span><br><span class="line">  <span class="comment">// 递归</span></span><br><span class="line">  recurse: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>&lt;boolean&gt;,</span><br><span class="line">) =&gt; <span class="built_in">Promise</span>&lt;boolean&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface MiddlewareNode &#123;</span><br><span class="line">  m: Middleware           <span class="comment">// 中间件函数</span></span><br><span class="line">  skip: boolean           <span class="comment">// 是否跳过</span></span><br><span class="line">  children: MiddlewareNode[] <span class="comment">// 子级中间件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染函数:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> currentMiddlewareNode</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 🔴 创建根中间件</span></span><br><span class="line">  <span class="keyword">const</span> middlewares = (currentMiddlewareNode = createMiddlewareNode())</span><br><span class="line">  <span class="comment">// 🔴 挂载</span></span><br><span class="line">  <span class="keyword">const</span> tree = mount(vnode)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>挂载是一个递归的过程，这个过程中，遇到<code>自定义组件</code>我们就展开，遇到 use 组件就将它们收集到 <code>currentMiddlewareNode</code> 中:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prevMiddlewareNode</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode.type === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 🔴自定义组件展开</span></span><br><span class="line">    <span class="keyword">const</span> rtn = vnode.type(vnode.props)</span><br><span class="line">    <span class="keyword">if</span> (rtn != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 递归挂载自定义组件的渲染结果</span></span><br><span class="line">      mount(rtn, inst)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode.type === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="comment">// 内置组件</span></span><br><span class="line">    <span class="keyword">if</span> (vnode.type === <span class="string">'use'</span>) &#123;</span><br><span class="line">      <span class="comment">// 🔴收集中间件</span></span><br><span class="line">      <span class="keyword">const</span> md = createMiddlewareNode(inst.props.m)</span><br><span class="line">      md.skip = !!inst.props.skip</span><br><span class="line">      currentMiddlewareNode.children.push(md)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 保存父级中间件</span></span><br><span class="line">      prevMiddlewareNode = currentMiddlewareNode</span><br><span class="line">      currentMiddlewareNode = md <span class="comment">// ⬇️推入栈，下级的中间件将加入这个列表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ... 其他内置组件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 🔴递归挂载子级节点</span></span><br><span class="line">    mountChilren(inst.props.children, inst)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vnode.type === <span class="string">'use'</span>) &#123;</span><br><span class="line">      currentMiddlewareNode = prevMiddlewareNode <span class="comment">// ⬆️弹出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🔴 子节点列表挂载</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountChilren</span>(<span class="params">children: any, parent: Instance</span>) </span>&#123;</span><br><span class="line">  childrenToArray(children).forEach(mount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="5-2-运行"><a href="#5-2-运行" class="headerlink" title="5.2 运行"></a>5.2 运行</h3><p>现在看看怎么运行起来。我们实现了一个简单的中间件机制，相对 Koa 好理解一点：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">runMiddlewares</span>(<span class="params">req, res, current</span>): <span class="title">Promise</span>&lt;<span class="title">boolean</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; m, skip, children &#125; = current</span><br><span class="line">  <span class="keyword">if</span> (skip) &#123;</span><br><span class="line">    <span class="comment">// 跳过, 直接返回 false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用中间件</span></span><br><span class="line">  <span class="keyword">return</span> m(req, res, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// recurse 回调</span></span><br><span class="line">    <span class="comment">// 🔴 如果有下级中间件，则递归调用子级中间件</span></span><br><span class="line">    <span class="keyword">if</span> (children &amp;&amp; children.length) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> child <span class="keyword">of</span> children) &#123;</span><br><span class="line">        <span class="keyword">const</span> matched = <span class="keyword">await</span> runMiddlewares(req, res, child)</span><br><span class="line">        <span class="keyword">if</span> (matched) &#123;</span><br><span class="line">          <span class="comment">// 🔴 如果其中一个兄弟中间件匹配，后续的中间件都不会被执行</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 🔴 没有下级中间件，或者没有任何下级中间件匹配</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>很简单哈？ 就是递归递归递归</p><p><br><br><br></p><h2 id="6-总结，终于完事了"><a href="#6-总结，终于完事了" class="headerlink" title="6. 总结，终于完事了"></a>6. 总结，终于完事了</h2><p>本文从配置文件讲到 DSL，又讲到了 JavaScript 内部 DSL 表达形式和能力。最后将焦点聚集在了 JSX 上面。</p><p>我通过一个实战的案例展示了 JSX 和 React 的组件化思维，它不仅仅适用于描述用户界面，我们也看到 JSX 作为一种 DSL 的潜力和灵活性。</p><p>最后总结一下优缺点。</p><p><br></p><p><strong>✅ 优点</strong></p><ul><li><strong>更好的类型推断和约束</strong>。 Typescript 友好</li><li><strong>可组合</strong>。具有组件封装和组合能力, 可以轻易封装高级、易于使用的接口</li><li><strong>Just Javascript</strong>。 本身就是 JavaScript 代码，很灵活</li><li><strong>更好的组织性、媲美配置文件</strong>。JSX 语法类似于 XML，有良好的组织性。</li><li><strong>习惯</strong>。 如果你习惯 React，Vue 这类前端框架，JSX 配置方式很容易被接受和上手</li><li><strong>实现简单</strong>。</li><li><strong>更能直观地表现层级结构</strong>。比如表示中间件的洋葱结构</li><li><strong>模块化</strong>。与生俱来，可以将接口分发到不同的文件中，然后可轻易地组合起来。</li></ul><p><br></p><p><strong>⚠️ 缺点</strong></p><ul><li>代码需要转译。需要 Babel 和 Typescript 转译。</li><li>有点 Verbose。</li></ul><p><br></p><p><strong>灵活却有组织性</strong>。灵活通常容易导致杂乱无章，组织性则可能意味着牺牲灵活性，两者在某种意义上面看是矛盾的。能够将两者平衡案例其实很少见，JSX 可能是一个。（我好像在吹 🐂）</p><p><br></p><p><strong>🎉🎉代码已经在 Github, 目前正处于原型阶段: <a href="https://github.com/ivan-94/jsxmock" target="_blank" rel="noopener">ivan-94/jsxmock</a> 欢迎 ⭐️ 和贡献。</strong></p><p><br><br><br></p><h2 id="7-扩展"><a href="#7-扩展" class="headerlink" title="7. 扩展"></a>7. 扩展</h2><ul><li><a href="https://www.yinwang.org/blog-cn/2017/05/25/dsl" target="_blank" rel="noopener">DSL 的误区</a></li><li><a href="https://draveness.me/dsl" target="_blank" rel="noopener">谈谈 DSL 以及 DSL 的应用（以 CocoaPods 为例）</a></li><li><a href="https://www.phodal.com/blog/javascript-dsl-example/" target="_blank" rel="noopener">JavaScript DSL 示例</a></li><li><a href="https://www.zhihu.com/question/35436669" target="_blank" rel="noopener">你是如何构建 Web 前端 Mock Server 的？</a></li><li><a href="https://docs.svrx.io/zh/blog/mock.html" target="_blank" rel="noopener">使用 svrx 实现更优雅的接口 Mock</a></li></ul><p><br></p><p>也学别人建个群(好多读者问过)，试试水吧…</p><p><img src="/images/group.png" alt></p><p><br></p><p><img src="/images/sponsor.jpg" alt></p><p><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天打算写一个简单的 API Mock 服务器，老生常谈哈？其实我是想讲 JSX, Mock 服务器只是一个幌子。我在寻找一种更简洁、方便、同时又可以灵活扩展的、和别人不太一样的方式，来定义各种 Mock API。后来我发现了 JSX 在领域问题描述的优势和潜力，当然这可
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>如何学一门新语言，以 Dart 为例</title>
    <link href="https://bobi.ink/2019/11/23/learn-lang/"/>
    <id>https://bobi.ink/2019/11/23/learn-lang/</id>
    <published>2019-11-22T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.329Z</updated>
    
    <content type="html"><![CDATA[<p>世界上没有一种可以各个领域通吃的语言，为了应对不同的场景和需求，我们摆脱不了要学习一门新的语言。最近准备入坑 <code>Flutter</code>(技术储备)，学了点 Dart, 一点心得分享给大家。</p><p><br></p><p><strong>大纲</strong></p><!-- TOC --><ul><li><a href="#介绍">介绍</a><ul><li><a href="#1-假定前提">1. 假定前提</a></li><li><a href="#2-基本原则">2. 基本原则</a></li><li><a href="#3-基本姿势">3. 基本姿势</a></li></ul></li><li><a href="#已有的语言认知">已有的语言认知</a></li><li><a href="#建立标签云">建立标签云</a></li><li><a href="#刻意学习以-dart-为例">刻意学习，以 Dart 为例</a><ul><li><a href="#①-2018-最坑人语言">① 2018 最坑人语言?</a></li><li><a href="#②-针对客户端优化">② 针对客户端优化</a></li><li><a href="#③-面向对象">③ 面向对象</a></li><li><a href="#④-操作符">④ 操作符</a></li><li><a href="#⑤-constfinal-与静态数据">⑤ const/final 与静态数据</a></li><li><a href="#⑥-类型系统">⑥ 类型系统</a></li><li><a href="#⑦-异步异步">⑦ 异步异步</a></li><li><a href="#⑧-元编程">⑧ 元编程</a></li></ul></li><li><a href="#实践">实践</a></li><li><a href="#深入了解这门语言">深入了解这门语言</a></li><li><a href="#总结">总结</a></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="1-假定前提"><a href="#1-假定前提" class="headerlink" title="1. 假定前提"></a>1. 假定前提</h3><p>我想看这篇文章的应该都是程序员了吧？都有自己熟悉的语言，这就好办了，我们可以复用已有的认知去快速学习一门新语言。如果你是小白，这篇文章可能不适合你</p><p><br></p><h3 id="2-基本原则"><a href="#2-基本原则" class="headerlink" title="2. 基本原则"></a>2. 基本原则</h3><ul><li><p><strong>确定语言的定位和场景</strong>。别再说 PHP 是最好的语言了，大家都知道。每一门语言都有自己定位和适用场景，为了解决不同的问题。<strong>所以学习一门语言的时候，首先要了解语言的定位和领域，这样你才能明白为什么语言设计者设计某个特性的动机</strong>。例如:</p><ul><li><code>JavaScript</code>：浏览器脚本语言霸主, 写前端肯定绕不开 JavaScript 啦。一门十几天搞出来的语言，就不要问 <code>[] == ![] // true</code> 是什么动机了, 不要学这些糟粕。</li><li><code>Dart</code>： 针对客户端(‘Flutter’)优化语言, 当初号称要取代 JavaScript, 官方自己的定位就是客户端</li><li><code>Go</code>： 据说是 <code>C++</code> 编译速度慢倒逼出来的语言。所以你可以站在 C++ 的对立面去思考它的设计：例如 简单的语法、高速编译、垃圾回收、高性能、高并发。半数是为了解决 C++ 的问题。适用于服务器编程、分布式、网络编程、云平台。</li><li><code>Rust</code>： 系统编程语言，<code>C/C++</code> 最有力的挑战者</li></ul><p><br></p><p>当然，也有一些语言只有在特定平台或场景才能使用，这种没办法，这属于<strong>商业壁垒</strong>。例如</p><ul><li><code>Swift/Objective-C</code> 基本只能用于 Apple 平台，尽管 Swift 开源，也可以跑在 Linux 上，但除了 Apple 应用开发，很少看到 Swift 的身影</li><li><code>C#</code> 和 Swift 类似</li></ul><p><br></p></li><li><p><strong>不要陷入语言的语法细节，剥离掉语法糖</strong>。学习新语言，可以暂时忽略掉语法的细节, 切换到上帝视角</p></li><li><p><strong>基于原有的认知，横向进行比较</strong>。正常来说编程语言 80% 概念或范式是通用的，这就是为什么你熟悉一门语言，可以快速入门其他语言。</p></li><li><p><strong>打破认知</strong>。另外 20% 包含该门语言独有的特性和思想, 这才是我们需要关注的核心。</p></li></ul><p><br></p><h3 id="3-基本姿势"><a href="#3-基本姿势" class="headerlink" title="3. 基本姿势"></a>3. 基本姿势</h3><ul><li><strong>确定自己要解决的问题/场景</strong>。 我们学一门语言一般不是为了学习语言而学习。首先你应该有需要解决场景和问题，接着带着这些问题对编程语言进行选型，确定多个语言候选者。</li><li><strong>思考这些语言是怎么解决你的问题的？</strong> 这就是’打破认知’的过程, 分析一下这些候选者优缺点</li><li><strong>确定要学习这门语言了？</strong> 下文会按照这个步骤展开<ul><li><strong>建立标签云</strong>。收集这门语言的 20% 独有特性/思想, 例如 Killer Feature、槽点、吹点，针对性刻意进行学习。</li><li><strong>粗略过一下官方文档</strong>。 也就是那80%，对基本语法有个基本的印象，类比自己熟悉的语言，可以快速理解。</li><li><strong>开始实践</strong>。现在你这门语言建立初步的印象了。趁热开始实践，比如可以跟着官方入门教程。一边实践一边查阅文档，很快就能熟练起来</li><li><strong>深入了解这门语言</strong></li></ul></li></ul><p><br><br><br></p><h2 id="已有的语言认知"><a href="#已有的语言认知" class="headerlink" title="已有的语言认知"></a>已有的语言认知</h2><p>下面是常见编程语言的构成图谱，对照一下，这些概念是否都知道? 是否真的了解你用来吃饭的家伙?</p><p><br></p><p><img src="/images/learn-lang/langmind.png" alt></p><p><br></p><p>没看懂？看来你没学过一门真正(复杂)的语言，如 <code>Scala</code>、<code>C嘎嘎</code>，<code>Rust</code>。😺 翻过这些大山，其他的就是一览众山小了。太难了</p><p>小孩子才做选择，牛逼(有精力)的人是全都要。你也可以学几门比较有代表性语言。参考<a href="https://book.douban.com/subject/10555435/" target="_blank" rel="noopener">《七天七语言》</a>开始点技能树:</p><ul><li><p><strong>按市场划分</strong>:</p><ul><li>通用类型语言(用来吃饭的)。 例如 Java、JavaScript、Python、C/C++、Go、PHP、Objective-C/Swift(iOS开发者, 严格说不算‘通用’)</li><li>符合自己口味的小众语言。Rust、Elixir、Ruby、Kotlin、Clojure、OCaml…</li></ul></li><li><p><strong>按范式划分</strong>:</p><ul><li>面向对象: 例如 Ruby、Java、Python…</li><li>多范式: 例如 JavaScript、Scala、Rust…</li><li>函数式: 例如 Lisp(例如Clojure)、Erlang、Haskell…</li><li>过程式: 例如 C、Go(可以算是面向对象、Whatever)</li><li>原型语言: Io，好小众</li></ul></li><li><p><strong>其他划分方式</strong>:</p><ul><li>类型: 强类型、弱类型; 静态类型、动态类型</li><li>执行方式: 静态语言、脚本语言</li><li>系统层次: 系统编程语言、应用语言</li></ul></li></ul><p><br><br><br></p><h2 id="建立标签云"><a href="#建立标签云" class="headerlink" title="建立标签云"></a>建立标签云</h2><p>上文说了，80% 的知识是可以复用的，我们要针对另外 20% 该语言独有的特性和思想进行刻意学习。我这里介绍一个方法是建立一个标签云。<strong>这个标签云是对这门语言的一些关键描述</strong>。 例如它的主要特性、优点、吐槽点。</p><p>这些关键描述对我们快速了解一门语言有很大的帮助, <strong>这个标签云其实代表的就是你对这门语言的基本印象</strong>。 换句话说，你学了一门语言，但没怎么用，过一段时间就忘光了所有语法细节，但是这门语言的基本印象会长久停留在你脑海中。我想这些印象就是这门语言的精髓所在吧！</p><p>那么怎么收集这个标签云?</p><ul><li>打开官网。看官方怎么描述自己的语言、有哪些主要特性、定位是什么。</li><li>也可以通过 Wiki 看看这门语言的系统的描述和定义</li><li>知乎。看别人怎么吹或者吐槽这门语言的</li><li>道听途说</li><li>快速预览官方指南。找亮点</li></ul><p>随便举几个例子。 Dart 语言:</p><p><img src="/images/learn-lang/dart.png" alt></p><blockquote><p>标签云使用 <a href="https://www.wordclouds.com" target="_blank" rel="noopener">WordClouds</a> 生成</p></blockquote><p><br></p><p>Go 语言：</p><p><img src="/images/learn-lang/go.png" alt></p><p><br></p><p>Javascript:</p><p><img src="/images/learn-lang/javascript.png" alt></p><p><br></p><p>Elixir:</p><p><img src="/images/learn-lang/elixir.png" alt></p><p><br><br><br></p><h2 id="刻意学习，以-dart-为例"><a href="#刻意学习，以-dart-为例" class="headerlink" title="刻意学习，以 Dart 为例"></a>刻意学习，以 Dart 为例</h2><p>接着带着这些问题针对性地去学习这门语言, 这里以Dart 为例，因为这两天正好在学 Dart，准备入坑 Flutter，我自己对 Dart 没什么好感。</p><p>学习方法, 永远是 <strong>What / Why / How</strong>: 是什么，为什么这么设计，具体怎么做?</p><h3 id="①-2018-最坑人语言"><a href="#①-2018-最坑人语言" class="headerlink" title="① 2018 最坑人语言?"></a>① 2018 最坑人语言?</h3><p>没有 Flutter 这门语言确实要挂了。编程语言也要看爹</p><p><br></p><h3 id="②-针对客户端优化"><a href="#②-针对客户端优化" class="headerlink" title="② 针对客户端优化"></a>② 针对客户端优化</h3><p>这是官方自己的定位。</p><p>针对客户端优化主要体现在<code>开发体验</code>和<code>运行性能</code>上面</p><ul><li><code>JIT</code>(Just in Time) 快速编译生效，这是 Hot reload 基础。<strong>Hot reload 可以让 Flutter 接近 Web 的开发体验</strong></li><li><code>AOT</code>(Ahead of Time) 生成高效原生代码。可以得到更快的运行速度和启动速度</li><li>另外一层意思是，Dart 这门语言和 JavaScript 非常相似。比如语法、单线程/事件循环、事件驱动、async/await、Isolate、Generator、Future/Stream、collection if/for 可以媲美JSX</li><li>支持编译到JavaScript。浏览器是重要的客户端，不支持 JavaScript 还敢说客户端优化？</li></ul><p><br></p><h3 id="③-面向对象"><a href="#③-面向对象" class="headerlink" title="③ 面向对象"></a>③ 面向对象</h3><p>语法和 Java 很像，有一些语法糖挺甜的。</p><ul><li><p>没有关键字区分 class 和 interface，可以说 class 就是 interface</p></li><li><p><code>Mixins</code>。前端对 Mixin 的概念应该都不陌生，毕竟这么多人用 Vue?</p></li><li><p>操作符重载。Javascript 不支持操作符重载。所以对前端来说算是一个新东西。 不过个人不推荐，JavaScript 没有操作符重载不也用得挺爽？ 而且操作符的语义不明确，会徒增心智负担，这时候还不如使用定义良好的方法。<strong>有意义的名称比符号要好记忆</strong>。</p></li><li><p><code>new</code> 可选。在某些场景让代码更简洁，比如 Flutter 组件声明。算是弥补没有 JSX 之痛吧。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(</span><br><span class="line">    Center(</span><br><span class="line">      child: Text(</span><br><span class="line">        <span class="string">'Hello, world!'</span>,</span><br><span class="line">        textDirection: TextDirection.ltr,</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Callable Classes</code>。语法糖，没想到有什么应用场景。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WannabeFunction</span> </span>&#123;</span><br><span class="line">  call(<span class="built_in">String</span> a, <span class="built_in">String</span> b, <span class="built_in">String</span> c) =&gt; <span class="string">'<span class="subst">$a</span> <span class="subst">$b</span> <span class="subst">$c</span>!'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wf = <span class="keyword">new</span> WannabeFunction();</span><br><span class="line"><span class="keyword">var</span> out = wf(<span class="string">"Hi"</span>,<span class="string">"there,"</span>,<span class="string">"gang"</span>); <span class="comment">// 🍬</span></span><br></pre></td></tr></table></figure><p>我直接 <code>wf.call</code> 也不麻烦吧? 灵感来自JavaScript？ JavaScript 的函数也是一个对象，可以有自己属性</p></li></ul><p><br></p><h3 id="④-操作符"><a href="#④-操作符" class="headerlink" title="④ 操作符"></a>④ 操作符</h3><p>Dart 也有一些有趣的操作符/表达式，来看看有多甜：</p><ul><li><p><strong>级联操作符(Cascade Notation)</strong>。级联操作符是一个很甜的语法糖。不说废话，看代码:</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">querySelector</span>(<span class="string">'#confirm'</span>) <span class="comment">// Get an object.</span></span><br><span class="line">..text = <span class="string">'Confirm'</span> <span class="comment">// 🍬 甜点，这是类 jQuery 的串行调用的增强版</span></span><br><span class="line">..classes.add(<span class="string">'important'</span>)</span><br><span class="line">..onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">'Confirmed!'</span>));</span><br></pre></td></tr></table></figure><p>等价于:</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">querySelector</span>(<span class="string">'#confirm'</span>);</span><br><span class="line">button.text = <span class="string">'Confirm'</span>;</span><br><span class="line">button.classes.add(<span class="string">'important'</span>);</span><br><span class="line">button.onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">'Confirmed!'</span>));</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><p><strong>容器操作符(Collection Operators)</strong>。这个语法糖也会比较甜，前期用 Dart 来描述 Flutter 的视图是一件很痛苦的事情。Dart 陆续添加了一些甜点，如<code>展开操作符</code>、<code>Collection if/for</code>, 再加上<code>命名函数参数</code>和 <code>new可选</code>，表达力已经很接近 JSX 了</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, ...list];</span><br><span class="line">[<span class="number">0</span>, ...?list]; <span class="comment">// 支持识别null的展开操作符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// collection if</span></span><br><span class="line"><span class="keyword">var</span> nav = [</span><br><span class="line">  <span class="string">'Home'</span>,</span><br><span class="line">  <span class="string">'Furniture'</span>,</span><br><span class="line">  <span class="string">'Plants'</span>,</span><br><span class="line">  <span class="keyword">if</span> (promoActive) <span class="string">'Outlet'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// collection for</span></span><br><span class="line"><span class="keyword">var</span> listOfStrings = [</span><br><span class="line">  <span class="string">'#0'</span>,</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> listOfInts) <span class="string">'#<span class="subst">$i</span>'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><br></p><p><img src="/images/learn-lang/flutter-code.png" alt></p></li></ul><p><br></p><h3 id="⑤-const-final-与静态数据"><a href="#⑤-const-final-与静态数据" class="headerlink" title="⑤ const/final 与静态数据"></a>⑤ const/final 与静态数据</h3><p>在 dart 中 const/final 使用的地方非常多，可以用于修饰变量、实例变量、对象创建。</p><blockquote><p>注意：静态数据和不可变数据是不同的概念</p></blockquote><ul><li>变量修饰</li></ul><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> name = <span class="string">'Bob'</span>;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> foo = [];</span><br><span class="line"><span class="keyword">const</span> baz = [];</span><br><span class="line"></span><br><span class="line">console.log(foo == baz); <span class="comment">// true 编译时常量</span></span><br></pre></td></tr></table></figure><p>const 将被视为’编译时’常量。相对final 有所优化</p><p><br></p><ul><li>修饰对象创建</li></ul><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">const</span> [];</span><br></pre></td></tr></table></figure><p>const 修饰变量创建，Dart 会默认以 const 的上下文来实例化对象:</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> primaryColors = [</span><br><span class="line">  Color(<span class="string">"red"</span>, [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>]),</span><br><span class="line">  Color(<span class="string">"green"</span>, [<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>]),</span><br><span class="line">  Color(<span class="string">"blue"</span>, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>]),</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>primaryColor被修饰 const 修饰，那么其下的对象创建都隐式使用 const 修饰。上面的代码等价于:</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> primaryColors = <span class="keyword">const</span> [</span><br><span class="line">  <span class="keyword">const</span> Color(<span class="string">"red"</span>, <span class="keyword">const</span> [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>]),</span><br><span class="line">  <span class="keyword">const</span> Color(<span class="string">"green"</span>, <span class="keyword">const</span> [<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>]),</span><br><span class="line">  <span class="keyword">const</span> Color(<span class="string">"blue"</span>, <span class="keyword">const</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>]),</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><strong>Dart 内置的容器对象默认支持const</strong>。 对于自定义类，需要类提供<strong>const构造方法</strong>, 而且所有实例都必须使用final修饰。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin =</span><br><span class="line">      <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 所有实例变量都必须用final修饰</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x, y;</span><br><span class="line">  <span class="comment">// const 构造方法</span></span><br><span class="line">  <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="⑥-类型系统"><a href="#⑥-类型系统" class="headerlink" title="⑥ 类型系统"></a>⑥ 类型系统</h3><ul><li><p>名义类型。没有Duck Duck Duck 🦆🦆🦆</p></li><li><p>Sound Type System(soundness，严格类型系统)。即<strong>静态类型+运行时检查</strong>, 比如一个变量静态类型为 String，如果将int赋值给它，编译器会报错。但是通过某些手段，我们可以绕过编译器检查，例如强制类型转换。Sound Type System 可以在运行时进行类型检查，不会放过这些错误。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">int</span> a;</span><br><span class="line">  a = <span class="string">"1"</span> <span class="keyword">as</span> <span class="built_in">int</span>; <span class="comment">// 绕过了静态类型检查, 但是运行会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好处:</p><ul><li>代码更健壮</li><li>有利于AOT</li><li>尽可能消灭bug，编译阶段的漏网之鱼，也会被检测出来，不要抱着侥幸心理。</li></ul></li><li><p>dynamic：可以视作是any类型吧？尽量避免使用</p></li></ul><p><br></p><h3 id="⑦-异步异步"><a href="#⑦-异步异步" class="headerlink" title="⑦ 异步异步"></a>⑦ 异步异步</h3><p>Future/Stream、async/await、Generator。不必多说，熟悉 JavaScript 一看就懂</p><p><br></p><h3 id="⑧-元编程"><a href="#⑧-元编程" class="headerlink" title="⑧ 元编程"></a>⑧ 元编程</h3><ul><li><p>MetaData。和Java的注解差不多。顾名思义，MetaData就是给你的代码提供更多的信息。可以用于提示编译器，在运行时通过反射库也可以获取到MetaData信息。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;...&#125;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>noSuchMethod()</code>。类似于 Ruby 的 method_missing。 当未找到属性或者方法时被调用，可以实现一些动态属性或方法。元编程神器。在 JavaScript 中可以通过Proxy 实现相同的效果。</p></li></ul><p><br><br><br></p><p>说实话，Dart 没有什么多少让人眼前一亮的特性。在它身上你可以看到许多其他语言的影子、例如Java、JavaScript、Swift… 这也无可厚非，现代编程语言确实长得越来越像。</p><p>好处是它特别容易上手，坏处是除了 Flutter 绑定之外，我找不到其他可以用它的理由。</p><p><br><br><br></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>借助已有的经验，很快就可以入门，这时候能马上上手去写是最好的。</p><p>可以从Hello World 开始, 或者也可以从官方的入门教程开始。Dart 的话。</p><p>hello world !</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Hello, World!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过最简单的 hello world 也可以获知一些关键信息:</p><ul><li>类似 C 的前缀式类型声明。</li><li>main 程序入口</li><li>分号不能省略</li><li>标准库。print 来源于 <code>dart:core</code> 这个包是全局的</li><li>List 数组</li><li>泛型</li><li>…</li></ul><p><br></p><p>Flutter 搞起来！</p><p><br><br><br></p><h2 id="深入了解这门语言"><a href="#深入了解这门语言" class="headerlink" title="深入了解这门语言"></a>深入了解这门语言</h2><p>如果你喜欢这门语言，想要让你们的关系进一步发展，你就要深入了解它：</p><ul><li>了解它的最佳实践</li><li>阅读它的语言规范</li><li>造轮子。比如写个静态网页生成器; 如果是面向对象语言，可以实现几个常见的设计模式</li><li>学习标准库</li><li>了解实现原理</li><li>了解性能分析和优化</li></ul><p><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>编程语言也有三重境界:</p><p><strong>看山是山，看山不是山，看山还是山</strong></p><ul><li>① 我用的语言就是最好的语言，如 PHP，很牛逼</li><li>② 所有语言都差不多，本质都是一样</li><li>③ 回归到语言，语言不过是个工具。就像画家的画笔，不过是实现自己想法的一个工具。这个阶段，我们不再争执什么是最好的语言，而且为了不同的绘制效果选择不同的画笔。</li></ul><p>只要能解决我们需要解决的问题，编程语言从来不是门槛，或者说它是最容易被克服的问题。就像别人吐槽 Flutter 用 Dart 而不用JavaScript一样。</p><p><br><br><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://book.douban.com/subject/10555435/" target="_blank" rel="noopener">七周七语言</a></li><li><a href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages" target="_blank" rel="noopener">Wiki: Comparison of programming languages</a></li><li><a href="https://dart.dev/guides/language/language-tour#libraries-and-visibility" target="_blank" rel="noopener">Dart 官方文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;世界上没有一种可以各个领域通吃的语言，为了应对不同的场景和需求，我们摆脱不了要学习一门新的语言。最近准备入坑 &lt;code&gt;Flutter&lt;/code&gt;(技术储备)，学了点 Dart, 一点心得分享给大家。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大纲&lt;/str
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>if 我是前端Leader，怎么走出小微前端团队的围墙?</title>
    <link href="https://bobi.ink/2019/11/17/fe-load/"/>
    <id>https://bobi.ink/2019/11/17/fe-load/</id>
    <published>2019-11-16T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>上一个星期一直忙于救火，周末又赶去参加了 <a href="https://tweb.tencent.com/#/" target="_blank" rel="noopener"><code>Tweb Conf</code></a>(首次参加这类活动)，所以没什么输出。但是这个星期的紧张、忙碌以及焦虑，让我想明白了一些事情，写了本文，没什么干货，只是一些絮絮叨叨。</p><p>上周对我来说还有一个重要的里程碑是掘金等级到达 <strong>LV5</strong>。目标已经达成了，这是一种释然，我不再想为了获取更多点赞、更多阅读量去写文章，不再去取一些哗众取宠的标题，不再需要去证明什么。我发现我打开掘金的频率骤然降低了，以前一天可能 checkout 几十次。</p><p>新的一年，希望能够沉下心来，深入钻研自己的方向，投放更多精力到参与开源上面。</p><p><br></p><p><strong>大纲</strong></p><!-- TOC --><ul><li><a href="#小微外包企业前端的困境">小微/外包企业前端的困境</a></li><li><a href="#中台的概念">中台的概念</a></li><li><a href="#前后端分离再分离">前后端分离再分离</a></li><li><a href="#极简的技术栈">极简的技术栈</a></li><li><a href="#避免单点故障">避免’单点故障’</a></li><li><a href="#集体利益大于个人利益">集体利益大于个人利益</a></li><li><a href="#谈谈个人的发展-跳槽与跳槽路上">谈谈个人的发展: 跳槽与跳槽路上</a></li><li><a href="#总结">总结</a></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br><br><br></p><h2 id="小微-外包企业前端的困境"><a href="#小微-外包企业前端的困境" class="headerlink" title="小微/外包企业前端的困境"></a>小微/外包企业前端的困境</h2><p><img src="/images/fe-load/audi.png" alt></p><p><br></p><p>相信待在大厂的头部程序员只是少数，大部分前端还是蜗居在<strong>小微企业</strong>前端团队(<strong>🔴注意：特指工程能力较弱的团队，排除大厂和大牛创业公司</strong>)，望着大厂的围墙。想象他们光鲜亮丽、充满激情样子。同样是拧螺丝，同样实践着前端工程化、同样用着Vue、React 全家桶，别人是搞的是航母上的铆钉，你拧的是奥迪双钻的螺丝。</p><p><br></p><p>大厂谈高大上技术、谈架构，谈场景。小微企业前端谈温饱，我们或多或少面临这些困境:</p><p><strong>边缘化</strong></p><p>在这类公司，前端没什么<strong>话语权</strong>，他们只是一个简单页面实现，简称切图仔。</p><p>本质上是业务性质和规模决定了前端的工作不会占用太大比重，自然也不会受到太多重视, 可取代性也很高。这类公司往往是传统行业，例如硬件、电力。相反依赖于端行业，如电商、社交，前端的地位会高很多。</p><p>这种环境下，前端不会关心太多业务，当然容易被边缘化，扮演相声里面的捧哏角色。</p><p><br></p><p><strong>协助混乱/基础设施薄弱</strong></p><p>小微企业，因为人员整体水平不高，协作通常也比较混乱、不规范。这里指的是一个项目的整体研发协作。</p><p>对于前端来说，我们的上游可能是后端，后端的代码质量和规范性对前端影响也会特别大。 例如接口混乱、文档不规范、未考虑应用场景、接口不测试等等… 这种工作环境下，效率会非常低，前端开发会非常痛苦。</p><p>基础设施弱，前端工程化总感觉束手束脚。</p><p><br></p><p><strong>忙碌</strong></p><p>感觉每天都很忙碌，却像什么事情都没有做。每天的工作重复一次又一次，原地踏步。</p><p><br></p><p><strong>孤岛</strong></p><p>像置身孤岛，知识和消息是封闭的，个人能力和技术很难有大的突破。公司的格局决定个人的格局。</p><p><br></p><p><strong>人员变动</strong></p><p>吸引不了优秀的人才，而且优秀人才也留不住，整体水平较低，很难有技术沉淀和开拓。</p><p><br></p><p><strong>理想/企业文化的认同感</strong></p><p>我们只是为了赚钱，别跟我谈什么理想。我们感觉自己在被压榨，是机器，这样的工作自然不会有什么幸福感。</p><p>等等等…</p><p><br><br><br></p><h2 id="中台的概念"><a href="#中台的概念" class="headerlink" title="中台的概念"></a>中台的概念</h2><p>今年中台的概念的很火，我没怎么去关注它，因为我认为它跟我们前端的距离还是比较远，而且大厂才能搞得起来。直到在 <code>TWeb Conf</code> 上听 <a href="https://www.zhihu.com/people/fouber" target="_blank" rel="noopener">张云龙</a> 讲了 <a href="https://juejin.im/post/5dd20202e51d453ff47f9c81#heading-2" target="_blank" rel="noopener">《Headless CMS——小微项目的业务中台解决方案》</a> 让我对‘中台’提起了兴趣。</p><blockquote><p>这里有一篇文章<a href="https://juejin.im/post/5d995f82f265da5ba308389d#comment" target="_blank" rel="noopener">《漫画：什么是中台？》</a> 通俗讲解了中台的概念。</p></blockquote><p>不是大厂才能实践中台，我发现我们的应用也存在很多重复的业务，每新建一个应用，后端都要重复去拷贝和实现这些业务。对于后端来说，资源非常浪费，对于前端来说也是一个灾难。 因为我们发现，尽管后端的业务本质上是重复的，但是因为人为原因，他们每一次拷贝暴露出来的接口和流程或多或少和之前的应用不一致，每次前端都需要重新适配。</p><p><br></p><p><img src="/images/fe-load/strapi.png" alt="配图"></p><p><br></p><p>张云龙介绍了一个适合小微项目的业务中台解决方案，它举的例子是 <a href="https://strapi.io" target="_blank" rel="noopener"><code>Strapi</code></a>: 这是一个<code>Headless CMS</code>, 翻译为中文就是’无头’内容管理系统，和传统 CMS 的最大区别是 Headless，即它只暴露接口，没有固定的界面。</p><p><br></p><p>通过它, 你可以实现：</p><ul><li>可视化、快速的业务模型创建。类似创建数据库模型（数据库无关），可以灵活地配置各种字段类型(除了原始类型、还支持邮箱、文件上传)以及模型关系。</li><li>暴露规范的接口。支持 <code>Restful</code> 和 <code>GraphQL</code>。内置支持排序、分页、过滤、自动生成文档</li><li>内置权限控制系统。角色、JWT 鉴权</li><li>轻松集成内部系统。可以灵活地与自己的内部系统对接</li><li>扩展性。插件系统</li></ul><p>Headless CMS 是一种适用于小微企业的业务’中台’解决方案。通过Strapi 我们可以快速搭建简单的外围业务模型, 复用通用的服务和插件。</p><p>你也可以认为这是一种分层的架构，隔离了核心业务和外围业务。外层相比内层更加多变和冗杂，Strapi 中台层隔离了 UI 和 核心服务，它让核心服务可以下沉，专注于实现更加通用的服务；<br>通过 Strapi 可以快速搭建非核心的外围衍生业务模式，暴露标准化的接口范式，一方面可以及时响应前端多变的需求，另一方面提供标准化、一致化的接口范式，也可以降低沟通成本、提高开发效率。基于此, 前端也可以沉淀自己的可复用的业务组件。</p><p>当然，正如张云龙所说的，Strapi 相比大厂中台，就是个玩具。但对于小微企业，迅速开发原型响应市场、提高研发效率，却是一剂良药。</p><p><br><br><br></p><h2 id="前后端分离再分离"><a href="#前后端分离再分离" class="headerlink" title="前后端分离再分离"></a>前后端分离再分离</h2><p>你会发现前端开发的体系化、正规化，其实伴随着前后端分离逐步深化:</p><ul><li><p><strong>盘古开天</strong>：没有前后端之分</p></li><li><p><strong>模板时代</strong>: 按照MVC架构，后端负责MC, 实现业务，给前端提供数据。前端负责 V, 即写模板。前端后在项目结构上并没有分离，但是职责开始了分化。</p></li><li><p><strong>接口时代</strong>：后端提供 HTTP/WS 接口，前端负责请求接口和实现页面渲染。CSR(客户端渲染)技术开始爆发，Backbone、Angular、React… 前端在项目结构上已经从后端脱离。开发效率进一步提高。接口就是一个约定，按照约定先行的原则，前后端可以实现并行开发。但是这个阶段后端接口实现还是需要关心页面的呈现，必须提供能够满足UI渲染的接口。</p></li><li><p><strong>BFF时代</strong>：BFF 即 Backends for Frontend。伴随着阵痛，前后端进一步分离。主要有两个原因：终端多样性，桌面端、iOS、Android、前端、小程序… 不同的客户端对接口有不同的需求、而且这些需求是多变的。另外后端业务也向微服务演化, 于是后端的接口会趋向原子化、功能更加单一、更加通用。</p><p>但是这对于前端开发来说也是比较痛苦的，实现一个页面需要调用很多接口、随之页面性能也会降低。分层架构又派上用场，那就多加一层呗，这一层就是BFF，它让客户端开发者根据的自己需求在服务端来粘合后端的通用服务。这会后端再也不用关心UI了。BFF 时代，GraphQL 和 NodeJS 备受瞩目。</p></li><li><p><strong>Serverless时代</strong>：BFF 推行需要良好的基础设施和研发流程支撑，架构难度也比较高，因此通常只有大厂搞得起来。Serverless 借助云平台, 降低了对基础设施的依赖，以及开发和维护的难度。 所以基于 Serverless 的 BFF 门槛更低。Serverless 对前端开发的意义不止于此，强烈推荐 <a href="https://zhuanlan.zhihu.com/p/65914436" target="_blank" rel="noopener">《Serverless 掀起新的前端技术变革》</a> 这篇文章。</p></li></ul><p><br></p><p>后端不想关心 UI 呈现所需要的数据，只想关注于业务的实现。前端也想摆脱后端的下游依赖，既然大家都觉得不合适，分开是最好的。</p><p>回到开头那句话，前端开发的体系化、正规化伴随着前/后端的分离再分离，反之，正是因为前/后端分离的深化，前端开发得以正规化、体系化。上一节张云龙介绍的‘中台‘的概念，在某种意义上，也是一种前后端分离的深化。</p><p>因此，如果你的团队感受到了阵痛，其实也正好说明公司业务正处于上升状态，如无意外，你们踏上前人走过的路，和后端进一步撕裂。</p><p><br><br><br></p><h2 id="极简的技术栈"><a href="#极简的技术栈" class="headerlink" title="极简的技术栈"></a>极简的技术栈</h2><p><strong>Keep it Simple, Keep it Stupid</strong>。 最近对这个原则体会颇深。小微团队技术选型不应该随大流、追随最新最热的技术，而是应该选择符合自己的团队水平和业务情况的极简技术栈。</p><p>这四个原则非常重要：</p><ul><li><strong>简单</strong></li><li><strong>自动化</strong></li><li><strong>清晰健全的文档</strong></li><li><strong>约束</strong></li></ul><p>举几个例子:</p><p>‘简单’主要是为了减低学习的门槛、降低心智的负担, 接口越简洁越好：</p><ul><li>约定 &gt; 配置</li><li>显式 &gt; 隐式</li><li>声明式 &gt; 命令式</li><li>接口协议: JSONRPC &gt; Restful</li><li>构建工具: Parcel &gt; Webpack, 除此之外还有Vue-cli, create-react-app</li><li>框架：随便举个例子 Vue &gt; React。Vue 入门会‘相对’简单，React 太灵活、社区百花齐放、尽管我很爱它，但是它没办法阻止别人干蠢事。</li><li>状态管理: Mobx &gt; Redux &gt; Rxjs。</li><li>当然, 具体场景具体分析</li></ul><p><br></p><p>‘自动化’，能够自动化解决的事情，就不要靠文档规范、靠口头沟通:</p><ul><li>ESlint、Styleint、HTMLlint、Markdownlint… *Lint。有各种各样的 lint 工具和社区推荐规范，自动检测各个环节是否符合规范。</li><li>Prettier 代码格式化。只有一种代码样式，别BB</li></ul><p><br></p><p>‘文档’，重要性不言而喻。有事先看文档，再问别人</p><p>‘约束’，在事情失去控制时，我能体会到那种绝望。这时候你会希望当初有更多的约束，尽量让代码保持在可控范围之内。例如 Typescript，各种 *Lint。如果没有约束机制，规范永远只是规范。</p><p><br><br><br></p><h2 id="避免’单点故障’"><a href="#避免’单点故障’" class="headerlink" title="避免’单点故障’"></a>避免’单点故障’</h2><p>小微前端团队，人员资源非常有限，往往每个人负责不同的项目，这就可能出现‘单点故障’。假如这时候项目的负责人请假或者离职，就会让人措手不及。一方面项目交接过程会拉长，另一方面其他成员上下文切换的成本也很高。我们尤其害怕接手的项目是一个烂摊子。</p><p>解决单点故障的唯一办法是让更多的成员交叉参与不同的项目，项目的责任在于团队而不在于个人。另外可以配合例如代码 Review 这些手段，多种途径让团队成员可以熟悉项目的代码。</p><p>代码规范和共享代码在这里也可以起到很大的作用。如果’知识’可以在多个项目中复用和共享，那么项目上下文切换的成本就相对比较低。</p><p><br></p><h2 id="集体利益大于个人利益"><a href="#集体利益大于个人利益" class="headerlink" title="集体利益大于个人利益"></a>集体利益大于个人利益</h2><p>不管是大公司还是小公司，集体的利益永远是大于个人利益的。</p><p>上周做了两个错误的决策，一个是批了一个紧急项目负责人请假，二是项目未完整测试上线就带队去参加Tweb Conf。这两个决策导致很大的风险，也挨上级领导批评了，还好最后都搞定了。反省以下几点欠缺：</p><ul><li>集体利益大于个人利益。这是我们从小被灌输的思想，在一个集体中，你的行为和决策是需要对集体负责的。</li><li>对项目缺乏整体的把控，没有充分的风险评估。尽管前端只是一个完整项目的一环，作为前端团队Leader, 还是需要从整体上了解项目的进度。你要知道项目的开始时间、截止时间、提测时间、开发/测试进度、当前资源情况等。通过这些信息来进行制定资源的分配计划和风险预估。</li><li>推动协作效率的改进。作为团队 Leader，就不能只单纯关注技术和代码。我们需要去关注团队之间的协作通道，提高团队层面的协作效率，为团队成员扫除沟通方面的障碍。</li></ul><p>就像我经常跟我们的团队伙伴说：问题不可怕，可怕的是不知道问题在哪里，你要想进步、就要多反思、多问为什么…</p><p><br></p><h2 id="谈谈个人的发展-跳槽与跳槽路上"><a href="#谈谈个人的发展-跳槽与跳槽路上" class="headerlink" title="谈谈个人的发展: 跳槽与跳槽路上"></a>谈谈个人的发展: 跳槽与跳槽路上</h2><p>大公司有什么?</p><p><img src="/images/fe-load/base.png" alt></p><p><br></p><p>小公司有什么，可能什么都没有，百废待兴… 空间可能很大，天花板也可能很低。大部分情况下，它可能只是你的一个跳板。你要么在跳槽，要么在跳槽路上，或者你已经麻木了，迷茫不知进退。</p><p>不管怎么样，小微企业的前端需要多考虑自己的个人发展。包括我自己也在不停地思考，不甘平庸，努力寻找可以花一辈子去奋斗的事业，而不只是工作。</p><p><br></p><p>对于个人发展, 我有以下几点建议：</p><ul><li>确定自己想要深入挖掘方向。很多所谓的大牛大多都是某一具体领域的专家。前端目前也有很多细分领域。见 这次 Tweb Conf 的会场布置就知道了，它细分了主会场(传统前端)、小程序&amp;工程化、Node&amp;架构、跨端&amp;综合。另外<a href="https://gmtc.infoq.cn/2019/shenzhen/" target="_blank" rel="noopener">GMTC 大会主题划分</a>也具有参考性</li><li>跳出自己的舒适区, 去尝试新的东西</li><li>勇气。人有多大胆，地有多大产。没有勇气会错过很多东西</li><li>参与社区, 树立个人品牌</li><li>Stay hungry，Stay foolish</li><li>基础很重要。别着急学花里胡哨的东西，别着急跟着别人去看源码</li><li>尝试去理解业务，理解商业和世界运作的规律，提升格局和软技能</li></ul><p><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>小微企业的围墙不能靠一个人就能推倒，业务的扩张和升级才是真正的动力。如果你觉得你公司有上升的动力和势态，而且你认同公司的价值观，不妨一起努力推动公司的进步。反之，要认真考虑自身的发展。</p><p><br></p><p>不说了，各自珍重，努力奋斗</p><p><img src="/images/fe-load/hard-work.jpg" alt></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/77095720" target="_blank" rel="noopener">Serverless For Frontend 前世今生</a></li><li><a href="https://zhuanlan.zhihu.com/p/65914436" target="_blank" rel="noopener">Serverless 掀起新的前端技术变革</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一个星期一直忙于救火，周末又赶去参加了 &lt;a href=&quot;https://tweb.tencent.com/#/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Tweb Conf&lt;/code&gt;&lt;/a&gt;(首次参加这类活动)，所以没什么输出。但是
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>[实战] 为了学好 React Hooks, 我抄了 Vue Composition API, 真香</title>
    <link href="https://bobi.ink/2019/11/04/react-composition/"/>
    <id>https://bobi.ink/2019/11/04/react-composition/</id>
    <published>2019-11-03T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.330Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5dadc6045188255a270a0f85" target="_blank" rel="noopener">前几篇文章</a>都在讲 React 的 Concurrent 模式, 很多读者都看懵了，这一篇来点轻松的，蹭了一下 Vue 3.0 的热度。讲讲如何在 React 下实现 <a href="https://vue-composition-api-rfc.netlify.com/#type-issues-with-class-api" target="_blank" rel="noopener"><code>Vue Composition API</code></a>(下面简称<strong>VCA</strong>)，只是个玩具，别当真。</p><p>实现 ‘React’ Composition API？看起来很吊，确实也是，通过本文你可以体会到这两种思想的碰撞, 你可以深入学习三样东西：<code>React Hooks</code>、<code>Vue Composition API</code>、<a href="https://mobx.js.org/refguide/api.html" target="_blank" rel="noopener"><code>Mobx</code></a>。篇幅很长(主要是代码)，当然干货也很多。</p><p><br></p><p><strong>目录</strong></p><p><br></p><!-- TOC --><ul><li><a href="#对比-react-hooks-和-vue-composition-api">对比 React Hooks 和 Vue Composition API</a><ul><li><a href="#基本-api-类比">基本 API 类比</a></li></ul></li><li><a href="#api-设计概览">API 设计概览</a></li><li><a href="#响应式数据和-ref">响应式数据和 ref</a><ul><li><a href="#关于-vue-composition-api-ref">关于 Vue Composition API ref</a></li><li><a href="#为什么需要-ref">为什么需要 ref?</a></li><li><a href="#ref-和-useref">ref 和 useRef</a></li></ul></li><li><a href="#生命周期方法">生命周期方法</a></li><li><a href="#watch">watch</a></li><li><a href="#包装-props-为响应式数据">包装 Props 为响应式数据</a></li><li><a href="#支持-context-注入">支持 Context 注入</a></li><li><a href="#跟踪组件依赖并触发重新渲染">跟踪组件依赖并触发重新渲染</a></li><li><a href="#forwardref-处理">forwardRef 处理</a></li><li><a href="#总结">总结</a></li><li><a href="#参考扩展">参考/扩展</a></li></ul><!-- /TOC --><p><br></p><p>Vue Composition API 是 Vue 3.0 的一个重要特性，和 React Hooks 一样，这是一种非常棒的<strong>逻辑组合/复用机制</strong>。尽管初期受到不少<a href="https://juejin.im/post/5d0f64d4f265da1b67211893" target="_blank" rel="noopener">争议</a>，<strong>我个人还是比较看好这个 API 提案，因为确实解决了 Vue 以往的很多痛点</strong>, 这些痛点在它的<a href="https://vue-composition-api-rfc.netlify.com/#motivation" target="_blank" rel="noopener"> RFC 文档</a>中说得很清楚。动机和 React Hooks 差不多，无非就是三点:</p><p><br></p><ul><li>① 逻辑组合和复用</li><li>② 更好的类型推断。完美支持 Typescript</li><li>③ Tree-shakable 和 代码压缩友好</li></ul><p><br></p><p>如果你了解 React Hooks 你会觉得 VCA 身上有很多 Hooks 的影子, 毕竟官方也承认 React Hooks 是 VCA 的主要灵感来源，但是 Vue 没有完全照搬 React Hooks，而是基于自己的数据响应式机制，创建出了自己特色的逻辑复用原语, 辨识度也是非常高的。</p><p><br><br><br></p><h2 id="对比-react-hooks-和-vue-composition-api"><a href="#对比-react-hooks-和-vue-composition-api" class="headerlink" title="对比 React Hooks 和 Vue Composition API"></a>对比 React Hooks 和 Vue Composition API</h2><p>对于 React 开发者来说, VCA 还解决了 React Hooks 的一些有点稍微让人难受、新手不友好的问题。这是驱动我写这篇文章原因之一，来尝试把 VCA 抄过来, 除了学习 VCA，还可以加深对 React Hooks 的理解。</p><p>VCA 官方 RFC 文档已经很详细列举了它和 React Hooks 的差异:</p><p><br></p><p><strong>① 总的来说，更符合惯用的 JavaScript 代码直觉</strong>。这主要是 Immutable 和 Mutable 的数据操作习惯的不同。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue: 响应式数据, 更符合 JavaScript 代码的直觉, 就是普通的对象操作</span></span><br><span class="line"><span class="keyword">const</span> data = reactive(&#123;<span class="attr">count</span>: <span class="number">1</span>&#125;)</span><br><span class="line">data.count++</span><br><span class="line"></span><br><span class="line"><span class="comment">// React: 不可变数据, JavaScript 原生不支持不可变数据，因此数据操作会 verbose 一点</span></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">1</span>)</span><br><span class="line">setCount(count + <span class="number">1</span>)</span><br><span class="line">setCoung(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// React: 或者使用 Reducer, 适合进行一些复杂的数据操作</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>, <span class="comment">/* 假设还有其他状态 */</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState)</span><br><span class="line">dispatch(&#123;<span class="attr">type</span>: <span class="string">'increment'</span>&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>不过, 不能说可变数据就一定好于不可变数据, 反之亦然。 <strong>不可变数据也给 React 发挥和优化的空间, 尤其在 Concurrent 模式下, 不可变数据可以更好地被跟踪和 reduce</strong>。 例如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React</span></span><br><span class="line"><span class="keyword">const</span> [state, setState] = useState(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> [startTransition] = useTransition()</span><br><span class="line"></span><br><span class="line">setState(<span class="number">1</span>)              <span class="comment">// 高优先级变更</span></span><br><span class="line">startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  <span class="comment">// 低优先级状态变更</span></span><br><span class="line">  setState(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>React 中状态变更可以有不同的优先级，实际上这些变更会放入一个队列中，界面可能先显示 <code>1</code>, 然后才是 <code>2</code>。<strong>你可以认为这个队列就是这个状态的历史快照，由 React 来调度进行状态的前进，有点类似于 Redux 的’时间旅行’</strong>。如果是可变数据，实现这种‘时间旅行’会相对比较麻烦。</p><p><br></p><hr><p><br></p><p><strong>② 不关心调用顺序和条件化</strong>。React Hooks <a href="https://juejin.im/post/5cfa29e151882539c33e4f5e" target="_blank" rel="noopener">基于数组实现</a>，每次重新渲染必须保证调用的顺序，否则会出现数据错乱。VCA 不依赖数组，不存在这些限制。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyHooks</span>(<span class="params">someCondition, antherCondition</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="comment">/* ... */</span>&#125;, []) <span class="comment">// 💥</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (anotherCondition) &#123;</span><br><span class="line">    <span class="keyword">return</span> something      <span class="comment">// 提前返回 💥</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [someState] = useState(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><p><strong>③ 不用每次渲染重复调用，减低 GC 的压力</strong>。 每次渲染所有 Hooks 都会重新执行一遍，这中间可能会重复创建一些临时的变量、对象以及闭包。而 VCA 的setup 只调用一次。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComp</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> add = <span class="function"><span class="params">()</span> =&gt;</span> setCount(<span class="function"><span class="params">c</span> =&gt;</span> c+<span class="number">1</span>)  <span class="comment">// 这些内联函数每次渲染都会创建</span></span><br><span class="line">  <span class="keyword">const</span> decr = <span class="function"><span class="params">()</span> =&gt;</span> setCount(<span class="function"><span class="params">c</span> =&gt;</span> c<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(count)</span><br><span class="line">  &#125;, [count])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    count: &#123;count&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">onClick</span>=<span class="string">&#123;add&#125;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">onClick</span>=<span class="string">&#123;decr&#125;</span>&gt;</span>decr<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><p><strong>④ 不用考虑 useCallback/useMemo 问题</strong>。 因为问题 ③ , 在 React 中，为了避免子组件 diff 失效导致无意义的重新渲染，我们几乎总会使用 useCallback 或者 useMemo 来缓存传递给下级的事件处理器或对象。</p><p>VCA 中我们可以安全地引用对象，随时可以存取最新的值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComp</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> add = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> setCount(<span class="function"><span class="params">c</span> =&gt;</span> c+<span class="number">1</span>), [])</span><br><span class="line">  <span class="keyword">const</span> decr = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> setCount(<span class="function"><span class="params">c</span> =&gt;</span> c<span class="number">-1</span>), [])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(count)</span><br><span class="line">  &#125;, [count])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">SomeComplexComponent</span> <span class="attr">count</span>=<span class="string">&#123;count&#125;</span> <span class="attr">onAdd</span>=<span class="string">&#123;add&#125;</span> <span class="attr">onDecr</span>=<span class="string">&#123;decr&#125;/</span>&gt;</span>)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// Vue: 没有此问题, 通过对象引用存取最新值</span></span><br><span class="line"><span class="xml">createComponent(&#123;</span></span><br><span class="line"><span class="xml">  setup((props) =&gt; &#123;</span></span><br><span class="line"><span class="xml">    const count = ref(0)</span></span><br><span class="line"><span class="xml">    const add = () =&gt; count.value++</span></span><br><span class="line"><span class="xml">    const decr = () =&gt; count.value--</span></span><br><span class="line"><span class="xml">    watch(count, c =&gt; console.log(c))</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line">    return () =&gt; &lt;SomeComplexComponent count=&#123;count&#125; onAdd=&#123;add&#125; onDecr=&#123;decr&#125;/&gt;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><p><strong>⑤ 不必手动管理数据依赖</strong>。在 React Hooks 中，使用 <code>useCallback</code>、<code>useMemo</code>、<code>useEffect</code> 这些 Hooks，都需要手动维护一个数据依赖数组。当这些依赖项变动时，才让缓存失效。</p><p>这往往是新手接触 React Hooks 的第一道坎。你要理解好闭包，理解好 Memoize 函数 ，才能理解这些 Hooks 的行为。这还不是问题，问题是这些数据依赖需要开发者手动去维护，很容易漏掉什么，导致bug。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComp</span>(<span class="params">&#123;anotherCount, onClick&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setState] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    onClick(anotherCount + count)</span><br><span class="line">  &#125;, [count]) <span class="comment">// 🐞漏掉了 antherCount 和 onClick</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此 React 团队开发了 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noopener">eslint-plugin-react-hooks</a>插件，辅助检查 React Hooks 的用法, 可以避免漏掉某些依赖。不过这个插件太死了，搞不好要写很多 <code>//eslint-disable-next-line</code> 😂</p><p>VCA 由于不存在 ④ 问题，当然也不存在 ⑤问题。 Vue 的响应式机制可以自动、精确地跟踪数据依赖，而且基于对象引用的不变性，我们不需要关心闭包问题。</p><p><br></p><hr><p><br></p><p>如果你长期被这些问题困扰，你会觉得 VCA 很有吸引力。而且它简单易学, 这简直是 Vue 开发者的‘福报‘啊！ 是不是也想自己动手写一个？把 VCA 搬到 React 这边来，解决这些问题？那请继续往下读</p><p><br><br><br></p><h3 id="基本-api-类比"><a href="#基本-api-类比" class="headerlink" title="基本 API 类比"></a>基本 API 类比</h3><p>首先，你得先了解 React Hooks 和 VCA。最好的学习资料是它们的官方文档。下面简单类比一下两者的 API:</p><p><br></p><table><thead><tr><th></th><th>React Hooks</th><th>Vue Composition API</th></tr></thead><tbody><tr><td>状态</td><td><code>const [value, setValue] = useState(0)</code> <br> <code>useReducer</code></td><td><code>const state = reactive({value: 0})</code> <br> <code>ref(0)</code></td></tr><tr><td>状态变更</td><td><code>setValue(1)</code> <br> <code>setValue(n =&gt; n + 1)</code> <br> <code>dispatch</code></td><td><code>state.value = 1</code> <br> <code>state.value++</code></td></tr><tr><td>状态衍生</td><td><code>useMemo(() =&gt; derived, [deps])</code></td><td><code>computed(() =&gt; derived)</code></td></tr><tr><td>对象引用</td><td><code>const foo = useRef(0);</code> <br> <code>foo.current = 1</code></td><td><code>const foo = ref(0)</code> <br> <code>foo.value = 1</code></td></tr><tr><td>挂载</td><td><code>useEffect(() =&gt; {/*挂载*/}, [])</code></td><td><code>onBeforeMount(() =&gt; {/*挂载前*/})</code> <br> <code>onMounted(() =&gt; {/*挂载后*/})</code></td></tr><tr><td>卸载</td><td><code>useEffect(() =&gt; () =&gt; {/*卸载*/}}, [])</code></td><td><code>onBeforeUnmount(() =&gt; {/*卸载前*/})</code> <br> <code>onUnmounted(() =&gt; {/*卸载后*/})</code></td></tr><tr><td>重新渲染</td><td><code>useEffect(() =&gt; {/*更新*/})</code></td><td><code>onBeforeUpdate(() =&gt; {/*更新前*/})</code> <br> <code>onUpdated(() =&gt; {/*更新后*/})</code></td></tr><tr><td>异常处理</td><td>目前只有类组件支持(<code>componentDidCatch</code>, <br> <code>static getDerivedStateFromError</code>)</td><td><code>onErrorCaptured((err) =&gt; {/*异常处理*/})</code></td></tr><tr><td>依赖监听</td><td><code>useEffect(() =&gt; {/*依赖更新*/}, [deps])</code></td><td><code>const stop = watch(() =&gt; {/*自动检测数据依赖, 更新...*/})</code></td></tr><tr><td>依赖监听 + 清理</td><td><code>useEffect(() =&gt; {/*...*/; return () =&gt; {/*清理*/}}, [deps])</code></td><td><code>watch(() =&gt; [deps], (newVal, oldVal, clean) =&gt; {/*更新*/; clean(() =&gt; {/* 清理*/})})</code></td></tr><tr><td>Context 注入</td><td><code>useContext(YouContext)</code></td><td><code>inject(key)</code> <br> <code>provider(key, value)</code></td></tr></tbody></table><p><br></p><p>对比上表，我们发现两者非常相似，每个功能都可以在对方身上找到等价物。 React Hooks 和 VCA 的主要差别如下:</p><p><br></p><ul><li><strong>数据方面</strong>。<code>Mutable</code> vs <code>Immutable</code>，<code>Reactive</code> vs <code>Diff</code>。</li><li><strong>更新响应方面</strong>。React Hooks 和其组件思维一脉相承，它依赖数据的比对来确定依赖的更新。而Vue 则基于自动的依赖订阅。这点可以通过对比 useEffect 和 watch 体会。</li><li><strong>生命周期钩子</strong>。React Hooks 已经弱化了组件生命周期的概念，类组件也废弃了<code>componentWillMount</code>、 <code>componentWillUpdate</code>、   <code>componentWillReceiveProps</code> 这些生命周期方法。 一则我们确实不需要这么多生命周期方法，React 做了减法；二则，Concurrent 模式下，Reconciliation 阶段组件可能会被重复渲染，这些生命周期方法不能保证只被调用一次，如果在这些生命周期方法中包含副作用，会导致应用异常, 所以废弃会比较好。Vue Composition API 继续沿用 Vue 2.x 的生命周期方法.</li></ul><p><br></p><p>其中第一点是最重要的，也是最大的区别(思想)。这也是为什么 VCA 的 ‘Hooks’ 只需要初始化一次，不需要在每次渲染时都去调用的主要原因: <strong>基于Mutable 数据，可以保持数据的引用，不需要每次都去重新计算</strong>。</p><p><br><br><br></p><h2 id="api-设计概览"><a href="#api-设计概览" class="headerlink" title="API 设计概览"></a>API 设计概览</h2><p>先来看一下，我们的玩具(随便取名叫<strong>mpos</strong>吧)的大体设计:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 就随便取名叫 mpos 吧</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  reactive,</span><br><span class="line">  box,</span><br><span class="line">  createRef,</span><br><span class="line">  computed,</span><br><span class="line">  inject,</span><br><span class="line">  watch,</span><br><span class="line">  onMounted,</span><br><span class="line">  onUpdated,</span><br><span class="line">  onUnmount,</span><br><span class="line">  createComponent,</span><br><span class="line">  Box</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'mpos'</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface CounterProps &#123;</span><br><span class="line">  initial: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MultiplyContext = React.createContext(&#123; <span class="attr">value</span>: <span class="number">0</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 Hooks</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTitle</span>(<span class="params">title: Box&lt;string&gt;</span>) </span>&#123;</span><br><span class="line">  watch(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">document</span>.title = title.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// createComponent 创建组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createComponent&lt;CounterProps&gt;(&#123;</span><br><span class="line">  <span class="comment">// 组件名</span></span><br><span class="line">  name: <span class="string">'Counter'</span>,</span><br><span class="line">  <span class="comment">// ⚛️ 和 Vue Composition API 一样的setup，只会被调用一次</span></span><br><span class="line">  <span class="comment">// 接受组件的 props 对象, 这也是响应式对象, 可以被watch，可以获取最新值</span></span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️创建一个响应式数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> data = reactive(&#123; <span class="attr">count</span>: props.initial, <span class="attr">tick</span>: <span class="number">0</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️等价于 Vue Composition API 的 ref</span></span><br><span class="line"><span class="comment">     * 由于reactive 不能包装原始类型，box 可以帮到我们</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> name = box(<span class="string">'kobe'</span>)</span><br><span class="line">    name.set(<span class="string">'curry'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(name.get()) <span class="comment">// curry</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️衍生数据计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> derivedCount = computed(<span class="function"><span class="params">()</span> =&gt;</span> data.count * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(derivedCount.get()) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️等价于 React.createRef()，用于引用Virtual DOM 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> containerRef = createRef&lt;HTMLDivElement&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️依赖注入，获取 React.Context 值, 类似于 useContext，只不过返回一个响应式数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> ctx = inject(MultiplyContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️可以复合其他 Hooks，实现逻辑组合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    useTitle(computed(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`title: <span class="subst">$&#123;data.count&#125;</span>`</span>))</span><br><span class="line">    <span class="keyword">const</span> awesome = useYourImagination()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️生命周期方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"mounted"</span>, container.current);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 支持类似 useEffect 的方式，返回一个函数，这个函数会在卸载前被调用</span></span><br><span class="line">      <span class="comment">// 因为一般资源获取和资源释放逻辑放在一起，代码会更清晰</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"unmount"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    onUpdated(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"update"</span>, data.count, props);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里是 onUnmount，而 VCA 是 onUnmounted</span></span><br><span class="line">    onUnmount(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"unmount"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️监听数据变动, 类似于 useEffect</span></span><br><span class="line"><span class="comment">     * 返回一个disposer，可以用于显式取消监听，默认会在组件卸载时自动取消</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> stop = watch(</span><br><span class="line">      () =&gt; [data.count], <span class="comment">// 可选</span></span><br><span class="line">      ([count]) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"count change"</span>, count);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 副作用</span></span><br><span class="line">        <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> data.tick++, count)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 副作用清理（可选）, 和useEffect 保持一致，在组件卸载或者当前函数被重新调用时，调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          clearInterval(timer)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// props 是一个响应式数据</span></span><br><span class="line">    watch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"initial change"</span>, props.initial);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// context 是一个响应式数据</span></span><br><span class="line">    watch(</span><br><span class="line">      () =&gt; [ctx.value],</span><br><span class="line">      ([ctxValue], [oldCtxValue]) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"context change"</span>, ctxValue);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️方法，不需要 useCallback，永久不变</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      data.count++;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ⚛️返回一个渲染函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 在这里你也可以调用 React Hooks, 就跟普通函数组件一样</span></span><br><span class="line">      useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br><span class="line">      &#125;, [])</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">"counter"</span> onClick=&#123;add&#125; ref=&#123;containerRef&#125;&gt;</span><br><span class="line">          &#123;data.count&#125; : &#123;derivedCount.get()&#125; : &#123;data.tick&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><p><br></p><p>我不打算完全照搬 VCA，因此略有简化和差异。以下是实现的要点:</p><ul><li>① 如何确保 setup 只初始化一次?</li><li>② 因为 ①，我们需要将 Context、Props 这些对象进行包装成响应式数据, 确保我们总是可以拿到最新的值，避免类似 React Hook 的闭包问题.</li><li>③ 生命周期钩子, watch 如何绑定到组件上？我们要实现一个调用上下文</li><li>④ watch 数据监听和释放</li><li>④ Context 支持, inject 怎么实现？</li><li>⑤ 如何触发组件重新渲染?</li></ul><p><br></p><p>我们带着这些问题，一步一步来实现这个 <strong>‘React Composition API’</strong></p><p><br><br><br></p><h2 id="响应式数据和-ref"><a href="#响应式数据和-ref" class="headerlink" title="响应式数据和 ref"></a>响应式数据和 ref</h2><p>如何实现数据的响应式？不需要我们自己去造轮子，现成最好库的是 <a href="https://mobx.js.org/refguide/observable.html" target="_blank" rel="noopener"><code>MobX</code></a>。</p><p><code>reactive</code> 和 <code>computed</code> 以及 <code>watch</code> 都可以在 Mobx 中找到等价的API。以下是 Mobx API 和 VCA 的对照表:</p><p><br></p><table><thead><tr><th>Mobx</th><th>Vue Composition API</th><th>描述</th></tr></thead><tbody><tr><td>observable(object/map/array/set)</td><td>reactive()</td><td>转换响应式对象</td></tr><tr><td>box(原始类型)</td><td>ref()</td><td>转换原始类型为响应式对象</td></tr><tr><td>computed() + 返回 box 类型</td><td>computed() + 返回 ref 类型</td><td>响应式衍生状态计算</td></tr><tr><td>autorun(), reaction()</td><td>watch()</td><td>监听响应式对象变动</td></tr></tbody></table><p><br></p><p>所以我们不需要自己去实现这些 API, 简单设置个别名:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mpos.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; observable, computed, isBoxedObservable &#125; <span class="keyword">from</span> <span class="string">'mobx'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type Box&lt;T&gt; = IObservableValue&lt;T&gt;</span><br><span class="line"><span class="keyword">export</span> type Boxes&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: T[K] extends Box&lt;infer V&gt; ? Box&lt;V&gt; : Box&lt;T[K]&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reactive = observable</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> box = reactive.box        <span class="comment">// 等价于 VCA 的 ref</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isBox = isBoxedObservabl</span><br><span class="line"><span class="keyword">export</span> &#123; computed &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于 VCA 的 toRefs, 见下文</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toBoxes</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>&gt;(<span class="params">obj: T</span>): <span class="title">Boxes</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res: Boxes&lt;T&gt; = &#123;&#125; <span class="keyword">as</span> any</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">k</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isBox(obj[k])) &#123;</span><br><span class="line">      res[k] = obj[k]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res[k] = &#123;</span><br><span class="line">        <span class="keyword">get</span>: () =&gt; obj[k],</span><br><span class="line">        <span class="keyword">set</span>: (v: any) =&gt; (obj[k] = v),</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>下面是它们的简单用法介绍(详细用法见<a href="https://mobx.js.org/refguide/observable.html" target="_blank" rel="noopener">官方文档</a>)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, box, computed &#125; <span class="keyword">from</span> <span class="string">'mpos'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ⚛️ reactive 可以用于转换 Map、Set、数组、对象为响应式数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> data = reactive(&#123;<span class="attr">foo</span>: <span class="string">'bar'</span>&#125;)</span><br><span class="line">data.foo = <span class="string">'baz'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reactive 内部使用Proxy 实现数据响应，他会返回一个新的对象，不会影响原始对象</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">firstName</span>: <span class="string">"Clive Staples"</span>, <span class="attr">lastName</span>: <span class="string">"Lewis"</span> &#125;</span><br><span class="line"><span class="keyword">const</span> person = reactive(initialState)</span><br><span class="line">person.firstName = <span class="string">'Kobe'</span></span><br><span class="line">person.firstName <span class="comment">// "Kobe"</span></span><br><span class="line">initialState.firstName <span class="comment">// "Clive Staples"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换数组</span></span><br><span class="line"><span class="keyword">const</span> arr = reactive([])</span><br><span class="line">arr.push(<span class="number">1</span>)</span><br><span class="line">arr[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ⚛️ 一般情况下都使用reactive，如果你要转换原始类型为响应式数据</span></span><br><span class="line"><span class="comment"> * 或者进行数据传递，可以用 box</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> temperature = box(<span class="number">20</span>)</span><br><span class="line">temperature.set(<span class="number">37</span>)</span><br><span class="line">temperature.get() <span class="comment">// 37</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ⚛️ 衍生数据计算, 它们也具有响应特性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> fullName = computed(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;person.firstName&#125;</span> <span class="subst">$&#123;person.lastName&#125;</span>`</span>)</span><br><span class="line">fullName.get() <span class="comment">// "Kobe Lewis"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="关于-vue-composition-api-ref"><a href="#关于-vue-composition-api-ref" class="headerlink" title="关于 Vue Composition API ref"></a>关于 Vue Composition API ref</h3><p>上面说了，<strong>VCA 的 ref 函数等价于 Mobx 的 box 函数</strong>。可以将原始类型包装为’响应式数据’(本质上就是创建一个reactive对象，监听getter/setter方法), 因此 ref 也被 称为<strong>包装对象</strong>(Mobx 的 box 命名更贴切):</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p><br></p><p>你可以这样理解, ref 内部就是一个 <code>computed</code> 封装(当然是假的):</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = reactive(&#123;value&#125;)</span><br><span class="line">  <span class="keyword">return</span> computed(&#123;</span><br><span class="line">    <span class="keyword">get</span>: () =&gt; data.value,</span><br><span class="line">    <span class="keyword">set</span>: val =&gt; data.value = val</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者这样理解也可以</span><br><span class="line">function ref(value) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = reactive(&#123;value&#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> value() &#123; <span class="keyword">return</span> data.value &#125;,</span><br><span class="line">    <span class="keyword">set</span> value(val) &#123; data.value = val &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>只不过它们需要通过 <code>value</code> 属性来存取值，有时候代码显得有点啰嗦。<strong>因此 VCA 在某些地方支持对 ref 对象进行<code>自动解包(Unwrap, 也称自动展开)</code></strong>, 不过目前自动解包，仅限于读取。 例如:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1️⃣ 作为reactive 值时</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">  count                  <span class="comment">// 可以赋值给 reactive 属性</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(state.count) <span class="comment">// 0 等价于 state.count.value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动展开有时候会让人困惑，这里有个陷阱，会导致原有的 ref 对象被覆盖</span></span><br><span class="line">state.count = <span class="number">1</span>          <span class="comment">// 被覆盖掉了, count 属性现在是 1, 而不是 Ref&lt;count&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2️⃣ 传递给模板时，模板可以自动解包</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// &lt;button @click="increment"&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// &lt;button @click="increment"&gt;&#123;&#123; count.value &#125;&#125;&lt;/button&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3️⃣ 支持直接 watch</span></span><br><span class="line">watch(count, (cur, prev) =&gt; &#123; <span class="comment">// 等价于 watch(() =&gt; count.value, (cur, prev) =&gt; &#123;&#125;)</span></span><br><span class="line">  <span class="built_in">console</span>.log(cur) <span class="comment">// 直接拿到的是 ref 的值，所以不需要 cur.value 这样获取</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>另外 VCA 的 computed 实际上就是返回 ref 对象:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> double = computed(<span class="function"><span class="params">()</span> =&gt;</span> state.count * <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(double.value) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><br></p><p>🤔 VSA 和 Mobx 的 API 惊人的相似。想必 Vue 不少借鉴了 Mobx.</p><p><br><br><br></p><h3 id="为什么需要-ref"><a href="#为什么需要-ref" class="headerlink" title="为什么需要 ref?"></a>为什么需要 ref?</h3><p>响应式对象有一个广为人知的陷阱，如果你对响应式对象进行解构、展开，或者将具体的属性传递给变量或参数，那么可能会导致响应丢失。 看下面的例子, 思考一下响应是怎么丢失的:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = reactive(&#123;<span class="attr">count</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构, 响应丢失了.</span></span><br><span class="line"><span class="comment">// 这时候 count 只是一个普通的、值为1的变量.</span></span><br><span class="line"><span class="comment">// reactive 对象变动不会传导到 count</span></span><br><span class="line"><span class="comment">// 修改变量本身，更不会影响到原本的reactive 对象</span></span><br><span class="line"><span class="keyword">let</span> &#123; count &#125; = data</span><br></pre></td></tr></table></figure><p><br></p><p>因为 Javascript <strong>原始值</strong>是<strong>按值传递</strong>的，这时候传递给变量、对象属性或者函数参数，引用就会丢失。<strong>为了保证 ‘安全引用’, 我们才需要用’对象’来包裹这些值，我们总是可以通过这个对象获取到最新的值</strong>:</p><p><img src="/images/react-composition/pass-by-reference-vs-pass-by-value-animation.gif" alt></p><p><br></p><p>关于 VCA 的 ref，还有 <a href="https://vue-composition-api-rfc.netlify.com/api.html#torefs" target="_blank" rel="noopener"><code>toRefs</code></a> 值得提一下。 <strong>toRefs 可以将 reactive 对象的每个属性都转换为 ref 对象，这样可以实现对象被解构或者展开的情况下，不丢失响应</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用toRefs 转换</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123;<span class="attr">count</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> stateRef = toRefs(state) <span class="comment">// 转换成了 Reactive&lt;&#123;count: Ref&lt;state.count&gt;&#125;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时候可以安全地进行解构和传递属性</span></span><br><span class="line"><span class="keyword">const</span> &#123; count &#125; = stateRef</span><br><span class="line"></span><br><span class="line">count.value    <span class="comment">// 1</span></span><br><span class="line">state.count    <span class="comment">// 1 三者指向同一个值</span></span><br><span class="line">stateRef.count.value <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">state.count++ <span class="comment">// 更新源 state</span></span><br><span class="line">count.value   <span class="comment">// 2 响应到 ref</span></span><br></pre></td></tr></table></figure><p><br></p><p>简单实现一下 toRefs, 没什么黑魔法:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toRefs</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isRef(obj[key])) &#123;</span><br><span class="line">      res[key] = obj[key]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res[key] = &#123;</span><br><span class="line">        <span class="keyword">get</span> value() &#123;</span><br><span class="line">          <span class="keyword">return</span> obj[key]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span> value(val) &#123;</span><br><span class="line">          obj[key] = val</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>toRefs 解决 reactive 对象属性值解构和展开导致响应丢失问题。配合<strong>自动解包</strong>，不至于让代码变得啰嗦(尽管有限制).</p><p><br></p><p> <strong>对于 VCA 来说，① ref 除了可以用于封装原始类型，更重要的一点是：② 它是一个’规范’的数据载体，它可以在 Hooks 之间进行数据传递；也可以暴露给组件层，用于引用一些对象，例如引用DOM组件实例</strong>。</p><p>举个例子, 下面的 <code>useOnline</code> Hook, 这个 Hooks 只返回一个状态:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useOnline</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> online = ref(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  online.value = navigator.onLine</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleOnline = <span class="function"><span class="params">()</span> =&gt;</span> (online.value = <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">const</span> handleOffline = <span class="function"><span class="params">()</span> =&gt;</span> (online.value = <span class="literal">false</span>)</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'online'</span>, handleOnline)</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'offline'</span>, handleOffline)</span><br><span class="line"></span><br><span class="line">  onUnmounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'online'</span>, handleOnline)</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'offline'</span>, handleOffline)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个 ref</span></span><br><span class="line">  <span class="comment">// 如果这时候返回一个 reactive 对象，会显得有点奇怪</span></span><br><span class="line">  <span class="keyword">return</span> online</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>如果 useOnline 返回一个 reactive 对象, 会显得有点怪:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样子？ online 可能会丢失响应</span></span><br><span class="line"><span class="keyword">const</span> &#123; online &#125; = useOnline() <span class="comment">// 返回 Reactive&lt;&#123;online: boolean&#125;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 怎么确定属性命名？</span></span><br><span class="line"><span class="keyword">const</span> online = useOnline()</span><br><span class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> online.online)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以我们需要规范，这个规范可以帮我们规避陷阱，也统一了使用方式</span></span><br><span class="line"><span class="comment">// 更规范的返回一个 ref，使用 value 来获取值</span></span><br><span class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> online.value)</span><br><span class="line"><span class="comment">// 可以更方便地进行监听</span></span><br><span class="line">wacth(online, (ol) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 直接拿到 online.value</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>再看另一个返回多个值的例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMousePosition</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pos = reactive(&#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;)</span><br><span class="line">  <span class="keyword">const</span> update = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    pos.x = e.pageX</span><br><span class="line">    pos.y = e.pageY</span><br><span class="line">  &#125;</span><br><span class="line">  onMounted(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">window</span>.addEventListener(<span class="string">'mousemove'</span>, update))</span><br><span class="line">  onUnmounted(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">window</span>.removeEventListener(<span class="string">'mousemove'</span>, update))</span><br><span class="line">  <span class="comment">// 返回多个值，可以使用 toRefs 批量转换</span></span><br><span class="line">  <span class="keyword">return</span> toRefs(pos)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyHook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 安全地使用解构表达式</span></span><br><span class="line">  <span class="keyword">const</span> &#123; x, y &#125; = useMousePosition()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... do something</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 安全地输出</span></span><br><span class="line">  <span class="keyword">return</span> &#123; x, y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>因此官方也推荐使用 ref 对象来进行数据传递，同时保持响应的传导</strong>。就到这吧，不然写着写着就变成 VCA 的文档了🌚。</p><p><br><br><br></p><h3 id="ref-和-useref"><a href="#ref-和-useref" class="headerlink" title="ref 和 useRef"></a>ref 和 useRef</h3><p>VCA ref 这个命名会让 React 开发者将其和 <code>useRef</code> 联想在一起。的确，VCA 的 ref 在结构、功能和职责上跟 React 的 useRef 很像。例如 <a href="https://vue-composition-api-rfc.netlify.com/api.html#template-refs" target="_blank" rel="noopener">ref 也可以用于引用 Virtual DOM的节点实例</a>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> root = ref(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with JSX</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &lt;div ref=&#123;root&#125;/&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>为了避免和现有的 useRef 冲突，而且在我们也不打算实现 ref 自动解包诸如此类的功能。因此在我们会沿用 Mobx 的 box 命名，对应的还有isBox, toBoxes 函数。</p><p><br></p><p>那怎么引用 Virtual DOM 节点呢？ 我们可以使用 React 的 <a href="https://reactjs.org/docs/react-api.html#reactcreateref" target="_blank" rel="noopener"><code>createRef()</code></a> 函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React 代码</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRef &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line">createComponent(&#123;</span><br><span class="line">  setup(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> containerRef = createRef()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &lt;div className=<span class="string">"container"</span> ref=&#123;containerRef&#125;&gt;?...?<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h2><p>接下来看看怎么实现 useMounted 这些生命周期方法。这些方法是全局、通用的，怎么关联到具体的组件上呢？</p><p>这个可以借鉴 React Hooks 的实现，当 setup() 被调用时，在一个全局变量中保存当前组件的上下文，生命周期方法再从这个上下文中存取信息。</p><p>来看一下 initial 的大概实现:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⚛️ 全局变量, 表示当前正在执行的 setup 的上下文</span></span><br><span class="line"><span class="keyword">let</span> compositionContext: CompositionContext | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * initial 方法接受一个 setup 方法， 返回一个 useComposition Hooks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initial</span>&lt;<span class="title">Props</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">Rtn</span>, <span class="title">Ref</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  setup: (props: Props</span>) =&gt; <span class="title">Rtn</span>,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">useComposition</span>(<span class="params">props: Props, ref?: React.RefObject&lt;Ref&gt;</span>): <span class="title">Rtn</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ⚛️ 使用 useRef 用来保存当前的上下文信息。 useRef，可以保证引用不变</span></span><br><span class="line">    <span class="keyword">const</span> context = useRef&lt;CompositionContext | <span class="literal">undefined</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前上下文为空，则开始初始化</span></span><br><span class="line">    <span class="comment">// ⚛️ 我们这样实现了 setup 只被调用一次!</span></span><br><span class="line">    <span class="keyword">if</span> (context.current == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 创建 Composition 上下文</span></span><br><span class="line">      <span class="keyword">const</span> ctx = (context.current = createCompositionContext(props));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ 进入当前组件的上下文作用域</span></span><br><span class="line">      <span class="keyword">const</span> prevCtx = compositionContext;</span><br><span class="line">      compositionContext = ctx;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ **调用 setup, 并缓存返回值**</span></span><br><span class="line">      ctx._instance = setup(ctx._props);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ 离开当前组件的上下文作用域, 恢复</span></span><br><span class="line">      compositionContext = prevCtx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他，下文展开</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 setup 的返回值</span></span><br><span class="line">    <span class="keyword">return</span> context.current._instance!;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>Ok，现在生命周期方法实现原理已经浮出水面, 当这些方法被调用时，只是简单地在 compositionContext 中注册回调, 例如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">onMounted</span>(<span class="params">cb: (</span>) =&gt; <span class="title">any</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️ 获取当前上下文</span></span><br><span class="line">  <span class="keyword">const</span> ctx = assertCompositionContext();</span><br><span class="line">  <span class="comment">// 注册回调</span></span><br><span class="line">  ctx.addMounted(cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">onUnmount</span>(<span class="params">cb: (</span>) =&gt; <span class="title">void</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = assertCompositionContext();</span><br><span class="line">  ctx.addDisposer(cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">onUpdated</span>(<span class="params">cb: (</span>) =&gt; <span class="title">void</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = assertCompositionContext();</span><br><span class="line">  ctx.addUpdater(cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>assertCompositionContext 获取 compositionContext，如果不在 <code>setup</code> 作用域下调用则抛出异常.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertCompositionContext</span>(<span class="params"></span>): <span class="title">CompositionContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (compositionContext == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`请在 setup 作用域使用`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> compositionContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>看一下 CompositionContext 接口的外形:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface CompositionContext&lt;P = any, R = any&gt; &#123;</span><br><span class="line">  <span class="comment">// 添加挂载回调</span></span><br><span class="line">  addMounted: <span class="function">(<span class="params">cb: (</span>) =&gt;</span> any) =&gt; <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 添加重新渲染回调</span></span><br><span class="line">  addUpdater: <span class="function">(<span class="params">cb: (</span>) =&gt;</span> <span class="keyword">void</span>) =&gt; <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 添加卸载回调</span></span><br><span class="line">  addDisposer: <span class="function">(<span class="params">cb: (</span>) =&gt;</span> <span class="keyword">void</span>) =&gt; <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 注册 React.Context 下文会介绍</span></span><br><span class="line">  addContext: &lt;T&gt;(ctx: React.Context&lt;T&gt;) =&gt; T;</span><br><span class="line">  // 添加通过ref暴露给外部的对象, 下文会介绍</span><br><span class="line">  addExpose: (value: any) =&gt; void</span><br><span class="line"></span><br><span class="line">  /** 私有属性 **/</span><br><span class="line">  // props 引用</span><br><span class="line">  _props: P;</span><br><span class="line">  // 表示是否已挂载</span><br><span class="line">  _isMounted: boolean;</span><br><span class="line">  // setup() 的返回值</span><br><span class="line">  _instance?: R;</span><br><span class="line">  _disposers: Array&lt;() =&gt; void&gt;;</span><br><span class="line">  _mounted: Array&lt;() =&gt; any&gt;;</span><br><span class="line">  _updater: Array&lt;() =&gt; void&gt;;</span><br><span class="line">  _contexts: Map&lt;React.Context&lt;any&gt;, &#123; value: any; updater: () =&gt; void &#125;&gt;</span><br><span class="line">  _exposer?: () =&gt; any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><code>addMounted</code>、<code>addUpdater</code> 这些方法实现都很简单, 只是简单添加到队列中:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCompositionContext</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt;(<span class="params">props: P</span>): <span class="title">CompositionContext</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = &#123;</span><br><span class="line">    addMounted: <span class="function"><span class="params">cb</span> =&gt;</span> ctx._mounted.push(cb),</span><br><span class="line">    addUpdater: <span class="function"><span class="params">cb</span> =&gt;</span> ctx._updater.push(cb),</span><br><span class="line">    addDisposer: <span class="function"><span class="params">cb</span> =&gt;</span> ctx._disposers.push(cb),</span><br><span class="line">    addContext: <span class="function"><span class="params">c</span> =&gt;</span> &#123;<span class="comment">/* ...  */</span>&#125; ,</span><br><span class="line">    _isMounted: <span class="literal">false</span>,</span><br><span class="line">    _instance: <span class="literal">undefined</span>,</span><br><span class="line">    _mounted: [],</span><br><span class="line">    _updater: [],</span><br><span class="line">    _disposers: [],</span><br><span class="line">    _contexts: <span class="keyword">new</span> <span class="built_in">Map</span>(),</span><br><span class="line">    _props: observable(props, &#123;&#125;, &#123; <span class="attr">deep</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">"props"</span> &#125;)</span><br><span class="line">    _exposer: <span class="literal">undefined</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>关键实现还是得回到 initial 方法中:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initial</span>&lt;<span class="title">Props</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">Rtn</span>, <span class="title">Ref</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  setup: (props: Props</span>) =&gt; <span class="title">Rtn</span>,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">useComposition</span>(<span class="params">props: Props, ref?: React.RefObject&lt;Ref&gt;</span>): <span class="title">Rtn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = useRef&lt;CompositionContext | <span class="literal">undefined</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context.current == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 初始化....</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 每次重新渲染, 调用 onUpdated 生命周期钩子</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> ctx = context.current;</span><br><span class="line">      <span class="comment">// 首次挂载时不调用</span></span><br><span class="line">      <span class="keyword">if</span> (ctx._isMounted) executeCallbacks(ctx._updater);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 挂载</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> ctx = context.current;</span><br><span class="line">      ctx._isMounted = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ 调用 useMounted 生命周期钩子</span></span><br><span class="line">      <span class="keyword">if</span> (ctx._mounted.length) &#123;</span><br><span class="line">        ctx._mounted.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// ⚛️ useMounted 如果返回一个函数，则添加到disposer中，卸载前调用</span></span><br><span class="line">          <span class="keyword">const</span> rt = cb();</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> rt === <span class="string">"function"</span>) &#123;</span><br><span class="line">            ctx.addDisposer(rt);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ctx._mounted = EMPTY_ARRAY; <span class="comment">// 释放掉</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ 调用 onUnmount 生命周期钩子</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> executeCallbacks(ctx._disposers);</span><br><span class="line">    &#125;, []);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>没错，这些生命周期方法，最终还是用 useEffect 来实现。</p><p><br><br><br></p><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>接下来看看 watch 方法的实现。watch 估计是除了 reactive 和 ref 之外调用的最频繁的函数了。</p><p>watch 方法可以通过 Mobx 的 <code>authrun</code> 和 <code>reaction</code> 方法来实现。我们进行简单的封装，让它更接近 Vue 的watch 函数的行为。</p><p>这里有一个要点是: watch 即可以在setup 上下文中调用，也可以裸露调用。在setup 上下文调用时，支持组件卸载前自动释放监听。 如果裸露调用，则需要开发者自己来释放监听:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 setup 上下文中调用，watch 会在组件卸载后自动解除监听</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyHook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = reactive(&#123;<span class="attr">count</span>: <span class="number">0</span>&#125;)</span><br><span class="line">  watch(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'count change'</span>, data.count))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 裸露调用，需要手动管理资源释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> stop = watch(<span class="function"><span class="params">()</span> =&gt;</span> someReactiveData, (data) =&gt; &#123;<span class="comment">/* reactiveData change */</span>&#125;)</span><br><span class="line">dosomething(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 手动释放</span></span><br><span class="line">  stop()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 另外watch 回调内部也可以获取到 stop 方法</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">wacth(<span class="function">(<span class="params">stop</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (someReactiveData === <span class="number">0</span>) &#123;</span><br><span class="line">    stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> someReactiveData, (data, stop) =&gt; &#123;<span class="comment">/* reactiveData change */</span>&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>另外 watch 的回调支持返回一个函数，用来释放副作用资源，这个行为和 useEffect 保持一致。VCA 的 watch 使用onClean 回调来释放资源，因为考虑到 async/await 函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="comment">/* do something*/</span>&#125;, time)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearInterval(timer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [time])</span><br><span class="line"></span><br><span class="line"><span class="comment">// watch</span></span><br><span class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="comment">/* do something*/</span>&#125;, time)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearInterval(timer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>看看实现代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reaction, autorun&#125; <span class="keyword">from</span> <span class="string">'mobx'</span></span><br><span class="line"><span class="keyword">export</span> type WatchDisposer = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">watch</span>(<span class="params">view: (stop: WatchDisposer</span>) =&gt; <span class="title">any</span>, <span class="title">options</span>?: <span class="title">IAutorunOptions</span>): <span class="title">WatchDisposer</span>;</span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">function</span> <span class="title">watch</span>&lt;<span class="title">T</span>&gt;(<span class="params">expression: (</span>) =&gt; <span class="title">T</span>, <span class="title">effect</span>: (<span class="params">arg: T, stop: WatchDisposer</span>) =&gt; <span class="title">any</span>, <span class="title">options</span>?: <span class="title">IReactionOptions</span>): <span class="title">WatchDisposer</span>;</span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">function</span> <span class="title">watch</span>(<span class="params">expression: any, effect: any, options?: any</span>): <span class="title">WatchDisposer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 放置 autorun 或者 reactive 返回的释放函数</span></span><br><span class="line">  <span class="keyword">let</span> nativeDisposer: WatchDisposer;</span><br><span class="line">  <span class="comment">// 放置上一次 watch 回调返回的副作用释放函数</span></span><br><span class="line">  <span class="keyword">let</span> effectDisposer: WatchDisposer | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 是否已经释放</span></span><br><span class="line">  <span class="keyword">let</span> disposed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装释放函数，支持被重复调用</span></span><br><span class="line">  <span class="keyword">const</span> stop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (disposed) <span class="keyword">return</span>;</span><br><span class="line">    disposed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (effectDisposer) effectDisposer();</span><br><span class="line">    nativeDisposer();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装回调方法</span></span><br><span class="line">  <span class="keyword">const</span> effectWrapper = <span class="function">(<span class="params">effect: (...args: any[]</span>) =&gt;</span> any, <span class="attr">argnum</span>: number) =&gt; (</span><br><span class="line">    ...args: any[]</span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 重新执行了回调，释放上一个回调返回的释放方法</span></span><br><span class="line">    <span class="keyword">if</span> (effectDisposer != <span class="literal">null</span>) effectDisposer();</span><br><span class="line">    <span class="keyword">const</span> rtn = effect.apply(<span class="literal">null</span>, args.slice(<span class="number">0</span>, argnum).concat(stop));</span><br><span class="line">    effectDisposer = <span class="keyword">typeof</span> rtn === <span class="string">"function"</span> ? rtn : <span class="literal">undefined</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> expression === <span class="string">"function"</span> &amp;&amp; <span class="keyword">typeof</span> effect === <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="comment">// reaction</span></span><br><span class="line">    nativeDisposer = reaction(expression, effectWrapper(effect, <span class="number">1</span>), options);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// autorun</span></span><br><span class="line">    nativeDisposer = autorun(effectWrapper(expression, <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果在 setup 上下文则添加到disposer 队列，在组件卸载时自动释放</span></span><br><span class="line">  <span class="keyword">if</span> (compositionContext) &#123;</span><br><span class="line">    compositionContext.addDisposer(stop);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> stop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>DONE!</p><p><br><br><br></p><h2 id="包装-props-为响应式数据"><a href="#包装-props-为响应式数据" class="headerlink" title="包装 Props 为响应式数据"></a>包装 Props 为响应式数据</h2><p>React 组件每次重新渲染都会生成一个新的 Props 对象，所以无法直接在 setup 中使用，我们需要将其转换为一个可以安全引用的对象，然后在每次重新渲染时更新这个对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">set</span> &#125; from 'mobx'</span><br><span class="line"></span><br><span class="line">export function initial&lt;Props extends object, Rtn, Ref&gt;(setup: (props: Props) =&gt; Rtn) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">useComposition</span>(<span class="params">props: Props, ref?: React.RefObject&lt;Ref&gt;</span>): <span class="title">Rtn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = useRef&lt;CompositionContext | <span class="literal">undefined</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">if</span> (context.current == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ⚛️ createCompositoonContext 会将props 转换为一个响应式数据, 而且这里是浅层转换</span></span><br><span class="line">      <span class="comment">// _props: observable(props, &#123;&#125;, &#123; deep: false, name: "props" &#125;)</span></span><br><span class="line">      <span class="keyword">const</span> ctx = (context.current = createCompositionContext(props));</span><br><span class="line">      <span class="keyword">const</span> prevCtx = compositionContext;</span><br><span class="line">      compositionContext = ctx;</span><br><span class="line">      ctx._instance = setup(ctx._props);</span><br><span class="line">      compositionContext = prevCtx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 每次重新渲染时更新, props 属性</span></span><br><span class="line">    <span class="keyword">set</span>(context.current._props, props);</span><br><span class="line"></span><br><span class="line">    return context.current._instance!;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="支持-context-注入"><a href="#支持-context-注入" class="headerlink" title="支持 Context 注入"></a>支持 Context 注入</h2><p>和 VCA 一样，我们通过 <code>inject</code> 支持依赖注入，不同的是我们的 <code>inject</code> 方法接收一个 <a href="https://reactjs.org/docs/context.html#contextprovider" target="_blank" rel="noopener"><code>React.Context</code></a> 对象。<code>inject</code> 可以从 Context 对象中推断出注入的类型。</p><p>另外受限于 React 的 Context 机制，我们没有实现 provider 函数，用户直接使用 Context.Provider 组件即可。</p><p>实现 Context 的注入还是得费点事，我们会利用 React 的 <a href="https://reactjs.org/docs/hooks-reference.html#usecontext" target="_blank" rel="noopener"><code>useContext</code></a> Hook 来实现，因此必须保证 <code>useContext</code> 的调用顺序。</p><p>和生命周期方法一样，调用 inject 时，将 Context 推入队列中, 只不过我们会立即调用一次 useContext 获取到值:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">inject</span>&lt;<span class="title">T</span>&gt;(<span class="params">Context: React.Context&lt;T&gt;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = assertCompositionContext();</span><br><span class="line">  <span class="comment">// ⚛️ 马上获取值</span></span><br><span class="line">  <span class="keyword">return</span> ctx.addContext(Context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>为了避免重复的 useContext 调用, 同时保证插入的顺序，我们使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="noopener"><code>Map</code></a> 来保存 Context 引用:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCompositionContext</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt;(<span class="params">props: P</span>): <span class="title">CompositionContext</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = &#123;</span><br><span class="line">    _isMounted: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// ⚛️ 使用 Map 保存</span></span><br><span class="line">    _contexts: <span class="keyword">new</span> <span class="built_in">Map</span>(),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 注册Context</span></span><br><span class="line">    addContext: <span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ⚛️ 已添加</span></span><br><span class="line">      <span class="keyword">if</span> (ctx._contexts.has(c)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx._contexts.get(c)!.value</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ 首次使用立即调用 useContext 获取 Context 的值</span></span><br><span class="line">      <span class="keyword">let</span> value = useContext(c)</span><br><span class="line">      <span class="comment">// ⚛️ 和 Props 一样转换为 响应式数据, 让 setup 可以安全地引用</span></span><br><span class="line">      <span class="keyword">const</span> wrapped = observable(value, &#123;&#125;, &#123; <span class="attr">deep</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">"context"</span> &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ⚛️ 插入到队列</span></span><br><span class="line">      ctx._contexts.set(c, &#123;</span><br><span class="line">        value: wrapped,</span><br><span class="line">        <span class="comment">// ⚛️ 更新器，这个会在组件挂载之后的每次重新渲染时调用</span></span><br><span class="line">        <span class="comment">// 我们需要保证 useContext 的调用顺序</span></span><br><span class="line">        updater: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// ⚛️ 依旧是调用 useContetxt 重新获取 Context 值</span></span><br><span class="line">          <span class="keyword">const</span> newValue = useContext(c)</span><br><span class="line">          <span class="keyword">if</span> (newValue !== value) &#123;</span><br><span class="line">            <span class="keyword">set</span>(wrapped, newValue)</span><br><span class="line">            value = newValue</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      return wrapped as any</span><br><span class="line">    &#125;,</span><br><span class="line">    // ....</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>回到 setup 函数，我们必须保证每一次渲染时都按照一样的次序调用 useContext：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initial</span>&lt;<span class="title">Props</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">Rtn</span>, <span class="title">Ref</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  setup: (props: Props</span>) =&gt; <span class="title">Rtn</span>,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">useComposition</span>(<span class="params">props: Props, ref?: React.RefObject&lt;Ref&gt;</span>): <span class="title">Rtn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = useRef&lt;CompositionContext | <span class="literal">undefined</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">if</span> (context.current == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> ctx = (context.current = createCompositionContext(props))</span><br><span class="line">      <span class="keyword">const</span> prevCtx = compositionContext</span><br><span class="line">      compositionContext = ctx</span><br><span class="line">      ctx._instance = setup(ctx._props)</span><br><span class="line">      compositionContext = prevCtx</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 一定要在其他 React Hooks 之前调用</span></span><br><span class="line">    <span class="comment">// 因为在 setup 调用的过程中已经调用了 useContext，所以只在挂载之后的重新渲染中才调用更新</span></span><br><span class="line">    <span class="keyword">if</span> (context.current._contexts.size &amp;&amp; context.current._isMounted) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> &#123; updater &#125; <span class="keyword">of</span> context.current._contexts.values()) &#123;</span><br><span class="line">        updater()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>DONE!</p><p><br><br><br></p><h2 id="跟踪组件依赖并触发重新渲染"><a href="#跟踪组件依赖并触发重新渲染" class="headerlink" title="跟踪组件依赖并触发重新渲染"></a>跟踪组件依赖并触发重新渲染</h2><p>基本接口已经准备就绪了，现在如何和 React 组件建立关联，在响应式数据更新后触发组件重新渲染?</p><p>Mobx 有一个库可以用来绑定 React 组件, 它就是 <a href="https://github.com/mobxjs/mobx-react-lite" target="_blank" rel="noopener"><code>mobx-react-lite</code></a>, 有了它, 我们可以监听响应式变化并触发组件重新渲染。用法如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">'mobx-react-lite'</span></span><br><span class="line"><span class="keyword">import</span> &#123; initial &#125; <span class="keyword">from</span> <span class="string">'mpos'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useComposition = initial(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;<span class="comment">/* setup */</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> YouComponent = observer(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> state = useComposition(props)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;state.data.count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>How it work? 如果这样一笔带过，估计很多读者会很扫兴，自己写一个 <code>observer</code> 也不难。我们可以参考 <a href="https://github.com/mobxjs/mobx-react" target="_blank" rel="noopener">mobx-react</a> 或者 mobx-react-lite 的实现。</p><p>它们都将渲染函数放在 <code>track</code> 函数的上下文下，track函数可以跟踪渲染函数依赖了哪些数据，当这些数据变动时，强制进行组件更新:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC , useRef, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Reaction &#125; <span class="keyword">from</span> <span class="string">'mobx'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span>&lt;<span class="title">Props</span> <span class="title">extends</span> </span>&#123;&#125;, Ref = <span class="keyword">void</span>&gt;(options: &#123;</span><br><span class="line">  name?: string</span><br><span class="line">  setup: <span class="function">(<span class="params">props: Props</span>) =&gt;</span> () =&gt; React.ReactElement</span><br><span class="line">  forwardRef?: boolean</span><br><span class="line">&#125;): FC&lt;Props&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; setup, name, forwardRef &#125; = options</span><br><span class="line">  <span class="comment">// ⚛️ 创建 useComposition Hook</span></span><br><span class="line">  <span class="keyword">const</span> useComposition = initial(setup)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Comp = <span class="function">(<span class="params">props: Props, ref: React.RefObject&lt;Ref&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 用于强制更新组件, 实现很简单，就是递增 useState 的值</span></span><br><span class="line">    <span class="keyword">const</span> forceUpdate = useForceUpdate()</span><br><span class="line">    <span class="keyword">const</span> reactionRef = useRef&lt;&#123; <span class="attr">reaction</span>: Reaction, <span class="attr">disposer</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span> &#125; | <span class="literal">null</span>&gt;(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> render = useComposition(props, forwardRef ? ref : <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建跟踪器</span></span><br><span class="line">    <span class="keyword">if</span> (reactionRef.current == <span class="literal">null</span>) &#123;</span><br><span class="line">      reactionRef.current = &#123;</span><br><span class="line">        <span class="comment">// ⚛️ 在依赖更新时，调用 forceUpdate 强制重新渲染</span></span><br><span class="line">        reaction: <span class="keyword">new</span> Reaction(<span class="string">`observer(<span class="subst">$&#123;name || <span class="string">"Unknown"</span>&#125;</span>)`</span>, () =&gt;  forceUpdate()),</span><br><span class="line">        <span class="comment">// 释放跟踪器</span></span><br><span class="line">        disposer: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (reactionRef.current &amp;&amp; !reactionRef.current.reaction.isDisposed) &#123;</span><br><span class="line">            reactionRef.current.reaction.dispose()</span><br><span class="line">            reactionRef.current = <span class="literal">null</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> () =&gt; reactionRef.current &amp;&amp; reactionRef.current.disposer(), [])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> rendering</span><br><span class="line">    <span class="keyword">let</span> error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 将 render 函数放在track 作用域下，收集 render 函数的数据依赖</span></span><br><span class="line">    reactionRef.current.reaction.track(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        rendering = render(props, inst)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        error = err</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      reactionRef.current.disposer()</span><br><span class="line">      <span class="keyword">throw</span> error</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rendering</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>接着，我们将 Comp 组件包裹在 React.memo 下，避免不必要重新渲染:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span>&lt;<span class="title">Props</span> <span class="title">extends</span> </span>&#123;&#125;, Ref = <span class="keyword">void</span>&gt;(options: &#123;</span><br><span class="line">  name?: string</span><br><span class="line">  setup: <span class="function">(<span class="params">props: Props</span>) =&gt;</span> () =&gt; React.ReactElement</span><br><span class="line">  forwardRef?: boolean</span><br><span class="line">&#125;): FC&lt;Props&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; setup, name, forwardRef &#125; = options</span><br><span class="line">  <span class="comment">// 创建 useComposition Hook</span></span><br><span class="line">  <span class="keyword">const</span> useComposition = initial(setup)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Comp = <span class="function">(<span class="params">props: Props, ref: React.RefObject&lt;Ref&gt;</span>) =&gt;</span> &#123;<span class="comment">/**/</span>&#125;</span><br><span class="line"></span><br><span class="line">  Comp.displayName = <span class="string">`Composition(<span class="subst">$&#123;name || <span class="string">"Unknown"</span>&#125;</span>)`</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> finalComp</span><br><span class="line">  <span class="keyword">if</span> (forwardRef) &#123;</span><br><span class="line">    <span class="comment">// 支持转发 ref</span></span><br><span class="line">    finalComp = React.memo(React.forwardRef(Comp))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    finalComp = React.memo(Comp)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  finalComp.displayName = name</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> finalComp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="forwardref-处理"><a href="#forwardref-处理" class="headerlink" title="forwardRef 处理"></a>forwardRef 处理</h2><p>最后一步了，有些时候我们的组件需要通过 ref 向外部暴露一些状态和方法。在Hooks 中我们使用 <code>useImperativeHandle</code> 来实现:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyInput</span>(<span class="params">props, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class="line">    focus: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">...</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">FancyInput = forwardRef(FancyInput);</span></span><br></pre></td></tr></table></figure><p><br></p><p>在我们的玩具中，我们自定义一个新的函数 <code>expose</code> 来暴露我们的公开接口：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  expose(&#123;</span><br><span class="line">    somePublicAPI: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>实现如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">expose</span>(<span class="params">value: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = assertCompositionContext();</span><br><span class="line">  ctx.addExpose(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>关键是 useComposition 的处理:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initial</span>&lt;<span class="title">Props</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">Rtn</span>, <span class="title">Ref</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  setup: (props: Props</span>) =&gt; <span class="title">Rtn</span>,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">useComposition</span>(<span class="params">props: Props, ref?: React.RefObject&lt;Ref&gt;</span>): <span class="title">Rtn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = useRef&lt;CompositionContext | <span class="literal">undefined</span>&gt;()</span><br><span class="line">    <span class="keyword">if</span> (context.current == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 初始化...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... useContext</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 如果传递了ref 且 调用了 expose 函数</span></span><br><span class="line">    <span class="comment">// 则使用useImperativeHandle 暴露给 ref</span></span><br><span class="line">    <span class="keyword">if</span> (ref &amp;&amp; context.current._exposer != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 只在 _exposer 变动后更新</span></span><br><span class="line">      useImperativeHandle(ref, context.current._exposer, [context.current._exposer]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><p>🎉🎉 搞定，<strong>所有代码都在这个 <a href="https://codesandbox.io/s/mobx-vue-composition-api-ft9mv?fontsize=14" target="_blank" rel="noopener">CodeSandbox</a> 中，大家可以自行体验</strong>. 🎉🎉 </p><p><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，这只是一个玩具🎃！整个过程也不过百来行代码。</p><p>就如标题所说的，通过这个玩具，学到很多奇淫巧技，你对 React Hooks 以及 Vue Composition API 的了解应该更深了吧？ <strong>之所以是个玩具，是因为它还有一些缺陷，不够 ’React‘, 又不够 ‘Vue’！只能以学习的目的自个玩玩! 而且搞这玩意, 搞不好可能在两个社区都会被喷</strong>。所以我话就撂这了，你们就不要在评论区喷了。</p><p><br></p><p>如果你了解过 <a href="https://juejin.im/post/5dadc6045188255a270a0f85#heading-13" target="_blank" rel="noopener">React Concurrent 模式</a>，你会发现这个架构是 React 自身的状态更新机制是深入绑定的。React 自身的setState 状态更新粒度更小、可以进行优先级调度、Suspense、可以通过 useTransition + Suspense 配合进入 Pending 状态、在’平行宇宙’中进行渲染。 <strong>React 自身的状态更新机制和组件的渲染体系是深度集成</strong>。</p><p>因此我们现在监听响应式数据，然后粗暴地 <code>forceUpdate</code>，会让我们丢失部分 React Concurrent 模式带来的红利。除此之外、开发者工具的集成、生态圈、Benchmark…</p><p>说到生态圈，如果你将这个玩具的 API 保持和 VCA 完全兼容，那么以后 Vue 社区的 Hooks 库也可以为你所用，想想脑洞挺大。</p><p><br></p><p><strong>搞这一套还不如直接上 Vue 是吧</strong>？毕竟 Vue 天生集成响应式数据，跟 React 的不可变数据一样, <strong>Vue 的响应式更新机制和其组件渲染体系是深度集成的</strong>。 整个工作链路自顶向下, 从数据到模板、再到底层组件渲染, 对响应式数据有更好、更高效地融合。</p><p>尽管如此，React 的灵活性、开放、多范式编程方式、创造力还是让人赞叹。(仅代表我作为React爱好者的立场)</p><p><br></p><p><strong>另外响应式机制也不是完全没有心智负担</strong>，最起码你要了解响应式数据的原理，知道什么可以被响应，什么不可以：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如不能使用解构和展开表达式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyHook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将count 拷贝给(按值传递) count变量，这会导致响应丢失，下游无法响应count 的变化</span></span><br><span class="line">  <span class="keyword">const</span> &#123; count &#125; = reactive(&#123;<span class="attr">count</span>: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; count &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有响应式数据转换成本，诸如此类的，网上也有大量的资料, 这里就不赘述了。 关于响应式数据需要注意的东西可以参考这些资料:</p><ul><li><a href="https://vue-composition-api-rfc.netlify.com/#plugin-development" target="_blank" rel="noopener">Vue Composition API Drawbacks</a></li><li><a href="https://mobx.js.org/best/react.html" target="_blank" rel="noopener">What does MobX react to?</a></li><li><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">Vue: 深入响应式原理</a></li></ul><p>除此之外，你有时候会纠结什么时候应该使用 reactive，什么时候应该使用 ref…</p><p>没有银弹，没有银弹。</p><p><br></p><p>最后的最后， <strong>useYourImagination</strong>, React Hooks 早已在 React 社区玩出了花🌸，Vue Composition API 完全可以将这些模式拿过来用，两个从结构和逻辑上都是差不多的，只不过换一下 ‘Mutable’ 的数据操作方式。安利 <a href="https://juejin.im/post/5d594ea5518825041301bbcb" target="_blank" rel="noopener">2019年了，整理了N个实用案例帮你快速迁移到React Hooks</a></p><p><br></p><p>我是荒山，觉得文章可以，请点个赞，下篇文章见！</p><p><br><br><br></p><h2 id="参考-扩展"><a href="#参考-扩展" class="headerlink" title="参考/扩展"></a>参考/扩展</h2><ul><li><a href="https://codesandbox.io/s/mobx-vue-composition-api-ft9mv?fontsize=14" target="_blank" rel="noopener"><strong>🎉本文源码：CodeSandbox</strong></a></li><li><a href="https://vue-composition-api-rfc.netlify.com/" target="_blank" rel="noopener"><strong>Vue Composition API RFC</strong></a></li><li><a href="https://zhuanlan.zhihu.com/p/68477600" target="_blank" rel="noopener">Vue Function-based API RFC 中文</a> 有点过时，不影响理解</li><li><a href="https://github.com/vuejs/composition-api" target="_blank" rel="noopener">@vue/composition-api</a></li><li><a href="https://mobx.js.org/" target="_blank" rel="noopener">Mobx</a></li><li><a href="https://github.com/kefranabg/awesome-vue-composition-api" target="_blank" rel="noopener">awesome-vue-composition-api</a></li><li><a href="https://codesandbox.io/s/github/nuxt/typescript/tree/master/examples/composition-api/minimal" target="_blank" rel="noopener">Vue Composition API CodeSandbox Playground</a></li><li><a href="https://zhuanlan.zhihu.com/p/71667382" target="_blank" rel="noopener">精读《Vue3.0 Function API》</a></li></ul><p><br></p><p><img src="/images/sponsor.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5dadc6045188255a270a0f85&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前几篇文章&lt;/a&gt;都在讲 React 的 Concurrent 模式, 很多读者都看懵了，这一篇
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>React Concurrent 模式抢先预览下篇: useTransition 的平行世界</title>
    <link href="https://bobi.ink/2019/10/28/concurrent-mode-transition/"/>
    <id>https://bobi.ink/2019/10/28/concurrent-mode-transition/</id>
    <published>2019-10-27T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章介绍了 <a href="https://juejin.im/post/5db65d87518825648f2ef899" target="_blank" rel="noopener"><code>Suspense</code></a>, 那么这篇文章就讲讲它的好搭档 <a href="https://reactjs.org/docs/concurrent-mode-reference.html#usetransition" target="_blank" rel="noopener"><code>useTransition</code></a>。如果你是 React 的粉丝，这两篇文章一定不能错过。</p><p>我们知道 React 内部做了翻天覆地的优化，外部也提供了一些紧凑的新 API，<strong>这些 API 主要用来优化用户体验</strong>。React 官方用一篇很长的文档<a href="https://reactjs.org/docs/concurrent-mode-patterns.html" target="_blank" rel="noopener">《Concurrent UI Patterns 》</a> 专门来介绍这一方面的动机和创造，其中的主角就是 <code>useTransition</code>。</p><p><br></p><p><strong>相关文章</strong></p><ul><li><a href="https://juejin.im/post/5dadc6045188255a270a0f85" target="_blank" rel="noopener">这可能是最通俗的 React Fiber(时间分片) 打开方式</a> 🔥先入个门</li><li><a href="https://juejin.im/post/5db65d87518825648f2ef899" target="_blank" rel="noopener">React Concurrent 模式抢先预览上篇: Suspense the world</a> 上篇</li></ul><p><br><br><br></p><p><strong>本文大纲</strong></p><!-- TOC --><ul><li><a href="#应用场景是什么">应用场景是什么？</a></li><li><a href="#usetransition-登场">useTransition 登场</a></li><li><a href="#usetransition-原理初探">useTransition 原理初探</a><ul><li><a href="#1️⃣-利用-starttransition-来运行低优先级任务"><strong>1️⃣ 利用 startTransition 来运行低优先级任务</strong></a></li><li><a href="#2️⃣-starttransition-更新触发-suspense"><strong>2️⃣ startTransition 更新触发 Suspense</strong></a></li><li><a href="#3️⃣-将-tick-更新提到-starttransition-作用域外"><strong>3️⃣ 将 tick 更新提到 startTransition 作用域外</strong></a></li><li><a href="#4️⃣-嵌套suspense"><strong>4️⃣ 嵌套Suspense</strong></a></li><li><a href="#5️⃣-可以和-mobx-和-redux-配合使用吗"><strong>5️⃣ 可以和 Mobx 和 Redux 配合使用吗?</strong></a></li></ul></li><li><a href="#那-usedeferedvalue-呢">那 useDeferedValue 呢？</a></li><li><a href="#总结">总结</a></li><li><a href="#参考资料">参考资料</a></li></ul><!-- /TOC --><p><br></p><p>React 用’<strong>平行宇宙</strong>‘来比喻这个 useTransition 这个 API。What？</p><p>用 Git 分支来比喻会更好理解一点, 如下图，React 可以从当前视图(可以视作 <code>Master</code>) 分支中 <code>Fork</code> 出来一个新的分支(尚且称为 <code>Pending</code>)，在这个新分支上进行更新，同时 <code>Master</code> 保持响应和更新，这两个分支就像’平行宇宙’，两者互不干扰。当 <code>Pending</code> 分支准备’妥当’，再合并(提交)到 <code>Master</code>分支。</p><p><img src="/images/concurrent-mode/suspense-branch.png" alt></p><p><br></p><p><code>useTransition</code> 就像一个时光隧道, 让组件进入一个平行宇宙，在这个平行宇宙中等待<code>异步状态</code>(异步请求、延时、whatever)就绪。当然组件也不能无限期待在平行宇宙，<code>useTranstion</code> 可以配置超时时间，如果超时了，就算<code>异步状态</code>未就绪也会被强制拉回现实世界。回到现实世界后，React 会立即对组件 Pengding 的变更进行合并，呈现在用户面前。</p><p>因此，你可以认为在Concurrent 模式下， React 组件有三种状态:</p><p><img src="/images/concurrent-mode/component-state.png" alt></p><p><br></p><ul><li><strong>Normal</strong> - 正常状态下的组件</li><li><strong>Suspense</strong> - 因异步状态而挂起的组件</li><li><strong>Pending</strong> - 进入平行宇宙的组件。对应的也有 Pending 的’状态变更’，这些变更 React 不会立即提交到用户界面，而是缓存着，等待 Suspense 就绪或超时。</li></ul><p>你可能还不太能理解, 没关系，继续往下读。</p><p><br><br><br></p><h2 id="应用场景是什么？"><a href="#应用场景是什么？" class="headerlink" title="应用场景是什么？"></a>应用场景是什么？</h2><p>‘平行宇宙’有什么用？ 我们不讲代码或者架构层次的东西。单从 <code>UI</code> 上看： <strong>在某些 UI 交互场景，我们并不想马上将变更立即应用到页面上</strong>。</p><p><strong>🔴比如你从一个页面切换到另一个页面，新页面可能需要一些时间才能加载完成，其实我们更乐于稍微停留在上一个页面，保持一些操作响应, 比如我们可以取消，或者进行其他操作，而给我看一个什么都没有的空白页面或者空转加载状态符, 感觉在做无谓的等待</strong>。</p><p>这种交互场景其实非常常见，眼前的例子就是浏览器：</p><p><br></p><p><img src="/images/concurrent-mode/browser.gif" alt><br><i>假装我要买个 AirPods</i></p><p><br></p><p>还有我们常用的 Github:</p><p><img src="/images/concurrent-mode/github.gif" alt><br><i>国外某著名交友网站</i></p><p><br></p><p>比如我想点击买个 <code>AirPods</code>，浏览器会停留在上一个页面，直到下一个页面的请求获得响应或者超时。另外浏览器会通过地址栏的加载指示符提示请求情况。这种交互设计，比直接切换过去，展示一个空白的页面要好得多. 页面可以保持用户响应, 也可以随时取消请求，保留在原来的页面。</p><blockquote><p>当然, Tab 切换时另外一种交互场景，我们希望它马上切换过去, 否则用户会觉得点击不起作用。</p></blockquote><p>‘平行宇宙’，还有一个好处: <strong>🔴我们假设大部分情况下，数据请求都是非常快的，这时候其实没有必要展示加载状态，这会导致页面闪烁和抖动。其实通过短暂的延时，可以来减少加载状态的展示频率</strong>。</p><p>另外，<strong>🔴useTransition 也可以用于包裹低优先级更新</strong>。 从目前的情况看，React 并没有意愿暴露过多的 Concurrent 模式的底层细节。如果你要调度低优先级的更新，只能使用 useTransition。</p><p><br><br><br></p><h2 id="usetransition-登场"><a href="#usetransition-登场" class="headerlink" title="useTransition 登场"></a>useTransition 登场</h2><p><img src="/images/concurrent-mode/page-state.png" alt></p><p><br></p><p>如上图，我们先按照 React 官方文档的描述来定义页面的各种状态。<strong>它提到页面加载有以下三个阶段</strong>:</p><p><strong>① 过渡阶段(Transition)</strong></p><p>指的是页面未就绪，等待加载关键数据的阶段。按照不同的展示策略，页面可以有以下两种状态：</p><ul><li><p><strong>⚛️退化(Receded)</strong>。马上将页面切换过去，展示一个大大的加载指示器或者空白页面。’退化’是什么意思? 按照 React 的说法是，页面原本有内容，现在变为无内容状态，这是一种退化，或者说历史的’退步’。</p></li><li><p><strong>⚛️待定(Pending)</strong>。这是 <code>useTransition</code> 要达到的状态，即停留在当前页面，让当前页面保持响应。在<strong>关键数据准备就绪</strong>时进入 <code>Skeleton</code>(骨架屏) 状态， 亦或者等待超时回退到 <code>Receded</code> 状态。</p></li></ul><p><br></p><p><strong>② 加载阶段(Loading)</strong></p><p>指的是<code>关键数据</code>已经准备就绪，可以开始展示页面的骨架或者框架部分。这个阶段有一个状态:</p><ul><li><strong>⚛️骨架(Skeleton)</strong>。关键数据已经加载完毕，页面展示了主体的框架。</li></ul><p><br></p><p><strong>③就绪阶段(Done)</strong>。</p><p>指的是页面完全加载完毕。这个阶段有一个状态:</p><ul><li><strong>⚛️完成(Complete)</strong> 页面完全呈现</li></ul><p><br><br><br></p><p>传统的 React 中，当我们变更状态进入一个新屏幕时，经历的是 <strong>🔴<code>Receded</code> -&gt; <code>Skeleton</code> -&gt; <code>Complete</code></strong> 路径。在此之前要实现 <strong>🔴<code>Pending</code> -&gt; <code>Skeleton</code> -&gt; <code>Complete</code></strong> 这种加载路径比较困难。 <code>useTransition</code> 可以改变这个局面。</p><p><br></p><p>接下来简单模拟一个页面切换，先来看默认情况下是如何加载的:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"letter"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️ 延迟加载2s，模拟异步数据请求</span></span><br><span class="line">  delay(<span class="string">"B"</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"letter"</span>&gt;</span>B<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️ 延迟加载4s，模拟异步数据请求</span></span><br><span class="line">  delay(<span class="string">"C"</span>, <span class="number">4000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"letter"</span>&gt;</span>C<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Page1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">A</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 页面2</span></span><br><span class="line"><span class="xml">function Page2() &#123;</span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">B</span> /&gt;</span></span></span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;Loading... C&lt;/div&gt;&#125;&gt;</span><br><span class="line">        &lt;C /&gt;</span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line"><span class="xml">  );</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function App() &#123;</span></span><br><span class="line"><span class="xml">  const [showPage2, setShowPage2] = useState(false);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  // 点击切换到页面2</span></span><br><span class="line"><span class="xml">  const handleClick = () =&gt;  setShowPage2(true)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line">    &lt;div className="App"&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;handleClick&#125;&gt;切换&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className="page"&gt;</span><br><span class="line">        &lt;Suspense fallback=&#123;&lt;div&gt;Loading ...&lt;/div&gt;&#125;&gt;</span><br><span class="line">          &#123;!showPage2 ? &lt;Page1 /&gt; : &lt;Page2 /&gt;&#125;</span><br><span class="line">        &lt;/Suspense&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  );</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>看一下运行效果:</p><p><img src="/images/concurrent-mode/demo1.gif" alt></p><p>点击切换后，我们会马上看到一个大大的 <code>Loading...</code>，接着 2s 后 B 加载完毕，再等待 2s 后 C 加载完毕。这个过程就是 <strong><code>Receded</code> -&gt; <code>Skeleton</code> -&gt; <code>Complete</code></strong></p><p><br></p><p>现在有请 useTransition 隆重登场 🎉，只需对上面的代码进行的简单改造：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⚛️ 导入 useTransition</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Suspense, useState, useTransition &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [showPage2, setShowPage2] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// ⚛️ useTransition 接收一个超时时间，返回一个startTransition 函数，以及一个 pending</span></span><br><span class="line">  <span class="keyword">const</span> [startTransition, pending] = useTransition(&#123; <span class="attr">timeoutMs</span>: <span class="number">10000</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">    <span class="comment">// ⚛️ 将可能触发 Suspense 挂起的状态变更包裹在 startTransition 中</span></span><br><span class="line">    startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setShowPage2(<span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;handleClick&#125;&gt;切换&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>* ⚛️ pending 表示处于待定状态, 你可以进行一些轻微的提示 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &#123;pending &amp;&amp; &lt;span&gt;切换中...&lt;/</span>span&gt;&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="page"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Suspense fallback=&#123;&lt;div&gt;Loading ...&lt;/</span>div&gt;&#125;&gt;</span><br><span class="line">          &#123;!showPage2 ? <span class="xml"><span class="tag">&lt;<span class="name">Page1</span> /&gt;</span> : <span class="tag">&lt;<span class="name">Page2</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>useTransition Hook 的API比较简洁，有4个需要关键的点:</p><ul><li><p><code>timeoutMs</code>, 表示切换的超时时间(最长在平行宇宙存在的时间)，useTransition 会让 React 保持在当前页面，直到被触发 Suspense 就绪或者超时。</p></li><li><p><code>startTransition</code>, 将可能触发页面切换(严格说是触发 Suspense 挂起)的状态变更包裹在 <code>startTransition</code> 下，实际上 startTransition 提供了一个’更新的上下文’。 下一节我们会深入探索这里面的细节</p></li><li><p><code>pending</code>, 表示正处于待定状态。我们可以通过这个状态值，适当地给用户一下提示。</p></li><li><p><code>Suspense</code>, useTransition 实现过渡状态必须和 Suspense 配合，也就是 <code>startTransition</code> 中的更新必须触发任意一个 Suspense 挂起。</p></li></ul><p><br></p><p>看一下实际的运行效果吧！</p><p><img src="/images/concurrent-mode/demo2.gif" alt></p><p><br></p><blockquote><p>可以在这个 <a href="https://codesandbox.io/s/usetransition-y74ry?fontsize=14" target="_blank" rel="noopener">CodeSandbox</a> 查看运行效果</p></blockquote><p>这个效果完全跟本节开始的’第一张图’一样: React 会保留在当前页面，<code>pending</code> 变为了true，接着 B 先就绪，界面马上切换过去。整个过程符合 <strong><code>Pending</code> -&gt; <code>Skeleton</code> -&gt; <code>Complete</code></strong> 的路径。</p><p><code>startTransition</code> 中的<code>变更</code>一旦触发 <code>Suspense</code>，React 就会将<code>变更</code>标记的 Pending 状态, React会延后 ’提交‘ 这些变更。所以<strong>实际上并没有开头说的平行宇宙, 那么高大上和神奇，React 只不过是延后了这些变更的提交。我们界面上看到的只不过是旧的或者未被 Pending 的状态，React 在后台进行了预渲染</strong>。</p><p>注意，React 只是暂时没有提交这些变更，不说明 React ’卡死了‘，处于Pending 状态的组件还会接收用户的响应，进行新的状态变更，新的状态更新也可以覆盖或终止 Pending 状态。</p><p><br></p><p>总结一下进入和退出 Pending 状态的条件:</p><ul><li><strong>进入Pending</strong> 状态首先需要将 <code>状态变更</code> 包裹在 <code>startTransition</code> 下，且这些更新会触发 Suspense 挂起</li><li><strong>退出 Pending</strong> 状态有三种方式: ① Suspense 就绪；② 超时；③ 被新的状态更新覆盖或者终止</li></ul><p><br><br><br></p><h2 id="usetransition-原理初探"><a href="#usetransition-原理初探" class="headerlink" title="useTransition 原理初探"></a>useTransition 原理初探</h2><p>这一节，我们深入探索一下 useTransition，但是方式不是去折腾源码，而是把它当成一个黑盒，通过几个实验来加深你对 useTransition 的理解。</p><p>useTransition 的前身是 <code>withSuspenseConfig</code>, <a href="https://github.com/sebmarkbage" target="_blank" rel="noopener">Sebmarkbage</a> 在今年五月份提的一个<a href="https://github.com/facebook/react/pull/15593" target="_blank" rel="noopener">PR</a> 中引进了它。</p><p>从命名上看，它不过是想配置一下 Suspense。 我们也可以通过最新的源码验证这一点。 useTransition 的工作’看似’非常简单:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTransition</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  config: SuspenseConfig | void | null,</span></span></span><br><span class="line">): [(() =&gt; void) =&gt; void, boolean] &#123;</span><br><span class="line">  <span class="keyword">const</span> [isPending, setPending] = updateState(<span class="literal">false</span>); <span class="comment">// 相当于useState</span></span><br><span class="line">  <span class="keyword">const</span> startTransition = updateCallback(             <span class="comment">// 相当于useCallback</span></span><br><span class="line">    callback =&gt; &#123;</span><br><span class="line">      setPending(<span class="literal">true</span>); <span class="comment">// 设置 pending 为 true</span></span><br><span class="line">      <span class="comment">// 以低优先级调度执行</span></span><br><span class="line">      Scheduler.unstable_next(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ⚛️ 设置suspenseConfig</span></span><br><span class="line">        <span class="keyword">const</span> previousConfig = ReactCurrentBatchConfig.suspense;</span><br><span class="line">        ReactCurrentBatchConfig.suspense = config === <span class="literal">undefined</span> ? <span class="literal">null</span> : config;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 还原 pending</span></span><br><span class="line">          setPending(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 执行你的回调</span></span><br><span class="line">          callback();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// ⚛️ 还原suspenseConfig</span></span><br><span class="line">          ReactCurrentBatchConfig.suspense = previousConfig;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    [config, isPending],</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> [startTransition, isPending];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>看似很普通，要点在哪？Sebmarkbage 在上述的 PR 中也提及了一些信息。</p><ul><li><p>startTransition 一开始执行就将 pending 设置为true。接着使用 <code>unstable_next</code> 执行回调, <strong>unstable_next 可以降低更新的优先级</strong>。也就是说 unstable_next 回调中触发的’变更‘优先级会比较低，它会让位为高优先级的更新，或者当前事务繁忙时，调度到下一空闲期再应用，但也可能马上就被应用。</p></li><li><p>要点是 <code>ReactCurrentBatchConfig.suspense</code> 的配置, 这里面会配置 Suspense 的超时时间。<strong>它表明这个区间触发的变更都被关联该 <code>suspenseConfig</code></strong>, 这些变更会根据 suspenseConfig 来计算自己的 <code>expiredTime</code>(可以视作‘优先级’)。我们暂且将这些关联了 suspenseConfig 的变更称为 <code>Pending 变更</code>.</p></li><li><p><code>Pending 变更</code> 触发的重新渲染(Render)也会关联该 <code>suspenseConfig</code>。如果在渲染期间触发了 Suspense，那么<code>Pending 变更</code> 就会被延迟提交(commit)，它们会缓存在内存中, 等到 Suspense 超时或者就绪, 抑或被其他更新覆盖, 才强制提交到用户界面。</p></li><li><p><code>Pending 变更</code> 只是被延迟提交了，但是不会影响最终数据和视图的一致性。React 会在内存中重新渲染，只是不提交到用户界面而已。</p></li></ul><p><br></p><p>React 内部的实现太过复杂，我发现去挖它或者用文字表达出来成本都很高。因此换一种方式，通过实验(黑盒)方式来了解它的行为：</p><blockquote><p>这些实验代码在这个 <a href="https://codesandbox.io/s/react-use-transition-tests-kg8rc?fontsize=14" target="_blank" rel="noopener">CodeSandbox</a> 中</p></blockquote><p><br></p><h3 id="1️⃣-利用-starttransition-来运行低优先级任务"><a href="#1️⃣-利用-starttransition-来运行低优先级任务" class="headerlink" title="1️⃣ 利用 startTransition 来运行低优先级任务"></a><strong>1️⃣ 利用 startTransition 来运行低优先级任务</strong></h3><p>这个实验主要用于验证 <code>unstable_next</code>, 它会让降低更新的优先级。通过下面的实验我们会观察到: 通过<code>startTransition</code> 包裹的变更在任务繁忙的情况会稍微延后更新，但是最终状态是一致的。</p><p>实验代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [tick, setTick] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [startTransition, pending] = useTransition(&#123; <span class="attr">timeoutMs</span>: <span class="number">10000</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ⚛️ 同步更新</span></span><br><span class="line">    setCount(count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ⚛️ 低优先级更新 tick</span></span><br><span class="line">      setTick(<span class="function"><span class="params">t</span> =&gt;</span> t + <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hello useTransition&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;handleClick&#125;&gt;ADD + 1&lt;/</span>button&gt;</span><br><span class="line">        &#123;pending &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>pending<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;Count: &#123;count&#125;&lt;/</span>div&gt;</span><br><span class="line">      &#123;<span class="comment">/* ⚛️ 这是一个复杂的组件，渲染需要一点时间，模拟繁忙的情况 */</span>&#125;</span><br><span class="line">      &lt;ComplexComponent value=&#123;tick&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>实验结果如下：</p><p><img src="/images/concurrent-mode/test1.gif" alt></p><p><br></p><p>在连续点击的情况下，<code>ComplexComponent</code> 的更新会明显滞后，这是因为 tick 变更会被延后和合并，但是最后它们的结果是一致的.</p><p><br><br><br></p><h3 id="2️⃣-starttransition-更新触发-suspense"><a href="#2️⃣-starttransition-更新触发-suspense" class="headerlink" title="2️⃣ startTransition 更新触发 Suspense"></a><strong>2️⃣ startTransition 更新触发 Suspense</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [tick, setTick] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [startTransition, pending] = useTransition(&#123; <span class="attr">timeoutMs</span>: <span class="number">10000</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">      setTick(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hello useTransition &#123;tick&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;handleClick&#125;&gt;ADD + 1&lt;/</span>button&gt;</span><br><span class="line">        &#123;pending &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">"pending"</span>&gt;</span>pending<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Tick /</span>&gt;</span><br><span class="line">      &lt;SuspenseBoundary id=&#123;count&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const SuspenseBoundary = (&#123; id &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;Suspense fallback="Loading..."&gt;</span></span><br><span class="line"><span class="regexp">      &#123;/</span>* 这里会抛出一个<span class="built_in">Promise</span>异常，<span class="number">3</span>s 后 resolved *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">      &lt;ComponentThatThrowPromise id=&#123;id&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Tick 组件每秒递增一次</span></span><br><span class="line"><span class="regexp">const Tick = (&#123; duration = 1000 &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const [tick, setTick] = useState(0);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    const t = setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      setTick(tick =&gt; tick + 1);</span></span><br><span class="line"><span class="regexp">    &#125;, duration);</span></span><br><span class="line"><span class="regexp">    return () =&gt; clearInterval(t);</span></span><br><span class="line"><span class="regexp">  &#125;, [duration]);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return &lt;div className="tick"&gt;tick: &#123;tick&#125;&lt;/</span>div&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/images/concurrent-mode/test2.gif" alt></p><p>当我们点击按钮时会递增 count 和 tick, count 会传递给 SuspenseBoundary，从而触发 Suspense。</p><p>通过上面的结果可以知道，在 startTransition 中进行了变更(携带suspenseConfig), 对应的重新渲染触发了 Suspense，所以进入了Pending状态，它们渲染结果不会被立即‘提交’，页面还是保持在原来的状态。</p><p>另外你会发现 App 组件的 tick 跟 SuspenseBoundary 一样也会被‘停止’(看Hello Transition 后面的tick)，因为 tick 变更也关联了suspenseConfig。</p><p>而 Tick 组件则每一秒递增一次，不会被阻塞。</p><p>这就说明了一旦触发了Suspense，只要关联了 suspenseConfig 的变更就会被‘暂停’提交。</p><p><br><br><br></p><h3 id="3️⃣-将-tick-更新提到-starttransition-作用域外"><a href="#3️⃣-将-tick-更新提到-starttransition-作用域外" class="headerlink" title="3️⃣ 将 tick 更新提到 startTransition 作用域外"></a><strong>3️⃣ 将 tick 更新提到 startTransition 作用域外</strong></h3><p>在 2️⃣ 的基础上，将 setTick 提到 startTransition 作用域外:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [tick, setTick] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [startTransition, pending] = useTransition(&#123; <span class="attr">timeoutMs</span>: <span class="number">10000</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"App rendering with"</span>, count, tick, pending);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTick(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">    startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleAddTick = <span class="function"><span class="params">()</span> =&gt;</span> setTick(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"App committed with"</span>, count, tick, pending);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hello useTransition &#123;tick&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;handleClick&#125;&gt;ADD + 1&lt;/</span>button&gt;</span><br><span class="line">        &lt;button onClick=&#123;handleAddTick&#125;&gt;Tick + <span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &#123;pending &amp;&amp; &lt;span className="pending"&gt;pending&lt;/</span>span&gt;&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Tick /</span>&gt;</span><br><span class="line">      &lt;SuspenseBoundary id=&#123;count&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/images/concurrent-mode/test3.gif" alt></p><p><br></p><p>现在 tick 会被立即更新，而 SuspenseBoundary 还会挂在 pending 状态。</p><p>我们打开控制台看一下，输出情况:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">App rendering with 1 2 true   # pending 被设置为true, count 这是时候是 1， 而 tick 是 2</span><br><span class="line">App rendering with 1 2 true</span><br><span class="line">read  1</span><br><span class="line">App committed with 1 2 true    # 进入Pending 状态之前的一次提交，我们在这里开始展示 pending 指示符</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面 Tick 更新了三次(3s)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们注意到，每一次 React 都会重新渲染一下 App 组件，即 <span class="string">'ping'</span> 一下处于 Pending 状态的组件, 检查一下是否‘就绪’(没有触发Suspense)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果还触发 Suspense, 说明还要继续等待，这些重新渲染的结果不会被提交</span></span><br><span class="line"></span><br><span class="line">App rendering with 2 2 false # ping, 这里count变成了2，且 pending 变成了 false</span><br><span class="line">App rendering with 2 2 false # 但是 React 在内存中渲染它们，我们看不到</span><br><span class="line">read  2</span><br><span class="line"></span><br><span class="line">Tick rendering with 76        # Tick 重新渲染</span><br><span class="line">Tick rendering with 76</span><br><span class="line">Tick committed with 76        # 提交 Tick 更新，刷新到界面上</span><br><span class="line">App rendering with 2 2 false  # ping 还是没有就绪，继续 pending</span><br><span class="line">App rendering with 2 2 false</span><br><span class="line">read  2</span><br><span class="line"></span><br><span class="line">Tick rendering with 77</span><br><span class="line">Tick rendering with 77</span><br><span class="line">Tick committed with 77</span><br><span class="line">App rendering with 2 2 false # ping</span><br><span class="line">App rendering with 2 2 false</span><br><span class="line">read  2</span><br><span class="line"></span><br><span class="line">Tick rendering with 78</span><br><span class="line">Tick rendering with 78</span><br><span class="line">Tick committed with 78</span><br><span class="line">App rendering with 2 2 false # ping</span><br><span class="line">App rendering with 2 2 false</span><br><span class="line">read  2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Ok, Promise 已经就绪了，这时候再一次重新渲染 App</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这次没有触发 Suspense，React 会马上提交用户界面</span></span><br><span class="line">App rendering with 2 2 false</span><br><span class="line">App rendering with 2 2 false</span><br><span class="line">read  2</span><br><span class="line">App committed with 2 2 false</span><br></pre></td></tr></table></figure><p>通过上面的日志，我们可以清晰地理解 Pending 组件的更新行为</p><p><br><br><br></p><h3 id="4️⃣-嵌套suspense"><a href="#4️⃣-嵌套suspense" class="headerlink" title="4️⃣ 嵌套Suspense"></a><strong>4️⃣ 嵌套Suspense</strong></h3><p>在3️⃣的基础上，将 SuspenseBoundary 改写为 DoubleSuspenseBoundary, 这里会嵌套一个 Suspense 加载一个更耗时的资源:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DoubleSuspenseBoundary = <span class="function">(<span class="params">&#123; id &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &#123;/</span>* 需要加载 <span class="number">2</span>s  *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">      &lt;ComponentThatThrowPromise id=&#123;id&#125; timeout=&#123;2000&#125; /</span>&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;Loading second...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>* 需要加载 <span class="number">4</span>s  *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;ComponentThatThrowPromise id=&#123;id + "second"&#125; timeout=&#123;4000&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Suspense&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下效果：</p><p><img src="/images/concurrent-mode/test4-1.gif" alt></p><p><br></p><p>首先注意观察首次挂载，<strong>Suspense 首次挂载时不会触发延迟提交</strong>，因此我们首先会看到 <code>Loading...</code>、接着第一个 <code>ComponentThatThrowPromise</code> 加载完毕，显示<code>ComponentThatThrowPromise id: 0</code> 和 <code>Loading second...</code>, 最后完全加载完毕。</p><p>接着我们点击按钮，这时候 DoubleSuspenseBoundary 会保持不动，等待 5s 后(也就是第二个<code>ComponentThatThrowPromise</code>加载完毕), 才提交。</p><p><br></p><p>理想的效果是跟首次挂载的时候一样：在第一个 ComponentThatThrowPromise 就绪时就切换过来，不用等待第二个加载完毕。</p><p>感觉有点不对？我这这里想了很久, 官方文档上 <a href="https://reactjs.org/docs/concurrent-mode-patterns.html#wrap-lazy-features-in-suspense" target="_blank" rel="noopener">Concurrent UI Patterns (Experimental) - Wrap Lazy Features in \&lt;Suspense></a> 说了，第二个<code>ComponentThatThrowPromise</code> 已经嵌套在 <code>Suspense</code> 中了，理论上应该不会阻塞提交。</p><p>回到开头的第一句话：’<strong>Suspense 首次挂载时不会触发延迟提交</strong>‘。我们再试一下, 给 DoubleSuspenseBoundary 设置一个key，强制让它销毁重新创建:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hello useTransition &#123;tick&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;handleClick&#125;&gt;ADD + 1&lt;/</span>button&gt;</span><br><span class="line">        &#123;pending &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">"pending"</span>&gt;</span>pending<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Tick /</span>&gt;</span><br><span class="line">      &#123;<span class="comment">/* ⚛️ 这里添加key，强制重新销毁创建 */</span>&#125;</span><br><span class="line">      &lt;DoubleSuspenseBoundary id=&#123;count&#125; key=&#123;count&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>试一下效果:</p><p><img src="/images/concurrent-mode/test4-2.gif" alt></p><p><br></p><p>我们发现，每次点击都是<code>Loading...</code>, Pending 状态没有了! 因为每次 <code>count</code> 递增, <code>DoubleSuspenseBoundary</code> 就会重新创建，不会触发延迟提交。</p><p>基于这个原理，我们可以再改造一下 <code>DoubleSuspenseBoundary</code>, 这一次，我们只给嵌套的 <code>Suspense</code> 加上key，让它们重新创建不阻塞 Pending 状态.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DoubleSuspenseBoundary = <span class="function">(<span class="params">&#123; id &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ComponentThatThrowPromise id=&#123;id&#125; timeout=&#123;2000&#125; /</span>&gt;</span><br><span class="line">      &#123;<span class="comment">/* ⚛️ 我们不希望这个 Suspense 阻塞 pending 状态, 给它加个key, 让它强制重新创建 */</span>&#125;</span><br><span class="line">      &lt;Suspense key=&#123;id&#125; fallback=&#123;&lt;div&gt;Loading second...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ComponentThatThrowPromise id=&#123;id + "second"&#125; timeout=&#123;4000&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><p>最后的效果</p><p><img src="/images/concurrent-mode/test4-3.gif" alt></p><p>It’s work! 🍻</p><p><br><br><br></p><h3 id="5️⃣-可以和-mobx-和-redux-配合使用吗"><a href="#5️⃣-可以和-mobx-和-redux-配合使用吗" class="headerlink" title="5️⃣ 可以和 Mobx 和 Redux 配合使用吗?"></a><strong>5️⃣ 可以和 Mobx 和 Redux 配合使用吗?</strong></h3><p>我也不知道，测试一下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mport React, &#123; useTransition, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider, useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"><span class="keyword">import</span> SuspenseBoundary <span class="keyword">from</span> <span class="string">"./SuspenseBoundary"</span>;</span><br><span class="line"><span class="keyword">import</span> Tick <span class="keyword">from</span> <span class="string">"./Tick"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">count</span>: <span class="number">0</span>, <span class="attr">tick</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> ADD_TICK = <span class="string">"ADD_TICK"</span>;</span><br><span class="line"><span class="keyword">const</span> ADD_COUNT = <span class="string">"ADD_COUNT"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(<span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> copy = &#123; ...state &#125;;</span><br><span class="line">  <span class="keyword">if</span> (action.type === ADD_TICK) &#123;</span><br><span class="line">    copy.tick++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    copy.count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copy</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Page = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; count, tick &#125; = useSelector(<span class="function">(<span class="params">&#123; tick, count &#125;</span>) =&gt;</span> (&#123; tick, count &#125;));</span><br><span class="line">  <span class="keyword">const</span> dispatch = useDispatch();</span><br><span class="line">  <span class="keyword">const</span> [startTransition, pending] = useTransition(&#123; <span class="attr">timeoutMs</span>: <span class="number">10000</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> addTick = <span class="function"><span class="params">()</span> =&gt;</span> dispatch(&#123; <span class="attr">type</span>: ADD_TICK &#125;);</span><br><span class="line">  <span class="keyword">const</span> addCount = <span class="function"><span class="params">()</span> =&gt;</span> dispatch(&#123; <span class="attr">type</span>: ADD_COUNT &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    addTick();</span><br><span class="line">    startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Start transition with count: "</span>, count);</span><br><span class="line">      addCount();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"End transition"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`App rendering with count(<span class="subst">$&#123;count&#125;</span>) pendig(<span class="subst">$&#123;pending&#125;</span>)`</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"committed with"</span>, count, tick, pending);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hello useTransition &#123;tick&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;handleClick&#125;&gt;ADD + 1&lt;/</span>button&gt;</span><br><span class="line">        &#123;pending &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">"pending"</span>&gt;</span>pending<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Tick /</span>&gt;</span><br><span class="line">      &lt;SuspenseBoundary id=&#123;count&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;Provider store=&#123;store&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Page /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><br></p><p>先看一下运行效果:</p><p><img src="/images/concurrent-mode/test5.gif" alt></p><p><br></p><p><img src="/images/concurrent-mode/hyhs.png" alt></p><p><br></p><p>What’s the problem? 整个界面都 <code>Pending</code> 了, 整个界面不单单指 <code>App</code> 这颗子树，而且 Tick 也不走了。打开控制台看到了一个警告:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Warning: Page triggered a user-blocking update that suspended.</span><br><span class="line"></span><br><span class="line">The fix is to split the update into multiple parts: a user-blocking update to provide immediate feedback, and another update that triggers the bulk of the changes.</span><br><span class="line">Refer to the documentation for useTransition to learn how to implement this pattern.</span><br></pre></td></tr></table></figure><p><br></p><p>先来看一下目前Rudux 和 Mobx 的Hooks API 是怎么更新的，<strong>本质上它们都采用订阅机制，在事件触发后进行强制更新</strong>, 基本结构如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useSomeOutsideStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取外部 store</span></span><br><span class="line">  <span class="keyword">const</span> store = getOutsideStore()</span><br><span class="line">  <span class="keyword">const</span> [, forceUpdate] = useReducer(<span class="function"><span class="params">s</span> =&gt;</span> s + <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 订阅外部数据源</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> disposer = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ⚛️ 强制更新</span></span><br><span class="line">      forceUpdate()</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> disposer</span><br><span class="line">  &#125;, [store])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>也就是说，我们在 <code>startTransition</code> 中更新 Redux 状态时，会同步接收到事件，然后调用 <code>forceUpdate</code>。<strong><code>forceUpdate</code> 才是真正在 suspenseConfig 上下文中变更的状态</strong>。</p><p>我们再看一下控制台日志:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Start transition with count 0</span><br><span class="line">End transition</span><br><span class="line">App rendering with count(1) pendig(true)  # 这里出问题了 🔴, 你可以和实验 3️⃣ 中的日志对比一下</span><br><span class="line">App rendering with count(1) pendig(true)  # 实验 3️⃣ 中这里的 count 是 0，而这里的count是1，说明没有 defer!</span><br><span class="line">read  1</span><br><span class="line"></span><br><span class="line">Warning: App triggered a user-blocking update that suspended.</span><br><span class="line">The fix is to split the update into multiple parts: a user-blocking update to provide immediate feedback, and another update that triggers the bulk of the changes.</span><br><span class="line">Refer to the documentation for useTransition to learn how to implement this pattern.</span><br></pre></td></tr></table></figure><p>通过日志可以基本上能够定位出问题，count 没有被延迟更新，所以导致’同步’触发了 Suspense，这也是 React 警告的原因。 由于 useTransition 目前还处于实验阶段，<strong>如果不是 startTransition 上下文中的状态更新导致的Suspense，行为还是未确定的</strong>。</p><p>但是最终的行为有点玄学，它会导致整个应用被‘Pending’，所有状态更新都不会被提交。这块我也很疑惑，没有精力深究下去，只能等待后续官方的更新，读者也可以去琢磨琢磨。</p><p>因此，暂时不推荐将会触发 Suspense 的状态放置在 Redux 或者 Mobx 中。</p><p><br><br><br></p><p>最后再重申一下， <code>useTransition</code> 要进入 <code>Pending</code> 状态要符合以下几个条件:</p><ul><li>最好使用 React 本身的状态机制进行更新, 如 Hooks 或 setState, 当前不要使用 Mobx 和 Redux</li><li>这些更新会触发 Suspense。</li><li>更新必须在<code>startTransition</code>作用域下, 这些更新会关联 <code>suspenseConfig</code></li><li>这些更新触发的重新渲染中, 必须触发至少一个 <code>Suspense</code></li><li>这个 <code>Suspense</code> 不是首次挂载</li></ul><p><br><br><br></p><h2 id="那-usedeferedvalue-呢？"><a href="#那-usedeferedvalue-呢？" class="headerlink" title="那 useDeferedValue 呢？"></a>那 useDeferedValue 呢？</h2><p>如果你理解了上面的内容, 那么 <code>useDeferedValue</code> 就好办了，它不过是 useTransition 的简单封装：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDeferredValue</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  value: T,</span></span></span><br><span class="line"><span class="function"><span class="params">  config: TimeoutConfig | void | null,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [prevValue, setValue] = useState(value);</span><br><span class="line">  <span class="keyword">const</span> [startTransition] = useTransition(config)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ useDeferredValue 只不过是监听 value 的变化，</span></span><br><span class="line">  <span class="comment">// 然后在 startTransition 中更新它。从而实现延迟更新的效果</span></span><br><span class="line">  useEffect(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setValue(value);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    [value, config],</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> prevValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><code>useDeferredValue</code> 只不过是使用 useEffect 监听 <code>value</code> 的变化， 然后在 startTransition 中更新它。从而实现延迟更新的效果。上文实验 1️⃣ 已经介绍过运行效果，React 会降低 startTransition 中更新的优先级， 这意味着在事务繁忙时它们会延后执行。</p><p><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们一开始介绍了 useTransition 的应用场景, 让页面实现 <strong><code>Pending</code> -&gt; <code>Skeleton</code> -&gt; <code>Complete</code></strong> 的更新路径, 用户在切换页面时可以停留在当前页面，让页面保持响应。 相比展示一个无用的空白页面或者加载状态，这种用户体验更加友好。</p><p>当然上述的假设条件时数据加载很慢，如果数据加载很快，利用 useTransition 机制，我们实现不让用户看到加载状态，这样能避免页面页面抖动和闪烁, 看起来像没有加载的过程。</p><p>接着我们简单介绍了 useTransition 的运行原理和条件。 如果 startTransition 中的状态更新触发了 Suspense，那么对应的组件就会进入 Pending 状态。在 Pending 状态期间，startTransition中设置变更都会被延迟提交。 Pending 状态会持续到 Suspense 就绪或者超时。</p><p>useTransition 必须和 Suspense 配合使用才能施展魔法。还有一个用户场景是我们可以将低优先级的更新放置到 startTransition 中。比如某个更新的成本很高，就可以选择放到 startTransition 中, 这些更新会让位高优先级的任务，另外会 React 延迟或合并一个比较复杂的更新，让页面保持响应。</p><p><br><br><br></p><p><strong>Ok，关于 Concurrent 模式的介绍就先告一段落了, 这是中文的第一手资料。写这些文章耗掉了我大部分的业余时间，如果你喜欢我的文章，请多给我点赞和反馈。</strong></p><p><br><br><br></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://reactjs.org/docs/concurrent-mode-patterns.html" target="_blank" rel="noopener">Concurrent UI Patterns</a></li><li><a href="https://github.com/facebook/react/pull/15593" target="_blank" rel="noopener">Add withSuspenseConfig API</a></li></ul><p><br></p><p><img src="/images/sponsor.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上篇文章介绍了 &lt;a href=&quot;https://juejin.im/post/5db65d87518825648f2ef899&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Suspense&lt;/code&gt;&lt;/a&gt;, 那么这篇文章就讲讲它的好搭
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>React Concurrent 模式抢先预览上篇: Suspense the world</title>
    <link href="https://bobi.ink/2019/10/26/concurrent-mode-suspense/"/>
    <id>https://bobi.ink/2019/10/26/concurrent-mode-suspense/</id>
    <published>2019-10-25T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.328Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2019.10.24</strong>, 在 <a href="https://www.youtube.com/channel/UCz5vTaEhvh7dOHEyd1efcaQ" target="_blank" rel="noopener">React Conf 2019</a> 首日， React 官方正式发布了关于 <code>Concurrent</code> 模式的第一个早期社区<a href="https://reactjs.org/docs/concurrent-mode-intro.html" target="_blank" rel="noopener">预览文档</a>, 正式和 React 的大众开发者见面, 令人兴奋。</p><p>跟去年的 React Hooks 一样, 尽管 Concurrent 还是<a href="https://reactjs.org/blog/2019/10/22/react-release-channels.html#experimental-channel" target="_blank" rel="noopener">实验性</a>的, 相信这次不会等太久…</p><p><br></p><p><strong>这个大招憋了四年多</strong></p><p><img src="/images/concurrent-mode/release.png" alt></p><p><br></p><p><strong>如果 React Hooks 目的是提高开发体验，那么 Concurrent 模式则专注于提升用户体验</strong>，表面上它对我们的开发的可能影响不大，React 内部已经变了好几重天。</p><p>这系列文章主要来源于官方的<a href="https://reactjs.org/docs/concurrent-mode-intro.html" target="_blank" rel="noopener">预览文档</a>, 专门给 React 尝鲜者准备。</p><p>这个月 Vue 3.0 源码发布，掘金相关文章像井喷一样，没理由 React 这么’大新闻’(尽管这个新闻3年前大家就知道了)… 我来带个头吧。</p><p><br></p><p><strong>🎉下篇：<a href="https://juejin.im/post/5dbee8e7e51d4558040f0830" target="_blank" rel="noopener">React Concurrent 模式抢先预览下篇: useTransition 的平行世界</a></strong></p><p><br></p><p><strong>文章内容框架</strong></p><!-- TOC --><ul><li><a href="#什么是-concurrent-模式">什么是 Concurrent 模式?</a></li><li><a href="#启用-concurrent-模式">启用 Concurrent 模式</a></li><li><a href="#什么是-suspense">什么是 Suspense?</a></li><li><a href="#suspense-的实现原理">Suspense 的实现原理</a></li><li><a href="#缓存-suspense-的异步操作状态">缓存 Suspense 的异步操作状态</a><ul><li><a href="#使用-context-api">使用 Context API</a></li><li><a href="#将缓存状态提取到父级">将缓存状态提取到父级</a></li></ul></li><li><a href="#并发发起请求">并发发起请求</a></li><li><a href="#处理竞态">处理竞态</a></li><li><a href="#错误处理">错误处理</a></li><li><a href="#suspense-编排">Suspense 编排</a></li><li><a href="#总结">总结</a></li><li><a href="#参考资料">参考资料</a></li></ul><!-- /TOC --><p><br><br><br></p><h2 id="什么是-concurrent-模式"><a href="#什么是-concurrent-模式" class="headerlink" title="什么是 Concurrent 模式?"></a>什么是 Concurrent 模式?</h2><p><img src="/images/concurrent-mode/cpu-vs-io.jpg" alt></p><p><strong>这是一个特性集合，可以让你的React 应用保持响应，可以根据用户的设备能力和网络情况优雅地调整</strong>。 这个特性集合，它包含<strong>两个方向</strong>的优化:</p><p><strong>1️⃣ CPU 密集型(CPU-bound)</strong></p><p>CPU 密集型指是 Reconcilation(协调或者Diff) 的优化. 在Concurrent 模式下面，Reconcilation 可以被中断, 让位给高优先级的任务，让应用保持响应.</p><p><strong>上一周，我抢在 React Conf 2019 之前发布了一篇文章<a href="https://juejin.im/post/5dadc6045188255a270a0f85" target="_blank" rel="noopener">《🔥这可能是最通俗的 React Fiber(时间分片) 打开方式》</a> 🤓，你想了解 Concurrent 模式, 强烈建议从这篇文章开始！</strong></p><p>CPU 密集型的优化对现有的代码保持兼容，几乎没有暴露新的API，主要的影响是废弃了一些生命周期方法，这个是众所周知的。</p><p><br></p><p><strong>2️⃣ I/O 密集型(I/O-bound)</strong></p><p>主要优化了 React 对异步的处理。主要的武器是 <code>Suspense</code> 以及 <a href="https://reactjs.org/docs/concurrent-mode-patterns.html" target="_blank" rel="noopener"><code>useTransition</code></a>:</p><ul><li><code>Suspense</code> - 新的异步数据处理方式。</li><li><code>useTransition</code> - 提供了一种预渲染的机制，React 可以在’另一个分支’中<strong>预渲染</strong>，等待数据到达，然后一次性渲染出来，减少中间的加载状态的显示和页面抖动/闪烁。</li></ul><p><br></p><p>这篇文章我就不再深入解释 Concurrent 模式是什么了，<strong>本文会介绍 Suspense，计划下一篇文章会介绍 useTranstion</strong>，敬请期待。</p><p><br><br><br></p><h2 id="启用-concurrent-模式"><a href="#启用-concurrent-模式" class="headerlink" title="启用 Concurrent 模式"></a>启用 Concurrent 模式</h2><p>Concurrent 模式目前还是实验性的，你可以通过以下命令来安装实验版本:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install react@experimental react-dom@experimental</span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">yarn add react@experimental react-dom@experimental</span><br></pre></td></tr></table></figure><p>上文说了，这是为尝鲜者准备的，尽管 API 应该不会有太大的变动, 不要用于生产环境。</p><p><br></p><p>开始 Concurrent 模式:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.createRoot(</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">).render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>);</span></span><br></pre></td></tr></table></figure><p><br></p><p>另外一个要注意的是，开启Concurrent 模式后，之前 deprecated 的生命周期方法就彻底不能用了，确保你的代码已经迁移。</p><p><br><br><br></p><h2 id="什么是-suspense"><a href="#什么是-suspense" class="headerlink" title="什么是 Suspense?"></a>什么是 Suspense?</h2><p>Suspense 这个大家应该都不陌生，在 v16.5 就已经有了这个 <code>Suspense</code> 这个API, 只不过通常利用它配合 <code>React.lazy</code> 实现代码分隔:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./OtherComponent'</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;OtherComponent /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>React.lazy 这是一次小小的尝试, Suspense 还有大用。 </p><p>如果将Suspense 翻译为中文的话是<code>等待</code>、<code>悬垂</code>、<code>悬停</code>的意思。<strong>React给出了一个更规范的定义</strong>：</p><p><strong>Suspense 不是一个‘数据获取库’, 而是一种提供给‘数据获取库’的<code>机制</code>，数据获取库通过这种机制告诉 React 数据还没有准备好，然后 React就会等待它完成后，才继续更新 UI</strong>。 简单总结一下 Suspense 是 React 提供的一种异步处理的机制, 它不是一个具体的数据请求库。<strong>它是React 提供的原生的组件异步调用原语</strong>。它是 Concurrent 模式特性集合中的重要角色。</p><p><br></p><p>现在, 我们可以更酷地使用 Suspense，相信我，马上它就会成为你手中的利剑。 有了它你可以这样请求远程数据:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Posts</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> posts = useQuery(GET_MY_POSTS)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"posts"</span>&gt;</span></span></span><br><span class="line">    &#123;posts.map(i =&gt; &lt;Post key=&#123;i.id&#125; value=&#123;i&#125;/&gt;)&#125;</span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function App() &#123;</span></span><br><span class="line">  return (&lt;div className="app"&gt;</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;Loader&gt;Posts Loading...&lt;/Loader&gt;&#125;&gt;</span><br><span class="line">      &lt;Posts /&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>加载依赖脚本:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyMap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useImportScripts(<span class="string">'//api.map.baidu.com/api?v=2.0&amp;ak=您的密钥'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">BDMap</span> /&gt;</span>)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function App() &#123;</span></span><br><span class="line">  return (&lt;div className="app"&gt;</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;Loader&gt;地图加载中...&lt;/Loader&gt;&#125;&gt;</span><br><span class="line">      &lt;MyMap /&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>仔细观察上面的代码，有两个特点：</p><ul><li>1️⃣ 我们需要 <code>Suspense</code> 来包裹这些包含异步操作的组件，并给它们提供<code>回退(fallback)</code>。在异步请求期间，会显示这个回退。</li><li>2️⃣ 上面的代码获取异步资源就跟同步调用似的。没错，有了 Suspense,  我们可以和<code>async/await</code>或者<code>Generator</code> 一样，用’同步‘的代码风格来处理异步请求</li></ul><p><br></p><p>很神奇对不对？React 是怎么做到的？</p><p><br><br><br></p><h2 id="suspense-的实现原理"><a href="#suspense-的实现原理" class="headerlink" title="Suspense 的实现原理"></a>Suspense 的实现原理</h2><p>早前就<a href="https://zhuanlan.zhihu.com/p/34210780" target="_blank" rel="noopener">有人剖析过 <code>Suspense</code> 的实现</a>，它利用了 React 的 <code>ErrorBoundary</code> 类似的机制来实现, 脑洞很大。</p><p>🤔 嗯… 如果是用 <code>ErrorBoundary</code> 的话，ErrorBoundary 可以用来捕获下级组件的异常，我们在做异步操作时，可以抛出一个异常，中断渲染工作，当我们完成异步操作时，再告诉React，我们已经准备好了，请继续渲染…</p><p>🤭这就能解释，为什么没有使用 async/await 和 Generator，却可以使用用同步的风格来处理异步操作, throw 是可以中断代码执行的…</p><p>🤔 不过这个’异常‘应该跟普通的异常区分开来，同时它应该可以通知 ErrorBoundary 异步操作已经就绪了，让它继续渲染子节点…</p><p><br></p><p>我想流程应该是这样的:</p><p><img src="/images/concurrent-mode/suspense.png" alt></p><p><br></p><p>其实，符合该场景的、现成的最好的’异常对象’是 Promise。 那就撸起袖子，实现一个:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> interface SuspenseProps &#123;</span><br><span class="line">  fallback: React.ReactNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SuspenseState &#123;</span><br><span class="line">  pending: boolean</span><br><span class="line">  error?: any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Suspense</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">SuspenseProps</span>, <span class="title">SuspenseState</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// ⚛️ 首先，记录是否处于挂载状态，因为我们不知道异步操作什么时候完成，可能在卸载之后</span></span><br><span class="line">  <span class="comment">// 组件卸载后就不能调用 setState 了</span></span><br><span class="line">  private mounted = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件状态</span></span><br><span class="line">  public state: SuspenseState = &#123;</span><br><span class="line">    <span class="comment">// ⚛️ 表示现在正阻塞在异步操作上</span></span><br><span class="line">    pending: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// ⚛️ 表示异步操作出现了问题</span></span><br><span class="line">    error: <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.mounted = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.mounted = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 使用 Error Boundary 机制捕获下级异常</span></span><br><span class="line">  public componentDidCatch(err: any) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.mounted) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚛️ 判断是否是 Promise, 如果不是则向上抛</span></span><br><span class="line">    <span class="keyword">if</span> (isPromise(err)) &#123;</span><br><span class="line">      <span class="comment">// 设置为 pending 状态</span></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">pending</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">      err.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ⚛️ 异步执行成功, 关闭pending 状态, 触发重新渲染</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123; <span class="attr">pending</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ⚛️ 异步执行失败, 我们需要妥善处理该异常，将它抛给 React</span></span><br><span class="line">        <span class="comment">// 因为处于异步回调中，在这里抛出异常无法被 React 捕获，所以我们这里先记录下来</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123; <span class="attr">error</span>: err || <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Suspense Error'</span>)&#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 在这里将 异常 抛给 React</span></span><br><span class="line">  public componentDidUpdate() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.pending &amp;&amp; <span class="keyword">this</span>.state.error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">this</span>.state.error</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public render() &#123;</span><br><span class="line">    <span class="comment">// ⚛️ 在pending 状态时渲染 fallback</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.state.pending ? <span class="keyword">this</span>.props.fallback : <span class="keyword">this</span>.props.children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实际上，Suspense不会去捕获异步操作的异常，也就是then和catch只是将pending设置为false。由下级组件自己选择如何去处理异常。这不过这里为了方便让大家理解 Suspense 的外在行为，将异常处理提到了这里。</p></blockquote><p><br></p><p>⚠️ 注意，<strong>以上代码只在<code>v16.6(不包括)</code>之前有效</strong>. 16.6正式推出 Suspense 后，Suspense 就和普通的 ErrorBoundary 隔离开来了，所以无法在 <code>componentDidCatch</code> 中捕获到 Promise. <strong>当组件中抛出 Promise 异常时，React 会向上查找最近的 Suspense 来处理它，如果找不到，React 会抛出错误</strong>。</p><p><br></p><p>上面的代码还算好理解，对吧？ 我们先不管 React 真实的实现如何，其内部显然要复杂得多，这些复杂性并不是所有开发者都需要去关心的。通过上面简单的代码，至少我们知道 Suspense 的行为是怎样的了。现在来测试一下：</p><p><br></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ComponentThatThrowError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error from component'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>throw error<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;ErrorBoundary&gt;</span><br><span class="line">        &lt;Suspense fallback=&#123;<span class="literal">null</span>&#125;&gt; &#123;<span class="comment">/* Suspense 不会捕获除Promise之外的异常，所以这里会被ErrorBoundary捕获 */</span>&#125;</span><br><span class="line">          &lt;ComponentThatThrowError /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>ErrorBoundary&gt;</span><br><span class="line">      &lt;ErrorBoundary&gt;                               &#123;<span class="comment">/* 如果异步操作失败，这个ErrorBoundary可以捕获异步操作的异常 */</span>&#125;</span><br><span class="line">        &lt;Suspense fallback=&#123;&lt;div&gt;loading...&lt;<span class="regexp">/div&gt;&#125;&gt; &#123;/</span>* 这里可以捕获ComponentThatThrowPromise 抛出的<span class="built_in">Promise</span>，并显示loading... *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">          &lt;ComponentThatThrowPromise /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>ErrorBoundary&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>上述代码展示了 Suspense 的基本用法以及异常处理。 你可以通过这个 <a href="https://codesandbox.io/s/react-custom-suspense-huff4?fontsize=14" target="_blank" rel="noopener">CodeSandbox</a> 实际运行一下这个实例.</p><p><br></p><p>现在来看下 <code>ComponentThatThrowResolvedPromise</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> throwed = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ComponentThatThrowResolvedPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!throwed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        throwed = <span class="literal">true</span></span><br><span class="line">        res()</span><br><span class="line">      &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>throw promise.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的要点是<code>throwed</code> 和 <code>throw new Promise</code>。在这个组件中，我们通过 <code>throw new Promise</code> 来中断组件渲染，Suspense会等待这个 Promise 就绪后，接着重新渲染。</p><p><strong>为了避免重新渲染时, 又抛出 Promise，导致’死循环’。这里需要使用一个’缓存’来表示异步操作已经就绪了，避免再次抛出异常</strong>。</p><p><strong>上面通过 throwed 全局变量来缓存异步操作的状态。但是对于组件来说全局状态是 Anti-Pattern，副作用会导致组件无法被复用。另外如果缓存脱离了组件的生命周期，它会变得难以控制, 我们怎么判断缓存是否有效? 这个缓存的生命周期是怎样控制？</strong>。</p><p>当然你可以使用 Redux 或者其他状态管理器来维护这些缓存，但是有时候我们都不想用状态管理器.</p><p><strong>能不能在组件内部缓存这些状态？答案是不行, 至少现在不可以</strong>, 由上面的自定义 Suspense 的实现可以解释: <strong>当 Suspense 切换到 pending 时，原有的组件树会被卸载，所有的组件状态都会丢失</strong>。</p><p>听起来挺沮丧，看来将异步操作迁移到 Suspense 还得花点心思。</p><p><br><br><br></p><h2 id="缓存-suspense-的异步操作状态"><a href="#缓存-suspense-的异步操作状态" class="headerlink" title="缓存 Suspense 的异步操作状态"></a>缓存 Suspense 的异步操作状态</h2><p>上面说了，我们无法在组件内部缓存异步操作的状态，那么现在只能放在外部了，可以考虑这些方案:</p><ul><li>全局缓存。 例如全局变量、全局状态管理器(如Redux、Mobx)</li><li>使用 Context API</li><li>由父级组件来缓存状态</li></ul><p>下面会介绍后面两种</p><p><br></p><h3 id="使用-context-api"><a href="#使用-context-api" class="headerlink" title="使用 Context API"></a>使用 Context API</h3><p>我们先用 Context API 作为例子，简单介绍如何缓存 <code>Suspense</code> 异步操作的状态。</p><p>首先定义一下异步操作的状态有哪些：</p><p><img src="/images/concurrent-mode/promise.png" alt><br><i>其实就是Promise的状态</i></p><p><br></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> enum PromiseState &#123;</span><br><span class="line">  Initial,  <span class="comment">// 初始化状态，即首次创建</span></span><br><span class="line">  Pending,  <span class="comment">// Promise 处于pending 状态</span></span><br><span class="line">  Resolved, <span class="comment">// 正常结束</span></span><br><span class="line">  Rejected, <span class="comment">// 异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们将保存在 Context 中的状态</span></span><br><span class="line"><span class="keyword">export</span> interface PromiseValue &#123;</span><br><span class="line">  state: PromiseState</span><br><span class="line">  value: any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>现在创建一个 <code>React.Context</code> 专门来缓存异步状态, 为了行文简洁，我们这个Context很简单，就是一个 <code>key-value</code> 存储：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface ContextValues &#123;</span><br><span class="line">  getResult(key: string): PromiseValue</span><br><span class="line">  resetResult(key: string): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Context = React.createContext&lt;ContextValues&gt;(&#123;&#125; <span class="keyword">as</span> any)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SimplePromiseCache: FC = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = useRef&lt;<span class="built_in">Map</span>&lt;string, PromiseValue&gt; | <span class="literal">undefined</span>&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据key获取缓存</span></span><br><span class="line">  <span class="keyword">const</span> getResult = useCallback(<span class="function">(<span class="params">key: string</span>) =&gt;</span> &#123;</span><br><span class="line">    cache.current = cache.current || <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache.current.has(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.current.get(key)!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> result = &#123; <span class="attr">state</span>: PromiseState.Initial, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line"></span><br><span class="line">    cache.current.set(key, result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据key c重置缓存</span></span><br><span class="line">  <span class="keyword">const</span> resetResult = useCallback(<span class="function">(<span class="params">key: string</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.current != <span class="literal">null</span>)  cache.current.delete(key)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> value = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> (&#123; getResult, resetResult, &#125;), [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span>&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>后面是重头戏，我们创建一个 <code>usePromise</code> Hooks来封装异步操作, 简化繁琐的步骤:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @params prom 接收一个Promise，进行异步操作</span></span><br><span class="line"><span class="comment"> * @params key 缓存键</span></span><br><span class="line"><span class="comment"> * @return 返回一个包含请求结果的对象，以及一个reset方法, 用于重置缓存，并重新请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>&lt;<span class="title">R</span>&gt;(<span class="params">prom: Promise&lt;R&gt;, key: string</span>): </span>&#123; data: R; reset: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span> &#125; &#123;</span><br><span class="line">  <span class="comment">// 用于强制重新渲染组件</span></span><br><span class="line">  <span class="keyword">const</span> [, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="comment">// 获取context值</span></span><br><span class="line">  <span class="keyword">const</span> cache = useContext(Context)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 监听key变化，并重新发起请求</span></span><br><span class="line">  useEffect(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    [key],</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ️⚛️ 异步处理</span></span><br><span class="line">  <span class="comment">// 从 Context 中取出缓存</span></span><br><span class="line">  <span class="keyword">const</span> result = cache.getResult(key)</span><br><span class="line">  <span class="keyword">switch</span> (result.state) &#123;</span><br><span class="line">    <span class="keyword">case</span> PromiseState.Initial:</span><br><span class="line">      <span class="comment">// ⚛️初始状态</span></span><br><span class="line">      result.state = PromiseState.Pending</span><br><span class="line">      result.value = prom</span><br><span class="line">      prom.then(</span><br><span class="line">        value =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (result.state === PromiseState.Pending) &#123;</span><br><span class="line">            result.state = PromiseState.Resolved</span><br><span class="line">            result.value = value</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        err =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (result.state === PromiseState.Pending) &#123;</span><br><span class="line">            result.state = PromiseState.Rejected</span><br><span class="line">            result.value = err</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      )</span><br><span class="line">      <span class="comment">// 抛出promise，并中断渲染</span></span><br><span class="line">      <span class="keyword">throw</span> prom</span><br><span class="line">    <span class="keyword">case</span> PromiseState.Pending:</span><br><span class="line">      <span class="comment">// ⚛️ 还处于请求状态，一个任务可能有多个组件触发，后面的渲染的组件可能会拿到Pending状态</span></span><br><span class="line">      <span class="keyword">throw</span> result.value</span><br><span class="line">    <span class="keyword">case</span> PromiseState.Resolved:</span><br><span class="line">      <span class="comment">// ⚛️ 已正常结束</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        data: result.value,</span><br><span class="line">        reset: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          cache.resetResult(key)</span><br><span class="line">          setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> PromiseState.Rejected:</span><br><span class="line">      <span class="comment">// ⚛️ 异常结束，抛出错误</span></span><br><span class="line">      <span class="keyword">throw</span> result.value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>上面的代码也没有特别难的地方，就是根据当前的异常请求的状态决定要抛出 Promise 还是返回异步请求的结果。</p><p>赶紧用起来, 首先用 <code>SimplePromiseCache</code> 包裹 <code>Suspense</code> 的上级组件，以便下级组件可以获取到缓存:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">SimplePromiseCache</span>&gt;</span></span></span><br><span class="line">    &lt;Suspense fallback="loading..."&gt;</span><br><span class="line">      &lt;DelayShow timeout=&#123;3000&#125;/&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">SimplePromiseCache</span>&gt;</span>)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>小试牛刀:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DelayShow</span>(<span class="params">&#123;timeout&#125;: &#123;timeout: number&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data &#125; = usePromise(</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>&lt;number&gt;(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> res(timeout), timeout)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="string">'delayShow'</span>, <span class="comment">// 缓存键</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>DelayShow: &#123;data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的运行效果如下：</p><p><img src="/images/concurrent-mode/usePromise.gif" alt></p><p><br></p><p>这一节展示了如何通过 Context API 来对异步操作进行缓存，这可能比你想象的要复杂的点，手动去管理这些缓存确实是一个棘手的问题(<strong>用什么作为缓存键，怎么判断缓存有效，怎么回收缓存</strong>)。包括 React 官方也没有给出一个完美的答案, 这个坑还是留给社区去探索吧。</p><p>除非你是库的作者，对于普通 React 开发者来说不必过早关注这些细节，相信很快会有很多 React 数据请求相关的第三方库会跟进 Suspense。</p><blockquote><p>React 官方有一个实验性的库: <a href="https://github.com/facebook/react/tree/master/packages/react-cache" target="_blank" rel="noopener">react-cache</a>, 目前采用的是 LRU 全局缓存</p></blockquote><p><br><br><br></p><h3 id="将缓存状态提取到父级"><a href="#将缓存状态提取到父级" class="headerlink" title="将缓存状态提取到父级"></a>将缓存状态提取到父级</h3><p><strong>既然无法在 Suspense 的子组件中缓存异步状态，那就提到父级组件呗，这样可以避免全局状态，不需要考虑缓存生命周期管理, 我们可以更灵活地管理这些状态，另外还可以简化下级组件逻辑</strong>。相比 Context API，我个人觉得这是一种更普适的方式。</p><p><br></p><p>So，怎么做？我们基于 <code>usePromise</code>, 再创建一个 <code>createResource</code> 函数, 它不再是一个Hooks，而是创建一个<strong>资源对象</strong>, 函数签名如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createResource</span>&lt;<span class="title">R</span>&gt;(<span class="params">prom: (</span>) =&gt; <span class="title">Promise</span>&lt;<span class="title">R</span>&gt;): <span class="title">Resource</span>&lt;<span class="title">R</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><p><code>createResource</code> 返回一个 <code>Resource</code> 对象:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Resource&lt;R&gt; &#123;</span><br><span class="line">  <span class="comment">// 读取'资源', 在Suspense包裹的下级组件中调用, 和上文的usePromise一样的效果</span></span><br><span class="line">  read(): R</span><br><span class="line">  <span class="comment">// ⚛️外加的好处，预加载</span></span><br><span class="line">  preload(): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>⚛️Resource 对象在父级组件中创建, 然后通过Props传递给下级组件，下级组件调用 <code>read()</code> 方法来读取数据。<code>对于下级组件来说 Resource 和普通的对象没什么区别，它察觉不出来这是一个异步请求</code></strong>。这就是这种 Suspense 的精妙之处!</p><p>另外由于 Resource 对象是在父级组件创建的，这有一个外加的好处: <strong>我们可以在显示下级组件之前，执行 <code>preload()</code> 预先执行异步操作</strong>。</p><p><br></p><p><code>createResource</code> 实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createResource</span>&lt;<span class="title">R</span>&gt;(<span class="params">prom: (</span>) =&gt; <span class="title">Promise</span>&lt;<span class="title">R</span>&gt;): <span class="title">Resource</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存</span></span><br><span class="line">  <span class="keyword">const</span> result: PromiseValue = &#123;</span><br><span class="line">    state: PromiseState.Initial,</span><br><span class="line">    value: prom,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">initial</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.state !== PromiseState.Initial) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    result.state = PromiseState.Pending</span><br><span class="line">    <span class="keyword">const</span> p = (result.value = result.value())</span><br><span class="line">    p.then(</span><br><span class="line">      (value: any) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.state === PromiseState.Pending) &#123;</span><br><span class="line">          result.state = PromiseState.Resolved</span><br><span class="line">          result.value = value</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      (err: any) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.state === PromiseState.Pending) &#123;</span><br><span class="line">          result.state = PromiseState.Rejected</span><br><span class="line">          result.value = err</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    read() &#123;</span><br><span class="line">      <span class="keyword">switch</span> (result.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> PromiseState.Initial:</span><br><span class="line">          <span class="comment">// ⚛️初始状态</span></span><br><span class="line">          <span class="comment">// 抛出promise，并中断渲染</span></span><br><span class="line">          <span class="keyword">throw</span> initial()</span><br><span class="line">        <span class="keyword">case</span> PromiseState.Pending:</span><br><span class="line">          <span class="comment">// ⚛️ 还处于请求状态，一个任务可能有多个组件触发，后面的渲染的组件可能会拿到Pending状态</span></span><br><span class="line">          <span class="keyword">throw</span> result.value</span><br><span class="line">        <span class="keyword">case</span> PromiseState.Resolved:</span><br><span class="line">          <span class="comment">// ⚛️ 已正常结束</span></span><br><span class="line">          <span class="keyword">return</span> result.value</span><br><span class="line">        <span class="keyword">case</span> PromiseState.Rejected:</span><br><span class="line">          <span class="comment">// ⚛️ 异常结束，抛出错误</span></span><br><span class="line">          <span class="keyword">throw</span> result.value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 预加载</span></span><br><span class="line">    preload: initial,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><code>createResource</code> 的用法也很简单, 在父组件创建 Resource，接着通过 Props 传递给子组件。 下面展示一个Tabs组件，渲染三个子Tab，因为同时只能显示一个Tab，我们可以选择预加载那些未显示的Tab, 来提升它们的打开速度:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [active, setActive] = useState(<span class="string">'tab1'</span>)</span><br><span class="line">  <span class="comment">// 创建 Resource</span></span><br><span class="line">  <span class="keyword">const</span> [resources] = useState(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    tab1: createResource(<span class="function"><span class="params">()</span> =&gt;</span> fetchPosts()),</span><br><span class="line">    tab2: createResource(<span class="function"><span class="params">()</span> =&gt;</span> fetchOrders()),</span><br><span class="line">    tab3: createResource(<span class="function"><span class="params">()</span> =&gt;</span> fetchUsers()),</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 预加载未展示的Tab数据</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(resources).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (name !== active) &#123;</span><br><span class="line">        resources[name].preload()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line">    &lt;Suspense fallback="loading..."&gt;</span><br><span class="line">      &lt;Tabs active=&#123;active&#125; onChange=&#123;setActive&#125;&gt;</span><br><span class="line">        &lt;Tab key="tab1"&gt;&lt;Posts resource=&#123;resources.tab1&#125;&gt;&lt;/Posts&gt;&lt;/Tab&gt;</span><br><span class="line">        &lt;Tab key="tab2"&gt;&lt;Orders resource=&#123;resources.tab2&#125;&gt;&lt;/Orders&gt;&lt;/Tab&gt;</span><br><span class="line">        &lt;Tab key="tab3"&gt;&lt;Users resource=&#123;resources.tab3&#125;&gt;&lt;/Users&gt;&lt;/Tab&gt;</span><br><span class="line">      &lt;/Tabs&gt;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>我们随便挑一个子组件, 看一下它的实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Posts: FC&lt;&#123;<span class="attr">resource</span>: Resource&lt;Post[]&gt;&#125;&gt; = <span class="function">(<span class="params">&#123;resource&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> posts = resource.read()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"posts"</span>&gt;</span></span></span><br><span class="line">    &#123;posts.map(i =&gt; &lt;PostSummary key=&#123;i.id&#125; value=&#123;i&#125; /&gt;)&#125;</span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>Ok, 这种方式相比 Context API 好很多了，我个人也偏向这种形式。这种模式下，因为 Resource 是由外部传入的，所以组件行为是确定的，容易被测试和复用。</p><p><br></p><p>不过两种各有应用场景:</p><ul><li>Context API 模式比较适合第三方数据请求库，比如Apollo、Relay。这种模式下，API会更加简洁、优雅。参考 <a href="https://relay.dev/docs/en/experimental/api-reference#uselazyloadquery" target="_blank" rel="noopener">Relay 的 API</a></li><li>createResource 模式则更适合普通开发者封装自己的异步操作。</li></ul><p><br><br><br></p><h2 id="并发发起请求"><a href="#并发发起请求" class="headerlink" title="并发发起请求"></a>并发发起请求</h2><p><img src="/images/concurrent-mode/twitter.png" alt></p><p><br></p><p>如上图，现实项目中经常会有这种场景，一个复杂的界面数据可能来源于多个接口，例如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户信息页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfilePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先拿到用户信息</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fetchUser().then(<span class="function"><span class="params">u</span> =&gt;</span> setUser(u));</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (user === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Loading profile...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;user.name&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ProfileTimeline /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 用户时间线</span><br><span class="line"> *<span class="regexp">/ </span></span><br><span class="line"><span class="regexp">function ProfileTimeline() &#123;</span></span><br><span class="line"><span class="regexp">  const [posts, setPosts] = useState(null);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    fetchPosts().then(p =&gt; setPosts(p));</span></span><br><span class="line"><span class="regexp">  &#125;, []);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  if (posts === null) &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;h2&gt;Loading posts...&lt;/</span>h2&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;posts.map(<span class="function"><span class="params">post</span> =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;post.id&#125;&gt;&#123;post.text&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>上面的代码示例来源于官方文档。上面代码 <code>fetchUser</code> 和 <code>fetchPosts</code> 是串行加载的，我们想让页面尽快的加载出来, 解决这个问题有两个方案：</p><ul><li>1️⃣ 将 fetchPosts 提到上级, 使用 <code>Promise.all</code> 并发加载</li><li>2️⃣ 将两者抽取成独立的组件，变成兄弟关系而不是父子关系. 这样可以被并发渲染，从而并发发起请求</li></ul><p><br></p><p>首先来看一下 1️⃣:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchProfileData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 promise all 并发加载</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">    fetchUser(),</span><br><span class="line">    fetchPosts()</span><br><span class="line">  ]).then(<span class="function">(<span class="params">[user, posts]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;user, posts&#125;;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = fetchProfileData();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfilePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> [posts, setPosts] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    promise.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      setUser(data.user);</span><br><span class="line">      setPosts(data.posts);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (user === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Loading profile...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;user.name&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &#123;/</span>* ProfileTimeline 变成了纯组件，不包含业务请求 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">      &lt;ProfileTimeline posts=&#123;posts&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>看起来不错，然后这个方式也存在硬伤:</p><ul><li>① 异步请求都要上提，然后使用 <code>Promise.all</code> 包裹，我觉得好麻烦, 复杂页面怎么办？</li><li>② 现在加载时间取决于 Promise.all 中执行最长的操作，说好的尽快渲染出来呢？fetchPosts 可能会加载很长，而 fetchUser 应该很快完成了，如果 fetchUser 先执行完，至少应该让用户先看到用户信息。</li></ul><p><br></p><p>1️⃣方案不是特别好，来看一下2️⃣方案:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfilePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"profile-page"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ProfileDetails</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ProfileTimeline</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>2️⃣方案是没有 Suspense 之前最好的方式，ProfileDetails 负责加载用户信息，ProfileTimeline 负责加载时间线，两者并发执行，互不干扰。</p><p>但是它也是有缺点：页面加载是会有两个<code>加载指示符</code>, 能不能合并？有可能 ProfileTimeline 先完成了，这时候 ProfileDetails 还在转圈，页面会很怪…</p><p><br></p><p>现在有请方案 3️⃣: <code>Suspense</code> 🎉</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resource = fetchProfileData();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfilePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;h1&gt;Loading profile...&lt;<span class="regexp">/h1&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ProfileDetails /</span>&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;h1&gt;Loading posts...&lt;<span class="regexp">/h1&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ProfileTimeline /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfileDetails</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = resource.user.read();</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;user.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfileTimeline</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> posts = resource.posts.read();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;posts.map(<span class="function"><span class="params">post</span> =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;post.id&#125;&gt;&#123;post.text&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p><br></p><p>当 React 渲染 ProfilePage 时, 它会返回 ProfileDetails 和 ProfileTimeline。</p><p>首先渲染 ProfileDetails 这时候资源未加载完毕，抛出 promise 异常，中断 ProfileDetails 的渲染。</p><p>接着 React 尝试渲染 ProfileTimeline, 同样抛出promise异常。</p><p>最后 React 找到 ProfileDetails 最近的Suspense，显示 Loading Profile…</p><p>和方案2️⃣一样，Suspense 支持并发发起请求，另外它解决了方案 2️⃣ 的一些缺陷: 加载指示符只有一个，而且如果 ProfileTimeline 率先完成，也不会显示出来。</p><p>不止于此，下文会介绍更为灵活的 Suspense 加载状态的显示策略。</p><p><br><br><br></p><h2 id="处理竞态"><a href="#处理竞态" class="headerlink" title="处理竞态"></a>处理竞态</h2><p><strong>就算 Javascript 是单线程的, 也可能需要处理竞争状态，主要是因为异步操作的时序是无法被保证的</strong>。</p><p>少卖关子，讲个实例。有这样一个组件，它依赖外部传递进来的 id 来异步获取数据:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">&#123;id&#125;: &#123;id: string&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState&lt;User|<span class="literal">undefined</span>&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 监听id变化并发起请求</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fetchUserInfo().then(<span class="function"><span class="params">user</span> =&gt;</span> setUser(user))</span><br><span class="line">  &#125;, [id])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> user == <span class="literal">null</span> ? <span class="xml"><span class="tag">&lt;<span class="name">Loading</span> /&gt;</span> : renderUser(user)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>上面的代码有什么问题呢？假设id变化了多次，这里会发起多个请求，但是这些请求完成的顺序没办法保证，这就会导致竞态，先发起的请求可能最后才完成，这就导致页面呈现错误的数据。</p><p><br></p><p>怎么解决？也比较好解决，利用类似<strong>乐观锁</strong>的机制。我们可以保存本次请求的id，如果请求结束时 id 不一致，就说明已经有新的请求发起了:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">&#123;id&#125;: &#123;id: string&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = setState&lt;User|<span class="literal">undefined</span>&gt;()</span><br><span class="line">  <span class="keyword">const</span> currentId = useRef&lt;string&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 监听id变化并发起请求</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    currentId.current = id</span><br><span class="line">    fetchUserInfo().then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// id 不一致，说明已经有新的请求发起了, 放弃</span></span><br><span class="line">      <span class="keyword">if</span> (id !== currentId.current) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      setUser(user)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [id])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> user == <span class="literal">null</span> ? <span class="xml"><span class="tag">&lt;<span class="name">Loading</span> /&gt;</span> : renderUser(user)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>Suspense 下面不存在竞态问题，上面的代码用 Suspense 实现如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">&#123;resource&#125;: &#123;resource: Resource&lt;User&gt;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = resource.read()</span><br><span class="line">  <span class="keyword">return</span> renderUser(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>我靠, 这么简洁！传递给 UserInfo 的就是一个简单的对象, 没有竞态. </p><p>那它的上级组件呢?</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createUserResource</span>(<span class="params">id: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    info: createResource(<span class="function"><span class="params">()</span> =&gt;</span> fecthUserInfo(id)),</span><br><span class="line">    timeline: createResource(<span class="function"><span class="params">()</span> =&gt;</span> fecthTimeline(id)),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserPage</span>(<span class="params">&#123;id&#125;: &#123;id: string&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [resource, setResource] = useState(<span class="function"><span class="params">()</span> =&gt;</span> createUserResource(id))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 将id的监听迁移到了这里</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 重新设置resource</span></span><br><span class="line">    setResource(createUserResource(id))</span><br><span class="line">  &#125;, [id])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"user-page"</span>&gt;</span></span></span><br><span class="line">    &lt;Suspense loading="Loading User..."&gt;</span><br><span class="line">      &lt;UserInfo resource=&#123;resource.info&#125; /&gt;</span><br><span class="line">      &lt;Timeline resource=&#123;resource.timeline&#125; /&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">  &lt;/div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>异步请求被转换成了’资源对象’，在这里只不过是一个普通的对象, 通过 Props 传递, 完美解决了异步请求的竞态问题…</p><p><br></p><blockquote><p><strong>另外 Suspense 还解决一个问题</strong>：在执行完异步操作后，我们的页面可能已经切换了，这时候通过 setState 设置组件状态，React就会抛出异常: <code>Can&#39;t perform a React state update on an unmounted component.</code>, 现在这个问题自然也解决了</p></blockquote><p><br><br><br></p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>如果异步请求异常了怎么解决？ 我们在上文 Suspense 实现原理一节已经说了，如果异步请求失败，React 会抛出异常，我们可以通过 ErrorBoundary 机制将其捕获。</p><p>我们写一个高阶组件来简化 Suspense 和 异常处理的过程:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">sup</span>&lt;<span class="title">P</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fallback: NonNullable&lt;React.ReactNode&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  catcher: (err: any</span>) =&gt; <span class="title">NonNullable</span>&lt;<span class="title">React</span>.<span class="title">ReactNode</span>&gt;,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">Comp: React.ComponentType&lt;P&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">    interface State &#123;</span><br><span class="line">      error?: any</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Sup</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">P</span>, <span class="title">State</span>&gt; </span>&#123;</span><br><span class="line">      state: State = &#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 捕获异常</span></span><br><span class="line">      <span class="keyword">static</span> getDerivedStateFromError(error: any) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; error &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          &lt;Suspense fallback=&#123;fallback&#125;&gt;</span><br><span class="line">            &#123;<span class="keyword">this</span>.state.error ? catcher(<span class="keyword">this</span>.state.error) : <span class="xml"><span class="tag">&lt;<span class="name">Comp</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Sup</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>用起来:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UserInfo.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UserInfo: FC&lt;UserInfoProps&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sup(</span><br><span class="line">  &lt;Loading text=<span class="string">"用户加载中..."</span>/&gt;,</span><br><span class="line">  (err) =&gt; <span class="xml"><span class="tag">&lt;<span class="name">ErrorMessage</span> <span class="attr">error</span>=<span class="string">&#123;err&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">)(UserInfo)</span></span><br></pre></td></tr></table></figure><p><br></p><p>减少了一些样板代码，还算比较简洁吧?。</p><p><br><br><br></p><h2 id="suspense-编排"><a href="#suspense-编排" class="headerlink" title="Suspense 编排"></a>Suspense 编排</h2><p>如果页面上有很多 Suspense, 那么多个圈在转，用户体验并不好。</p><p>但是我们又不好直接将它们合并，因为每一块加载优先级、生命周期都不一样，强行绑到一个 Suspense 也不好。例如:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserPage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">"loading..."</span>&gt;</span></span></span><br><span class="line">    &lt;UserInfo resource=&#123;infoResource&#125; /&gt;</span><br><span class="line">    &lt;UserPost resource=&#123;postResource&#125; /&gt;</span><br><span class="line">  &lt;/Suspense&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设 UserPost 需要进行分页，每次点击下一页都会导致整个 <code>UserPage</code> loading… 这肯定无法接受…</p><p><br></p><p><strong>因此 Concurrent 模式引入了一个新的API <code>SuspenseList</code>, 用来对多个 Suspense 的加载状态进行编排。我们可以根据实际的场景选择加载状态的显示策略</strong>。例如</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Page</span>(<span class="params">&#123; resource &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;SuspenseList revealOrder=<span class="string">"forwards"</span>&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;h2&gt;Loading Foo...&lt;<span class="regexp">/h2&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Foo resource=&#123;resource&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Suspense fallback=&#123;&lt;h2&gt;Loading Bar...&lt;/</span>h2&gt;&#125;&gt;</span><br><span class="line">        &lt;Bar resource=&#123;resource&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>SuspenseList&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>假设 <code>Foo</code> 加载时间是 <code>5s</code>，而 <code>Bar</code> 加载完成时间是 <code>2s</code>。SuspenseList 的各种编排组合的效果如下:</p><p><img src="/images/concurrent-mode/suspense-list.gif" alt><br><i>可以通过这个 <a href="https://codesandbox.io/s/react-suspenselist-sk3rj?fontsize=14" target="_blank" rel="noopener">CodeSandbox 示例</a> 体验 </i></p><p><br></p><p><code>revealOrder</code> 表示显示的顺序，它目前有三个可选值: <code>forwards</code>, <code>backwards</code>, <code>together</code></p><ul><li><code>forwards</code> - 由前到后显示。也就说前面的没有加载完成，后面的也不会显示. 即使后面的 Suspense 提前完成异步操作，也需要等待前面的执行完成</li><li><code>backwards</code> - 和forwards相反, 由后到前依次显示.</li><li><code>together</code> - 等所有Suspense 加载完成后一起显示</li></ul><p><br></p><p>除此之外 <code>SuspenseList</code> 还有另外一个属性 <code>tail</code>, 用来控制是否要折叠这些 Suspense，它有三个值 <code>默认值</code>, <code>collapsed</code>, <code>hidden</code></p><ul><li>默认值 - 全部显示</li><li><code>collapsed</code> - 折叠，只显示第一个正在加载的Suspense</li><li><code>hidden</code> - 不显示任何加载状态</li></ul><p><br></p><p>另外 SuspenseList 是可组合的，SuspenseList 下级可以包含其他 SuspenseList.</p><p><br><br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文的主角是 <code>Suspense</code>, 如果说 <code>React Hooks</code> 是React提供的逻辑复用原语，ErrorBoundary 是异常捕获原语，那么 Suspense 将是 React 的异步操作原语。通过Suspense + ErrorBoundary，简化了手动去处理加载状态和异常状态。</p><p>Suspense 可以理解为中断渲染、或者暂停渲染的意思。我们简单探讨了 Suspense 的实现原理，它不过是利用了 ErrorBoundary 的异常抛出机制来中断渲染，配合 Suspense 组件在异步操作完结后恢复组件的渲染。</p><p>不过组件在重新渲染(重入)时，所有状态都丢失了，无法在组件本地保存异步处理的状态，所以得向外求，将异步处理的状态缓存在全局或者上级组件。</p><p>有人会说 React 已经不纯了、不够函数式了。我不敢擅作评论，我不是虔诚的函数式编程爱好者，我觉得只要能更好的解决问题，哪种编程范式无所谓。自从 React Hooks 出来后，就没有所谓的纯函数式组件了。对于 Suspense 来说，createResource 模式也可以让一个组件的行为变得可被预测和测试。关于其他的痛点，还是要进一步实践和验证。</p><p>Suspense 让人非常兴奋，它不仅解决了一些以往异步处理的问题，还带来了新的开发方式。心急的同学可以在自己的实验项目中尝试它。</p><p><br><br><br></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://reactjs.org/docs/concurrent-mode-suspense.html" target="_blank" rel="noopener">Suspense for Data Fetching (Experimental)</a></li><li><a href="https://www.youtube.com/watch?v=ByBPyMBTzM0" target="_blank" rel="noopener">Concurrent Rendering in React - Andrew Clark and Brian Vaughn - React Conf 2018</a></li><li><a href="https://zhuanlan.zhihu.com/p/34210780" target="_blank" rel="noopener">React：Suspense的实现与探讨</a></li><li><a href="https://github.com/facebook/react/blob/master/packages/react-cache/src/ReactCache.js" target="_blank" rel="noopener">react-cache</a></li></ul><p><br></p><p><img src="/images/sponsor.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;2019.10.24&lt;/strong&gt;, 在 &lt;a href=&quot;https://www.youtube.com/channel/UCz5vTaEhvh7dOHEyd1efcaQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React Co
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>这可能是最通俗的 React Fiber 打开方式</title>
    <link href="https://bobi.ink/2019/10/18/react-fiber/"/>
    <id>https://bobi.ink/2019/10/18/react-fiber/</id>
    <published>2019-10-17T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.330Z</updated>
    
    <content type="html"><![CDATA[<p>写一篇关于 React Fiber 的文章， 这个 Flag 立了很久，这也是今年的目标之一. 最近的在掘金的文章获得很多关注和鼓励，给了我很多动力，所以下定决心好好把它写出来。 我会以最通俗的方式将它讲透, 因此这算是一篇科普式的文章。不管你是使用React、还是Vue，这里面的思想值得学习学习!</p><p><br></p><p><img src="/images/react-fiber/react-conf.png" alt></p><p><br></p><p>一年一度的 React 春晚: <a href="https://conf.reactjs.org/schedule.html" target="_blank" rel="noopener">React Conf</a> 即将到来，不知道今年会不会有什么惊喜，去年是 React Hooks，前年是 React Fiber…<br>我得赶在 React Conf 之前发布这篇文章:</p><ul><li><p>😲 <strong>React Fiber 已经出来这么久了， 这文章是老酒装新瓶吧</strong>? <em>对于我来说，通过这篇文章我重新认识了 React Fiber，它不是一个新东西, 它也是老酒装新瓶，不信你就看吧…</em></p></li><li><p>🆕 <strong>React Fiber 不是一个新的东西，但在前端领域是第一次广为认知的应用</strong>。</p></li><li><p>😦 <strong>了解它有啥用</strong>? <em>React Fiber 代码很复杂，门槛很高，你不了解它，后面 React 新出的 Killer Feature 你可能就更不能理解了</em></p></li><li><p>🤥 <strong>我不是升到React v16了吗? 没什么出奇的啊</strong>? <em>真正要体会到 React Fiber 重构效果，可能下个月、可能要等到 v17。v16 只是一个过渡版本，也就是说，现在的React 还是同步渲染的，一直在跳票、不是说今年第二季度就出来了吗</em>？</p></li><li><p>😁 <strong>不好意思，一不小心又写得有点长，你就当小说看吧, 代码都是伪代码</strong></p></li></ul><p><br></p><p><strong>以下文章大纲</strong></p><ul><li><a href="#单处理进程调度-fiber-不是一个新的东西">单处理进程调度: Fiber 不是一个新的东西</a></li><li><a href="#类比浏览器javascript执行环境">类比浏览器JavaScript执行环境</a></li><li><a href="#何为-fiber">何为 Fiber</a><ul><li><a href="#1-一种流程控制原语">1. 一种流程控制原语</a></li><li><a href="#2-一个执行单元">2. 一个执行单元</a></li></ul></li><li><a href="#react-的fiber改造">React 的Fiber改造</a><ul><li><a href="#1-数据结构的调整">1. 数据结构的调整</a></li><li><a href="#2-两个阶段的拆分">2. 两个阶段的拆分</a></li><li><a href="#3-reconcilation">3. Reconcilation</a></li><li><a href="#4-双缓冲">4. 双缓冲</a></li><li><a href="#5-副作用的收集和提交">5. 副作用的收集和提交</a></li></ul></li><li><a href="#⚠️-未展开部分-🚧----中断和恢复">⚠️ 未展开部分 🚧 – 中断和恢复</a></li><li><a href="#凌波微步">凌波微步</a></li><li><a href="#站在巨人的肩膀上">站在巨人的肩膀上</a></li></ul><p><br><br><br></p><h2 id="单处理进程调度-fiber-不是一个新的东西"><a href="#单处理进程调度-fiber-不是一个新的东西" class="headerlink" title="单处理进程调度: Fiber 不是一个新的东西"></a>单处理进程调度: Fiber 不是一个新的东西</h2><p><br></p><p><img src="/images/react-fiber/dos.jpg" alt><br><i>这个黑乎乎的界面应该就是微软的 <code>DOS</code> 操作系统</i></p><p><br></p><p>微软 <a href="https://zh.wikipedia.org/zh-cn/DOS" target="_blank" rel="noopener"><code>DOS</code></a> 是一个<code>单任务操作系统</code>, 也称为’单工操作系统‘. 这种操作系统同一个时间只允许运行一个程序. <a href="https://www.zhihu.com/people/s.invalid" target="_blank" rel="noopener">invalid s</a>在<a href="https://www.zhihu.com/question/319595914/answer/683541635" target="_blank" rel="noopener">《在没有GUI的时代(只有一个文本界面），人们是怎么运行多个程序的？》</a> 的回答中将其称为: ‘<strong>一种压根没有任务调度的“残疾”操作系统</strong>‘.</p><p>在这种系统中，你想执行多个任务，只能等待前一个进程退出，然后再载入一个新的进程。</p><p>直到 Windows 3.x，它才有了真正意义的进程调度器，实现了多进程并发执行。</p><blockquote><p>注意并发和并行不是同一个概念。</p></blockquote><p><br></p><p>现代操作系统都是<strong>多任务操作系统</strong>. 进程的调度策略如果按照CPU核心数来划分，可以分为<strong>单处理器调度</strong>和<strong>多处理器调度</strong>。本文只关注的是单处理器调度，因为它可以类比JavaScript的运行机制。</p><p><strong>🔴说白了，为了实现进程的并发，操作系统会按照一定的调度策略，将CPU的执行权分配给多个进程，多个进程都有被执行的机会，让它们交替执行，形成一种“同时在运行”假象, 因为CPU速度太快，人类根本感觉不到。实际上在单核的物理环境下同时只能有一个程序在运行</strong>。</p><brk><p><img src="/images/react-fiber/longzhu.jpg" alt></p><p><br></p><p>这让我想起了“龙珠”中的分身术(小时候看过，说错了别喷)，实质上是一个人，只不过是他运动速度太快，看起来就像分身了. 这就是所谓的<strong>并发(Concurrent)</strong>(单处理器)。</p><p><br></p><p><img src="/images/react-fiber/naruto.jpg" alt></p><p><br></p><p>相比而言, 火影忍者中的分身术，是物理存在的，他们可以真正实现同时处理多个任务，这就是<strong>并行</strong>(严格地讲这是<code>Master-Slave</code>架构，分身虽然物理存在，但应该没有独立的意志)。</p><p>所以说<strong>🔴并行可以是并发，而并发不一定是并行，两种不能划等号, 并行一般需要物理层面的支持</strong>。 关于并发和并行，Go 之父 Rob Pike 有一个非常著名的演讲<a href="https://blog.golang.org/concurrency-is-not-parallelism" target="_blank" rel="noopener">Concurrency is not parallelism</a></p><p><br></p><p>扯远了，接下来进程怎么调度就是教科书的内容了。如果读者在大学认真学过<strong>操作系统原理</strong>, 你可以很快理解以下几种单处理器进程<strong>调度策略</strong>(我就随便科普一下，算送的, 如果你很熟悉这块，可以跳过)：</p><p><br></p><p><strong>0️⃣ 先到先得(First-Come-First-Served, FCFS)</strong></p><p>这是最简单的调度策略, 简单说就是<strong>没有调度</strong>。谁先来谁就先执行，执行完毕后就执行下一个。不过如果中间某些进程因为I/O阻塞了，这些进程会挂起移回就绪队列(说白了就是重新排队).</p><p><code>FCFS</code> 上面 <code>DOS</code> 的单任务操作系统没有太大的区别。所以非常好理解，因为生活中到处是这样的例子:。</p><ul><li><p><strong>FCFS 对<code>短进程</code>不利</strong>。 短进程即执行时间非常短的进程，可以用饭堂排队来比喻: <em>在饭堂排队打饭的时候，最烦那些一个人打包好好几份的人，这些人就像<code>长进程</code>一样，霸占着CPU资源，后面排队只打一份的人会觉得很吃亏，打一份的人会觉得他们优先级应该更高，毕竟他们花的时间很短，反正你打包那么多份再等一会也是可以的，何必让后面那么多人等这么久…</em></p></li><li><p><strong>FCFS 对<code>I/O密集</code>不利</strong>。I/O密集型进程(这里特指同步I/O)在进行I/O操作时，会阻塞休眠，这会导致进程重新被放入就绪队列，等待下一次被宠幸。 可以类比ZF部门办业务: <em>假设 CPU 一个窗口、I/O 一个窗口。在CPU窗口好不容易排到你了，这时候发现一个不符合条件或者漏办了, 需要去I/O搞一下，Ok 去 I/O窗口排队，I/O执行完了，到CPU窗口又得重新排队。对于这些丢三落四的人很不公平…</em></p></li></ul><p>所以 FCFS 这种原始的策略在单处理器进程调度中并不受欢迎。</p><p><br></p><p><strong>1️⃣ 轮转</strong></p><p>这是一种基于时钟的<strong>抢占策略</strong>，这也是抢占策略中最简单的一种: <strong>公平地给每一个进程一定的执行时间，当时间消耗完毕或阻塞，操作系统就会调度其他进程，将执行权抢占过来</strong>。</p><blockquote><p><strong>决策模式</strong>: <code>抢占策略</code>相对应的有<code>非抢占策略</code>，非抢占策略指的是让进程运行直到结束、阻塞(如I/O或睡眠)、或者主动让出控制权；抢占策略支持中断正在运行的进程，将主动权掌握在操作系统这里，不过通常开销会比较大。</p></blockquote><p>这种调度策略的要点是<strong>确定合适的时间片长度</strong>: 太长了，长进程霸占太久资源，其他进程会得不到响应(等待执行时间过长)，这时候就跟上述的 <code>FCFS</code> 没什么区别了;  太短了也不好，因为进程抢占和切换都是需要成本的, 而且成本不低，时间片太短，时间可能都浪费在上下文切换上了，导致进程干不了什么实事。</p><p>因此<strong>时间片的长度最好符合大部分进程完成一次典型交互所需的时间</strong>.</p><p>轮转策略非常容易理解，只不过确定时间片长度需要伤点脑筋；另外和<code>FCFS</code>一样，轮转策略对I/O进程还是不公平。</p><p><br></p><p><strong>2️⃣ 最短进程优先(Shortest Process Next, SPN)</strong></p><p>上面说了<code>先到先得</code>策略对<code>短进程</code>不公平，<code>最短进程优先</code>索性就让’最短’的进程优先执行，也就是说: <strong>按照进程的预估执行时间对进程进行优先级排序，先执行完短进程，后执行长进程。这是一种非抢占策略</strong>。</p><p>这样可以让短进程能得到较快的响应。但是怎么获取或者<strong>评估进程执行时间</strong>呢？一是让程序的提供者提供，这不太靠谱；二是由操作系统来收集进程运行数据，并对它们进程统计分析。例如最简单的是计算它们的平均运行时间。不管怎么说都比上面两种策略要复杂一点。</p><p><code>SPN</code> 的缺陷是: 如果系统有大量的短进程，那么长进程可能会饥饿得不到响应。</p><p>另外因为它不是抢占性策略, 尽管现在短进程可以得到更多的执行机会，但是还是没有解决 <code>FCFS</code> 的问题: 一旦长进程得到CPU资源，得等它执行完，导致后面的进程得不到响应。</p><p><br></p><p><strong>3️⃣ 最短剩余时间(Shortest Remaining Time, SRT)</strong></p><p><strong>SRT 进一步优化了SPN，增加了抢占机制</strong>。在 SPN 的基础上，当一个进程添加到就绪队列时，操作系统会比较<em>刚添加的新进程</em>和<em>当前正在执行的老进程</em>的‘剩余时间’，如果新进程剩余时间更短，新进程就会抢占老进程。</p><p>相比轮转的抢占，SRT 没有中断处理的开销。但是在 SPN 的基础上，操作系统需要记录进程的历史执行时间，这是新增的开销。<strong>另外长进程饥饿问题还是没有解决</strong>。</p><p><br></p><p><strong>4️⃣ 最高响应比优先(HRRN)</strong></p><p><strong>为了解决长进程饥饿问题，同时提高进程的响应速率</strong>。还有一种<code>最高响应比优先的</code>策略，首先了解什么是响应比:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">响应比 = （等待执行时间 + 进程执行时间） / 进程执行时间</span><br></pre></td></tr></table></figure><p><strong>这种策略会选择响应比最高的进程优先执行</strong>：</p><ul><li>对于短进程来说，因为执行时间很短，分母很小，所以响应比比较高，会被优先执行</li><li>对于长进程来说，执行时间长，一开始响应比小，但是随着等待时间增长，它的优先级会越来越高，最终可以被执行</li></ul><p><br></p><p><strong>5️⃣ 反馈法</strong></p><p>SPN、SRT、HRRN都需要对进程时间进行评估和统计，实现比较复杂且需要一定开销。而反馈法采取的是<strong>事后反馈</strong>的方式。这种策略下: <strong>每个进程一开始都有相同的优先级，每次被抢占(需要配合其他抢占策略使用，如轮转)，优先级就会降低一级。因此通常它会根据优先级划分多个队列</strong>。</p><p>举个例子: </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">队列1</span><br><span class="line">队列2</span><br><span class="line">...</span><br><span class="line">队列N</span><br></pre></td></tr></table></figure><p>新增的任务会推入<code>队列1</code>，<code>队列1</code>会按照<code>轮转策略</code>以一个时间片为单位进行调度。短进程可以很快得到响应，而对于长进程可能一个时间片处理不完，就会被抢占，放入<code>队列2</code>。</p><p><code>队列2</code>会在<code>队列1</code>任务清空后被执行，有时候低优先级队列可能会等待很久才被执行，所以一般会给予一定的补偿，例如增加执行时间，所以<code>队列2</code>的轮转时间片长度是2。</p><p>反馈法仍然可能导致长进程饥饿，所以操作系统可以统计长进程的等待时间，当等待时间超过一定的阈值，可以选择提高它们的优先级。</p><p><br><br><br></p><p><img src="/images/react-fiber/process-schedule.png" alt></p><p>没有一种调度策略是万能的, 它需要考虑很多因素:</p><ul><li>响应速率。进程等待被执行的时间</li><li>公平性。兼顾短进程、长进程、I/O进程</li></ul><p>这两者在某些情况下是对立的，提高了响应，可能会减低公平性，导致饥饿。短进程、长进程、I/O进程之间要取得平衡也非常难。</p><p>上面这些知识对本文来说已经足够了，现实世界操作系统的进程调度算法比教科书上说的要复杂的多，有兴趣读者可以去研究一下 <code>Linux</code> 相关的进程调度算法，这方面的资料也非常多, 例如<a href="https://blog.csdn.net/gatieme/article/details/51456569" target="_blank" rel="noopener">《Linux进程调度策略的发展和演变》</a>。</p><p><br><br><br></p><h2 id="类比浏览器javascript执行环境"><a href="#类比浏览器javascript执行环境" class="headerlink" title="类比浏览器JavaScript执行环境"></a>类比浏览器JavaScript执行环境</h2><p><br></p><p><img src="/images/react-fiber/singleroad.jpg" alt><br><i>JavaScript 就像单行道</i></p><p><br></p><p>JavaScript 是<a href="https://juejin.im/post/5a6547d0f265da3e283a1df7" target="_blank" rel="noopener">单线程运行</a>的，而且在浏览器环境屁事非常多，它要负责页面的JS解析和执行、绘制、事件处理、静态资源加载和处理, 这些任务可以类比上面’进程‘。</p><blockquote><p>这里特指Javascript 引擎是单线程运行的。 严格来说，Javascript 引擎和页面渲染引擎在同一个渲染线程，GUI 渲染和 Javascript执行 两者是互斥的. 另外异步 I/O 操作底层实际上可能是多线程的在驱动。</p></blockquote><p><img src="/images/react-fiber/frame-full.jpg" alt><br><i>图片来源: <a href="https://developers.google.com/web/fundamentals/performance/rendering" target="_blank" rel="noopener">Rendering Performance</a></i></p><p><strong>它只是一个’JavaScript’，同时只能做一件事情，这个和 <code>DOS</code> 的单任务操作系统一样的，事情只能一件一件的干。要是前面有一个傻叉任务长期霸占CPU，后面什么事情都干不了，浏览器会呈现卡死的状态，这样的用户体验就会非常差</strong>。</p><p><br></p><p><strong>对于’前端框架‘来说，解决这种问题有三个方向</strong>:</p><ul><li>1️⃣ 优化每个任务，让它有多快就多快。挤压CPU运算量</li><li>2️⃣ 快速响应用户，让用户觉得够快，不能阻塞用户的交互</li><li>3️⃣ 尝试 Worker 多线程</li></ul><p>Vue 选择的是第1️⃣, 因为对于Vue来说，使用<code>模板</code>让它有了很多优化的空间，配合响应式机制可以让Vue可以精确地进行节点更新, 读者可以去看一下<a href="https://www.yuque.com/vueconf/2019/gwn1z0" target="_blank" rel="noopener">今年Vue Conf 尤雨溪的演讲</a>，非常棒!；而 React 选择了2️⃣ 。对于Worker 多线程渲染方案也有人尝试，要保证状态和视图的一致性相当麻烦。</p><p><br></p><p>React 为什么要引入 Fiber 架构？ 看看下面的火焰图，这是React V15 下面的一个列表渲染资源消耗情况。整个渲染花费了130ms, <strong>🔴在这里面 React 会递归比对VirtualDOM树，找出需要变动的节点，然后同步更新它们, 一气呵成。这个过程 React 称为 <code>Reconcilation</code>(中文可以译为<code>协调</code>)</strong>.</p><p><br></p><p><img src="/images/react-fiber/perf.png" alt></p><p><br></p><p>在 Reconcilation 期间，React 会霸占着浏览器资源，一则会导致用户触发的事件得不到响应, 二则会导致掉帧，用户可以感知到这些卡顿。</p><p>这样说，你可能没办法体会到，通过下面两个图片来体会一下(<em>图片来源于：<a href="https://twitter.com/dan_abramov" target="_blank" rel="noopener">Dan Abramov</a> 的 <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" target="_blank" rel="noopener">Beyond React 16</a> 演讲, 推荐看一下👍. 另外非常感谢<a href="https://www.zhihu.com/people/BlackGanglion/activities" target="_blank" rel="noopener">淡苍</a> 将一个<a href="https://codesandbox.io/s/koyz664q35" target="_blank" rel="noopener">类似的DEMO 分享在了 CodeSandbox</a>上🎉，大家自行体验</em>):</p><p><br></p><p>同步模式下的 React:</p><p><img src="/images/react-fiber/sync-mode.gif" alt></p><p><br></p><p>优化后的 <code>Concurrent</code> 模式下的 React:</p><p><img src="/images/react-fiber/concurrent-mode.gif" alt></p><p><br></p><p>React 的 Reconcilation 是CPU密集型的操作, 它就相当于我们上面说的’长进程‘。所以初衷和进程调度一样，我们要让高优先级的进程或者短进程优先运行，不能让长进程长期霸占资源。</p><p>所以React 是怎么优化的？ 划重点， <strong>🔴为了给用户制造一种应用很快的’假象’，我们不能让一个程序长期霸占着资源. 你可以将浏览器的渲染、布局、绘制、资源加载(例如HTML解析)、事件响应、脚本执行视作操作系统的’进程’，我们需要通过某些调度策略合理地分配CPU资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率</strong>。</p><p><br></p><p><strong>🔴所以 React 通过Fiber 架构，让自己的Reconcilation 过程变成可被中断。 ‘适时’地让出CPU执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处</strong>:</p><ul><li>与其一次性操作大量 DOM 节点相比, 分批延时对DOM进行操作，可以得到更好的用户体验。这个在<a href="https://juejin.im/post/5d76f469f265da039a28aff7#heading-1" target="_blank" rel="noopener">《「前端进阶」高性能渲染十万条数据(时间分片)》</a> 以及司徒正美的<a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener">《React Fiber架构》</a> 都做了相关实验</li><li>司徒正美在<a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener">《React Fiber架构》</a> 也提到：<strong>🔴给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对reflow进行修正</strong>.</li></ul><p><br></p><p>这就是为什么React 需要 Fiber 😏。</p><p><br></p><h2 id="何为-fiber"><a href="#何为-fiber" class="headerlink" title="何为 Fiber"></a>何为 Fiber</h2><p>对于 React 来说，Fiber 可以从两个角度理解:</p><p><br></p><h3 id="1-一种流程控制原语"><a href="#1-一种流程控制原语" class="headerlink" title="1. 一种流程控制原语"></a>1. 一种流程控制原语</h3><p>Fiber 也称<a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272" target="_blank" rel="noopener">协程</a>、或者纤程。 笔者第一次接触这个概念是在学习 Ruby 的时候，Ruby就将协程称为 Fiber。后来发现很多语言都有类似的机制，例如Lua 的<code>Coroutine</code>, 还有前端开发者比较熟悉的 <code>ES6</code> 新增的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="noopener"><code>Generator</code></a>。</p><blockquote><p>本文不纠结 <a href="https://stackoverflow.com/questions/3324643/processes-threads-green-threads-protothreads-fibers-coroutines-whats-the/16375591#16375591" target="_blank" rel="noopener">Processes, threads, green threads, protothreads, fibers, coroutines: what’s the difference?</a></p></blockquote><p><strong>🔴 其实协程和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制</strong>。要理解协程，你得和普通函数一起来看, 以Generator为例:</p><p>普通函数执行的过程中无法<strong>被中断和恢复</strong>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task</span><br><span class="line">  <span class="keyword">while</span> (task = tasks.shift()) &#123;</span><br><span class="line">    execute(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>而 <code>Generator</code> 可以:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (task = tasks.shift()) &#123;</span><br><span class="line">    <span class="comment">// 🔴 判断是否有高优先级事件需要处理, 有的话让出控制权</span></span><br><span class="line">    <span class="keyword">if</span> (hasHighPriorityEvent()) &#123;</span><br><span class="line">      <span class="keyword">yield</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完高优先级事件后，恢复函数调用栈，继续执行...</span></span><br><span class="line">    execute(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>React Fiber 的思想和协程的概念是契合的: <strong>🔴React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染</strong>。</p><p><br></p><p>那么现在你应该有以下疑问:</p><ul><li>1️⃣ 浏览器没有抢占的条件, 所以React只能用让出机制?</li><li>2️⃣ 怎么确定有高优先任务要处理，即什么时候让出？</li><li>3️⃣ React 那为什么不使用 Generator？</li></ul><p><br><br><br></p><p><strong>答1️⃣: 没错, 主动让出机制</strong></p><p>一是浏览器中没有类似进程的概念，’任务‘之间的界限很模糊，没有上下文，所以不具备中断/恢复的条件。二是没有抢占的机制，我们无法中断一个正在执行的程序。</p><p>所以我们只能采用类似协程这样控制权让出机制。这个和上文提到的进程调度策略都不同，它有更一个专业的名词：<a href="https://juejin.im/post/5d12c907f265da1b6d4033c5#heading-7" target="_blank" rel="noopener"><strong>合作式调度(Cooperative Scheduling)</strong></a>, 相对应的有<strong>抢占式调度(Preemptive Scheduling)</strong></p><p><strong>这是一种’契约‘调度，要求我们的程序和浏览器紧密结合，互相信任</strong>。比如可以由浏览器给我们分配执行时间片(通过<code>requestIdleCallback</code>实现, 下文会介绍)，我们要按照约定在这个时间内执行完毕，并将控制权还给浏览器。</p><p><img src="/images/react-fiber/cs.png" alt></p><p><br></p><p>这种调度方式很有趣，你会发现<strong>这是一种身份的对调</strong>，以前我们是老子，想怎么执行就怎么执行，执行多久就执行多久; 现在为了我们共同的用户体验统一了战线, 一切听由浏览器指挥调度，浏览器是老子，我们要跟浏览器申请执行权，而且这个执行权有期限，借了后要按照约定归还给浏览器。</p><p>当然你超时不还浏览器也拿你没办法 🤷‍… 合作式调度的缺点就在于此，全凭自律，用户要挖大坑，谁都拦不住。</p><p><br></p><hr><p><br></p><p><strong>答2️⃣: requestIdleCallback API</strong></p><p>上面代码示例中的 <code>hasHighPriorityEvent()</code> 在目前浏览器中是无法实现的，我们没办法判断当前是否有更高优先级的任务等待被执行。</p><p>只能换一种思路，通过<strong>超时检查的机制来让出控制权</strong>。解决办法是: <em>确定一个合理的运行时长，然后在合适的检查点检测是否超时(比如每执行一个小任务)，如果超时就停止执行，将控制权交换给浏览器</em>。</p><p>举个例子，为了让视图流畅地运行，可以按照人类能感知到最低限度每秒60帧的频率划分时间片，这样每个时间片就是 16ms。</p><p>其实浏览器提供了相关的接口 —— <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noopener"><code>requestIdleCallback</code></a> API：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestIdleCallback(</span><br><span class="line">  callback: <span class="function">(<span class="params">dealine: IdleDeadline</span>) =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">  option?: &#123;timeout: <span class="built_in">number</span>&#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p><br></p><p><code>IdleDeadline</code>的接口如下：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IdleDealine &#123;</span><br><span class="line">  didTimeout: <span class="built_in">boolean</span> <span class="comment">// 表示任务执行是否超过约定时间</span></span><br><span class="line">  timeRemaining(): DOMHighResTimeStamp <span class="comment">// 任务可供执行的剩余时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单从名字上理解的话, <code>requestIdleCallback</code>的意思是<strong>让浏览器在’有空’的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行, 为了不耽误事，我们最好在这个时间范围内执行完毕</strong>。</p><p><br></p><p><strong>那浏览器什么时候有空？</strong></p><p>我们先来看一下浏览器在一帧(Frame，可以认为事件循环的一次循环)内可能会做什么事情:</p><p><img src="/images/react-fiber/frame.png" alt><br><i>你可以打开 Chrome 开发者工具的Performance标签，这里可以详细看到Javascript的每一帧都执行了什么任务(Task), 花费了多少时间。</i></p><p><br></p><p><img src="/images/react-fiber/frame-life.png" alt><br><i>图片来源: <a href="https://juejin.im/post/5ad71f39f265da239f07e862" target="_blank" rel="noopener">你应该知道的requestIdleCallback</a></i></p><p>浏览器在一帧内可能会做执行下列任务，而且它们的执行顺序基本是固定的:</p><ul><li>处理用户输入事件</li><li>Javascript执行</li><li>requestAnimation 调用</li><li>布局 Layout</li><li>绘制 Paint</li></ul><p><br></p><p>上面说理想的一帧时间是 <code>16ms</code> (1000ms / 60)，如果浏览器处理完上述的任务(布局和绘制之后)，还有盈余时间，浏览器就会调用 <code>requestIdleCallback</code> 的回调。例如</p><p><br></p><p><img src="/images/react-fiber/ric.png" alt></p><p><br></p><p><strong>但是在浏览器繁忙的时候，可能不会有盈余时间，这时候<code>requestIdleCallback</code>回调可能就不会被执行。 为了避免饿死，可以通过requestIdleCallback的第二个参数指定一个超时时间</strong>。</p><blockquote><p>另外不建议在<code>requestIdleCallback</code>中进行<code>DOM</code>操作，因为这可能导致样式重新计算或重新布局(比如操作DOM后马上调用 <code>getBoundingClientRect</code>)，这些时间很难预估的，很有可能导致回调执行超时，从而掉帧。</p></blockquote><p><br></p><p>目前 <code>requestIdleCallback</code> 目前只有Chrome支持。所以目前 React <a href="https://github.com/facebook/react/blob/master/packages/scheduler/src/forks/SchedulerHostConfig.default.js" target="_blank" rel="noopener">自己实现了一个</a>。它利用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel" target="_blank" rel="noopener"><code>MessageChannel</code></a> 模拟将回调延迟到’绘制操作’之后执行:</p><p><br></p><p><img src="/images/react-fiber/mc.png" alt></p><p><br></p><details><br><summary>简单看一下代码</summary><br><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>)</span><br><span class="line"><span class="keyword">const</span> ch = <span class="keyword">new</span> MessageChannel()</span><br><span class="line"><span class="keyword">let</span> pendingCallback</span><br><span class="line"><span class="keyword">let</span> startTime</span><br><span class="line"><span class="keyword">let</span> timeout</span><br><span class="line"></span><br><span class="line">ch.port2.onmessage = <span class="function"><span class="keyword">function</span> <span class="title">work</span>(<span class="params"></span>)  </span>&#123;</span><br><span class="line">  <span class="comment">// 在绘制之后被执行</span></span><br><span class="line">  <span class="keyword">if</span> (pendingCallback) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = performance.now()</span><br><span class="line">    <span class="comment">// 通过now - startTime可以计算出requestAnimationFrame到绘制结束的执行时间</span></span><br><span class="line">    <span class="comment">// 通过这些数据来计算剩余时间</span></span><br><span class="line">    <span class="comment">// 另外还要处理超时(timeout)，避免任务被饿死</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (hasRemain &amp;&amp; noTimeout) &#123;</span><br><span class="line">      pendingCallback(deadline)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleRequestIdleCallback</span>(<span class="params">callback, timeout</span>) </span>&#123;</span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">animation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在绘制之前被执行</span></span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    startTime = performance.now()</span><br><span class="line">    timeout = timeout</span><br><span class="line">    dosomething()</span><br><span class="line">    <span class="comment">// 调度回调到绘制结束后执行</span></span><br><span class="line">    pendingCallback = callback</span><br><span class="line">    ch.port1.postMessage(<span class="string">'hello'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details><p><br></p><p><strong>任务优先级</strong></p><p>上面说了，为了避免任务被饿死，可以设置一个超时时间. <strong>这个超时时间不是死的，低优先级的可以慢慢等待, 高优先级的任务应该率先被执行</strong>. 目前 React 预定义了 5 个优先级, 这个我在[《谈谈React事件机制和未来(react-events)》]中也介绍过:</p><ul><li><code>Immediate</code>(-1) - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断</li><li><code>UserBlocking</code>(250ms) 这些任务一般是用户交互的结果, 需要即时得到反馈</li><li><code>Normal</code> (5s) 应对哪些不需要立即感受到的任务，例如网络请求</li><li><code>Low</code> (10s) 这些任务可以放后，但是最终应该得到执行. 例如分析通知</li><li><code>Idle</code> (没有超时时间) 一些没有必要做的任务 (e.g. 比如隐藏的内容), 可能会被饿死</li></ul><p><br></p><hr><p><br></p><p><strong>答3️⃣: 太麻烦</strong></p><p>官方在<a href="https://github.com/facebook/react/issues/7942" target="_blank" rel="noopener">《Fiber Principles: Contributing To Fiber》</a> 也作出了解答。主要有两个原因：</p><ol><li>Generator 不能在栈中间让出。比如你想在嵌套的函数调用中间让出, 首先你需要将这些函数都包装成Generator，另外这种栈中间的让出处理起来也比较麻烦，难以理解。除了语法开销，现有的生成器实现开销比较大，所以不如不用。</li><li>Generator 是有状态的, 很难在中间恢复这些状态。</li></ol><blockquote><p>上面理解可能有出入，建议看一下原文</p></blockquote><p>可能都没看懂，简单就是 React 尝试过用 Generator 实现，后来发现很麻烦，就放弃了。</p><p><br><br><br></p><h3 id="2-一个执行单元"><a href="#2-一个执行单元" class="headerlink" title="2. 一个执行单元"></a>2. 一个执行单元</h3><p>Fiber的另外一种解读是’纤维‘: <strong>这是一种数据结构或者说执行单元</strong>。我们暂且不管这个数据结构长什么样，<strong>🔴将它视作一个执行单元，每次执行完一个’执行单元’,  React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去</strong>.</p><p><br></p><p>上文说了，React 没有使用 Generator 这些语言/语法层面的让出机制，而是实现了自己的调度让出机制。这个机制就是基于’Fiber‘这个执行单元的，它的过程如下：</p><p>假设用户调用 <code>setState</code> 更新组件, 这个待更新的任务会先放入队列中, 然后通过 <code>requestIdleCallback</code> 请求浏览器调度：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">updateQueue.push(updateTask);</span><br><span class="line">requestIdleCallback(performWork, &#123;timeout&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p>现在浏览器有空闲或者超时了就会调用<code>performWork</code>来执行任务：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1️⃣ performWork 会拿到一个Deadline，表示剩余时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performWork</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2️⃣ 循环取出updateQueue中的任务</span></span><br><span class="line">  <span class="keyword">while</span> (updateQueue.length &gt; <span class="number">0</span> &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123;</span><br><span class="line">    workLoop(deadline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3️⃣ 如果在本次执行中，未能将所有任务执行完毕，那就再请求浏览器调度</span></span><br><span class="line">  <span class="keyword">if</span> (updateQueue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    requestIdleCallback(performWork);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong><code>workLoop</code> 的工作大概猜到了，它会从更新队列(updateQueue)中弹出更新任务来执行，每执行完一个‘<code>执行单元</code>‘，就检查一下剩余时间是否充足，如果充足就进行执行下一个<code>执行单元</code>，反之则停止执行，保存现场，等下一次有执行权时恢复</strong>:</p><p><br></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存当前的处理现场</span></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork: Fiber | <span class="literal">undefined</span> <span class="comment">// 保存下一个需要处理的工作单元</span></span><br><span class="line"><span class="keyword">let</span> topWork: Fiber | <span class="literal">undefined</span>        <span class="comment">// 保存第一个工作单元</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline: IdleDeadline</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// updateQueue中获取下一个或者恢复上一次中断的执行单元</span></span><br><span class="line">  <span class="keyword">if</span> (nextUnitOfWork == <span class="literal">null</span>) &#123;</span><br><span class="line">    nextUnitOfWork = topWork = getNextUnitOfWork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴 每执行完一个执行单元，检查一次剩余时间</span></span><br><span class="line">  <span class="comment">// 如果被中断，下一次执行还是从 nextUnitOfWork 开始处理</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123;</span><br><span class="line">    <span class="comment">// 下文我们再看performUnitOfWork</span></span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork, topWork);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交工作，下文会介绍</span></span><br><span class="line">  <span class="keyword">if</span> (pendingCommit) &#123;</span><br><span class="line">    commitAllWork(pendingCommit);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画个流程图吧！</p><p><br></p><p><img src="/images/react-fiber/workloop.png" alt></p><p><br><br><br></p><h2 id="react-的fiber改造"><a href="#react-的fiber改造" class="headerlink" title="React 的Fiber改造"></a>React 的Fiber改造</h2><p>Fiber 的核心内容已经介绍完了，现在来进一步看看React 为 Fiber 架构做了哪些改造, 如果你对这部分内容不感兴趣可以跳过。</p><p><br></p><h3 id="1-数据结构的调整"><a href="#1-数据结构的调整" class="headerlink" title="1. 数据结构的调整"></a>1. 数据结构的调整</h3><p><img src="/images/react-fiber/diff.png" alt><br><i>左侧是Virtual DOM，右侧可以看作diff的递归调用栈</i></p><p><br></p><p>上文中提到 React 16 之前，Reconcilation 是同步的、递归执行的。也就是说这是基于函数’调用栈‘的Reconcilation算法，因此通常也称它为<code>Stack Reconcilation</code>. 你可以通过这篇文章<a href="https://juejin.im/post/5cfa29e151882539c33e4f5e" target="_blank" rel="noopener">《从Preact中了解React组件和hooks基本原理》</a> 来回顾一下历史。</p><p><br></p><p>栈挺好的，代码量少，递归容易理解, 至少比现在的 React Fiber架构好理解😂, 递归非常适合树这种嵌套数据结构的处理。</p><p>只不过这种依赖于调用栈的方式不能随意中断、也很难被恢复, 不利于异步处理。 这种调用栈，不是程序所能控制的， 如果你要恢复递归现场，可能需要从头开始, 恢复到之前的调用栈。</p><p>因此<strong>首先我们需要对React现有的数据结构进行调整，<a href="https://zhuanlan.zhihu.com/p/36425839" target="_blank" rel="noopener"><code>模拟函数调用栈</code></a>, 将之前需要递归进行处理的事情分解成增量的执行单元，将递归转换成迭代</strong>.</p><p><br></p><p>React 目前的做法是使用<code>链表</code>, 每个 VirtualDOM 节点内部现在使用 <code>Fiber</code>表示, 它的结构大概如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type Fiber = &#123;</span><br><span class="line">  <span class="comment">// Fiber 类型信息</span></span><br><span class="line">  type: any,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚛️ 链表结构</span></span><br><span class="line">  <span class="comment">// 指向父节点，或者render该节点的组件</span></span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向第一个子节点</span></span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向下一个兄弟节点</span></span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>用图片来展示这种关系会更直观一些：</p><p><img src="/images/react-fiber/fiber-node.png" alt></p><p><br></p><p><strong>使用链表结构只是一个结果，而不是目的，React 开发者一开始的目的是冲着模拟调用栈去的</strong>。这个很多关于Fiber 的文章都有提及, 关于调用栈的详细定义参见<a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank" rel="noopener">Wiki</a>：</p><p><img src="/images/react-fiber/callstack.png" alt></p><blockquote><p>调用栈最经常被用于存放子程序的<strong>返回地址</strong>。在调用任何子程序时，主程序都必须暂存子程序运行完毕后应该返回到的地址。因此，如果被调用的子程序还要调用其他的子程序，其自身的返回地址就必须存入调用栈，在其自身运行完毕后再行取回。除了返回地址，还会保存<code>本地变量</code>、<code>函数参数</code>、<code>环境传递</code>(Scope?)</p></blockquote><p><br></p><p>React Fiber 也被称为虚拟栈帧(Virtual Stack Frame), 你可以拿它和函数调用栈类比一下, 两者结构非常像:</p><table><thead><tr><th></th><th>函数调用栈</th><th>Fiber</th></tr></thead><tbody><tr><td>基本单位</td><td>函数</td><td>Virtual DOM 节点</td></tr><tr><td>输入</td><td>函数参数</td><td>Props</td></tr><tr><td>本地状态</td><td>本地变量</td><td>State</td></tr><tr><td>输出</td><td>函数返回值</td><td>React Element</td></tr><tr><td>下级</td><td>嵌套函数调用</td><td>子节点(child)</td></tr><tr><td>上级引用</td><td>返回地址</td><td>父节点(return)</td></tr></tbody></table><p><br></p><p>Fiber 和调用栈帧一样, 保存了节点处理的上下文信息，因为是手动实现的，所以更为可控，我们可以保存在内存中，随时中断和恢复。</p><p><br></p><p>有了这个数据结构调整，现在可以以迭代的方式来处理这些节点了。来看看 <code>performUnitOfWork</code> 的实现, 它其实就是一个深度优先的遍历：</p><p><br></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @params fiber 当前需要处理的节点</span></span><br><span class="line"><span class="comment"> * @params topWork 本次更新的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber: Fiber, topWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对该节点进行处理</span></span><br><span class="line">  beginWork(fiber);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在子节点，那么下一个待处理的就是子节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有子节点了，上溯查找兄弟节点</span></span><br><span class="line">  <span class="keyword">let</span> temp = fiber;</span><br><span class="line">  <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">    completeWork(temp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到顶层节点了, 退出</span></span><br><span class="line">    <span class="keyword">if</span> (temp === topWork) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到，下一个要处理的就是兄弟节点</span></span><br><span class="line">    <span class="keyword">if</span> (temp.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> temp.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有, 继续上溯</span></span><br><span class="line">    temp = temp.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>你可以配合上文的 <code>workLoop</code> 一起看，<strong>Fiber 就是我们所说的工作单元，<code>performUnitOfWork</code> 负责对 <code>Fiber</code> 进行操作，并按照深度遍历的顺序返回下一个 Fiber</strong>。</p><p><strong>因为使用了链表结构，即使处理流程被中断了，我们随时可以从上次未处理完的<code>Fiber</code>继续遍历下去</strong>。</p><p>整个迭代顺序和之前递归的一样, 下图假设在 <code>div.app</code> 进行了更新：</p><p><br></p><p><img src="/images/react-fiber/work-order.png" alt><br><i>比如你在<code>text(hello)</code>中断了，那么下一次就会从 <code>p</code> 节点开始处理</i></p><p><br></p><p>这个数据结构调整还有一个好处，就是某些节点异常时，我们可以打印出完整的’节点栈‘，只需要沿着节点的<code>return</code>回溯即可。</p><p><br><br><br></p><h3 id="2-两个阶段的拆分"><a href="#2-两个阶段的拆分" class="headerlink" title="2. 两个阶段的拆分"></a>2. 两个阶段的拆分</h3><p><br></p><p><img src="/images/react-fiber/fiber-reconciler.png" alt></p><p><br></p><p>如果你现在使用最新的 React 版本(v16), 使用 Chrome 的 Performance 工具，可以很清晰地看到每次渲染有两个阶段：<code>Reconciliation</code>(协调阶段) 和 <code>Commit</code>(提交阶段).</p><blockquote><p>我在之前的多篇文章中都有提及: <a href="https://juejin.im/post/5d8395646fb9a06ad16faa57" target="_blank" rel="noopener">《自己写个React渲染器: 以 Remax 为例(用React写小程序)》</a></p></blockquote><p>除了Fiber 工作单元的拆分，两阶段的拆分也是一个非常重要的改造，在此之前都是一边Diff一边提交的。先来看看这两者的区别:</p><ul><li><p><strong>⚛️ 协调阶段</strong>: 可以认为是 Diff 阶段, <strong>这个阶段可以被中断</strong>, 这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等, 这些变更React 称之为’<code>副作用</code>(Effect)’ . 以下生命周期钩子会在协调阶段被调用：</p><ul><li><code>constructor</code></li><li><code>componentWillMount</code> 废弃</li><li><code>componentWillReceiveProps</code> 废弃</li><li><code>static getDerivedStateFromProps</code></li><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code> 废弃</li><li><code>render</code></li></ul></li><li><p><strong>⚛️ 提交阶段</strong>: 将上一个阶段计算出来的需要处理的<strong>副作用(Effects)</strong>一次性执行了。<strong>这个阶段必须同步执行，不能被打断</strong>. 这些生命周期钩子在提交阶段被执行:</p><ul><li><code>getSnapshotBeforeUpdate()</code> 严格来说，这个是在进入 commit 阶段前调用</li><li><code>componentDidMount</code></li><li><code>componentDidUpdate</code></li><li><code>componentWillUnmount</code></li></ul></li></ul><p><br></p><p>也就是说，在协调阶段如果时间片用完，React就会选择让出控制权。因为协调阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题。</p><p>需要注意的是：因为协调阶段可能被中断、恢复，甚至重做，<strong>⚠️React 协调阶段的生命周期钩子可能会被调用多次!</strong>, 例如 <code>componentWillMount</code> 可能会被调用两次。 </p><p>因此建议 <strong>协调阶段的生命周期钩子不要包含副作用</strong>. 索性 React 就废弃了这部分可能包含副作用的生命周期方法，例如<code>componentWillMount</code>、<code>componentWillUpdate</code>. v17后我们就不能再用它们了, 所以现有的应用应该尽快迁移.</p><p><br></p><p>现在你应该知道为什么’提交阶段’必须同步执行，不能中断的吧？ 因为我们要正确地处理各种副作用，包括DOM变更、还有你在<code>componentDidMount</code>中发起的异步请求、useEffect 中定义的副作用… 因为有副作用，所以必须保证按照次序只调用一次，况且会有用户可以察觉到的变更, 不容差池。</p><p>关于为什么要拆分两个阶段，<a href="https://github.com/facebook/react/issues/13186#issuecomment-403959161" target="_blank" rel="noopener">这里</a>有更详细的解释。</p><p><br><br><br></p><h3 id="3-reconcilation"><a href="#3-reconcilation" class="headerlink" title="3. Reconcilation"></a>3. Reconcilation</h3><p>接下来就是就是我们熟知的<code>Reconcilation</code>(为了方便理解，本文不区分Diff和Reconcilation, 两者是同一个东西)阶段了. <strong>思路和 Fiber 重构之前差别不大, 只不过这里不会再递归去比对、而且不会马上提交变更</strong>。</p><p>首先再进一步看一下<code>Fiber</code>的结构:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Fiber &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 节点的类型信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 标记 Fiber 类型, 例如函数组件、类组件、宿主组件</span></span><br><span class="line">  tag: WorkTag,</span><br><span class="line">  <span class="comment">// 节点元素类型, 是具体的类组件、函数组件、宿主组件(字符串)</span></span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">any</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 结构信息</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 子节点的唯一键, 即我们渲染列表传入的key属性</span></span><br><span class="line">  key: <span class="literal">null</span> | <span class="built_in">string</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 节点的状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 节点实例(状态)：</span></span><br><span class="line">  <span class="comment">//        对于宿主组件，这里保存宿主组件的实例, 例如DOM节点。</span></span><br><span class="line">  <span class="comment">//        对于类组件来说，这里保存类组件的实例</span></span><br><span class="line">  <span class="comment">//        对于函数组件说，这里为空，因为函数组件没有实例</span></span><br><span class="line">  stateNode: <span class="built_in">any</span>,</span><br><span class="line">  <span class="comment">// 新的、待处理的props</span></span><br><span class="line">  pendingProps: <span class="built_in">any</span>,</span><br><span class="line">  <span class="comment">// 上一次渲染的props</span></span><br><span class="line">  memoizedProps: <span class="built_in">any</span>, <span class="comment">// The props used to create the output.</span></span><br><span class="line">  <span class="comment">// 上一次渲染的组件状态</span></span><br><span class="line">  memoizedState: <span class="built_in">any</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 副作用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 当前节点的副作用类型，例如节点更新、删除、移动</span></span><br><span class="line">  effectTag: SideEffectTag,</span><br><span class="line">  <span class="comment">// 和节点关系一样，React 同样使用链表来将所有有副作用的Fiber连接起来</span></span><br><span class="line">  nextEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 替身</span></span><br><span class="line"><span class="comment">   * 指向旧树中的节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  alternate: Fiber | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>Fiber 包含的属性可以划分为 5 个部分:</p><ul><li><strong>🆕 结构信息</strong> - 这个上文我们已经见过了，Fiber 使用链表的形式来表示节点在树中的定位</li><li><strong>节点类型信息</strong> - 这个也容易理解，tag表示节点的分类、type 保存具体的类型值，如div、MyComp</li><li><strong>节点的状态</strong> - 节点的组件实例、props、state等，它们将影响组件的输出</li><li><p><strong>🆕 副作用</strong> - 这个也是新东西. 在 Reconciliation 过程中发现的’副作用’(变更需求)就保存在节点的<code>effectTag</code> 中(想象为打上一个标记).<br>那么怎么将本次渲染的所有节点副作用都收集起来呢？ 这里也使用了链表结构，在遍历过程中React会将所有有‘副作用’的节点都通过<code>nextEffect</code>连接起来</p></li><li><p><strong>🆕 替身</strong> - React 在 Reconciliation 过程中会构建一颗新的树(官方称为workInProgress tree，<strong>WIP树</strong>)，可以认为是一颗表示当前工作进度的树。还有一颗表示已渲染界面的<strong>旧树</strong>，React就是一边和旧树比对，一边构建WIP树的。 alternate 指向旧树的同等节点。</p></li></ul><p><br></p><p>现在可以放大看看<code>beginWork</code>  是如何对 Fiber 进行比对的:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">fiber: Fiber</span>): <span class="title">Fiber</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fiber.tag === WorkTag.HostComponent) &#123;</span><br><span class="line">    <span class="comment">// 宿主节点diff</span></span><br><span class="line">    diffHostComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.ClassComponent) &#123;</span><br><span class="line">    <span class="comment">// 类组件节点diff</span></span><br><span class="line">    diffClassComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.FunctionComponent) &#123;</span><br><span class="line">    <span class="comment">// 函数组件节点diff</span></span><br><span class="line">    diffFunctionalComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他类型节点，省略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>宿主节点比对:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffHostComponent</span>(<span class="params">fiber: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新增节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.stateNode == <span class="literal">null</span>) &#123;</span><br><span class="line">    fiber.stateNode = createHostComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateHostComponent(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newChildren = fiber.pendingProps.children;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比对子节点</span></span><br><span class="line">  diffChildren(fiber, newChildren);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>类组件节点比对也差不多:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffClassComponent</span>(<span class="params">fiber: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.stateNode == <span class="literal">null</span>) &#123;</span><br><span class="line">    fiber.stateNode = createInstance(fiber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.hasMounted) &#123;</span><br><span class="line">    <span class="comment">// 调用更新前生命周期钩子</span></span><br><span class="line">    applybeforeUpdateHooks(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 调用挂载前生命周期钩子</span></span><br><span class="line">    applybeforeMountHooks(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染新节点</span></span><br><span class="line">  <span class="keyword">const</span> newChildren = fiber.stateNode.render();</span><br><span class="line">  <span class="comment">// 比对子节点</span></span><br><span class="line">  diffChildren(fiber, newChildren);</span><br><span class="line"></span><br><span class="line">  fiber.memoizedState = fiber.stateNode.state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>子节点比对:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">fiber: Fiber, newChildren: React.ReactNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldFiber = fiber.alternate ? fiber.alternate.child : <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 全新节点，直接挂载</span></span><br><span class="line">  <span class="keyword">if</span> (oldFiber == <span class="literal">null</span>) &#123;</span><br><span class="line">    mountChildFibers(fiber, newChildren)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 新子节点</span></span><br><span class="line">  <span class="keyword">const</span> elements = extraElements(newChildren)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比对子元素</span></span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length || oldFiber != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevFiber = newFiber;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index]</span><br><span class="line">    <span class="keyword">const</span> sameType = isSameType(element, oldFiber)</span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">      newFiber = cloneFiber(oldFiber, element)</span><br><span class="line">      <span class="comment">// 更新关系</span></span><br><span class="line">      newFiber.alternate = oldFiber</span><br><span class="line">      <span class="comment">// 打上Tag</span></span><br><span class="line">      newFiber.effectTag = UPDATE</span><br><span class="line">      newFiber.return = fiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新节点</span></span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">      newFiber = createFiber(element)</span><br><span class="line">      newFiber.effectTag = PLACEMENT</span><br><span class="line">      newFiber.return = fiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除旧节点</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">      oldFiber.effectTag = DELETION;</span><br><span class="line">      oldFiber.nextEffect = fiber.nextEffect</span><br><span class="line">      fiber.nextEffect = oldFiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldFiber) &#123;</span><br><span class="line">      oldFiber = oldFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">      fiber.child = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevFiber &amp;&amp; element) &#123;</span><br><span class="line">      prevFiber.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>上面的代码很粗糙地还原了 Reconciliation 的过程, 但是对于我们理解React的基本原理已经足够了.</p><p><br></p><p>这里引用一下<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">Youtube: Lin Clark presentation in ReactConf 2017</a> 的Slide，来还原 Reconciliation 的过程. Lin Clark 这个演讲太经典了，几乎所有介绍 React Fiber 的文章都会引用它的Slide. 偷个懒，我也用下:</p><blockquote><p>这篇文章<a href="https://juejin.im/post/5ab7b3a2f265da2378403e57" target="_blank" rel="noopener">《React Fiber》</a> 用文字版解释了Link Clark Slide.</p></blockquote><p><img src="/images/react-fiber/effect-tag.png" alt></p><p><br></p><p>上图是 Reconciliation 完成后的状态，左边是旧树，右边是WIP树。对于需要变更的节点，都打上了’标签’。 在提交阶段，React 就会将这些打上标签的节点应用变更。</p><p><br><br><br></p><h3 id="4-双缓冲"><a href="#4-双缓冲" class="headerlink" title="4. 双缓冲"></a>4. 双缓冲</h3><p><code>WIP 树</code>构建这种技术类似于图形化领域的’<strong>双缓存(Double Buffering)</strong>‘技术, 图形绘制引擎一般会使用双缓冲技术，先将图片绘制到一个缓冲区，再一次性传递给屏幕进行显示，这样可以防止屏幕抖动，优化渲染性能。</p><p>放到React 中，WIP树就是一个缓冲，它在Reconciliation 完毕后一次性提交给浏览器进行渲染。它可以减少内存分配和垃圾回收，WIP 的节点不完全是新的，比如某颗子树不需要变动，React会克隆复用旧树中的子树。</p><p>双缓存技术还有另外一个重要的场景就是异常的处理，比如当一个节点抛出异常，仍然可以继续沿用旧树的节点，避免整棵树挂掉。</p><p>Dan 在 <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" target="_blank" rel="noopener">Beyond React 16</a> 演讲中用了一个非常恰当的比喻，那就是Git 功能分支，<strong>你可以将 WIP 树想象成从旧树中 Fork 出来的功能分支，你在这新分支中添加或移除特性，即使是操作失误也不会影响旧的分支。当你这个分支经过了测试和完善，就可以合并到旧分支，将其替换掉. 这或许就是’提交(commit)阶段‘的提交一词的来源吧？</strong>:</p><p><br></p><p><img src="/images/react-fiber/gitbranch.png" alt></p><p><br><br><br></p><h3 id="5-副作用的收集和提交"><a href="#5-副作用的收集和提交" class="headerlink" title="5. 副作用的收集和提交"></a>5. 副作用的收集和提交</h3><p>接下来就是将所有打了 Effect 标记的节点串联起来，这个可以在<code>completeWork</code>中做, 例如:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parent = fiber.return</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 到达顶端</span></span><br><span class="line">  <span class="keyword">if</span> (parent == <span class="literal">null</span> || fiber === topWork) &#123;</span><br><span class="line">    pendingCommit = fiber</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.effectTag != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.nextEffect) &#123;</span><br><span class="line">      parent.nextEffect.nextEffect = fiber</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parent.nextEffect = fiber</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.nextEffect) &#123;</span><br><span class="line">    parent.nextEffect = fiber.nextEffect</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>最后了，将所有副作用提交了:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> next = fiber</span><br><span class="line">  <span class="keyword">while</span>(next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fiber.effectTag) &#123;</span><br><span class="line">      <span class="comment">// 提交，偷一下懒，这里就不展开了</span></span><br><span class="line">      commitWork(fiber)</span><br><span class="line">    &#125;</span><br><span class="line">    next = fiber.nextEffect</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清理现场</span></span><br><span class="line">  pendingCommit = nextUnitOfWork = topWork = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="⚠️-未展开部分-🚧-–-中断和恢复"><a href="#⚠️-未展开部分-🚧-–-中断和恢复" class="headerlink" title="⚠️ 未展开部分 🚧 – 中断和恢复"></a>⚠️ 未展开部分 🚧 – 中断和恢复</h2><p>上文只是介绍了简单的中断和恢复机制，我们从哪里跌倒就从哪里站起来，在哪个节点中断就从哪个节点继续处理下去。 也就是说，到目前为止：<strong>⚠️更新任务还是串行执行的，我们只是将整个过程碎片化了. 对于那些需要优先处理的更新任务还是会被阻塞</strong>。我个人觉得这才是 React Fiber 中最难处理的一部分。</p><p><strong>实际情况是，在 React 得到控制权后，应该优先处理高优先级的任务</strong>。也就是说中断时正在处理的任务，在恢复时会让位给高优先级任务，原本中断的任务可能会被放弃或者重做。</p><p><strong>但是如果不按顺序执行任务，可能会导致前后的状态不一致</strong>。 比如低优先级任务将 <code>a</code> 设置为0，而高优先级任务将 <code>a</code> 递增1, 两个任务的执行顺序会影响最终的渲染结果。因此<strong>要让高优先级任务插队, 首先要保证状态更新的时序</strong>。</p><p><br></p><p>解决办法是: <strong>所有更新任务按照顺序插入一个队列, 状态必须按照插入顺序进行计算，但任务可以按优先级顺序执行</strong>, 例如：</p><p><br></p><p><img src="/images/react-fiber/resume-1.png" alt></p><p><br></p><p>红色表示高优先级任务。要计算它的状态必须基于前序任务计算出来的状态, 从而保证<strong>状态的最终一致性</strong>：</p><p><br></p><p><img src="/images/react-fiber/resume-2.png" alt></p><p>最终红色的高优先级任务 <code>C</code> 执行时的状态值是<code>a=5,b=3</code>. 在恢复控制权时，会按照优先级先执行 <code>C</code>, 前面的<code>A</code>、 <code>B</code>暂时跳过</p><p><br></p><p><img src="/images/react-fiber/resume-3.png" alt></p><p><br></p><p>上面被跳过任务不会被移除，在执行完高优先级任务后它们还是会被执行的。因为不同的更新任务影响的节点树范围可能是不一样的，举个例子 <code>a</code>、<code>b</code> 可能会影响 <code>Foo</code> 组件树，而 <code>c</code> 会影响 <code>Bar</code> 组件树。所以为了保证<strong>视图的最终一致性</strong>, 所有更新任务都要被执行。</p><p><br></p><p><img src="/images/react-fiber/resume-4.png" alt></p><p>首先 <code>C</code> 先被执行，它更新了 <code>Foo</code> 组件</p><p>接着执行 <code>A</code> 任务，它更新了<code>Foo</code> 和 <code>Bar</code> 组件，由于 <code>C</code> 已经以最终状态<code>a=5, b=3</code>更新了<code>Foo</code>组件，这里可以做一下性能优化，直接复用C的更新结果， 不必触发重新渲染。因此 <code>A</code> 仅需更新 <code>Bar</code> 组件即可。</p><p>接着执行 <code>B</code>，同理可以复用 Foo 更新结果。</p><p><br></p><p>道理讲起来都很简单，React Fiber 实际上非常复杂，不管执行的过程怎样拆分、以什么顺序执行，最重要的是保证<strong>状态的一致性</strong>和<strong>视图的一致性</strong>，这给了 React 团队很大的考验，以致于现在都没有正式release出来。</p><p><br><br><br></p><h2 id="凌波微步"><a href="#凌波微步" class="headerlink" title="凌波微步"></a>凌波微步</h2><p><img src="/images/react-fiber/new-frame.jpg" alt><br><i>同样来自Link Clark 的 Slider</i></p><p>前面说了一大堆，从操作系统进程调度、到浏览器原理、再到合作式调度、最后谈了React的基本改造工作, 地老天荒… 就是为了上面的小人可以在练就凌波微步, 它脚下的坑是浏览器的调用栈。</p><p>React 开启 <code>Concurrent Mode</code> 之后就不会挖大坑了，而是一小坑一坑的挖，挖一下休息一下，有紧急任务就优先去做。</p><p><br></p><p><img src="/images/react-fiber/benifit.png" alt><br><i>来源：<a href="https://www.youtube.com/watch?v=V1Ly-8Z1wQA&t=207s" target="_blank" rel="noopener">Flarnie Marchan - Ready for Concurrent Mode?</a></i></p><p><br></p><p>开启 <code>Concurrent Mode</code> 后，我们可以得到以下好处(详见<a href="https://www.youtube.com/watch?v=ByBPyMBTzM0" target="_blank" rel="noopener">Concurrent Rendering in React</a>):</p><ul><li>快速响应用户操作和输入，提升用户交互体验</li><li>让动画更加流畅，通过调度，可以让应用保持高帧率</li><li>利用好I/O 操作空闲期或者CPU空闲期，进行一些预渲染。 比如离屏(offscreen)不可见的内容，优先级最低，可以让 React 等到CPU空闲时才去渲染这部分内容。这和浏览器的preload等预加载技术差不多。</li><li>用<code>Suspense</code> 降低加载状态(load state)的优先级，减少闪屏。 比如数据很快返回时，可以不必显示加载状态，而是直接显示出来，避免闪屏；如果超时没有返回才显式加载状态。</li></ul><p><br></p><p>但是它肯定不是完美的，因为浏览器无法实现抢占式调度，无法阻止开发者做傻事的，开发者可以随心所欲，想挖多大的坑，就挖多大的坑。</p><p>为了共同创造美好的世界，我们要严律于己，该做的优化还需要做: 纯组件、虚表、简化组件、缓存…</p><p>尤雨溪在今年的<a href="https://www.yuque.com/vueconf/2019" target="_blank" rel="noopener">Vue Conf</a>一个观点让我印象深刻：<strong>如果我们可以把更新做得足够快的话，理论上就不需要时间分片了</strong>。</p><p><strong>时间分片并没有降低整体的工作量，该做的还是要做</strong>, 因此React 也在考虑利用CPU空闲或者I/O空闲期间做一些预渲染。所以跟尤雨溪说的一样：React Fiber 本质上是为了解决 React 更新低效率的问题，<strong>不要期望 Fiber 能给你现有应用带来质的提升, 如果性能问题是自己造成的，自己的锅还是得自己背</strong>.</p><p><br><br><br></p><h2 id="站在巨人的肩膀上"><a href="#站在巨人的肩膀上" class="headerlink" title="站在巨人的肩膀上"></a>站在巨人的肩膀上</h2><p><br></p><p>本文之所以能成文，离不开社区上优质的开源项目和资料。</p><p><strong>迷你 Fiber 实现</strong>:</p><p>React 现在的代码库太复杂了! 而且一直在变动和推翻自己，<a href="https://www.zhihu.com/people/he-shi-jun" target="_blank" rel="noopener">Hax</a> 在 <a href="https://www.zhihu.com/question/270428598/answer/354017709" target="_blank" rel="noopener">《为什么社区里那些类 React 库至今没有选择实现 Fiber 架构？》 </a> 就开玩笑说: Fiber 性价比略低… 到了这个阶段，竞品太多，facebook 就搞一个 fiber 来作为护城河……</p><p>这种工程量不是一般团队能Hold住的， 如果你只是想了解 Fiber，去读 React 的源码性价比也很低，不妨看看这些 Mini 版实现, 感受其精髓，不求甚解:</p><ul><li><a href="https://github.com/RubyLouvre/anu" target="_blank" rel="noopener">anu</a> <a href="https://github.com/RubyLouvre" target="_blank" rel="noopener">司徒正美</a> 开发的类React框架</li><li><a href="https://github.com/132yse/fre" target="_blank" rel="noopener">Fre</a> <a href="https://www.zhihu.com/people/132yse" target="_blank" rel="noopener">伊撒尔</a> 开发的类React框架，代码很精简⁉️</li><li><a href="https://github.com/Foveluy/Luy" target="_blank" rel="noopener">Luy</a></li><li><a href="https://github.com/pomber/didact" target="_blank" rel="noopener">didact</a></li></ul><p><br></p><p><strong>优秀的文章 &amp; 演讲</strong></p><p>本文只是对React Fiber进行了简单的科普，实际上React 的实现比本文复杂的多，如果你想深入理解React Fiber的，下面这些文章不容错过:</p><ul><li><a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017 👍🎦</a> React Fiber 启蒙，YouTube</li><li><a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" target="_blank" rel="noopener">Beyond React 16 - Dan Abramov 👍🎦</a></li><li><a href="https://www.youtube.com/watch?v=ByBPyMBTzM0&amp;t=151s" target="_blank" rel="noopener">Concurrent Rendering in React - Andrew Clark and Brian Vaughn 👍🎦</a></li><li><a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener">司徒正美: React Fiber架构 👍</a> 看不如写</li><li><a href="https://www.zhihu.com/people/NE_SmallTown/posts" target="_blank" rel="noopener">展望 React 17，回顾 React 往事 👍</a> 看完 <a href="https://www.zhihu.com/people/NE_SmallTown" target="_blank" rel="noopener">Heaven</a> 的相关文章，会觉得你了解的React 知识真的只是<a href="https://zhuanlan.zhihu.com/jheaven" target="_blank" rel="noopener">冰山一角</a>，我们都没资格说我们懂 React。</li><li><a href="https://zhuanlan.zhihu.com/p/36425839" target="_blank" rel="noopener">浅入 React16/fiber 系列 👍</a> 同样来自 Heaven</li><li><a href="https://www.zhihu.com/search?type=content&amp;q=requestIdleCallback" target="_blank" rel="noopener">淡苍：深入剖析 React Concurrent 👍</a></li><li><a href="https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec" target="_blank" rel="noopener">Didact Fiber: Incremental reconciliation  👍</a> 实现了简单的 React Fiber</li><li><a href="https://zhuanlan.zhihu.com/p/26027085" target="_blank" rel="noopener">程墨: React Fiber是什么</a></li><li><a href="https://zhuanlan.zhihu.com/p/57346388" target="_blank" rel="noopener">译 深入React fiber架构及源码</a></li><li><a href="http://www.ayqy.net/blog/dive-into-react-fiber/" target="_blank" rel="noopener">黯羽轻扬: 完全理解React Fiber</a></li><li><a href="https://github.com/facebook/react/issues/7942" target="_blank" rel="noopener">Fiber Principles: Contributing To Fiber</a></li><li><a href="https://philippspiess.com/scheduling-in-react/" target="_blank" rel="noopener">Scheduling in React</a></li><li><a href="https://juejin.im/post/5d12c907f265da1b6d4033c5" target="_blank" rel="noopener">桃翁: Deep In React 之浅谈 React Fiber 架构（一）</a></li><li><a href="https://juejin.im/post/5b028db26fb9a07ac162ba68#heading-12" target="_blank" rel="noopener">为 Luy 实现 React Fiber 架构</a></li><li><a href="https://juejin.im/post/5ab7b3a2f265da2378403e57" target="_blank" rel="noopener">妖僧风月: React Fiber</a></li><li><a href="https://www.youtube.com/watch?v=V1Ly-8Z1wQA&amp;t=207s" target="_blank" rel="noopener">Flarnie Marchan - Ready for Concurrent Mode? 🎦</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/rendering" target="_blank" rel="noopener">Web Fundamentals &gt; Performance</a></li><li><a href="https://juejin.im/post/5ad71f39f265da239f07e862" target="_blank" rel="noopener">你应该知道的requestIdleCallback</a></li><li><a href="https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering/" target="_blank" rel="noopener">深入探究 eventloop 与浏览器渲染的时序问题</a></li><li><a href="https://nolanlawson.com/2018/09/25/accurately-measuring-layout-on-the-web/" target="_blank" rel="noopener">Accurately measuring layout on the web</a></li></ul><p><br></p><p><strong>自荐React 相关文章</strong></p><p>回顾一下今年写的关于 React 的相关文章</p><p>Concurrent模式预览（推荐）:</p><ul><li><a href="https://juejin.im/post/5db65d87518825648f2ef899#comment" target="_blank" rel="noopener">React Concurrent 模式抢先预览上篇: Suspense the world</a></li><li><a href="https://juejin.im/post/5dbee8e7e51d4558040f0830" target="_blank" rel="noopener">React Concurrent 模式抢先预览下篇: useTransition 的平行世界</a></li></ul><p><br></p><p>往期文章:</p><ul><li><a href="https://juejin.im/post/5cd7f2c4e51d453a7d63b715" target="_blank" rel="noopener">React组件设计实践总结 系列 共5篇</a></li><li><a href="https://juejin.im/post/5d8395646fb9a06ad16faa57" target="_blank" rel="noopener">自己写个React渲染器: 以 Remax 为例(用React写小程序)</a></li><li><a href="https://juejin.im/post/5d44e3745188255d5861d654" target="_blank" rel="noopener">谈谈React事件机制和未来(react-events)</a></li><li><a href="https://juejin.im/post/5d594ea5518825041301bbcb" target="_blank" rel="noopener">2019年了，整理了N个实用案例帮你快速迁移到React Hooks</a></li><li><a href="https://juejin.im/post/5d045350f265da1b695d5bf2" target="_blank" rel="noopener">浅谈React性能优化的方向</a></li><li><a href="https://juejin.im/post/5cfa29e151882539c33e4f5e" target="_blank" rel="noopener">从Preact中了解React组件和hooks基本原理</a></li><li><a href="https://juejin.im/post/5d06bf0a51882528194a9736" target="_blank" rel="noopener">React性能测量和分析</a></li></ul><p><br></p><p>本文讲了 React 如何优化 CPU 问题，React 野心远不在于此, I/O 方向的优化也在实践，例如 Suspend…  还有很多没讲完，后面的文章见！</p><p><br></p><p>问卷调查，你觉得这种文章风格怎样？</p><ul><li>A. 事无巨细，太啰嗦了</li><li>B. 娓娓道来，深入浅出我喜欢</li><li>C. 内容不够深入</li><li>D. 文章篇幅太长，可以拆分</li></ul><p>多选，下方评论，👍点赞走起</p><blockquote><p><strong>改了一个正经一点的网名：_sx_(傻叉) -&gt; 荒山 ⛰</strong></p></blockquote><p><br></p><p><img src="/images/sponsor.jpg" alt></p><p><br></p></brk>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写一篇关于 React Fiber 的文章， 这个 Flag 立了很久，这也是今年的目标之一. 最近的在掘金的文章获得很多关注和鼓励，给了我很多动力，所以下定决心好好把它写出来。 我会以最通俗的方式将它讲透, 因此这算是一篇科普式的文章。不管你是使用React、还是Vue，
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>深入浅出 Babel 下篇：既生 Plugin 何生 Macros</title>
    <link href="https://bobi.ink/2019/10/10/babel-macro/"/>
    <id>https://bobi.ink/2019/10/10/babel-macro/</id>
    <published>2019-10-09T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>接着上篇文章: <a href="https://juejin.im/post/5d94bfbf5188256db95589be" target="_blank" rel="noopener">《深入浅出 Babel 上篇：架构和原理 + 实战 🔥》</a></p><p><br></p><p><strong>这篇文章干货不少于上篇文章，这篇我们深入讨论一下宏这个玩意</strong> —— <em>我想我们对宏并不陌生，因为很多程序员第一门语言就是 <code>C/C++</code>; 一些 <code>Lisp</code> 方言也支持宏(如 <code>Clojure</code>、<code>Scheme</code>), 听说它们的宏写起来很优雅；一些现代的编程语言对宏也有一定的支持，如 <code>Rust</code>、<code>Nim</code>、<code>Julia</code>、<code>Elixir</code>，它们是如何解决技术问题, 实现类Lisp的宏系统的？宏在这些语言中扮演这什么角色…</em></p><blockquote><p>如果没读过上篇文章，请先阅读一下，避免影响对本篇文章内容的理解。</p></blockquote><p><br></p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#关于宏">关于宏</a><ul><li><a href="#文本替换式">文本替换式</a></li><li><a href="#语法扩展式">语法扩展式</a></li><li><a href="#sweetjs">Sweet.js</a></li><li><a href="#小结">小结</a></li></ul></li><li><a href="#既生-plugin-何生-macro">既生 Plugin 何生 Macro</a></li><li><a href="#如何写一个-babel-macro">如何写一个 Babel Macro</a><ul><li><a href="#实战">实战</a></li></ul></li><li><a href="#扩展资料">扩展资料</a></li></ul><!-- /TOC --><p><br></p><h2 id="关于宏"><a href="#关于宏" class="headerlink" title="关于宏"></a>关于宏</h2><p><a href="https://zh.wikipedia.org/wiki/巨集" target="_blank" rel="noopener"><code>Wiki</code></a> 上面对‘宏’的定义是：<strong>宏(Macro), 是一种批处理的称谓，它根据一系列的预定义规则转换一定的文本模式。<code>解释器</code>或<code>编译器</code>在遇到宏时会自动进行这一模式转换，这个转换过程被称为“宏展开(Macro Expansion)”。对于编译语言，宏展开在编译时发生，进行宏展开的工具常被称为宏展开器。</strong></p><p>你可以认为，<strong>宏就是用来生成代码的代码，它有能力进行一些句法解析和代码转换</strong>。宏大致可以分为两种: <strong>文本替换</strong>和<strong>语法扩展</strong></p><p><br></p><h3 id="文本替换式"><a href="#文本替换式" class="headerlink" title="文本替换式"></a>文本替换式</h3><p>大家或多或少有接触过宏，很多程序员第一门语言是<code>C/C++</code>(包括C的衍生语言<code>Objective-C</code>),  在<code>C</code>中就有宏的概念。使用<code>#define</code>指令定义一个宏:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(X, Y) ((X) &lt; (Y) ? (X) : (Y))</span></span><br></pre></td></tr></table></figure><p>如果我们的程序使用了这个宏，就会在编译阶段被展开，例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MIN(a + b, c + d)</span><br></pre></td></tr></table></figure><p>会被展开为:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">((a + b) &lt; (c + d) ? (a + b) : (c + d))</span><br></pre></td></tr></table></figure><p><br></p><p>除了<code>函数宏</code>, <code>C</code> 中还有<code>对象宏</code>, 我们通常使用它来声明’常量’:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1214</span></span><br></pre></td></tr></table></figure><p><br></p><p><img src="/images/babel/c-compile.gif" alt></p><p>如上图，<strong>宏本质上不是<code>C</code>语言的一部分</strong>, 它由<code>C预处理器</code>提供，预处理器在编译之前对源代码进行<strong>文本替换</strong>，生成‘真正’的 <code>C</code> 代码，再传递给编译器。</p><blockquote><p>当然 C 预处理器不仅仅会处理宏，它还包含了头文件引入、条件编译、行控制等操作</p></blockquote><p>除此之外，<a href="https://segmentfault.com/a/1190000004104696" target="_blank" rel="noopener"><code>GNU m4</code></a>是一个更专业/更强大/更通用的预处理器(宏展开器)。这是一个通用的宏展开器，不仅可以用于 C，也可以用于其他语言和文本文件的处理(<em>参考这篇有趣的文章：<a href="https://segmentfault.com/a/1190000004342956" target="_blank" rel="noopener">《使用 GNU m4 为 Markdown 添加目录支持》</a></em>)， 关于<code>m4</code>可以看<a href="https://segmentfault.com/a/1190000004104696" target="_blank" rel="noopener">让这世界再多一份 GNU m4 教程</a> 系列文章.</p><p>文本替换式宏很容易理解、实现也简单，因为它们只是纯文本替换, 换句话说它就像‘文本编辑器’。所以相对而言，<strong>这种形式的宏能力有限，比如它不会检验语法是否合法, 使用它经常会出现问题</strong>。</p><p>所以<strong>随着现代编程语言表达能力越来越强，很多语言都不再推荐使用宏/不提供宏，而是使用语言本身的机制(例如函数)来解决问题，这样更安全、更容易理解和调试。没用宏机制，现代语言可以通过提供强大的反射机制或者动态编程特性(如Javascript的Proxy、Python的装饰器)来弥补缺失宏导致的元编程短板。 所以反过来推导，之所以<code>C</code>语言需要宏，正是因为<code>C</code>语言的表达能力太弱了</strong>。</p><p><br><br><br></p><h3 id="语法扩展式"><a href="#语法扩展式" class="headerlink" title="语法扩展式"></a>语法扩展式</h3><p>‘真正’的宏起源于<a href="https://zh.wikipedia.org/wiki/LISP" target="_blank" rel="noopener"><code>Lisp</code></a>. 这个得益于Lisp语言本身的一些特性：</p><p><img src="/images/babel/lisp.png" alt></p><p><br></p><ul><li><strong>它的语法非常简单</strong>。只有<a href="https://zh.wikipedia.org/wiki/S-表达式" target="_blank" rel="noopener">S-表达式(s-expression)</a>(<em>特征为括号化的前缀表示法, 可以认为S-表达式就是近似的 Lisp 的抽象语法树(AST)</em>)</li><li><strong>数据即代码</strong>。S-表达式本身就是树形数据结构。另外 Lisp 支持数据和代码之间的转换</li></ul><p><br></p><p>由于 Lisp 这种简单的语法结构，使得数据和程序之间只有一线之隔(<strong>quote修饰就是数据， 没有quote就是程序</strong>), 换句话说就是程序和数据之间可以灵活地转换。这种<code>数据即程序、程序即数据</code>的概念，使得Lisp可以轻松地自定义宏. 不妨来看一下Lisp定义宏的示例：</p><figure class="highlight clj"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 使用defmacro定义一个nonsense宏, 接收一个function-name参数. 宏需要返回一个quoted</span></span><br><span class="line"><span class="comment">; ` 这是quote函数的简写，表示quote，即这段‘程序’是一段‘数据’, 或者说将‘程序’转换为‘数据’. quote不会被‘求值’</span></span><br><span class="line"><span class="comment">; defun 定义一个函数</span></span><br><span class="line"><span class="comment">; , 这是unquote函数的简写， 表示unquote，即将‘数据’转换为‘程序’. unquote会进行求值</span></span><br><span class="line"><span class="comment">; intern 将字符串转换为symbol，即标识符</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> nonsense (<span class="name">function-name</span>)</span><br><span class="line">  `(<span class="name">defun</span> ,(<span class="name"><span class="builtin-name">intern</span></span> (<span class="name"><span class="builtin-name">concat</span></span> <span class="string">"nonsense-"</span> function-name)) (<span class="name">input</span>) <span class="comment">; 定义一个nonsense-$&#123;function-name&#125; 方法</span></span><br><span class="line">     (<span class="name">print</span> (<span class="name"><span class="builtin-name">concat</span></span> ,function-name input))))                   <span class="comment">; 输入`$&#123;function-name&#125;$&#123;input&#125;`</span></span><br></pre></td></tr></table></figure><details><br>  <summary>如果你不理解上面程序的含义，这里有一个Javascript的实现</summary><br><br>  注意：‘宏’一般在编译阶段被展开, 下面代码只是为了协作你理解上述的Lisp代码<br>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">nonsense</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> rtn</span><br><span class="line">   <span class="built_in">eval</span>(<span class="string">`rtn = function nonsense<span class="subst">$&#123;name&#125;</span>(input) &#123;</span></span><br><span class="line"><span class="string">     console.log('<span class="subst">$&#123;name&#125;</span>', input)</span></span><br><span class="line"><span class="string">   &#125;`</span>)</span><br><span class="line">   <span class="keyword">return</span> rtn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details><p><br></p><p>应用宏展开：</p><figure class="highlight clj"><table><tr><td class="code"><pre><span class="line">(<span class="name">nonsense</span> <span class="string">"apple"</span>)           <span class="comment">; 展开宏，这里会创建一个nonsense-apple函数</span></span><br><span class="line">(<span class="name">nonsense-apple</span> <span class="string">" is good"</span>)  <span class="comment">; 调用刚刚创建的宏</span></span><br><span class="line">                             <span class="comment">; =&gt; "apple is good"</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>对于Lisp而言，宏有点像一个函数, 只不过这个函数必须返回一个<code>quoted数据</code>; 当调用这个宏时，Lisp会使用<code>unquote</code>函数将宏返回的<code>quoted数据</code>转换为<code>程序</code></strong>。</p><p><img src="/images/babel/lisp-macro.png" alt></p><p><br></p><p>通过上面的示例，你会感叹Lisp的宏实现竟然如此清奇，如此简单。 搞得我想跟着<a href="http://tiye.me" target="_blank" rel="noopener">题叶</a>学一波<a href="https://clojure.org" target="_blank" rel="noopener">Clojure</a>，但是后来我学了<a href="https://elixir-lang.org" target="_blank" rel="noopener">Elixir</a> 😂.</p><p><img src="/images/babel/sicp.png" alt></p><p><br></p><p>Lisp宏的灵活性得益于简单的语法(S-表达式可以等价于它的AST)，对于复杂语法的语言(例如Javascript)，要实现类似Lisp的宏就难得多. 因此很少有现代语言提供宏机制可能也是这个原因。</p><p>尽管如此，现在很多技术难点慢慢被解决，很多现代语言也引入’类’ Lisp的宏机制，如<a href="https://doc.rust-lang.org/book/ch19-06-macros.html" target="_blank" rel="noopener">Rust</a>、<a href="https://julialang.org" target="_blank" rel="noopener">Julia</a>, 还有Javascript的 <a href="https://www.sweetjs.org/doc/tutorial" target="_blank" rel="noopener">Sweet.js</a></p><p><br><br><br></p><h3 id="sweet-js"><a href="#sweet-js" class="headerlink" title="Sweet.js"></a>Sweet.js</h3><p>Sweet.js 和 Rust 师出同门，所以两个的宏语法和非常接近(初期)。 不过需要注意的是: <strong>官方认为 Sweet.js 目前仍处于实验阶段</strong>，而且Github最后提交时间停留在2年前，社区上也未见大规模的使用。所以不要在生产环境中使用它，但是不妨碍我们去学习一个现代编程语言的宏机制。</p><p>我们先使用 <code>Sweet.js</code> 来实现上面我们通过 <code>Lisp</code> 实现的<code>nosense</code>宏, 对比起来更容易理解:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; unwrap, fromIdentifier, fromStringLiteral &#125; <span class="keyword">from</span> <span class="string">'@sweet-js/helpers'</span> <span class="keyword">for</span> syntax;</span><br><span class="line"></span><br><span class="line">syntax nosense = <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = ctx.next().value;</span><br><span class="line">  <span class="keyword">let</span> funcName = <span class="string">'nonsense'</span> + unwrap(name).value</span><br><span class="line"></span><br><span class="line">  return #`function $&#123;fromIdentifier(name, funcName)&#125; () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log($&#123;fromStringLiteral(name, unwrap(name).value)&#125; + input)</span><br><span class="line">  &#125;<span class="string">`;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nosense Apple</span></span><br><span class="line"><span class="string">nosenseApple(" is Good") // Apple is Good</span></span><br></pre></td></tr></table></figure><p><br></p><p>首先，Sweet.js使用<code>syntax</code>关键字来定义一个宏，其语法类似于<code>const</code>或者<code>let</code>。</p><p><strong>本质上一个宏就是一个函数, 只不过在编译阶段被执行</strong>. 这个函数接收一个 <a href="https://www.sweetjs.org/doc/reference#syntax-transformer" target="_blank" rel="noopener"><code>TransformerContext</code></a> 对象，你也通过这个对象获取宏应用传入的<strong>语法对象(Syntax Object)数组</strong>，最终这个宏也要返回<strong>语法对象数组</strong>。</p><p>什么是语法对象？语法对象是 Sweet.js 关于语法的内部表示, 你可以类比上文Lisp的 quoted 数据。<strong>在复杂语法的语言中，没办法使用 quoted 这么简单的序列来表示语法，而使用 AST 则更复杂，开发者更难以驾驭。所以大部分宏实现会参考 Lisp 的<code>S-表达式</code>，取折中方案，将传入的程序转换为Tokens，再组装成类似quoted的数据结构</strong>。</p><p>举个例子，Sweet.js 会将 <code>foo,bar(&#39;baz&#39;, 1)</code>转换成这样的数据结构:</p><p><img src="/images/babel/syntaxobject.png" alt></p><p>从上图可知，Sweet.js 会将传入的程序解析成<strong>嵌套的Token序列</strong>，这个结构和Lisp的<code>S-表达式</code>非常相似。也就是, 说对于闭合的词法单元会被嵌套存储，例如上例的<code>(&#39;baz&#39;, 1)</code>.</p><blockquote><p>Elixir 也采用了<a href="https://elixir-lang.org/getting-started/meta/quote-and-unquote.html" target="_blank" rel="noopener">类似的quote/unquote机制</a>，可以结合着一起理解</p></blockquote><p><br></p><p><code>TransformerContext</code>实现了迭代器方法，所以我们通过调用它的<code>next()</code>来遍历获取语法对象。最后宏必须返回一个语法对象数组，Sweet.js 使用了类似<code>字符串模板</code>的<a href="https://www.sweetjs.org/doc/reference#syntax-templates" target="_blank" rel="noopener">语法</a>(称为<code>语法模板</code>)来简化开发，这个模板最终转换为语法对象数组。</p><blockquote><p>需要注意的是<code>语法模板</code>的内嵌值只能是语法对象、语法对象序列或者TransformerContext.</p></blockquote><details><br><summary>旧版本使用了<a href="https://jlongster.com/Stop-Writing-JavaScript-Compilers--Make-Macros-Instead" target="_blank" rel="noopener">模式匹配</a>，和Rust语法类似，我个人更喜欢这个，不知为何废弃了</summary><br><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">macro define &#123;</span><br><span class="line">    rule &#123; $x &#125; =&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> $x</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rule &#123; $x = $expr &#125; =&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> $x = $expr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define y;</span><br><span class="line">define y = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><br><br></details><p><br></p><p>说了这么多，类似Sweet.js <code>语法对象</code> 的设计是现代编程语言为了贴近 Lisp 宏的一个关键技术点。我发现<code>Elixir</code>、<code>Rust</code>等语言也使用了类似的设计。 除了数据结构的设计，现代编程语言的宏机制还包含以下特性：</p><p><br></p><p><strong>1️⃣ 卫生宏(Hygiene)</strong></p><p>卫生宏指的是在宏内生成的变量不会污染外部作用域，也就是说，在宏展开时，Sweet.js 会避免宏内定义的变量和外部冲突.</p><p>举个例子，我们创建一个swap宏，交换变量的值:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">syntax swap = <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> a = ctx.next().value</span><br><span class="line"> ctx.next() <span class="comment">// 吃掉','</span></span><br><span class="line"> <span class="keyword">const</span> b = ctx.next().value</span><br><span class="line"> return #`</span><br><span class="line"> <span class="keyword">let</span> temp = $&#123;a&#125;</span><br><span class="line"> $&#123;a&#125; = $&#123;b&#125;</span><br><span class="line"> $&#123;b&#125; = temp</span><br><span class="line"> <span class="string">`;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">swap foo,bar</span></span><br></pre></td></tr></table></figure><p>展开会输出为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> temp_10 = foo; <span class="comment">// temp变量被重命名为temp_10</span></span><br><span class="line">foo = bar;</span><br><span class="line">bar = temp_10;</span><br></pre></td></tr></table></figure><p>如果你想引用外部的变量，也可以。不过不建议这么做，<strong>宏不应该假定其被展开的上下文</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">syntax swap = <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  return #`</span><br><span class="line">  temp = $&#123;a&#125; <span class="comment">// 不使用 let 声明</span></span><br><span class="line">  $&#123;a&#125; = $&#123;b&#125;</span><br><span class="line">  $&#123;b&#125; = temp</span><br><span class="line">  <span class="string">`;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>2️⃣ 模块化</strong></p><p>Sweet.js 的宏是模块化的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'lang sweet.js'</span>;</span><br><span class="line"><span class="comment">// 导出宏</span></span><br><span class="line"><span class="keyword">export</span> syntax <span class="class"><span class="keyword">class</span> </span>= <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>导入：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="class"><span class="keyword">class</span> &#125; <span class="title">from</span> './<span class="title">es2015</span>-<span class="title">macros</span>'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Droid</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, color) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rollWithIt(it) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">" is rolling with "</span> + it;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>相对Babel(编译器)来说，Sweet.js的宏是模块化/显式的。Babel你需要在配置文件中配置各种插件和选项，尤其是团队项目构建有统一规范和环境时，项目构建脚本修改可能有限制。而模块化的宏是源代码的一部分，而不是构建脚本的一部分，这使得它们可以被灵活地使用、重构以及废弃</strong>。</p><p>下文介绍的 <code>babel-plugin-macros</code> 最大的优势就在这里, 通常<strong>我们希望构建环境是统一的、稳定的、开发人员应该专注于代码的开发，而不是如何去构建程序，正是因为代码多变性，才催生出了这些方案</strong>。</p><p><br></p><p>需要注意的是<strong>宏是在编译阶段展开</strong>的，所以无法运行用户代码，例如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> log = <span class="function"><span class="params">msg</span> =&gt;</span> <span class="built_in">console</span>.log(msg); <span class="comment">// 用户代码, 运行时被求值，所以无法被访问</span></span><br><span class="line"></span><br><span class="line">syntax m = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 宏函数在编译阶段被执行</span></span><br><span class="line">  log(<span class="string">'doing some Sweet things'</span>); <span class="comment">// ERROR: 未找到变量log</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><p>Sweet.js 和其他语言的宏一样，有了它你可以:</p><ul><li>新增语法糖(和Sweet.js 一样甜), 实现复合自己口味的语法或者某些实验性的语言特性</li><li>自定义<a href="https://www.sweetjs.org/doc/tutorial#sweet-operators" target="_blank" rel="noopener">操作符</a>, 很强大</li><li>消灭重复的代码，提升语言的表达能力。</li><li>…</li><li>别炫技</li></ul><p><br></p><p>🤕很遗憾！Sweet.js 基本死了。所以现在当个玩具玩玩尚可，切勿用于生产环境。即使没有死，Sweet.js 这种非标准的语法, 和现有的Javascript工具链生态格格不入，开发和调试都会比较麻烦(比如Typescript).</p><p>归根到底，Sweet.js 的失败，是社区抛弃了它。Javascript语言表达能力越来越强，版本迭代快速，加上有了Babel和Typescript这些解决方案，实在拿不出什么理由来使用 Sweet.js</p><blockquote><p>Sweet.js 相关论文可以看<a href="https://github.com/sweet-js/sweet-core/wiki/Macro-resources" target="_blank" rel="noopener">这里</a></p></blockquote><p><br></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这一节扯得有点多，将宏的历史和分类讲了个遍。 最后的总结是Elixir官方教程里面的一句话：<strong>显式好于隐式，清晰的代码优于简洁的代码(Clear code is better than concise code)</strong></p><p>能力越大、责任越大。宏强大，比正常程序要更难以驾驭，你可能需要一定的成本去学习和理解它, 所以能不用宏就不用宏，<strong>宏是应该最后的法宝</strong>.</p><p><br><br><br></p><h2 id="既生-plugin-何生-macro"><a href="#既生-plugin-何生-macro" class="headerlink" title="既生 Plugin 何生 Macro"></a>既生 Plugin 何生 Macro</h2><p>🤓还没完， 一下子扯了好远，掰回正题。既然 Babel 有了 Plugin 为什么又冒出了个 <a href="https://github.com/kentcdodds/babel-plugin-macros" target="_blank" rel="noopener"><code>babel-plugin-macros</code></a>?</p><blockquote><p>如果你尚不了解Babel Macro，可以先读一下<a href="https://github.com/kentcdodds/babel-plugin-macros" target="_blank" rel="noopener">官方文档</a>, 另外<a href="https://create-react-app.dev" target="_blank" rel="noopener">Creact-React-APP</a> 已经内置</p></blockquote><p>这个得从 <a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">Create-React-App(CRA)</a> 说起，CRA 将所有的项目构建逻辑都封装在<a href="https://github.com/facebook/create-react-app/tree/master/packages/react-scripts" target="_blank" rel="noopener"><code>react-scripts</code></a> 服务中。<strong>这样的好处是，开发者不需要再关心构建的细节, 另外构建工具的升级也变得非常方便, 直接升级 <code>react-scripts</code>即可</strong>。</p><p>如果自己维护构建脚本的话，升一次级你需要升级一大堆的依赖，如果你要维护跨项目的构建脚本，那就更蛋疼了。</p><blockquote><p>我在<a href="https://juejin.im/post/5d2fcaacf265da1b95708f63" target="_blank" rel="noopener">《为什么要用vue-cli3?》</a> 里阐述了 CRA 以及 Vue-cli这类的工具对团队项目维护的重要性。</p></blockquote><p>CRA 是<strong>强约定</strong>的，它是按照React社区的最佳实践给你准备的，为了保护封装带来的红利，它不推荐你去手动配置Webpack、Babel… 所以才催生除了 babel-plugin-macros, 大家可以看这个 <a href="https://github.com/facebook/create-react-app/issues/2730" target="_blank" rel="noopener">Issue: RFC - babel-macros</a></p><p><strong>所以为 Babel 寻求一个’零配置’的机制是 <code>babel-plugin-macros</code> 诞生的主要动机</strong>。</p><p>这篇文章正好证实了这个动机：<a href="https://babeljs.io/blog/2017/09/11/zero-config-with-babel-macros" target="_blank" rel="noopener">《Zero-config code transformation with babel-plugin-macros》</a>, 这篇文章引述了一个重要的观点：”<strong>Compilers are the New Frameworks</strong>“</p><p>的确，<strong>Babel 在现代的前端开发中扮演着一个很重要的角色，越来越多的框架或库会创建自己的 Babel 插件，它们会在编译阶段做一些优化，来提高用户体验、开发体验以及运行时的性能</strong>。比如:</p><ul><li><a href="https://github.com/lodash/babel-plugin-lodash" target="_blank" rel="noopener">babel-plugin-lodash</a> 将lodash导入转换为按需导入</li><li><a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="noopener">babel-plugin-import</a> 上篇文章提过的这个插件，也是实现按需导入</li><li><a href="https://github.com/jamiebuilds/babel-react-optimize" target="_blank" rel="noopener">babel-react-optimize</a> 静态分析React代码，利用一定的措施优化运行效率。比如将静态的props或组件抽离为常量</li><li><a href="https://github.com/entwicklerstube/babel-plugin-root-import" target="_blank" rel="noopener">root-import</a> 将基于根目录的导入路径重写为相对路径</li><li><a href="https://www.styled-components.com/docs/tooling#babel-macro" target="_blank" rel="noopener">styled-components</a> 典型的CSS-in-js方案，利用Babel 插件来支持服务端渲染、预编译模板、样式压缩、清除死代码、提升调试体验。</li><li><a href="https://github.com/kentcdodds/babel-plugin-preval" target="_blank" rel="noopener">preval</a> 在编译时预执行代码</li><li><a href="https://www.apollographql.com/docs/react/v2.5/recipes/babel/#using-babel-plugin-graphql-tag" target="_blank" rel="noopener">babel-plugin-graphql-tag</a> 预编译GraphQL查询</li><li>…</li></ul><p><br></p><p>上面列举的插件场景中，<strong>并不是所有插件都是通用的，它们要么是跟某一特定的框架绑定、要么用于处理特定的文件类型或数据。这些非通用的插件是最适合使用macro取代的</strong>。</p><p>用 <code>preval</code> 举个例子. 使用插件形式, 你首先要配置插件:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [<span class="string">"preval"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传递给preval的字符串会在编译阶段被执行</span></span><br><span class="line"><span class="comment">// preval插件会查找preval标识符，将字符串提取出来执行，在将执行的结果赋值给greeting</span></span><br><span class="line"><span class="keyword">const</span> greeting = preval<span class="string">`</span></span><br><span class="line"><span class="string">  const fs = require('fs')</span></span><br><span class="line"><span class="string">  module.exports = fs.readFileSync(require.resolve('./greeting.txt'), 'utf8')</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p><br></p><p>使用Macro方式:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先你要显式导入</span></span><br><span class="line"><span class="keyword">import</span> preval <span class="keyword">from</span> <span class="string">'preval.macro'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 和上面一样</span></span><br><span class="line"><span class="keyword">const</span> greeting = preval<span class="string">`</span></span><br><span class="line"><span class="string">  const fs = require('fs')</span></span><br><span class="line"><span class="string">  module.exports = fs.readFileSync(require.resolve('./greeting.txt'), 'utf8')</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p><br></p><p>这两者达到的效果是一样的，但意义却不太一样。有哪些区别？</p><ul><li><p>1️⃣ <strong>很显然，Macro不需要配置<code>.babelrc</code></strong>(<em>当然babel-plugin-macros这个基座需要装好</em>). 这个对于CRA这种不推荐配置构建脚本的工具来说很有帮助</p></li><li><p>2️⃣ <strong>由隐式转换为了显式</strong>。上一节就说了“显式好于隐式”。你必须在源代码中通过<code>导入语句</code>声明你使用了 Macro； 而基于插件的方式，你可能不知道<code>preval</code>这个标识符哪里来的? 如何被应用？何时被应用？而且通常你还需要和其他工具链的配合，例如ESlint、Typescript声明等等。</p><p>  Macro 由代码显式地应用，我们更明确它被应用的目的和时机，对源代码的侵入性最小。因为中间多了 <code>babel-plugin-macro</code> 这一层，我们降低了对构建环境的耦合，让我们的代码更方便被迁移。</p></li><li><p>3️⃣ <strong>Macro相比Plugin 更容易被实现</strong>。因为它专注于具体的 AST 节点，见下文</p></li><li><p>4️⃣ 另外，当配置出错时，Macro可以得到更好的错误提示</p></li></ul><p>有利有弊，Babel Macro 肯定也有些缺陷，例如相对于插件来说只能<em>显式转换</em>，这样代码可能会比较啰嗦，不过个人觉得在某些场景利大于弊, 能显式的就显式。</p><p><br></p><p>那么Babel Macro也是宏？<strong>相对于 Sweet.js 这些’正统’的宏机制有哪些不足</strong>？</p><ul><li><p><strong>首先 Babel Macro 必须是合法的 Javascript 语法</strong>。不支持自定义语法，也要分两面讨论，合法的Javascript语法不至于打破现有的工具协作链，如果允许用户毫无限制地创建新的语法，将来指不定会和标准的语法发生歧义。 反过来不能自定义语法的‘宏’，是否显得不太地道，不够’强大’?</p></li><li><p><strong>因为必须是合法的Javascript语法，Babel Macro 实现DSL(Domain-specific languages)能力就弱化了</strong></p></li><li><p><strong>再者，Babel Macro 和 Babel Plugin没有本质的区别</strong>，相比Sweet.js提供了显式定义和应用宏的语法，Babel Macro直接操作 AST 则要复杂得多，你还是需要了解一些编译原理，这把一般的开发者挡在了门外。</p></li></ul><blockquote><p>Babel 可以实现自定义语法，只不过你需要Fork <code>@babel/parser</code>, 对它进行改造(可以看这篇文章<a href="https://juejin.im/post/5d9be731f265da5bbc3e879b" target="_blank" rel="noopener">《精读《用 Babel 创造自定义 JS 语法》》</a>)。这个有点折腾，不太推荐</p></blockquote><p><br></p><p><strong>总之，Babel Macro 本质上和Babel Plugin没有什么区别，它只是在Plugin 之上封装了一层(<a href="https://juejin.im/post/5d7ffad551882545ff173083" target="_blank" rel="noopener">分层架构模式的强大</a>)，创建了一个新的平台，让开发者可以在源代码层面显式地应用代码转换</strong>。所以，<strong>任何适合显式去转换的场景都适合用Babel Macro来做</strong>：</p><ul><li>特定框架、库的代码转换。如 <code>styled-components</code></li><li>动态生成代码。<code>preval</code></li><li>特定文件、语言的处理。例如<code>graphql-tag.macro</code>、<code>yaml.macro</code>、<code>svgr.macro</code></li><li>… (查看<a href="https://github.com/jgierer12/awesome-babel-macros#graphql" target="_blank" rel="noopener">awesome-babel-macros</a>)</li></ul><p><br><br><br></p><h2 id="如何写一个-babel-macro"><a href="#如何写一个-babel-macro" class="headerlink" title="如何写一个 Babel Macro"></a>如何写一个 Babel Macro</h2><p>所以，Babel Macro是如何运作的呢？ <code>babel-plugin-macros</code> 要求开发者必须显式地导入 Macro，它会遍历匹配所有导入语句，<strong>如果导入源匹配<code>/[./]macro(\.js)?$/</code>正则，就会认为你在启用Macro</strong>。例如下面这些导入语句都匹配正则：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'my.macro'</span></span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">'./bar/macro'</span></span><br><span class="line"><span class="keyword">import</span> &#123; baz <span class="keyword">as</span> _baz&#125; <span class="keyword">from</span> <span class="string">'baz/macro.js'</span></span><br><span class="line"><span class="comment">// 不支持命名空间导入</span></span><br></pre></td></tr></table></figure><p><br></p><p>Ok, 当匹配到导入语句后，<code>babel-plugin-macros</code>就会去导入你指定的 <code>macro</code> <strong>模块或者npm包</strong>(Macro 即可以是本地文件，也可以是公开的 npm 包， 或者是npm包中的子路径)。</p><p>那么 <code>macro</code> 文件里面要包含什么内容呢？如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createMacro &#125; = <span class="built_in">require</span>(<span class="string">'babel-plugin-macros'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createMacro(<span class="function">(<span class="params">&#123;references, state, babel&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ... macro 逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p><code>macro</code> 文件必须默认导出一个由 <code>ceateMacro</code> 创建的实例, 在其回调中可以获取到一些关键对象：</p><ul><li><code>babel</code> 和普通的Babel插件一样，Macro 可以获取到一个 <code>babel-core</code> 对象</li><li><code>state</code> 这个我们也比较熟悉，Babel 插件的 visitor 方法的第二个参数就是它, 我们可以通过它获取一些配置信息以及保存一些自定义状态</li><li><code>references</code> 获取 Macro 导出标识符的所有引用。上一篇文章介绍了作用域，你应该还没忘记绑定和引用的概念。如下</li></ul><p>假设用户这样子使用你的 Macro:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> foo, &#123;bar, baz <span class="keyword">as</span> Baz&#125; <span class="keyword">from</span> <span class="string">'./my.macro'</span> <span class="comment">// 创建三个绑定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面开始引用这些绑定</span></span><br><span class="line">foo(<span class="number">1</span>)</span><br><span class="line">foo(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">bar<span class="string">`by tagged Template`</span></span><br><span class="line">;<span class="xml"><span class="tag">&lt;<span class="name">Baz</span>&gt;</span>by JSX<span class="tag">&lt;/<span class="name">Baz</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>那么你将拿到<code>references</code>结构是这样的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// key 为'绑定', value 为'引用数组'</span></span><br><span class="line">  <span class="keyword">default</span>: [NodePath<span class="comment">/*Identifier(foo)*/</span>, NodePath<span class="comment">/*Identifier(foo)*/</span>], <span class="comment">// 默认导出，即foo</span></span><br><span class="line">  bar: [NodePath<span class="comment">/*Identifier(bar)*/</span>],</span><br><span class="line">  baz: [NodePath<span class="comment">/*JSXIdentifier(Baz)*/</span>], <span class="comment">// 注意key为baz，不是Baz</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>查看<a href="https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/author.md" target="_blank" rel="noopener">详细开发指南</a> <br><br><a href="https://astexplorer.net" target="_blank" rel="noopener">AST Explorer</a> 也支持 babel-plugin-macros，可以玩一下. 下面的实战实例，也建议在这里探索一下</p></blockquote><p>接下来你就可以遍历<code>references</code>, 对这些节点进行转换，实现你想要的宏功能。开始实战!</p><p><br><br><br></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>这一次我们模范<a href="https://github.com/kentcdodds/babel-plugin-preval/blob/master/src/object-to-ast.js" target="_blank" rel="noopener"><code>preval</code></a> 创建一个<code>eval.macro</code> Macro, 利用它在编译阶段执行(eval)一些代码。例如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> evalm <span class="keyword">from</span> <span class="string">'eval.macro'</span></span><br><span class="line"><span class="keyword">const</span> x = evalm<span class="string">`</span></span><br><span class="line"><span class="string">function fib(n) &#123;</span></span><br><span class="line"><span class="string">  const SQRT_FIVE = Math.sqrt(5);</span></span><br><span class="line"><span class="string">  return Math.round(1/SQRT_FIVE * (Math.pow(0.5 + SQRT_FIVE/2, n) - Math.pow(0.5 - SQRT_FIVE/2, n)));</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fib(20)</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      ↓ ↓ ↓ ↓ ↓ ↓</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">6765</span></span><br></pre></td></tr></table></figure><p><br></p><p>创建 Macro 文件. 按照上一节的介绍，① 我们使用<code>createMacro</code>来创建一个 <code>Macro</code>实例, ② 并从<code>references</code> 中拿出所有<code>导出标识符</code>的引用路径, ③接着就是对这些引用路径进行AST转换:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createMacro, MacroError &#125; = <span class="built_in">require</span>(<span class="string">'babel-plugin-macros'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myMacro</span>(<span class="params">&#123; references, state, babel &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取默认导出的所有引用</span></span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">default</span>: defaultImport = [] &#125; = references;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 遍历引用并进行求值</span></span><br><span class="line">  defaultImport.forEach(<span class="function"><span class="params">referencePath</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (referencePath.parentPath.type === <span class="string">"TaggedTemplateExpression"</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> val = referencePath.parentPath.get(<span class="string">"quasi"</span>).evaluate().value</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">eval</span>(val)</span><br><span class="line">      <span class="keyword">const</span> ast = objToAst(res)</span><br><span class="line">      referencePath.parentPath.replaceWith(ast)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 输出友好的报错信息</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> MacroError(<span class="string">'只支持标签模板字符串, 例如：evalm`1`'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createMacro(myMacro);</span><br></pre></td></tr></table></figure><p><br></p><p>为了行文简洁，本案例中只支持<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings" target="_blank" rel="noopener"><code>标签模板字符串</code></a> 形式调用，但是标签模板字符串中可能包含内插的字符串，例如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hello<span class="string">`</span></span><br><span class="line"><span class="string">hello world <span class="subst">$&#123;foo&#125;</span> + <span class="subst">$&#123;bar + baz&#125;</span></span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>其 AST 结构如下:</p><p><img src="/images/babel/tag-template.png" alt></p><p><br></p><p>我们需要将 <code>TaggedTemplateExpression</code> 节点转换为字符串。手动去拼接会很麻烦，好在每个 AST 节点的 Path 对象都有一个<code>evaluate</code> 方法，这个方法可以对节点进行‘静态求值’：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">t.evaluate(parse(<span class="string">"5 + 5"</span>)) <span class="comment">// &#123; confident: true, value: 10 &#125;</span></span><br><span class="line">t.evaluate(parse(<span class="string">"!true"</span>)) <span class="comment">// &#123; confident: true, value: false &#125;</span></span><br><span class="line"><span class="comment">// ❌两个变量相加无法求值，因为变量值在运行时才存在，这里confident为false：  </span></span><br><span class="line">t.evaluate(parse(<span class="string">"foo + foo"</span>)) <span class="comment">// &#123; confident: false, value: undefined &#125;</span></span><br></pre></td></tr></table></figure><p>因此这样子的标签模板字符串是无法求值的:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">evalm<span class="string">`1 + <span class="subst">$&#123;foo&#125;</span>`</span> <span class="comment">// 包含变量</span></span><br><span class="line">evalm<span class="string">`1 + <span class="subst">$&#123;bar(<span class="number">1</span>)&#125;</span>`</span> <span class="comment">// 包含函数调用</span></span><br></pre></td></tr></table></figure><p><strong>这个和 <code>Typescript</code> 的 <a href="https://www.typescriptlang.org/docs/handbook/enums.html" target="_blank" rel="noopener"><code>enum</code></a>， 还有一些编译语言的常量是一样的，它们在编译阶段被求值，只有一些原始值以及一些原始值的表达式才支持在编译阶段被求值</strong>.</p><p><br></p><p>So，上面的代码还不够健壮，我们再优化一下，在求值失败时给用户更好的提示:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">defaultImport.forEach(<span class="function"><span class="params">referencePath</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (referencePath.parentPath.type === <span class="string">"TaggedTemplateExpression"</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> evaluated = referencePath.parentPath.get(<span class="string">"quasi"</span>).evaluate();</span><br><span class="line">    <span class="comment">// 转换标签模板字符串失败</span></span><br><span class="line">    <span class="keyword">if</span> (!evaluated.confident) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> MacroError(<span class="string">"标签模板字符串内插值只支持原始值和原始值表达式"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">eval</span>(evaluated.value);</span><br><span class="line">      <span class="keyword">const</span> ast = objToAst(res);</span><br><span class="line">      <span class="comment">// 替换掉调用节点</span></span><br><span class="line">      referencePath.parentPath.replaceWith(ast);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> MacroError(<span class="string">`求值失败: <span class="subst">$&#123;err.message&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MacroError(<span class="string">"只支持标签模板字符串, 例如：evalm`1 + 1`"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p>接下来将执行后的值转换为 AST，然后替换掉<code>TaggedTemplateExpression</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToAst</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(res);</span><br><span class="line">  <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">    str = <span class="string">"undefined"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> variableDeclarationNode = babel.template(<span class="string">`var x = <span class="subst">$&#123;str&#125;</span>`</span>, &#123;&#125;)();</span><br><span class="line">  <span class="comment">// 取出初始化表达式的 AST</span></span><br><span class="line">  <span class="keyword">return</span> variableDeclarationNode.declarations[<span class="number">0</span>].init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>@babel/template</code> 就派上用场了，它可以将字符串代码解析成 AST，当然直接使用<code>parse</code>方法解析也是可以的。</p><p><br></p><p>Ok, 文章到这里基本结束了。本文对‘宏’进行了深入的讨论，从 <code>C</code> 语言的文本替换宏到濒死的<code>Sweet.js</code>, 最后介绍了<code>babel-plugin-macros</code>.</p><p>Babel Macro 本质上还是Babel 插件，只不过它是模块化的，你要使用它必须显式地导入。和‘正统’宏相比， Babel Macro 直接操作 AST，需要你掌握编译原理， ‘正统’宏可以实现的东西, Babel Macro也可以实现(例如卫生宏). 虽然相比Babel插件略有简化，还是比较啰嗦。另外Babel Macro 不能创建新的语法，这使得它可以和现有的工具生态保持兼容。</p><p>最后！打开脑洞 🧠，Babel Macro 可以做很多有意思的东西，查看<a href="https://github.com/jgierer12/awesome-babel-macros" target="_blank" rel="noopener">《Awesome babel macros》</a>。不过要<strong>谨记：‘显式好于隐式，清晰的代码优于简洁的代码’</strong></p><p><br></p><p><strong>截止 2019.10.10 掘金粉丝数已经突破 ✨2000✨，继续关注我，点赞给我支持</strong>。</p><p><br></p><p><img src="/images/sponsor.jpg" alt></p><p><br></p><h2 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h2><ul><li><a href="https://babeljs.io/blog/2017/09/11/zero-config-with-babel-macros" target="_blank" rel="noopener">Zero-config code transformation with babel-plugin-macros</a></li><li><a href="https://github.com/facebook/create-react-app/issues/2730" target="_blank" rel="noopener">RFC - babel-macros</a></li><li><a href="https://jlongster.com/Stop-Writing-JavaScript-Compilers--Make-Macros-Instead" target="_blank" rel="noopener">STOP WRITING JAVASCRIPT COMPILERS! MAKE MACROS INSTEAD</a></li><li><a href="https://blog.oyanglul.us/javascript/clojure-essence-in-javascript-macro" target="_blank" rel="noopener">JavaScript玩转Clojure大法之 - Macro (1)</a></li><li><a href="https://elixir-lang.org/getting-started/meta/macros.html" target="_blank" rel="noopener">Elixir Macro</a></li><li><a href="https://kaisery.gitbooks.io/rust-book-chinese/content/content/Macros%20宏.html" target="_blank" rel="noopener">Rust 的宏</a></li><li><a href="https://juejin.im/post/5cebce946fb9a07ece67aec4" target="_blank" rel="noopener">iOS深思篇 | 宏定义</a></li><li><a href="https://medium.com/@fxn/how-does-elixir-compile-execute-code-c1b36c9ec8cf" target="_blank" rel="noopener">How does Elixir compile/execute code?</a></li><li><a href="https://segmentfault.com/a/1190000004104696" target="_blank" rel="noopener">让这世界再多一份 GNU m4 教程 (1)</a></li><li><a href="https://segmentfault.com/a/1190000004050807" target="_blank" rel="noopener">宏语言为何不受欢迎</a></li><li><a href="https://github.com/babel/awesome-babel" target="_blank" rel="noopener">awesome-babel</a></li><li><a href="https://www.zhihu.com/question/19875500" target="_blank" rel="noopener">各编程语言对「宏」的支持是怎样的？</a></li><li><a href="https://github.com/sweet-js/sweet-core/wiki/Macro-resources" target="_blank" rel="noopener">Sweetjs 相关论文</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接着上篇文章: &lt;a href=&quot;https://juejin.im/post/5d94bfbf5188256db95589be&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《深入浅出 Babel 上篇：架构和原理 + 实战 🔥》&lt;/a&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>深入浅出 Babel 上篇：架构和原理 + 实战</title>
    <link href="https://bobi.ink/2019/10/01/babel/"/>
    <id>https://bobi.ink/2019/10/01/babel/</id>
    <published>2019-09-30T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>国庆放假了，我还在利用碎片时间在写文章，不知道长假还有没有人看，试试水吧！</p><p>这个文章系列将带大家深入浅出 <a href="https://babeljs.io" target="_blank" rel="noopener"><code>Babel</code></a>, 这个系列将分为上下两篇：上篇主要介绍 Babel 的架构和原理，顺便实践一下插件开发的；下篇会介绍 <a href="https://github.com/kentcdodds/babel-plugin-macros" target="_blank" rel="noopener">`babel-plugin-macros </a>, 利用它来写属于 Javascript 的’宏‘，</p><p>✨满满的干货，不容错过哦. 写文不易，点赞是最大的鼓励。</p><blockquote><p>注意: 本文不是 Babel 的基础使用教程！如果你对 Babel 尚不了解，请查看<a href="https://babeljs.io" target="_blank" rel="noopener">官方网站</a>, 或者这个<a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md" target="_blank" rel="noopener">用户手册</a></p></blockquote><p><br></p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#babel-的处理流程">Babel 的处理流程</a></li><li><a href="#babel-的架构">Babel 的架构</a></li><li><a href="#访问者模式">访问者模式</a><ul><li><a href="#节点的遍历">节点的遍历</a></li><li><a href="#节点的上下文">节点的上下文</a></li><li><a href="#副作用的处理">副作用的处理</a></li><li><a href="#作用域的处理">作用域的处理</a></li></ul></li><li><a href="#搞一个插件呗">搞一个插件呗</a></li><li><a href="#最后">最后</a></li><li><a href="#扩展">扩展</a></li></ul><!-- /TOC --><p><br></p><h2 id="babel-的处理流程"><a href="#babel-的处理流程" class="headerlink" title="Babel 的处理流程"></a>Babel 的处理流程</h2><p><img src="/images/babel/process.png" alt><br><i>Babel 的处理流程</i></p><p><br></p><p>上图是 Babel 的处理流程, 如果读者学习过<code>编译器原理</code>，这个过程就相当亲切了.</p><p>首先从源码 <code>解析(Parsing)</code> 开始，解析包含了两个步骤:</p><p><strong>1️⃣词法解析(Lexical Analysis)</strong>： <code>词法解析器(Tokenizer)</code>在这个阶段将字符串形式的代码转换为<code>Tokens(令牌)</code>. Tokens 可以视作是一些语法片段组成的数组. 例如<code>for (const item of items) {}</code> 词法解析后的结果如下:</p><p><img src="/images/babel/tokens.png" alt></p><p>从上图可以看，每个 Token 中包含了语法片段、位置信息、以及一些类型信息. 这些信息有助于后续的语法分析。</p><p><br></p><p><strong>2️⃣语法解析(Syntactic Analysis)</strong>：这个阶段语法<code>解析器(Parser)</code>会把<code>Tokens</code>转换为<code>抽象语法树(Abstract Syntax Tree，AST)</code></p><p><strong>什么是AST</strong>?</p><p>它就是一棵’对象树’，用来表示代码的语法结构，例如<code>console.log(&#39;hello world&#39;)</code>会解析成为:</p><p><img src="/images/babel/ast.png" alt></p><p><code>Program</code>、<code>CallExpression</code>、<code>Identifier</code> <strong>这些都是节点的类型，每个节点都是一个有意义的语法单元</strong>。 这些节点类型定义了一些属性来描述节点的信息。</p><p>JavaScript的语法越来越复杂，而且 Babel 除了支持最新的JavaScript规范语法, 还支持 <code>JSX</code>、<code>Flow</code>、现在还有<code>Typescript</code>。想象一下 AST 的节点类型有多少，其实我们不需要去记住这么多类型、也记不住. <strong>插件开发者会利用 <a href="https://astexplorer.net" target="_blank" rel="noopener"><code>ASTExplorer</code></a> 来审查解析后的AST树</strong>, 非常强大👍。</p><p><strong>AST 是 Babel 转译的核心数据结构，后续的操作都依赖于 AST</strong>。</p><p><br></p><p>接着就是<strong>转换(Transform)</strong>了，转换阶段会对 AST 进行遍历，在这个过程中对节点进行增删查改。Babel 所有插件都是在这个阶段工作, 比如语法转换、代码压缩。</p><p><br></p><p><strong>Javascript In Javascript Out</strong>, 最后阶段还是要把 AST 转换回字符串形式的Javascript，同时这个阶段还会生成Source Map。</p><p><br><br><br></p><h2 id="babel-的架构"><a href="#babel-的架构" class="headerlink" title="Babel 的架构"></a>Babel 的架构</h2><p>我在<a href="https://juejin.im/post/5d7ffad551882545ff173083" target="_blank" rel="noopener">《透过现象看本质: 常见的前端架构风格和案例🔥》</a> 提及 <code>Babel</code> 和 <code>Webpack</code> 为了适应复杂的定制需求和频繁的功能变化，都使用了<a href="https://juejin.im/post/5d7ffad551882545ff173083#heading-10" target="_blank" rel="noopener">微内核</a> 的架构风格。<strong>也就是说它们的核心非常小，大部分功能都是通过插件扩展实现的</strong>。</p><p><br></p><p>所以简单地了解一下 Babel 的架构和一些基本概念，对后续文章内容的理解, 以及Babel的使用还是有帮助的。</p><p><strong>一图胜千言</strong>。仔细读过我文章的朋友会发现，我的风格就是能用图片说明的就不用文字、能用文字的就不用代码。<strong>虽然我的原创文章篇幅都很长，图片还是值得看看的</strong>。</p><p><img src="/images/babel/arch.png" alt></p><p><br></p><p>Babel 是一个 <a href="https://github.com/lerna/lerna" target="_blank" rel="noopener"><code>MonoRepo</code></a> 项目， 不过组织非常清晰，下面就源码上我们能看到的模块进行一下分类， 配合上面的架构图让你对Babel有个大概的认识:</p><p><br></p><p><strong>1️⃣ 核心</strong>:</p><p><code>@babel/core</code> 这也是上面说的‘微内核’架构中的‘内核’。对于Babel来说，这个内核主要干这些事情：</p><ul><li>加载和处理配置(config)</li><li>加载插件</li><li>调用 <code>Parser</code> 进行语法解析，生成 <code>AST</code></li><li>调用 <code>Traverser</code> 遍历AST，并使用<code>访问者模式</code>应用’插件’对 AST 进行转换</li><li>生成代码，包括SourceMap转换和源代码生成</li></ul><p><br></p><p><strong>2️⃣ 核心周边支撑</strong></p><ul><li><p><strong>Parser(<code>@babel/parser</code>)</strong>： 将源代码解析为 AST 就靠它了。 它已经内置支持很多语法. 例如 JSX、Typescript、Flow、以及最新的ECMAScript规范。目前为了执行效率，parser是<a href="https://babeljs.io/docs/en/babel-parser#faq" target="_blank" rel="noopener">不支持扩展的</a>，由官方进行维护。如果你要支持自定义语法，可以 fork 它，不过这种场景非常少。</p></li><li><p><strong>Traverser(<code>@babel/traverse</code>)</strong>：  实现了<code>访问者模式</code>，对 AST 进行遍历，<code>转换插件</code>会通过它获取感兴趣的AST节点，对节点继续操作, 下文会详细介绍<code>访问器模式</code>。</p></li><li><p><strong>Generator(<code>@babel/generator</code>)</strong>： 将 AST 转换为源代码，支持 SourceMap</p></li></ul><p><br></p><p><strong>3️⃣ 插件</strong></p><p>打开 Babel 的源代码，会发现有好几种类型的‘插件’。</p><ul><li><p><strong>语法插件(<code>@babel/plugin-syntax-*</code>)</strong>：上面说了 <code>@babel/parser</code> 已经支持了很多 JavaScript 语法特性，Parser也不支持扩展. <strong>因此<code>plugin-syntax-*</code>实际上只是用于开启或者配置Parser的某个功能特性</strong>。</p><p>一般用户不需要关心这个，Transform 插件里面已经包含了相关的<code>plugin-syntax-*</code>插件了。用户也可以通过<a href="https://babeljs.io/docs/en/options#parseropts" target="_blank" rel="noopener"><code>parserOpts</code></a>配置项来直接配置 Parser</p></li><li><p><strong>转换插件</strong>： 用于对 AST 进行转换, 实现转换为ES5代码、压缩、功能增强等目的. Babel仓库将转换插件划分为两种(只是命名上的区别)：</p><ul><li><code>@babel/plugin-transform-*</code>： 普通的转换插件</li><li><code>@babel/plugin-proposal-*</code>： 还在’提议阶段’(非正式)的语言特性, 目前有<a href="https://babeljs.io/docs/en/next/plugins#experimental" target="_blank" rel="noopener">这些</a></li></ul></li><li><p><strong>预定义集合(<code>@babel/presets-*</code>)</strong>： 插件集合或者分组，主要方便用户对插件进行管理和使用。比如<code>preset-env</code>含括所有的标准的最新特性; 再比如<code>preset-react</code>含括所有react相关的插件.</p></li></ul><p><br></p><p><strong>4️⃣ 插件开发辅助</strong></p><ul><li><p><code>@babel/template</code>： 某些场景直接操作AST太麻烦，就比如我们直接操作DOM一样，所以Babel实现了这么一个简单的模板引擎，可以将字符串代码转换为AST。比如在生成一些辅助代码(helper)时会用到这个库</p></li><li><p><code>@babel/types</code>： AST 节点构造器和断言. 插件开发时使用很频繁</p></li><li><p><code>@babel/helper-*</code>： 一些辅助器，用于辅助插件开发，例如简化AST操作</p></li><li><p><code>@babel/helper</code>： 辅助代码，单纯的语法转换可能无法让代码运行起来，比如低版本浏览器无法识别class关键字，这时候需要添加辅助代码，对class进行模拟。</p></li></ul><p><br></p><p><strong>5️⃣ 工具</strong></p><ul><li><p><code>@babel/node</code>： Node.js CLI, 通过它直接运行需要 Babel 处理的JavaScript文件</p></li><li><p><code>@babel/register</code>： Patch NodeJs 的require方法，支持导入需要Babel处理的JavaScript模块</p></li><li><p><code>@babel/cli</code>： CLI工具</p></li></ul><p><br><br><br></p><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>转换器会遍历 AST 树，找出自己感兴趣的节点类型, 再进行转换操作. 这个过程和我们操作<code>DOM</code>树差不多，只不过目的不太一样。AST 遍历和转换一般会使用<a href="https://www.jianshu.com/p/1f1049d0a0f4" target="_blank" rel="noopener"><code>访问者模式</code></a>。</p><p>想象一下，Babel 有那么多插件，如果每个插件自己去遍历AST，对不同的节点进行不同的操作，维护自己的状态。这样子不仅低效，它们的逻辑分散在各处，会让整个系统变得难以理解和调试， 最后插件之间关系就纠缠不清，乱成一锅粥。</p><p><strong>所以转换器操作 AST 一般都是使用<code>访问器模式</code>，由这个<code>访问者(Visitor)</code>来 ① 进行统一的遍历操作，② 提供节点的操作方法，③ 响应式维护节点之间的关系；而插件(设计模式中称为‘具体访问者’)只需要定义自己感兴趣的节点类型，当访问者访问到对应节点时，就调用插件的访问(visit)方法</strong>。</p><p><br></p><h3 id="节点的遍历"><a href="#节点的遍历" class="headerlink" title="节点的遍历"></a>节点的遍历</h3><p>假设我们的代码如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span> + v + <span class="string">'!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>解析后的 AST 结构如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">File</span><br><span class="line">  Program (program)</span><br><span class="line">    FunctionDeclaration (body)</span><br><span class="line">      Identifier (id)  #hello</span><br><span class="line">      Identifier (params[0]) #v</span><br><span class="line">      BlockStatement (body)</span><br><span class="line">        ExpressionStatement ([0])</span><br><span class="line">          CallExpression (expression)</span><br><span class="line">            MemberExpression (callee)  #console.log</span><br><span class="line">              Identifier (object)  #console</span><br><span class="line">              Identifier (property)  #log</span><br><span class="line">            BinaryExpression (arguments[0])</span><br><span class="line">              BinaryExpression (left)</span><br><span class="line">                StringLiteral (left)  #'hello'</span><br><span class="line">                Identifier (right)  #v</span><br><span class="line">              StringLiteral (right)  #'!'</span><br></pre></td></tr></table></figure><p><br></p><p>访问者会以<code>深度优先</code>的顺序, 或者说递归地对 AST 进行遍历，其调用顺序如下图所示:</p><p><img src="/images/babel/traveser.png" alt></p><p><br></p><p>上图中<code>绿线</code>表示进入该节点，<code>红线</code>表示离开该节点。下面写一个超简单的’具体访问者’来还原上面的遍历过程:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'@babel/core'</span>)</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">'@babel/traverse'</span>).default</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = babel.parseSync(code)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> depth = <span class="number">0</span></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  enter(path) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`enter <span class="subst">$&#123;path.type&#125;</span>(<span class="subst">$&#123;path.key&#125;</span>)`</span>)</span><br><span class="line">    depth++</span><br><span class="line">  &#125;,</span><br><span class="line">  exit(path) &#123;</span><br><span class="line">    depth--</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`  exit <span class="subst">$&#123;path.type&#125;</span>(<span class="subst">$&#123;path.key&#125;</span>)`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><details><br><summary> 查看代码执行结果 </summary><br><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">enter Program(program)</span><br><span class="line">  enter FunctionDeclaration(0)</span><br><span class="line">    enter Identifier(id)</span><br><span class="line">    exit Identifier(id)</span><br><span class="line">    enter Identifier(0)</span><br><span class="line">    exit Identifier(0)</span><br><span class="line">    enter BlockStatement(body)</span><br><span class="line">      enter ExpressionStatement(0)</span><br><span class="line">        enter CallExpression(expression)</span><br><span class="line">          enter MemberExpression(callee)</span><br><span class="line">            enter Identifier(object)</span><br><span class="line">            exit Identifier(object)</span><br><span class="line">            enter Identifier(property)</span><br><span class="line">            exit Identifier(property)</span><br><span class="line">          exit MemberExpression(callee)</span><br><span class="line">          enter BinaryExpression(0)</span><br><span class="line">            enter BinaryExpression(left)</span><br><span class="line">              enter StringLiteral(left)</span><br><span class="line">              exit StringLiteral(left)</span><br><span class="line">              enter Identifier(right)</span><br><span class="line">              exit Identifier(right)</span><br><span class="line">            exit BinaryExpression(left)</span><br><span class="line">            enter StringLiteral(right)</span><br><span class="line">            exit StringLiteral(right)</span><br><span class="line">          exit BinaryExpression(0)</span><br><span class="line">        exit CallExpression(expression)</span><br><span class="line">      exit ExpressionStatement(0)</span><br><span class="line">    exit BlockStatement(body)</span><br><span class="line">  exit FunctionDeclaration(0)</span><br><span class="line">exit Program(program)</span><br></pre></td></tr></table></figure><br><br></details><p><br></p><p>当访问者进入一个节点时就会调用 <code>enter(进入)</code> 方法，反之离开该节点时会调用 <code>exit(离开)</code> 方法。 一般情况下，插件不会直接使用<code>enter</code>方法，只会关注少数几个节点类型，所以具体访问者也可以这样声明访问方法:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">traverse(ast, &#123;</span><br><span class="line">  <span class="comment">// 访问标识符</span></span><br><span class="line">  Identifier(path) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`enter Identifier`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 访问调用表达式</span></span><br><span class="line">  CallExpression(path) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`enter CallExpression`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 上面是enter的简写，如果要处理exit，也可以这样</span></span><br><span class="line">  <span class="comment">// 二元操作符</span></span><br><span class="line">  BinaryExpression: &#123;</span><br><span class="line">    enter(path) &#123;&#125;,</span><br><span class="line">    exit(path) &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 更高级的, 使用同一个方法访问多种类型的节点</span></span><br><span class="line">  <span class="string">"ExportNamedDeclaration|Flow"</span>(path) &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p><strong>那么 Babel 插件是怎么被应用的呢？</strong></p><p>Babel 会按照插件定义的顺序来应用访问方法，比如你注册了多个插件，babel-core 最后传递给访问器的数据结构大概长这样：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  Identifier: &#123;</span><br><span class="line">    enter: [plugin-xx, plugin-yy,] <span class="comment">// 数组形式</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>当进入一个节点时，这些插件会按照注册的顺序被执行。大部分插件是不需要开发者关心定义的顺序的，有少数的情况需要稍微注意以下，例如<code>plugin-proposal-decorators</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">"@babel/plugin-proposal-decorators"</span>,     <span class="comment">// 必须在plugin-proposal-class-properties之前</span></span><br><span class="line">    <span class="string">"@babel/plugin-proposal-class-properties"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>所有插件定义的顺序，按照惯例，应该是新的或者说实验性的插件在前面，老的插件定义在后面。因为可能需要新的插件将 AST 转换后，老的插件才能识别语法（向后兼容）。下面是官方配置例子, 为了确保先后兼容，<code>stage-*</code>阶段的插件先执行:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"es2015"</span>, <span class="string">"react"</span>, <span class="string">"stage-2"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意Preset的执行顺序相反，详见官方<a href="https://babeljs.io/docs/en/next/plugins#plugin-ordering" target="_blank" rel="noopener">文档</a></p></blockquote><p><br></p><h3 id="节点的上下文"><a href="#节点的上下文" class="headerlink" title="节点的上下文"></a>节点的上下文</h3><p>访问者在访问一个节点时, 会无差别地调用 <code>enter</code> 方法，我们怎么知道这个节点在什么位置以及和其他节点的关联关系呢？</p><p>通过上面的代码，读者应该可以猜出几分，每个<code>visit</code>方法都接收一个 <code>Path</code> 对象, 你可以将它当做一个‘上下文’对象，类似于<code>JQuery</code>的 <code>JQuery</code>(<code>const $el = $(&#39;.el&#39;)</code>) 对象，这里面包含了很多信息：</p><ul><li>当前节点信息</li><li>节点的关联信息。父节点、子节点、兄弟节点等等</li><li>作用域信息</li><li>上下文信息</li><li>节点操作方法。节点增删查改</li><li>断言方法。isXXX, assertXXX</li></ul><p>下面是它的主要结构:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">NodePath</span>&lt;<span class="title">T</span> </span>= Node&gt; &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(hub: Hub, parent: Node);</span><br><span class="line">    parent: Node;</span><br><span class="line">    hub: Hub;</span><br><span class="line">    contexts: TraversalContext[];</span><br><span class="line">    data: object;</span><br><span class="line">    shouldSkip: boolean;</span><br><span class="line">    shouldStop: boolean;</span><br><span class="line">    removed: boolean;</span><br><span class="line">    state: any;</span><br><span class="line">    opts: object;</span><br><span class="line">    skipKeys: object;</span><br><span class="line">    parentPath: NodePath;</span><br><span class="line">    context: TraversalContext;</span><br><span class="line">    container: object | object[];</span><br><span class="line">    listKey: string; // 如果节点在一个数组中，这个就是节点数组的键</span><br><span class="line">    inList: boolean;</span><br><span class="line">    parentKey: string;</span><br><span class="line">    key: string | number; // 节点所在的键或索引</span><br><span class="line">    node: T;  // 🔴 当前节点</span><br><span class="line">    scope: Scope; // 🔴当前节点所在的作用域</span><br><span class="line">    type: T extends undefined | null ? string | null : string; // 🔴节点类型</span><br><span class="line">    typeAnnotation: object;</span><br><span class="line">    // ... 还有很多方法，实现增删查改</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以通过这个<a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-visitors" target="_blank" rel="noopener">手册</a>来学习怎么通过 Path 来转换 AST. 后面也会有代码示例，这里就不展开细节了</p><p><br></p><h3 id="副作用的处理"><a href="#副作用的处理" class="headerlink" title="副作用的处理"></a>副作用的处理</h3><p>实际上访问者的工作比我们想象的要复杂的多，上面示范的是静态 AST 的遍历过程。而 AST 转换本身是有副作用的，比如插件将旧的节点替换了，那么访问者就没有必要再向下访问旧节点了，而是继续访问新的节点, 代码如下。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">traverse(ast, &#123;</span><br><span class="line">  ExpressionStatement(path) &#123;</span><br><span class="line">    <span class="comment">// 将 `console.log('hello' + v + '!')` 替换为 `return ‘hello’ + v`</span></span><br><span class="line">    <span class="keyword">const</span> rtn = t.returnStatement(t.binaryExpression(<span class="string">'+'</span>, t.stringLiteral(<span class="string">'hello'</span>), t.identifier(<span class="string">'v'</span>)))</span><br><span class="line">    path.replaceWith(rtn)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>上面的代码, 将<code>console.log(&#39;hello&#39; + v + &#39;!&#39;)</code>语句替换为<code>return &quot;hello&quot; + v;</code>, 下图是遍历的过程：</p><p><img src="/images/babel/replace.png" alt></p><p><br></p><p>我们可以对 AST 进行任意的操作，比如删除父节点的兄弟节点、删除第一个子节点、新增兄弟节点… <strong>当这些操作’污染’了 AST 树后，访问者需要记录这些状态，响应式(Reactive)更新 Path 对象的关联关系, 保证正确的遍历顺序，从而获得正确的转译结果</strong>。</p><p><br></p><h3 id="作用域的处理"><a href="#作用域的处理" class="headerlink" title="作用域的处理"></a>作用域的处理</h3><p>访问者可以确保正确地遍历和修改节点，但是对于转换器来说，另一个比较棘手的是对作用域的处理，这个责任落在了插件开发者的头上。插件开发者必须非常谨慎地处理作用域，不能破坏现有代码的执行逻辑。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>, b = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">foo, bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b)</span><br><span class="line">  <span class="keyword">return</span> foo + bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如你要将 <code>add</code> 函数的第一个参数 <code>foo</code> 标识符修改为<code>a</code>, 你就需要<strong>递归</strong>遍历子树，查出<code>foo</code>标识符的所有<code>引用</code>, 然后替换它:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">traverse(ast, &#123;</span><br><span class="line">  <span class="comment">// 将第一个参数名转换为a</span></span><br><span class="line">  FunctionDeclaration(path) &#123;</span><br><span class="line">    <span class="keyword">const</span> firstParams = path.get(<span class="string">'params.0'</span>)</span><br><span class="line">    <span class="keyword">if</span> (firstParams == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> name = firstParams.node.name</span><br><span class="line">    <span class="comment">// 递归遍历，这是插件常用的模式。这样可以避免影响到外部作用域</span></span><br><span class="line">    path.traverse(&#123;</span><br><span class="line">      Identifier(path) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.node.name === name) &#123;</span><br><span class="line">          path.replaceWith(t.identifier(<span class="string">'a'</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generate(ast).code)</span><br><span class="line"><span class="comment">// function add(a, bar) &#123;</span></span><br><span class="line"><span class="comment">//   console.log(a, b);</span></span><br><span class="line"><span class="comment">//   return a + bar;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>🤯慢着，好像没那么简单，替换成 <code>a</code> 之后, <code>console.log(a, b)</code> 的行为就被破坏了。所以这里不能用 <code>a</code>，得换个标识符, 譬如<code>c</code>.</p><p><br></p><p>这就是转换器需要考虑的作用域问题，<strong>AST 转换的前提是保证程序的正确性</strong>。 我们在添加和修改<code>引用</code>时，需要确保与现有的所有引用不冲突。Babel本身不能检测这类异常，只能依靠插件开发者谨慎处理。</p><p><br></p><p>Javascript采用的是词法作用域, 也就是根据源代码的词法结构来确定作用域：</p><p><img src="/images/babel/scope.png" alt></p><p>在<strong>词法区块(block)</strong>中，由于新建变量、函数、类、函数参数等创建的标识符，都属于这个区块作用域. 这些标识符也称为<strong>绑定(Binding)</strong>，而对这些绑定的使用称为<strong>引用(Reference)</strong></p><p>在Babel中，使用<code>Scope</code>对象来表示作用域。 我们可以通过Path对象的<code>scope</code>字段来获取当前节点的<code>Scope</code>对象。它的结构如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: NodePath;</span><br><span class="line">  block: Node;         <span class="comment">// 所属的词法区块节点, 例如函数节点、条件语句节点</span></span><br><span class="line">  parentBlock: Node;   <span class="comment">// 所属的父级词法区块节点</span></span><br><span class="line">  parent: Scope;       <span class="comment">// ⚛️指向父作用域</span></span><br><span class="line">  bindings: &#123; [name: string]: Binding; &#125;; <span class="comment">// ⚛️ 该作用域下面的所有绑定(即该作用域创建的标识符)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><code>Scope</code> 对象和 <code>Path</code> 对象差不多，<strong>它包含了作用域之间的关联关系(通过parent指向父作用域)，收集了作用域下面的所有绑定(bindings), 另外还提供了丰富的方法来对作用域仅限操作</strong>。</p><p>我们可以通过<code>bindings</code>属性获取当前作用域下的所有绑定(即标识符)，每个绑定由<code>Binding</code>类来表示：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Binding</span> </span>&#123;</span><br><span class="line">  identifier: t.Identifier;</span><br><span class="line">  scope: Scope;</span><br><span class="line">  path: NodePath;</span><br><span class="line">  kind: <span class="string">"var"</span> | <span class="string">"let"</span> | <span class="string">"const"</span> | <span class="string">"module"</span>;</span><br><span class="line">  referenced: boolean;</span><br><span class="line">  references: number;              <span class="comment">// 被引用的数量</span></span><br><span class="line">  referencePaths: NodePath[];      <span class="comment">// ⚛️获取所有应用该标识符的节点路径</span></span><br><span class="line">  constant: boolean;               <span class="comment">// 是否是常量</span></span><br><span class="line">  constantViolations: NodePath[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过<code>Binding</code>对象我们可以确定标识符被引用的情况</strong>。</p><p>Ok，有了 <code>Scope</code> 和 <code>Binding</code>, 现在有能力实现安全的变量重命名转换了。 为了更好地展示作用域交互，在上面代码的基础上，我们再增加一下难度：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>, b = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">foo, bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="string">'1'</span> <span class="comment">// 新增了一个变量声明</span></span><br><span class="line">    <span class="keyword">return</span> a + (foo + bar)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你要重命名函数参数 <code>foo</code>, 不仅要考虑<code>外部的作用域</code>, 也要考虑<code>下级作用域</code>的绑定情况，确保这两者都不冲突。</p><p>上面的代码作用域和标识符引用情况如下图所示:</p><p><img src="/images/babel/scope2.png" alt></p><p><br></p><p>来吧，接受挑战，试着将函数的第一个参数重新命名为更短的标识符:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于获取唯一的标识符</span></span><br><span class="line"><span class="keyword">const</span> getUid = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`_<span class="subst">$&#123;(uid++) || <span class="string">''</span>&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = babel.parseSync(code)</span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  FunctionDeclaration(path) &#123;</span><br><span class="line">    <span class="comment">// 获取第一个参数</span></span><br><span class="line">    <span class="keyword">const</span> firstParam = path.get(<span class="string">'params.0'</span>)</span><br><span class="line">    <span class="keyword">if</span> (firstParam == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> currentName = firstParam.node.name</span><br><span class="line">    <span class="keyword">const</span> currentBinding = path.scope.getBinding(currentName)</span><br><span class="line">    <span class="keyword">const</span> gid = getUid()</span><br><span class="line">    <span class="keyword">let</span> sname</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环找出没有被占用的变量名</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      sname = gid()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1️⃣首先看一下父作用域是否已定义了该变量</span></span><br><span class="line">      <span class="keyword">if</span> (path.scope.parentHasBinding(sname)) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2️⃣ 检查当前作用域是否定义了变量</span></span><br><span class="line">      <span class="keyword">if</span> (path.scope.hasOwnBinding(sname)) &#123;</span><br><span class="line">        <span class="comment">// 已占用</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//  再检查第一个参数的当前的引用情况,</span></span><br><span class="line">      <span class="comment">// 如果它所在的作用域定义了同名的变量，我们也得放弃</span></span><br><span class="line">      <span class="keyword">if</span> (currentBinding.references &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> findIt = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> refNode <span class="keyword">of</span> currentBinding.referencePaths) &#123;</span><br><span class="line">          <span class="keyword">if</span> (refNode.scope !== path.scope &amp;&amp; refNode.scope.hasBinding(sname)) &#123;</span><br><span class="line">            findIt = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (findIt) &#123;</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始替换掉</span></span><br><span class="line">    <span class="keyword">const</span> i = t.identifier(sname)</span><br><span class="line">    currentBinding.referencePaths.forEach(<span class="function"><span class="params">p</span> =&gt;</span> p.replaceWith(i))</span><br><span class="line">    firstParam.replaceWith(i)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generate(ast).code)</span><br><span class="line"><span class="comment">// const a = 1,</span></span><br><span class="line"><span class="comment">//       b = 2;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function add(_, bar) &#123;</span></span><br><span class="line"><span class="comment">//   console.log(a, b);</span></span><br><span class="line"><span class="comment">//   return () =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     const a = '1'; // 新增了一个变量声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return a + (_ + bar);</span></span><br><span class="line"><span class="comment">//   &#125;;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>上面的例子虽然没有什么实用性，而且还有Bug(没考虑<code>label</code>)，但是正好可以揭示了作用域处理的复杂性。</p><p><br></p><p>Babel的 <code>Scope</code> 对象其实提供了一个<code>generateUid</code>方法来生成唯一的、不冲突的标识符。我们利用这个方法再简化一下我们的代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">traverse(ast, &#123;</span><br><span class="line">  FunctionDeclaration(path) &#123;</span><br><span class="line">    <span class="keyword">const</span> firstParam = path.get(<span class="string">'params.0'</span>)</span><br><span class="line">    <span class="keyword">if</span> (firstParam == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i = path.scope.generateUidIdentifier(<span class="string">'_'</span>) <span class="comment">// 也可以使用generateUid</span></span><br><span class="line">    <span class="keyword">const</span> currentBinding = path.scope.getBinding(firstParam.node.name)</span><br><span class="line">    currentBinding.referencePaths.forEach(<span class="function"><span class="params">p</span> =&gt;</span> p.replaceWith(i))</span><br><span class="line">    firstParam.replaceWith(i)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>能不能再短点!</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">traverse(ast, &#123;</span><br><span class="line">  FunctionDeclaration(path) &#123;</span><br><span class="line">    <span class="keyword">const</span> firstParam = path.get(<span class="string">'params.0'</span>)</span><br><span class="line">    <span class="keyword">if</span> (firstParam == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i = path.scope.generateUid(<span class="string">'_'</span>) <span class="comment">// 也可以使用generateUid</span></span><br><span class="line">    path.scope.rename(firstParam.node.name, i)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><details><br><summary>查看generateUid的实现代码</summary><br><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">generateUid(name: string = <span class="string">"temp"</span>) &#123;</span><br><span class="line">  name = t</span><br><span class="line">    .toIdentifier(name)</span><br><span class="line">    .replace(<span class="regexp">/^_+/</span>, <span class="string">""</span>)</span><br><span class="line">    .replace(<span class="regexp">/[0-9]+$/g</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> uid;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    uid = <span class="keyword">this</span>._generateUid(name, i);</span><br><span class="line">    i++;</span><br><span class="line">  &#125; <span class="keyword">while</span> (</span><br><span class="line">    <span class="keyword">this</span>.hasLabel(uid) ||</span><br><span class="line">    <span class="keyword">this</span>.hasBinding(uid) ||</span><br><span class="line">    <span class="keyword">this</span>.hasGlobal(uid) ||</span><br><span class="line">    <span class="keyword">this</span>.hasReference(uid)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> program = <span class="keyword">this</span>.getProgramParent();</span><br><span class="line">  program.references[uid] = <span class="literal">true</span>;</span><br><span class="line">  program.uids[uid] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details><p>非常简洁哈？作用域操作最典型的场景是代码压缩，代码压缩会对变量名、函数名等进行压缩… 然而实际上很少的插件场景需要跟作用域进行复杂的交互，所以关于作用域这一块就先讲到这里。</p><p><br></p><h2 id="搞一个插件呗"><a href="#搞一个插件呗" class="headerlink" title="搞一个插件呗"></a>搞一个插件呗</h2><p>等等别走，还没完呢，这才到2/3。学了上面得了知识，总得写一个玩具插件试试水吧?</p><p>现在打算模仿<a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="noopener">babel-plugin-import</a>, 写一个极简版插件，来实现模块的按需导入. 在这个插件中，我们会将类似这样的导入语句:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;A, B, C <span class="keyword">as</span> D&#125; <span class="keyword">from</span> <span class="string">'foo'</span></span><br></pre></td></tr></table></figure><p>转换为:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> A <span class="keyword">from</span> <span class="string">'foo/A'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'foo/A/style.css'</span></span><br><span class="line"><span class="keyword">import</span> B <span class="keyword">from</span> <span class="string">'foo/B'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'foo/B/style.css'</span></span><br><span class="line"><span class="keyword">import</span> D <span class="keyword">from</span> <span class="string">'foo/C'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'foo/C/style.css'</span></span><br></pre></td></tr></table></figure><p>首先通过 <a href="https://astexplorer.net" target="_blank" rel="noopener">AST Explorer</a> 看一下导入语句的 AST 节点结构:</p><p><img src="/images/babel/import.png" alt></p><p><br></p><p>通过上面展示的结果，我们需要处理 <code>ImportDeclaration</code> 节点类型，将它的<code>specifiers</code>拿出来遍历处理一下。另外如果用户使用了<code>默认导入</code>语句，我们将抛出错误，提醒用户不能使用默认导入. </p><p>基本实现如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要识别的模块</span></span><br><span class="line"><span class="keyword">const</span> MODULE = <span class="string">'foo'</span></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  <span class="comment">// 访问导入语句</span></span><br><span class="line">  ImportDeclaration(path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.node.source.value !== MODULE) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是空导入则直接删除掉</span></span><br><span class="line">    <span class="keyword">const</span> specs = path.node.specifiers</span><br><span class="line">    <span class="keyword">if</span> (specs.length === <span class="number">0</span>) &#123;</span><br><span class="line">      path.remove()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否包含了默认导入和命名空间导入</span></span><br><span class="line">    <span class="keyword">if</span> (specs.some(<span class="function"><span class="params">i</span> =&gt;</span> t.isImportDefaultSpecifier(i) || t.isImportNamespaceSpecifier(i))) &#123;</span><br><span class="line">      <span class="comment">// 抛出错误，Babel会展示出错的代码帧</span></span><br><span class="line">      <span class="keyword">throw</span> path.buildCodeFrameError(<span class="string">"不能使用默认导入或命名空间导入"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换命名导入</span></span><br><span class="line">    <span class="keyword">const</span> imports = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> spec <span class="keyword">of</span> specs) &#123;</span><br><span class="line">      <span class="keyword">const</span> named = MODULE + <span class="string">'/'</span> + spec.imported.name</span><br><span class="line">      <span class="keyword">const</span> local = spec.local</span><br><span class="line">      imports.push(t.importDeclaration([t.importDefaultSpecifier(local)], t.stringLiteral(named)))</span><br><span class="line">      imports.push(t.importDeclaration([], t.stringLiteral(<span class="string">`<span class="subst">$&#123;named&#125;</span>/style.css`</span>)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换原有的导入语句</span></span><br><span class="line">    path.replaceWithMultiple(imports)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p>逻辑还算简单，<code>babel-plugin-import</code>可比这复杂得多。</p><p><br></p><p>接下来，我们将它封装成标准的 Babel 插件。 按照规范，我们需要创建一个<code>babel-plugin-*</code>前缀的包名：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mkdir babel-plugin-toy-<span class="keyword">import</span></span><br><span class="line">cd babel-plugin-toy-<span class="keyword">import</span></span><br><span class="line">yarn init -y</span><br><span class="line">touch index.js</span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>你也可以通过 <a href="https://github.com/babel/generator-babel-plugin/tree/master/generators/app/templates" target="_blank" rel="noopener">generator-babel-plugin</a> 来生成项目模板.</p></blockquote><p><br></p><p>在 <code>index.js</code> 文件中填入我们的代码。<code>index.js</code>默认导出一个函数，函数结构如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接受一个 babel-core 对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">babel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="attr">types</span>: t&#125; = babel</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    pre(state) &#123;</span><br><span class="line">      <span class="comment">// 前置操作，可选，可以用于准备一些资源</span></span><br><span class="line">    &#125;,</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      <span class="comment">// 我们的访问者代码将放在这里</span></span><br><span class="line">      ImportDeclaration(path, state) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    post(state) &#123;</span><br><span class="line">      <span class="comment">// 后置操作，可选</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>我们可以从访问器方法的第二个参数<code>state</code>中获取用户传入的参数</strong>。假设用户配置为:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  plugins: [[<span class="string">'toy-plugin'</span>, &#123;<span class="attr">name</span>: <span class="string">'foo'</span>&#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以这样获取用户传入的参数:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">babel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="attr">types</span>: t&#125; = babel</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      ImportDeclaration(path, state) &#123;</span><br><span class="line">        <span class="keyword">const</span> mod = state.opts &amp;&amp; state.opts.name</span><br><span class="line">        <span class="keyword">if</span> (mod == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打完收工 🙏，发布!</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn publish # good luck</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote><p>新世界的大门已经打开: ⛩</p></blockquote><p>本文主要介绍了 Babel 的架构和原理，还实践了一下 Babel 插件开发，读到这里，你算是入了 Babel 的门了.</p><p>接下来你可以去熟读<a href="https://github.com/jamiebuilds/babel-handbook" target="_blank" rel="noopener">Babel手册</a>, 这是目前最好的教程,<br><a href="https://astexplorer.net/#/KJ8AjD6maa" target="_blank" rel="noopener">ASTExplorer</a>是最好的演练场，多写代码多思考。<br>你也可以去看<a href="https://github.com/babel/babel/tree/master/packages" target="_blank" rel="noopener">Babel的官方插件实现</a>, 迈向更高的台阶。</p><p>本文还有下篇，我将在下篇文章中介绍<a href="https://github.com/kentcdodds/babel-plugin-macros" target="_blank" rel="noopener">babel-plugin-macros</a>, 敬请期待！</p><p>点赞是对我最好鼓励。</p><p><br></p><p><img src="/images/sponsor.jpg" alt></p><p><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://astexplorer.net/#/KJ8AjD6maa" target="_blank" rel="noopener">ASTExplorer</a></li><li><a href="https://github.com/jamiebuilds/babel-handbook" target="_blank" rel="noopener">babel-handbook</a></li><li><a href="https://github.com/babel/generator-babel-plugin" target="_blank" rel="noopener">generator-babel-plugin</a></li><li><a href="https://the-super-tiny-compiler.glitch.me" target="_blank" rel="noopener">the-super-tiny-compiler</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;国庆放假了，我还在利用碎片时间在写文章，不知道长假还有没有人看，试试水吧！&lt;/p&gt;
&lt;p&gt;这个文章系列将带大家深入浅出 &lt;a href=&quot;https://babeljs.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Babel&lt;/code
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>if 我是前端团队 Leader，怎么用好看板进行任务管理</title>
    <link href="https://bobi.ink/2019/09/23/kanban/"/>
    <id>https://bobi.ink/2019/09/23/kanban/</id>
    <published>2019-09-22T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.329Z</updated>
    
    <content type="html"><![CDATA[<p><code>看板</code>是一种非常常见的任务管理机制。我们使用到的大部分团队协作工具中都有看板的身影，例如 <a href="http://tower.im" target="_blank" rel="noopener"><code>Tower</code></a>、<a href="http://teambition.com" target="_blank" rel="noopener"><code>Teambition</code></a>、<code>Trello</code>、<code>Github</code>、<code>Gitlab</code>… </p><p>看板不仅可以用于团队协作，也可以用于对个人时间进行管理和优化。 <strong>可是你真的会用看板吗</strong>？</p><p><br></p><p><code>Wiki</code> 上面的解释是： <code>看板是丰田生产模式中的重要概念，指为了达到及时生产（JIT）方式控制现场生产流程的工具。及时生产方式中的拉式生产系统可以使信息的流程缩短，并配合定量、固定装货容器等方式，而使生产过程中的物料流动顺畅</code>.</p><p>从上面的定义中需要注意以下要点:</p><ul><li><strong>及时生产</strong> - 这是一种通过减少生产过程中的库存和相关的顺带成本，改善商业投资回报的管理战略。</li><li><strong>控制现场</strong> - 看板是一种<code>现场还原</code>和<code>现场控制</code>方法</li><li><strong>拉式生产系统</strong> - 传统的软件开发都是使用<code>推(Push)模式</code>，即规定某个任务由指定人在指定时间内完成。而拉式生产系统，更像生产者-消费者模式，看板就是一个信号等，当上游有已完成的任务，通知下游开始处理这些任务</li><li><strong>定量</strong> - 流程上的每个环节是有固定带宽的，这有助于暴露流程上的瓶颈</li></ul><p><br></p><p><a href="https://www.infoq.cn/article/kanban-development-method" target="_blank" rel="noopener">《解析精益产品开发（一）—— 看板开发方法》</a> 对看板总结得非常好, <strong>看板工具的实质是</strong>：后道工序在需要时，通过看板向前道工序发出信号——请给我需要数量的输入，前道工序只有得到看板后，才按需生产。看板信号由下游向上游传递，拉动上游的生产活动，使产品向下游流动。拉动的源头是最上游的客户价值，也就是客户订单或需求。</p><p>下面会循序渐进，介绍看板应用的几个阶段。如果你的团队还停留在第一个阶段，不妨试试继续深入实践。</p><p><br></p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#第一阶-从既有的流程开始-流程可视化">第一阶： 从既有的流程开始， 流程可视化</a><ul><li><a href="#流程的抽象">流程的抽象</a></li><li><a href="#不断改进的流程">不断改进的流程</a></li><li><a href="#看板的范围">看板的范围</a></li><li><a href="#优先级划分">优先级划分</a></li><li><a href="#推模型push与拉模型pull">推模型(Push)与拉模型(Pull)</a></li><li><a href="#暴露瓶颈">暴露瓶颈</a></li><li><a href="#总结">总结</a></li></ul></li><li><a href="#第二阶在制品限制">第二阶：在制品限制</a><ul><li><a href="#什么是在制品">什么是在制品</a></li><li><a href="#为什么限制在制品">为什么限制在制品?</a></li><li><a href="#wip要限制多少">WIP要限制多少?</a></li></ul></li><li><a href="#第三阶-结合scrum">第三阶: 结合Scrum</a><ul><li><a href="#简单介绍一下scrum">简单介绍一下Scrum</a></li><li><a href="#融合到看板中">融合到看板中</a><ul><li><a href="#设定开发周期">设定开发周期</a></li><li><a href="#每日回顾">每日回顾</a></li><li><a href="#流程监控">流程监控</a></li></ul></li></ul></li><li><a href="#看板一日游">看板一日游</a><ul><li><a href="#设计看板">设计看板</a></li><li><a href="#创建任务">创建任务</a></li><li><a href="#开始吧">开始吧</a></li></ul></li><li><a href="#扩展资料">扩展资料</a></li></ul><!-- /TOC --><p><br></p><p><strong>系列文章</strong></p><ul><li><a href="https://juejin.im/post/5d3a7134f265da1b5d57f1ed" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么制定前端协作规范? 🔥</a></li><li><a href="https://juejin.im/post/5d71cec6e51d4561b674c4d0" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么做好概要设计</a></li><li><a href="https://juejin.im/post/5d8d4557e51d4577fe41b62d" target="_blank" rel="noopener">if 我是前端团队 Leader，怎么用好看板进行任务管理?</a></li></ul><p><br></p><h2 id="第一阶：-从既有的流程开始，-流程可视化"><a href="#第一阶：-从既有的流程开始，-流程可视化" class="headerlink" title="第一阶： 从既有的流程开始， 流程可视化"></a>第一阶： 从既有的流程开始， 流程可视化</h2><p><img src="/images/kanban/sample.png" alt></p><p><strong>将开发流程可视化是看板的最基本的用法</strong>. 上面是一个典型的看板实例，它直观地描述了一个<code>功能项</code>的<strong>生命周期</strong>以及该团队的<strong>开发流程</strong>。它给我们展示了这样一个流程:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">需求分析 -&gt; 产品设计 -&gt; 开发 -&gt; 测试 -&gt; 部署</span><br></pre></td></tr></table></figure><p><br></p><h3 id="流程的抽象"><a href="#流程的抽象" class="headerlink" title="流程的抽象"></a>流程的抽象</h3><p>每个人、每个团队工作流程都不一样。在设计看板之前我们需要梳理一下自己的工作流程.</p><p>比如’个人‘的流程就非常简单了，就只有一个动作：’做与不做’. 所以个人看板通常是这样的</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">todo -&gt; doing -&gt; done</span><br></pre></td></tr></table></figure><p>你会发现，即使很简单的流程，<strong>流程的每个环节都会有三个子模块：<code>未做</code>/<code>正在做</code>/<code>已完成</code></strong>. 对于个人看板而言，划分这三个模块，主要是为了<strong>还原当前的现场</strong>。对于团队而言，这一点更为重要，你可以通过看板直观地跟踪任务开发的进度</p><p><br></p><p>我们团队目前的开发流程也很简单是：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">设计 -&gt; 开发 -&gt; ...</span><br></pre></td></tr></table></figure><ul><li><strong>设计</strong>: 应用设计，可选，一般在开启一个项目或者重要的功能开发时会进行<a href="https://juejin.im/post/5d71cec6e51d4561b674c4d0" target="_blank" rel="noopener"><code>概要设计</code></a></li><li><strong>开发</strong>: 正常的开发流程</li></ul><p>当然这仅仅是前端团队的’局部‘流程，完整的软件开发流程如第一个看板实例所示。因为我们不是一个’敏捷‘团队，只要负责<code>前端开发</code>这个环节即可. 大局上看<code>需求分析</code>、<code>产品设计</code>、<code>测试</code>以及<code>部署</code>不在我们的控制范围之内。所以不应归纳到我们的开发流程中。</p><p><br></p><h3 id="不断改进的流程"><a href="#不断改进的流程" class="headerlink" title="不断改进的流程"></a>不断改进的流程</h3><p>流程不是一成不变的，它会随着实践的深入不断演化。举个例子，因为我们团队成员能力和经验不均匀，比如新手代码经常出 Bug，细节也没有做好。怎么解决？</p><p><strong>首先想一下能否在流程上做一下改进</strong>, 来减缓或杜绝这种情况，提高代码质量?</p><p>反复思考和讨论后，我们决定在 <code>开发</code> 环节之后添加了一个 <code>交叉测试/Review/用户体验测试</code> 环节。这个包含三层含义, <code>交叉测试</code>是指定其他人来测试、<code>Review</code>指的是代码层次的审查(白盒)，<code>用户体验测试</code>则是从用户角度触发进行验收测试(黑盒)。</p><p><br></p><p>下面是改进后的看板(<code>设计 -&gt; 开发 -&gt; 交叉测试</code>):</p><p><img src="/images/kanban/ourkanban.png" alt></p><p><br></p><h3 id="看板的范围"><a href="#看板的范围" class="headerlink" title="看板的范围"></a>看板的范围</h3><p><img src="/images/kanban/person.png" alt><br><i>颜值很高的个人看板</i></p><p><br></p><p>上面看到了’个人看板‘、’团队看板‘，以及’一个涵盖完整软件开发流程的看板‘。<strong>你会发现看板应用得非常广，可以应用于不同的层次，表示任务的粒度也不一样</strong>。</p><p>我们前端团队内部就有两个看板，一个是<code>周计划看板</code>，一个是<code>任务看板</code>。</p><p><code>周计划看板</code>任务粒度是’项目’或者’重大功能’，用于规划和跟踪每周的大概任务； 而<code>任务看板</code>则是各种细化的任务, 例如小的功能、Bug修复、细节优化. 粒度平均在1<code>人/天</code>以下，可以最大程度还原每个开发成员的开发现场。</p><p><br></p><p>在团队协作层面, 我们还有一个<code>研发看板</code>，这个和第一个看板例子相似，还原一个应用完整的研发流程，每个团队占用看板上面的一栏，展示和跟踪团队之间的信息流动:</p><p><img src="/images/kanban/team.png" alt><br><i>研发看板</i></p><p><br></p><h3 id="优先级划分"><a href="#优先级划分" class="headerlink" title="优先级划分"></a>优先级划分</h3><p>上面我们<code>团队看板</code>中，有几个比较特殊的栏: <code>计划</code>/<code>本周待办</code>/<code>缓冲区</code>。主要栏主要目的是为了给任务划分优先级，让团队专注于目前应该优先处理的任务。</p><p>看板中优先级可以通过两种方式来处理:</p><p><strong>1. 拆分看板</strong>:</p><p>例如优先级排序 <code>缓冲区</code> &gt; <code>本周待办</code> &gt; <code>计划</code></p><ul><li><strong>计划</strong> - 近期需要进行的任务，有些任务优先级很低，可能一年半载都不会处理。这一栏有点像备忘录</li><li><strong>周计划</strong> - 从计划栏中筛选部分任务，作为本周的’开发目标‘。表示本周计划要完成的事情</li><li><strong>缓冲区</strong> - 从周计划中筛选优先级最高的任务，需要优先被处理</li><li><strong>已完成(周结束时间)</strong> 放置每周已完成的任务, 这个和周计划相对应，可以反馈’周计划‘完成的进度。</li></ul><p>我们通常会每周’归档‘一次<code>已完成</code>栏。如果使用<code>Tower</code>，可以通过’查看归档‘，获取所有的以周为单位的历史记录</p><p><img src="/images/kanban/arch.png" alt></p><p><br></p><p><strong>2. 设置任务优先级</strong></p><p>在任务层级也可以设定特殊的标签，来标记任务的优先级。另外也可以将高优先级任务排在队列前面, 表示任务的优先级</p><p>下图使用 <code>Tower</code> 可以为任务设置优先级，它会使用不同的颜色来标注它:</p><p><img src="/images/kanban/create-task.png" alt></p><p><br></p><h3 id="推模型-push-与拉模型-pull"><a href="#推模型-push-与拉模型-pull" class="headerlink" title="推模型(Push)与拉模型(Pull)"></a>推模型(Push)与拉模型(Pull)</h3><p>还是<a href="https://coolshell.cn" target="_blank" rel="noopener">左耳朵耗子</a>, 他在某期节目提到的’x 型人才和y 型人才论‘，让我印象深刻, 他指出人才可以分为两种:</p><ul><li>x 型人才: 给任务就做，不给任务就不知道做什么</li><li>y 型人才: 自驱动、拥有自主性和主动性，对企业有归宿感。这种人适合做管理者</li></ul><p>大部分人都是x型人才，所以企业需要花高一点的薪酬雇佣y型人才来管理和驱动x型人才。 但我认为这不是天生的，在后天给予一定的责任和鼓励，或者在某些管理机制下，我们也可以成为 y 型人才，甚至成为 y 型团队。很多敏捷理论就推崇’团队自治‘、希望团队以及成员可以<strong>自我驱动</strong>，推动业务的发展。<code>拉模式</code>也能体现这种思想.</p><p>传统团队都使用推模式，由Leader将任务分配给团队成员, 指定完成的时间和各种指标。这种方式也称为<code>推动系统(Push System)</code>,  它一般依赖于时间的排定，时间到了就被’被动地‘推动去做某些事情.</p><p>而看板非常适合拉模式。所以看板也被称为<code>信号板(Signal)</code>, 你可以将任务当做一个’事件‘，由事件来驱动工作(类似生产者-消费者模式)。这还是有点像工厂的流水线，上游的产出就是一种’事件‘，下游主动去拉取上游的物件进行处理.</p><p>这种模式的好处是，Leader不需要再去关心细微的工作分配和决策，让团队成员自己有效地安排事件。另外这也可以避免出现这样一种情况：团队成员只熟悉其中某些项目，或者只会做、只负责一类事情。这使得成员离岗时，团队会变得比较被动，因为其他成员对离岗成员的工作情况不熟悉。因此拉动模式，也可以让团队成员离开自己的舒适区，参与和熟悉各种项目</p><p>我们目前使用的是<strong>混合型</strong>, 有些任务是提前指派合适的人去做的，而如果看板中没有指定负责人，这个任务就可以由任何人来负责，推拉结合。</p><p><br></p><h3 id="暴露瓶颈"><a href="#暴露瓶颈" class="headerlink" title="暴露瓶颈"></a>暴露瓶颈</h3><p>流程上的多个环节会像管道(pipe)一样，通过输入输出连接在一起:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tasks -&gt; (流程1) -&gt; (流程2) -&gt; Done</span><br></pre></td></tr></table></figure><p>上一个流程的输出(Done)，就是下一个流程的输入(Todo). 按照理想的状态，信息流应该是流畅、平稳地在管道上流淌的。如果某个环节出现瓶颈，那么可能会导致忙的忙死，闲的闲死。</p><p>如果你有细心思考，看板的流程管理方式有点像’工厂的流水线作业‘，如果某个环节阻塞，这个环节就会堆积很多元件，而下游则会出现空闲等待情况, 而该环节的上游也会被阻塞。</p><p><br></p><p><strong>通过看板的现场还原，我们可以容易地发现这种流程上的瓶颈. 怎么解决这个问题</strong>？</p><p>这个可以类比程序，当我们发现程序上的一个性能问题时，通常有两个解决的方向:</p><ul><li>是否是算法问题? 能否使用更好的算法或者解决方案？对应到开发任务中，要考虑一下是否实现的方法不对？</li><li>如果是硬件的瓶颈，能否扩展硬件资源，升级好点的硬件？对应到开发任务中，要考虑一下是否要多加些人手？</li></ul><p>下一节会介绍，我会介绍通过设置<code>在制品</code>数量(带宽)，让看板更容易地暴露瓶颈.</p><p><br></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过看板我们可以得到这些好处:</p><ul><li><strong>流程可视化</strong>: 通过看板可以看到任务会经过哪些环节，当前在哪个环节</li><li><strong>还原开发现场</strong>:<ul><li>直观地跟踪开发的进度</li><li>暴露流程瓶颈</li><li>贡献看得见</li></ul></li><li><strong>拉模式</strong>: 自我驱动</li></ul><p><br><br><br></p><h2 id="第二阶：在制品限制"><a href="#第二阶：在制品限制" class="headerlink" title="第二阶：在制品限制"></a>第二阶：在制品限制</h2><p>大部分团队对看板的应用只停留在第一阶，即流程可视化。看板的魅力远不止于此。第二个阶段，我们要开始限制在制品的数量。</p><p><br></p><h3 id="什么是在制品"><a href="#什么是在制品" class="headerlink" title="什么是在制品"></a>什么是在制品</h3><p>在制品(Work-In-Process WIP), 也称为半成品。顾名思义就是部分未完成的任务。</p><p><img src="/images/kanban/wip.jpg" alt></p><p>在看板中, 一些栏会有在制品限制，用于<strong>限制该环节’同时‘可以处理的事情</strong>。换句话说就是限制某个环节的’流量带宽‘，或者说节流.</p><p><br></p><h3 id="为什么限制在制品"><a href="#为什么限制在制品" class="headerlink" title="为什么限制在制品?"></a>为什么限制在制品?</h3><p><strong>1. 更快暴露瓶颈</strong></p><p>尽管在’第一阶’时，我们也可以识别出流程的瓶颈，但并不是特别直观，至少从看板上较难察觉。你可能要详细跟踪询问，才能了解哪个流程卡住了。</p><p>限制了WIP后，每个环节的带宽是固定的，比如’测试‘环节的WIP限制是6，如果’测试‘环节到达限制，上游就没办法给它塞其他任务了。这就暴露了’测试’环节的瓶颈</p><p><strong>怎么设定WIP的限制额也是比较重要的，设置太小，会导致并发处理的任务量变小，资源可能得不到利用，太大又不容易暴露瓶颈</strong>。下节会介绍如何设置WIP.</p><p><br></p><p><strong>2. 避免中断，避免上下文切换</strong></p><p>限制WIP的另一个好处，是减少成员并发处理多个任务的数量。</p><p>和计算机的进程一样，进程的上下文切换代价是比较大的。对于开发者来说，任务中断、任务调换也会浪费切换的时间，因为我们需要调整/回顾思路来投入新的任务流程。</p><p>所以说通过限制WIP，可以让成员专注于正在处理的任务，做完这个任务再去拉取新的任务。</p><p><br></p><p><strong>3. 盈余时间</strong></p><p>当下游出现阻塞，上游或下游可能就会出现<code>盈余时间</code>。这些盈余时间看起来像浪费，其实对于开发者或团队来说，可以做很多事情。比如:</p><ul><li><strong>休息/学习</strong>:<br>可以利用这段时间来学习。对于前端来说，必须不断的学习，提高自己的水平和竞争力，这对项目开发也是有益处的. 在996这种环境下，企业家逐渐剥夺了我们生产生产力的能力。</li><li><strong>帮助解决瓶颈</strong>:<br>下游出现瓶颈了，我们可以停下来，帮助他们解决问题。例如其他同事因为某些问题卡住，我们可以帮助他一起解决问题；再比如下游测试环节出问题了，我们可以一起进行测试。作为一个团队齐步向前，变相提高团队凝聚力和责任心</li><li><strong>优化</strong>:<br>反思流程问题，考虑如果提高产能</li><li><strong>其他事情</strong>:<br>比如可以进行交叉测试和写文档，优化开发工具</li></ul><p><br></p><h3 id="wip要限制多少"><a href="#wip要限制多少" class="headerlink" title="WIP要限制多少?"></a>WIP要限制多少?</h3><p>在制品限制值不是具体可计算的，需要长期经验积累和磨合才能定下一个合适的值. 值越小，成员可以更专注于当前的事情，增强成员之间的协作。值越大，可以处理的事情更多，任务调度会更为灵活。</p><p>一个基于经验的、折中的公式是： <code>在制品上限 = 团队规模 * 2 -1</code>。</p><p><br><br><br></p><h2 id="第三阶-结合scrum"><a href="#第三阶-结合scrum" class="headerlink" title="第三阶: 结合Scrum"></a>第三阶: 结合Scrum</h2><p><a href="https://zh.wikipedia.org/zh-hans/Scrum" target="_blank" rel="noopener"><code>Scrum</code></a> 也是一个敏捷框架. 它的规则非常简单，但是要精通非常难。所以第三阶段，我们可以尝试将 <code>Scrum</code> 的某些规则融合到看板的管理流程中</p><p><br></p><h3 id="简单介绍一下scrum"><a href="#简单介绍一下scrum" class="headerlink" title="简单介绍一下Scrum"></a>简单介绍一下Scrum</h3><p><img src="/images/kanban/scrum.png" alt></p><p>上图一个典型的 <code>Scrum</code> 流程.</p><p>简而言之，<code>Scrum</code> 首先会将应用开发过程拆分为多个迭代周期，这个迭代周期称为 <code>Sprint</code> (一个冲刺)，周期一般为1-4周。</p><p><br></p><p><img src="/images/kanban/backlog.png" alt></p><p>在每次开始一个冲刺时，会从<code>功能列表</code>(Product Backlog)中，按照优先级和时间评估筛选出这个冲刺可以完成的任务列表，称为<code>冲刺列表</code>(Sprint Backlog); 接着就在这个迭代周期里专心完成这些任务</p><p>另外 <code>Scrum</code> 还定义了各种<code>活动</code>, 来进行持续的反馈和调整， 例如:</p><ul><li><strong>Sprint计划会议</strong> - 在开始一个冲刺前，计划一个周期内需要做哪些任务，对任务进行时间评估</li><li><strong>每日立会</strong> - 同步开发进度、发现开发中的障碍、增加交流和沟通</li><li><strong>评审会议</strong> - 在冲刺结束时举行，用于检查计划中的工作，哪些完成了，哪些没有完成。有些团队会让功能的负责人演示自己所做的功能，然后 PM 会看这个功能是否达到了要求</li><li><strong>回顾会议</strong> - 在冲刺结束时举行，回顾和反省本次迭代遇到的问题、以及如何改进</li></ul><p>另外，<code>Scrum</code>还定义了各种角色和价值观。这些不在本文的范围之内，我们也不会全部照搬. 有兴趣的读者可以查看参考文献</p><p><br></p><h3 id="融合到看板中"><a href="#融合到看板中" class="headerlink" title="融合到看板中"></a>融合到看板中</h3><h4 id="设定开发周期"><a href="#设定开发周期" class="headerlink" title="设定开发周期"></a>设定开发周期</h4><p>瀑布式和敏捷的明显区别就是开发流程分割成多个迭代过程。按<code>Scrum</code>的定义就是一个’冲刺‘.</p><p>在我们实际的开发中，会以一个星期作为一个开发周期。我觉的一周的时间刚刚好，时间太长很难对任务时间进行评估，而且未知因素也会更多.</p><p><img src="/images/kanban/sprint.png" alt></p><p>在一个星期开始前，从’计划‘栏中筛选本周要进行任务，拖进’本周待办’栏。这个过程就有点像 <code>Scrum</code> 的<code>计划会议</code></p><p><br></p><h4 id="每日回顾"><a href="#每日回顾" class="headerlink" title="每日回顾"></a>每日回顾</h4><p>笔者每天开始工作时，就会将团队成员聚集在一起，对着看板简单询问任务开发的进度，回顾昨日的工作，看是否出现障碍。如果有障碍则及时处理障碍，如果任务超出预期，则考虑是否应该重新调整计划。</p><p>总之就是尽早暴露问题，保证流程的顺畅。在这里<strong>看板就是一种重要的沟通工具</strong>。每日询问的时间都很短，一般都不超过10分钟，这个过程有点像 <code>Scrum</code> 的每日立会</p><p>在<code>Tower</code>中，完成任务后我们不会直接将卡片拖入已完成列表，而是在最后一个环节点击’已完成‘，这样方便次日对已完成的任务进行回顾，回顾完成后再统一拖入’已完成‘栏</p><p><br></p><h4 id="流程监控"><a href="#流程监控" class="headerlink" title="流程监控"></a>流程监控</h4><p><strong>燃尽图</strong></p><p>燃尽图是常见的Scrum进度跟踪工具。它的外形如下:</p><p><img src="/images/kanban/burndown.png" alt></p><p>横轴为开发周期，纵轴为任务量. 理想状态下，任务量在周期结束时应该变为0，也就是说理想的线段是一条对角线(蓝线), 这也是一条参考线。如果在某个指定时间点，红线高于蓝线，则说明进度有些延迟，反之就是超前</p><p>使用燃尽图，我们一般会通常会在每日回顾时在燃尽图上绘制一个点，表示截止到此刻未完成的任务量</p><p><br></p><p><strong>累计流量图</strong></p><p>累计流量图统计每一天每一栏的在制品数量。从而可以反映不同环节任务处理速率，以及暴露环节之间的瓶颈:</p><p><img src="/images/kanban/cumulative-flow.png" alt></p><p><br><br><br></p><h2 id="看板一日游"><a href="#看板一日游" class="headerlink" title="看板一日游"></a>看板一日游</h2><p>下面模仿经典的文章<a href="https://blog.crisp.se/2009/06/26/henrikkniberg/1246053060000" target="_blank" rel="noopener">《看板一日游》</a> 实践一下本文讲述的看板使用流程。我们使用的工具是 <code>Tower</code>，这个也是我们团队目前在使用的，功能基本够用。</p><p><br></p><h3 id="设计看板"><a href="#设计看板" class="headerlink" title="设计看板"></a>设计看板</h3><p>假设我们的前端团队有3个人，开发流程是这样的: <code>开发 -&gt; 交叉测试 -&gt; 部署</code>。按照上面学到的知识，我们设计了这样的看板布局:</p><p><img src="/images/kanban/oneday1-1.png" alt></p><p><br></p><h3 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h3><p>现在点开Tower任务创建窗口. <code>Tower</code> 的任务功能已经非常丰富了。为了更方面其他人处理任务，我们对任务进行了一些规范</p><p><img src="/images/kanban/oneday2.png" alt></p><p><br></p><ul><li>① 标题: <code>以 [scope] 概述 (时间评估)</code>. <ul><li><code>scope</code> 是指任务的范围，例如项目A，项目B</li><li><code>时间评估</code> 要求对耗时较久的任务进行评估。我们一般推荐任务的粒度在3h 到 2d之间，小于3h考虑将任务进行合并，大于2d则考虑继续拆分任务</li></ul></li><li>② 指派负责人: 可选，不指派则说明采用拉模式</li><li>③ 任务的Deadline</li><li>④ 设置任务优先级</li><li>⑤ 详细说明</li><li>⑥ 细化任务</li><li>⑦ 依赖任务</li><li>⑧ 任务标签: 可以指定任务的类型，例如功能、Bug、优化、重构</li></ul><p><br></p><h3 id="开始吧"><a href="#开始吧" class="headerlink" title="开始吧"></a>开始吧</h3><p><strong>首选计划一下这周需要这些什么</strong>:</p><p><img src="/images/kanban/oneday3.png" alt></p><p><br></p><p><strong>开始工作，按照优先级排序 ，放入缓冲区:</strong></p><p><img src="/images/kanban/oneday4.png" alt></p><p><br></p><p><strong>认领自己的任务</strong></p><p><img src="/images/kanban/oneday5-1.png" alt></p><p><br></p><p><strong>ok，完成了，放入下一个栏</strong></p><p><img src="/images/kanban/oneday6-1.png" alt></p><p><br></p><p><img src="/images/kanban/oneday7-1.png" alt></p><p><br></p><p><strong>下游达到在制品限制了，不行, 得清一下，停下手动的工作，做一下交叉测试吧</strong></p><p><img src="/images/kanban/oneday8-1.png" alt></p><p><br></p><p><img src="/images/kanban/oneday9-1.png" alt></p><p><br></p><p><img src="/images/kanban/oneday10-1.png" alt></p><p><strong>次日问询回顾，任务完成的还不错，有遇到什么问题吗？完成回顾后将任务正式拖入已完成</strong></p><p><img src="/images/kanban/oneday11-1.png" alt></p><p><br></p><p>😫好累，不写总结了，就这样吧，</p><p>本文完！</p><p><br></p><h2 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h2><ul><li><a href="https://www.zhihu.com/question/30270633" target="_blank" rel="noopener">求推荐在线看板工具软件？</a> 电子看板推荐</li><li><a href="https://github.com" target="_blank" rel="noopener">看板系统实施细则</a></li><li><a href="https://book.douban.com/subject/26764497/" target="_blank" rel="noopener">《精益开发与看板方法》</a></li><li><a href="https://www.infoq.cn/article/kanban-development-method" target="_blank" rel="noopener">解析精益产品开发（一）—— 看板开发方法</a></li><li><a href="https://www.jianshu.com/p/e44b1038c9cf" target="_blank" rel="noopener">Scrum vs. 看板，还是Scrum + 看板？</a></li><li><a href="https://ruddyblog.wordpress.com/tag/看板一日遊/" target="_blank" rel="noopener">one day in kanban land 中文版</a></li></ul><p><img src="/images/sponsor.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;看板&lt;/code&gt;是一种非常常见的任务管理机制。我们使用到的大部分团队协作工具中都有看板的身影，例如 &lt;a href=&quot;http://tower.im&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Tower&lt;/code&gt;&lt;/a&gt;、
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>自己写个React渲染器: 以 Remax 为例(用React写小程序)</title>
    <link href="https://bobi.ink/2019/09/15/remax/"/>
    <id>https://bobi.ink/2019/09/15/remax/</id>
    <published>2019-09-14T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.330Z</updated>
    
    <content type="html"><![CDATA[<p>上个月蚂蚁金服前端发布了一个新的框架 <a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a>, 口号是<strong>使用真正的、完整的 React 来开发小程序</strong>.</p><p>对于原本的 React 开发者来说 ‘Learn once, write anywhere’ , 和 ReactNative 开发体验差不多，<strong>而对于小程序来说则是全新的开发体验</strong>。</p><p><a href="https://github.com/NervJS/taro" target="_blank" rel="noopener"><code>Taro</code></a>号称是‘类React’的开发方案，但是它是使用静态编译的方式实现，<a href="https://www.zhihu.com/people/meck" target="_blank" rel="noopener">边柳</a> 在它的 <a href="https://zhuanlan.zhihu.com/p/79788488" target="_blank" rel="noopener">《Remax - 使用真正的 React 构建小程序》</a>文章中也提到了这一点:</p><p><code>所谓静态编译，就是使用工具把代码语法分析一遍，把其中的 JSX 部分和逻辑部分抽取出来，分别生成小程序的模板和 Page 定义。</code></p><p>这种方案实现起来比较复杂，且运行时并没有 React 存在。</p><p><br></p><p>相比而言，<a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 的解决方案就简单很多，<strong>它不过就是新的React渲染器</strong>.</p><p><img src="/images/remax/01.png" alt></p><p><br></p><blockquote><p>因为 <a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 刚发布不久，核心代码比较简单，感兴趣的可以去 <a href="https://github.com/remaxjs/remax" target="_blank" rel="noopener">github</a> 观摩贡献 <br><br>可以通过 CodeSandbox 游乐场试玩自定义Renderer: <a href="https://codesandbox.io/s/react-custom-renderer-mm9kl?fontsize=14" target="_blank" rel="noopener">Edit react-custom-renderer</a> <br><br>文章看起来比较长，好戏在后头，一步一步来 🦖</p></blockquote><p><br></p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#关于react的一些基本概念">关于React的一些基本概念</a></li><li><a href="#自定义react渲染器">自定义React渲染器</a></li><li><a href="#hostconfig-渲染器适配">HostConfig 渲染器适配</a></li><li><a href="#宿主组件">宿主组件</a></li><li><a href="#镜像树的构建和操作">镜像树的构建和操作</a></li><li><a href="#节点更新">节点更新</a></li><li><a href="#副作用提交">副作用提交</a></li><li><a href="#hostconfig执行流程总结">HostConfig执行流程总结</a></li><li><a href="#同步到渲染进程">同步到渲染进程</a></li><li><a href="#总结">总结</a></li><li><a href="#扩展阅读">扩展阅读</a></li></ul><!-- /TOC --><p><br></p><h2 id="关于react的一些基本概念"><a href="#关于react的一些基本概念" class="headerlink" title="关于React的一些基本概念"></a>关于React的一些基本概念</h2><p>创建一个 React 自定义渲染器，你需要对React渲染的基本原理有一定的了解。所以在深入阅读本文之前，先要确保你能够理解以下几个基本概念:</p><p><strong>1. Element</strong></p><p>我们可以通过 <code>JSX</code> 或者 <code>React.createElement</code> 来创建 Element，用来描述我们要创建的视图节点。比如:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">'button button-blue'</span>&gt;</span><br><span class="line">  &lt;b&gt;</span><br><span class="line">    OK!</span><br><span class="line">  &lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure><p><code>JSX</code> 会被转义译为:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">"button"</span>,</span><br><span class="line">  &#123; <span class="attr">class</span>: <span class="string">'button button-blue'</span> &#125;,</span><br><span class="line">  React.createElement(<span class="string">"b"</span>, <span class="literal">null</span>, <span class="string">"OK!"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>React.createElement</code> 最终构建出类似这样的对象:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">'button'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">'button button-blue'</span>,</span><br><span class="line">    children: &#123;</span><br><span class="line">      type: <span class="string">'b'</span>,</span><br><span class="line">      props: &#123;</span><br><span class="line">        children: <span class="string">'OK!'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说 <strong>Element 就是一个普通的对象，描述用户创建的节点类型、props 以及 children</strong>。这些 Elements 组合成树，描述用户视图</p><p><br></p><p><strong>2. Component</strong></p><p>可以认为是 Element 的类型，它有两种类型：</p><ul><li><p><strong>Host Component</strong>: 宿主组件，这是由渲染的平台提供的‘内置’组件，例如<code>ReactDOM</code> 平台下面的 <code>DOM</code> 节点，如 <code>div</code>、<code>span</code>… 这些组件类型为字符串</p></li><li><p><strong>Composite Component</strong>: 复合组件，这是一种用户自定义的组件封装单位。通常包含自定义的逻辑、状态以及输出 Element 树。复合类型可以为类或函数</p></li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DeleteAccount = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;Are you sure?<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &lt;DangerButton&gt;Yep&lt;<span class="regexp">/DangerButton&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Button color='blue'&gt;Cancel&lt;/</span>Button&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>3. Instance</strong></p><p>当 React 开始渲染一个 Element 时，会根据组件类型为它创建一个‘实例’，例如类组件，会调用<code>new</code>操作符实例化。这个实例会一直引用，直到 Element 从 Element Tree 中被移除。</p><p><code>首次渲染</code>: React 会实例化一个 <code>MyButton</code> 实例，调用挂载相关的生命周期方法，并执行 <code>render</code> 方法，递归渲染下级</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">MyButton</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">MyButton</span>&gt;</span></span>, container)</span><br></pre></td></tr></table></figure><p><br></p><p><code>更新</code>: 因为组件类型没有变化，React 不会再实例化，这个属于‘节点更新’，React 会执行更新相关的生命周期方法，如<code>shouldComponentUpdate</code>。如果需要更新则再次执行<code>render</code>方法</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">MyButton</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">MyButton</span>&gt;</span></span>, container)</span><br></pre></td></tr></table></figure><p><br></p><p><code>卸载</code>: 组件类型不一样了, 原有的 MyButton 被替换. MyButton 的实例将要被销毁，React 会执行卸载相关的生命周期方法，如<code>componentWillUnmount</code></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>, container)</span><br></pre></td></tr></table></figure><p><br></p><p><strong>4. Reconciler</strong> &amp; <strong>Renderer</strong></p><p><code>Reconciler</code> 和 <code>Renderer</code> 的关系可以通过下图缕清楚.</p><p><strong>Reconciler 的职责是维护 VirtualDOM 树，内部实现了 Diff/Fiber 算法，决定什么时候更新、以及要更新什么</strong></p><p>而 <strong>Renderer 负责具体平台的渲染工作，它会提供宿主组件、处理事件等等</strong>。例如ReactDOM就是一个渲染器，负责DOM节点的渲染和DOM事件处理。</p><p><br></p><p><img src="/images/remax/02.png" alt></p><p><br></p><p><strong>5. Fiber 的两个阶段</strong><br>React 使用了 Fiber 架构之后，更新过程被分为两个阶段(Phase)</p><ul><li><strong>协调阶段(Reconciliation Phase)</strong> 这个阶段 React 会找出需要更新的节点。这个阶段是可以被打断的，比如有优先级更高的事件要处理时。</li><li><strong>提交阶段(Commit Phase)</strong> 将上一个阶段计算出来的需要处理的<strong>副作用(Effects)</strong>一次性执行了。这个阶段必须同步执行，不能被打断</li></ul><p><br></p><p>如果按照<code>render</code>为界，可以将生命周期函数按照两个阶段进行划分：</p><ul><li><strong>协调阶段</strong><ul><li><code>constructor</code></li><li><code>componentWillMount</code> 废弃</li><li><code>componentWillReceiveProps</code> 废弃</li><li><code>static getDerivedStateFromProps</code></li><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code> 废弃</li><li><code>render</code></li><li><code>getSnapshotBeforeUpdate()</code></li></ul></li><li><strong>提交阶段</strong><ul><li><code>componentDidMount</code></li><li><code>componentDidUpdate</code></li><li><code>componentWillUnmount</code></li></ul></li></ul><p><br></p><blockquote><p>没理解？那么下文读起来对你可能比较吃力，建议阅读一些关于React基本原理的相关文章。</p></blockquote><p><br></p><p>就目前而言，React 大部分核心的工作已经在 Reconciler 中完成，好在 React 的架构和模块划分还比较清晰，React官方也暴露了一些库，这极大简化了我们开发 Renderer 的难度。开始吧！</p><p><br></p><h2 id="自定义react渲染器"><a href="#自定义react渲染器" class="headerlink" title="自定义React渲染器"></a>自定义React渲染器</h2><p>React官方暴露了一些库供开发者来扩展自定义渲染器：</p><ul><li><a href="https://github.com/facebook/react/tree/master/packages/react-reconciler" target="_blank" rel="noopener">react-reconciler</a> - 这就是 React 的协调器, React 的核心所在。我们主要通过它来开发渲染器。</li><li><a href="https://github.com/facebook/react/tree/master/packages/scheduler" target="_blank" rel="noopener">scheduler</a> - 合作调度器的一些 API 。本文不会用到</li></ul><blockquote><p>需要注意的是，<strong>这些包还是实验性的</strong>，API可能不太稳定。另外，没有详细的文档，你需要查看源代码或者其他渲染器实现；本文以及扩展阅读中的文章也是很好的学习资料。</p></blockquote><p><br></p><p>创建一个自定义渲染器只需两步:</p><p><img src="/images/remax/04.png" alt></p><p>第一步: <strong>实现宿主配置</strong>，这是<code>react-reconciler</code>要求宿主提供的一些适配器方法和配置项。这些配置项定义了如何创建节点实例、构建节点树、提交和更新等操作。下文会详细介绍这些配置项</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Reconciler = <span class="built_in">require</span>(<span class="string">'react-reconciler'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HostConfig = &#123;</span><br><span class="line">  <span class="comment">// ... 实现适配器方法和配置项</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><p>第二步：<strong>实现渲染函数</strong>，类似于<a href="https://reactjs.org/docs/react-dom.html#render" target="_blank" rel="noopener"><code>ReactDOM.render()</code></a> 方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Reconciler实例, 并将HostConfig传递给Reconciler</span></span><br><span class="line"><span class="keyword">const</span> MyRenderer = Reconciler(HostConfig);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 假设和ReactDOM一样，接收三个参数</span></span><br><span class="line"><span class="comment"> * render(&lt;MyComponent /&gt;, container, () =&gt; console.log('rendered'))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建根容器</span></span><br><span class="line">  <span class="keyword">if</span> (!container._rootContainer) &#123;</span><br><span class="line">    container._rootContainer = ReactReconcilerInst.createContainer(container, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新根容器</span></span><br><span class="line">  <span class="keyword">return</span> ReactReconcilerInst.updateContainer(element, container._rootContainer, <span class="literal">null</span>, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器既是 React 组件树挂载的<code>目标</code>(例如 ReactDOM 我们通常会挂载到 <code>#root</code> 元素，<code>#root</code> 就是一个容器)、也是组件树的 <code>根Fiber节点(FiberRoot)</code>。根节点是整个组件树的入口，它将会被 Reconciler 用来保存一些信息，以及管理所有节点的更新和渲染。</p><p>关于 Fiber 架构的一些细节可以看这些文章:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/57346388" target="_blank" rel="noopener">《译 深入React fiber架构及源码》</a></li><li><a href="https://juejin.im/post/5ab7b3a2f265da2378403e57" target="_blank" rel="noopener">《React Fiber》</a> 有能力的同学，可以直接看<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">Lin Clark</a>的演讲</li></ul><p><br></p><h2 id="hostconfig-渲染器适配"><a href="#hostconfig-渲染器适配" class="headerlink" title="HostConfig 渲染器适配"></a>HostConfig 渲染器适配</h2><p><code>HostConfig</code> 支持非常多的参数，完整列表可以看<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/forks/ReactFiberHostConfig.custom.js" target="_blank" rel="noopener">这里</a>. 下面是一些自定义渲染器<strong>必须</strong>提供的参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface HostConfig &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用于分享一些上下文信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 获取根容器的上下文信息, 只在根节点调用一次</span></span><br><span class="line">  getRootHostContext(rootContainerInstance: Container): HostContext;</span><br><span class="line">  <span class="comment">// 获取子节点的上下文信息, 每遍历一个节点都会调用一次</span></span><br><span class="line">  getChildHostContext(parentHostContext: HostContext, <span class="attr">type</span>: Type, <span class="attr">rootContainerInstance</span>: Container): HostContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 节点实例的创建</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 普通节点实例创建，例如DOM的Element类型</span></span><br><span class="line">  createInstance(type: Type, <span class="attr">props</span>: Props, <span class="attr">rootContainerInstance</span>: Container, <span class="attr">hostContext</span>: HostContext, <span class="attr">internalInstanceHandle</span>: OpaqueHandle,): Instance;</span><br><span class="line">  <span class="comment">// 文本节点的创建，例如DOM的Text类型</span></span><br><span class="line">  createTextInstance(text: string, <span class="attr">rootContainerInstance</span>: Container, <span class="attr">hostContext</span>: HostContext, <span class="attr">internalInstanceHandle</span>: OpaqueHandle): TextInstance;</span><br><span class="line">  <span class="comment">// 决定是否要处理子节点/子文本节点. 如果不想创建则返回true. 例如ReactDOM中使用dangerouslySetInnerHTML, 这时候子节点会被忽略</span></span><br><span class="line">  shouldSetTextContent(type: Type, <span class="attr">props</span>: Props): boolean;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 节点树构建</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 如果节点在*未挂载*状态下，会调用这个来添加子节点</span></span><br><span class="line">  appendInitialChild(parentInstance: Instance, <span class="attr">child</span>: Instance | TextInstance): <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// **下面都是副作用(Effect)，在’提交‘阶段被执行**</span></span><br><span class="line">  <span class="comment">// 添加子节点</span></span><br><span class="line">  appendChild?(parentInstance: Instance, <span class="attr">child</span>: Instance | TextInstance): <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 添加子节点到容器节点(根节点)</span></span><br><span class="line">  appendChildToContainer?(container: Container, <span class="attr">child</span>: Instance | TextInstance): <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 插入子节点</span></span><br><span class="line">  insertBefore?(parentInstance: Instance, <span class="attr">child</span>: Instance | TextInstance, <span class="attr">beforeChild</span>: Instance | TextInstance): <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 插入子节点到容器节点(根节点)</span></span><br><span class="line">  insertInContainerBefore?(container: Container, <span class="attr">child</span>: Instance | TextInstance, <span class="attr">beforeChild</span>: Instance | TextInstance,): <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 删除子节点</span></span><br><span class="line">  removeChild?(parentInstance: Instance, <span class="attr">child</span>: Instance | TextInstance): <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 从容器节点(根节点)中移除子节点</span></span><br><span class="line">  removeChildFromContainer?(container: Container, <span class="attr">child</span>: Instance | TextInstance): <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 节点挂载</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 在完成所有子节点初始化时(所有子节点都appendInitialChild完毕)时被调用, 如果返回true，则commitMount将会被触发</span></span><br><span class="line">  <span class="comment">// ReactDOM通过这个属性和commitMount配置实现表单元素的autofocus功能</span></span><br><span class="line">  finalizeInitialChildren(parentInstance: Instance, <span class="attr">type</span>: Type, <span class="attr">props</span>: Props, <span class="attr">rootContainerInstance</span>: Container, <span class="attr">hostContext</span>: HostContext): boolean;</span><br><span class="line">  <span class="comment">// 和finalizeInitialChildren配合使用，commitRoot会在’提交‘完成后(resetAfterCommit)执行, 也就是说组件树渲染完毕后执行</span></span><br><span class="line">  commitMount?(instance: Instance, <span class="attr">type</span>: Type, <span class="attr">newProps</span>: Props, <span class="attr">internalInstanceHandle</span>: OpaqueHandle): <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 节点更新</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 准备节点更新. 如果返回空则表示不更新，这时候commitUpdate则不会被调用</span></span><br><span class="line">  prepareUpdate(instance: Instance, <span class="attr">type</span>: Type, <span class="attr">oldProps</span>: Props, <span class="attr">newProps</span>: Props, <span class="attr">rootContainerInstance</span>: Container, <span class="attr">hostContext</span>: HostContext,): <span class="literal">null</span> | UpdatePayload;</span><br><span class="line">  <span class="comment">// **下面都是副作用(Effect)，在’提交‘阶段被执行**</span></span><br><span class="line">  <span class="comment">// 文本节点提交</span></span><br><span class="line">  commitTextUpdate?(textInstance: TextInstance, <span class="attr">oldText</span>: string, <span class="attr">newText</span>: string): <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 普通节点提交</span></span><br><span class="line">  commitUpdate?(instance: Instance, <span class="attr">updatePayload</span>: UpdatePayload, <span class="attr">type</span>: Type, <span class="attr">oldProps</span>: Props, <span class="attr">newProps</span>: Props, <span class="attr">internalInstanceHandle</span>: OpaqueHandle): <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 重置普通节点文本内容, 这个需要和shouldSetTextContent(返回true时)配合使用，</span></span><br><span class="line">  resetTextContent?(instance: Instance): <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 提交</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 开始’提交‘之前被调用，比如这里可以保存一些状态，在’提交‘完成后恢复状态。比如ReactDOM会保存当前元素的焦点状态，在提交后恢复</span></span><br><span class="line">  <span class="comment">// 执行完prepareForCommit，就会开始执行Effects(节点更新)</span></span><br><span class="line">  prepareForCommit(containerInfo: Container): <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 和prepareForCommit对应，在提交完成后被执行</span></span><br><span class="line">  resetAfterCommit(containerInfo: Container): <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 调度</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 这个函数将被Reconciler用来计算当前时间, 比如计算任务剩余时间 </span></span><br><span class="line">  <span class="comment">// ReactDOM中会优先使用Performance.now, 普通场景用Date.now即可</span></span><br><span class="line">  now(): number;</span><br><span class="line">  <span class="comment">// 自定义计时器</span></span><br><span class="line">  setTimeout(handler: <span class="function">(<span class="params">...args: any[]</span>) =&gt;</span> <span class="keyword">void</span>, <span class="attr">timeout</span>: number): TimeoutHandle | NoTimeout;</span><br><span class="line">  <span class="comment">// 取消计时器</span></span><br><span class="line">  clearTimeout(handle: TimeoutHandle | NoTimeout): <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 表示一个空的计时器，见👆clearTimeout的签名</span></span><br><span class="line">  noTimeout: NoTimeout;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ? 功能未知</span></span><br><span class="line">  shouldDeprioritizeSubtree(type: Type, <span class="attr">props</span>: Props): boolean;</span><br><span class="line">  <span class="comment">// 废弃</span></span><br><span class="line">  scheduleDeferredCallback(callback: <span class="function"><span class="params">()</span> =&gt;</span> any, options?: &#123; <span class="attr">timeout</span>: number &#125;): any;</span><br><span class="line">  <span class="comment">// 废弃</span></span><br><span class="line">  cancelDeferredCallback(callbackID: any): <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 功能开启</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 开启节点修改，一般渲染器都会开启，不然无法更新节点</span></span><br><span class="line">  supportsMutation: boolean;</span><br><span class="line">  <span class="comment">// 开启持久化 ?</span></span><br><span class="line">  supportsPersistence: boolean;</span><br><span class="line">  <span class="comment">// 开启hydrate，一般用于服务端渲染</span></span><br><span class="line">  supportsHydration: boolean;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 杂项</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 获取可公开的节点实例，即你愿意暴露给用户的节点信息，用户通过ref可以获取到这个对象。一般自定义渲染器原样返回即可, 除非你想有选择地给用户暴露信息</span></span><br><span class="line">  getPublicInstance(instance: Instance | TextInstance): PublicInstance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 还有很多参数，由于一般渲染器不会用到，暂时不讲了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>如果按照<code>Fiber的两个阶段</code>来划分的话，接口分类是这样的:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">| 协调阶段                 | 开始提交         | 提交阶段                  | 提交完成         |</span><br><span class="line">|-------------------------|----------------|--------------------------|-----------------|</span><br><span class="line">| createInstance          | prepareCommit  | appendChild              | resetAfterCommit|</span><br><span class="line">| createTextInstance      |                | appendChildToContainer   | commitMount     |</span><br><span class="line">| shouldSetTextContent    |                | insertBefore             |                 |</span><br><span class="line">| appendInitialChild      |                | insertInContainerBefore  |                 |</span><br><span class="line">| finalizeInitialChildren  |                | removeChild              |                 |</span><br><span class="line">| prepareUpdate           |                | removeChildFromContainer |                 |</span><br><span class="line">|                         |                | commitTextUpdate         |                 |</span><br><span class="line">|                         |                | commitUpdate             |                 |</span><br><span class="line">|                         |                | resetTextContent         |                 |</span><br></pre></td></tr></table></figure><p><br></p><p>通过上面接口定义可以知道 <code>HostConfig</code> 配置比较丰富，涉及节点操作、挂载、更新、调度、以及各种生命周期钩子, 可以控制渲染器的各种行为.</p><p>看得有点蒙圈？没关系, 你暂时没有必要了解所有的参数，下面会一点一点展开解释这些功能。你可以最后再回来看这里。</p><p><br></p><h2 id="宿主组件"><a href="#宿主组件" class="headerlink" title="宿主组件"></a>宿主组件</h2><p>React中有两种组件类型，一种是<code>宿主组件(Host Component)</code>, 另一种是<code>复合组件(CompositeComponent)</code>. <code>宿主组件</code>是平台提供的，例如 <code>ReactDOM</code> 平台提供了 <code>div</code>、<code>span</code>、<code>h1</code>… 等组件. 这些组件通常是字符串类型，直接渲染为平台下面的视图节点。</p><p>而<code>复合组件</code>，也称为<code>自定义组件</code>，用于组合其他<code>复合组件</code>和<code>宿主组件</code>，通常是类或函数。</p><p>渲染器不需要关心<code>复合组件</code>的处理, Reconciler 交给渲染器的是一颗<code>宿主组件树</code>。</p><p>当然在 <a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 中，也定义了很多小程序特定的<code>宿主组件</code>，比如我们可以这样子使用它们:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">view</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><code>Reconciler</code> 会调用 <code>HostConfig</code> 的 <code>createInstance</code> 和<code>createTextInstance</code> 来创建<code>宿主组件</code>的实例，所以自定义渲染器必须实现这两个方法. 看看 <code>Remax</code> 是怎么做的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HostConfig = &#123;</span><br><span class="line">  <span class="comment">// 创建宿主组件实例</span></span><br><span class="line">  createInstance(type: string, <span class="attr">newProps</span>: any, <span class="attr">container</span>: Container) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = generate();</span><br><span class="line">    <span class="comment">// 预处理props, remax会对事件类型Props进行一些特殊处理</span></span><br><span class="line">    <span class="keyword">const</span> props = processProps(newProps, container, id);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> VNode(&#123;</span><br><span class="line">      id,</span><br><span class="line">      type,</span><br><span class="line">      props,</span><br><span class="line">      container,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建宿主组件文本节点实例</span></span><br><span class="line">  createTextInstance(text: string, <span class="attr">container</span>: Container) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = generate();</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> VNode(&#123;</span><br><span class="line">      id,</span><br><span class="line">      type: TYPE_TEXT,</span><br><span class="line">      props: <span class="literal">null</span>,</span><br><span class="line">      container,</span><br><span class="line">    &#125;);</span><br><span class="line">    node.text = text;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否需要处理子节点。如果返回true则不创建，整个下级组件树都会被忽略。</span></span><br><span class="line">  <span class="comment">// 有一些场景是不需要创建文本节点的，而是由父节点内部消化。</span></span><br><span class="line">  <span class="comment">// 举个例子，在ReactDOM中，如果某个节点设置了dangerouslySetInnerHTML，那么它的children应该被忽略，</span></span><br><span class="line">  <span class="comment">// 这时候 shouldSetTextContent则应该返回true</span></span><br><span class="line">  shouldSetTextContent(type, nextProps) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ReactDOM 中上面两个方法分别会通过 <code>document.createElement</code> 和 <code>document.createTextNode</code> 来创建<code>宿主组件</code>(即<code>DOM节点</code>)。</p><p><br></p><p><img src="/images/remax/wxm.png" alt></p><p>上面是微信小程序的架构图(图片来源: <a href="https://mp.weixin.qq.com/s/3QE3g0NmaBAi91lbrihhVw" target="_blank" rel="noopener">一起脱去小程序的外套 - 微信小程序架构解析</a>)。</p><p><strong>因为小程序隔离了<code>渲染进程</code>和<code>逻辑进程</code>。<a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 是跑在<code>逻辑进程</code>上的，在<code>逻辑进程</code>中无法进行实际的渲染, 只能通过<code>setData</code>方式将更新指令传递给<code>渲染进程</code>后，再进行解析渲染</strong>。</p><p>所以<a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a>选择在<code>逻辑进程</code>中先构成一颗<code>镜像树</code>(Mirror Tree), 然后再同步到<code>渲染进程</code>中，如下图:</p><p><img src="/images/remax/03.png" alt></p><p><br></p><p><strong>上面的 <code>VNode</code> 就是镜像树中的<code>虚拟节点</code>，主要用于保存一些节点信息，不做任何特殊处理</strong>, 它的结构如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  id: number;                  <span class="comment">// 唯一的节点id</span></span><br><span class="line">  container: Container;</span><br><span class="line">  children: VNode[];           <span class="comment">// 子节点</span></span><br><span class="line">  mounted = <span class="literal">false</span>;             <span class="comment">// 节点是否已经挂载</span></span><br><span class="line">  type: string | symbol;       <span class="comment">// 节点的类型</span></span><br><span class="line">  props?: any;                 <span class="comment">// 节点的props</span></span><br><span class="line">  parent: VNode | <span class="literal">null</span> = <span class="literal">null</span>; <span class="comment">// 父节点引用</span></span><br><span class="line">  text?: string;               <span class="comment">// 如果是文本节点，这里保存文本内容</span></span><br><span class="line">  path(): Path                 <span class="comment">// 节点的路径. 同步到渲染进程后，通过path恢复到树中</span></span><br><span class="line">  <span class="comment">// 子节点操作</span></span><br><span class="line">  appendChild(node: VNode, <span class="attr">immediately</span>: boolean)</span><br><span class="line">  removeChild(node: VNode, <span class="attr">immediately</span>: boolean)</span><br><span class="line">  insertBefore(newNode: VNode, <span class="attr">referenceNode</span>: VNode, <span class="attr">immediately</span>: boolean)</span><br><span class="line"></span><br><span class="line">  update()                     <span class="comment">// 触发同步到渲染进程</span></span><br><span class="line">  toJSON(): string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VNode 的完整代码可以看<a href="https://github.com/remaxjs/remax/blob/master/packages/remax/src/VNode.ts" target="_blank" rel="noopener">这里</a></p><p><br></p><h2 id="镜像树的构建和操作"><a href="#镜像树的构建和操作" class="headerlink" title="镜像树的构建和操作"></a>镜像树的构建和操作</h2><p>要构建出完整的节点树需要实现<code>HostConfig</code> 的 <code>appendChild</code>、<code>insertBefore</code>、<code>removeChild</code> 等方法, 如下， 这些方法都比较容易理解，所以不需要过多解释。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HostConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 支持节点修改</span></span><br><span class="line">  <span class="comment">// 有些静态渲染的场景，例如渲染为pdf文档，这时候可以关闭</span></span><br><span class="line">  <span class="comment">// 当关闭时，只需要实现appendInitiaChild</span></span><br><span class="line">  supportsMutation: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于初始化(首次)时添加子节点</span></span><br><span class="line">  appendInitialChild: <span class="function">(<span class="params">parent: VNode, child: VNode</span>) =&gt;</span> &#123;</span><br><span class="line">    parent.appendChild(child, <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加子节点</span></span><br><span class="line">  appendChild(parent: VNode, <span class="attr">child</span>: VNode) &#123;</span><br><span class="line">    parent.appendChild(child, <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入子节点</span></span><br><span class="line">  insertBefore(parent: VNode, <span class="attr">child</span>: VNode, <span class="attr">beforeChild</span>: VNode) &#123;</span><br><span class="line">    parent.insertBefore(child, beforeChild, <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点</span></span><br><span class="line">  removeChild(parent: VNode, <span class="attr">child</span>: VNode) &#123;</span><br><span class="line">    parent.removeChild(child, <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加节点到容器节点，一般情况我们不需要和appendChild特殊区分</span></span><br><span class="line">  appendChildToContainer(container: any, <span class="attr">child</span>: VNode) &#123;</span><br><span class="line">    container.appendChild(child);</span><br><span class="line">    child.mounted = <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入节点到容器节点</span></span><br><span class="line">  insertInContainerBefore(container: any, <span class="attr">child</span>: VNode, <span class="attr">beforeChild</span>: VNode) &#123;</span><br><span class="line">    container.insertBefore(child, beforeChild);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从容器节点移除节点</span></span><br><span class="line">  removeChildFromContainer(container: any, <span class="attr">child</span>: VNode) &#123;</span><br><span class="line">    container.removeChild(child);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="节点更新"><a href="#节点更新" class="headerlink" title="节点更新"></a>节点更新</h2><p>上一节讲的是树结构层面的更新，当节点属性变动或者文本内容变动时，也需要进行更新。我们可以通过下列 <code>HostConfig</code> 配置来处理这类更新:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HostConfig = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 更新相关</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 可以在这里比对props，如果props没有变化则不进行更新，这和React组件的shouldComponentUpdate差不多</span></span><br><span class="line">  <span class="comment">// **返回’空‘则表示不更新该节点, 这时候commitUpdate则不会被调用**</span></span><br><span class="line">  prepareUpdate(node: VNode, <span class="attr">type</span>: string, <span class="attr">oldProps</span>: any, <span class="attr">newProps</span>: any) &#123;</span><br><span class="line">    oldProps = processProps(oldProps, node.container, node.id);</span><br><span class="line">    newProps = processProps(newProps, node.container, node.id);</span><br><span class="line">    <span class="keyword">if</span> (!shallowequal(newProps, oldProps)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进行节点更新</span></span><br><span class="line">  commitUpdate(</span><br><span class="line">    node: VNode,</span><br><span class="line">    updatePayload: any,</span><br><span class="line">    type: string,</span><br><span class="line">    oldProps: any,</span><br><span class="line">    newProps: any</span><br><span class="line">  ) &#123;</span><br><span class="line">    node.props = processProps(newProps, node.container, node.id);</span><br><span class="line">    node.update();</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进行文本节点更新</span></span><br><span class="line">  commitTextUpdate(node: VNode, <span class="attr">oldText</span>: string, <span class="attr">newText</span>: string) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldText !== newText) &#123;</span><br><span class="line">      node.text = newText;</span><br><span class="line">      <span class="comment">// 更新节点</span></span><br><span class="line">      node.update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ok, 这个也比较好理解。<br>对于普通节点更新，<code>Reconciler</code> 会先调用 <code>prepareUpdate</code>, 确定是否要更新，如果返回非空数据，<code>Reconciler</code> 就会将节点放入 <code>Effects</code> 链中，在<code>提交</code>阶段调用 <code>commitUpdate</code> 来执行更新。<br>文本节点更新则直接调用 <code>commitTextUpdate</code>，不在话下.</p><p><br></p><h2 id="副作用提交"><a href="#副作用提交" class="headerlink" title="副作用提交"></a>副作用提交</h2><p>React 的<code>更新的两个阶段</code>这个概念非常重要，这个也体现在HostConfig上:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HostConfig = &#123;</span><br><span class="line">  <span class="comment">// Reconciler说，我要开始提交了，你提交前要做什么，就在这做吧</span></span><br><span class="line">  <span class="comment">// 比如ReactDOM会在这里保存当前DOM文档的选中状态和焦点状态, 以及禁用事件处理。因为DOM更新可能会破坏这些状态</span></span><br><span class="line">  prepareForCommit: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reconciler说，我已经提交完了</span></span><br><span class="line">  <span class="comment">// ReactDOM会在这里恢复提交前的DOM文档的选中状态和焦点状态</span></span><br><span class="line">  resetAfterCommit: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在协调阶段，当一个节点完成'创建'后调用。如果有子节点，则在所有子节点appendInitialChild完成后调用</span></span><br><span class="line">  <span class="comment">// 返回一个boolean值表示’完成提交‘后是否要调用commitMount. 通俗讲就是告诉Reconciler，当前节点完成’挂载‘后要执行某些东西</span></span><br><span class="line">  <span class="comment">// ReactDOM会使用这个钩子来处理带有autofoucs属性的节点，在commitMount中实现自动获取焦点</span></span><br><span class="line">  finalizeInitialChildren: <span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 和finalizeInitialChildren配合使用，如果前者返回true，在Reconciler完成提交后，对应节点的commitMount会被执行</span></span><br><span class="line">  commitMount: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>将上文讲到的所有钩子都聚合起来，按照更新的阶段和应用的目标(target)进行划分，它们的分布是这样的：</p><p><img src="/images/remax/overview.png" alt></p><p><br></p><p>那么对于 <a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 来说, 什么时候应该将’更新’提交到<code>渲染进程</code>呢？答案是上图所有在<code>提交阶段</code>的方法被调用时。</p><p><code>提交阶段</code>原意就是用于执行各种副作用的，例如视图更新、远程方法请求、订阅… 所以 <a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 也会在这个阶段收集<code>更新指令</code>，在下一个循环推送给渲染进程。</p><p><br></p><h2 id="hostconfig执行流程总结"><a href="#hostconfig执行流程总结" class="headerlink" title="HostConfig执行流程总结"></a>HostConfig执行流程总结</h2><p>回顾一下自定义渲染器各种方法调用的流程, 首先看一下<strong>挂载</strong>的流程:</p><p>假设我们的组件结构如下:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="keyword">new</span> Container()</span><br><span class="line"><span class="keyword">const</span> MyComp = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;hello world&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;div className=<span class="string">"root"</span>&gt;</span><br><span class="line">    &lt;MyComp /&gt;</span><br><span class="line">    &lt;span&gt;--custom renderer&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;,</span><br><span class="line">  container,</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"rendered"</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>React 组件树的结构如下(左图)，但对于渲染器来说，树结构是右图。<br>自定义组件是React 层级的东西，渲染器只需要关心最终需要渲染的视图结构, 换句话说渲染器只关心<code>宿主组件</code>:</p><p><img src="/images/remax/tree-compare.png" alt></p><p><br></p><p>挂载会经历以下流程:</p><p><img src="/images/remax/mount.png" alt></p><p>通过上面的流程图，可以很清晰看到每个钩子的调用时机。</p><p><br></p><p>同理，我们再来看一下节点<strong>更新</strong>时的流程. 我们稍微改造一下上面的程序，让它定时触发更新:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComp = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> isEven = count % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 递增计数器</span></span><br><span class="line">      setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(timer)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"mycomp"</span> style=&#123;&#123; <span class="attr">color</span>: isEven ? <span class="string">"red"</span> : <span class="string">"blue"</span> &#125;&#125;&gt;</span><br><span class="line">      &#123;isEven ? <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>even<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line">      &lt;span className=<span class="string">"foo"</span>&gt;hello world &#123;count&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>下面是更新的流程:</p><p><img src="/images/remax/update.png" alt></p><p><br></p><p>当<code>MyComp</code>的 <code>count</code> 由1变为2时，<code>MyComp</code> 会被重新渲染，这时候新增了一个<code>div</code> 节点(红色虚框), 另外 <code>hello world 1</code> 也变成了 <code>hello world 2</code>。</p><p>新增的 <code>div</code> 节点创建流程和挂载时一样，只不过它不会立即插入到父节点中，而是先放到<code>Effect</code>链表中，在<code>提交阶段</code>统一执行。</p><p>同理<code>hello world {count}</code>文本节点的更新、以及其他节点的 Props 更新都是放到Effect链表中，最后时刻才更新提交. 如上图的 <code>insertBefore</code>、<code>commitTextUpdate</code>、<code>commitUpdate</code>.</p><p>另外一个比较重要的是 <code>prepareUpdate</code> 钩子，你可以在这里告诉 Reconciler，节点是否需要更新，如果需要更新则返回非空值，这样 <code>commitUpdate</code> 才会被触发。</p><p><br></p><h2 id="同步到渲染进程"><a href="#同步到渲染进程" class="headerlink" title="同步到渲染进程"></a>同步到渲染进程</h2><p>React 自定义渲染器差不多就这样了，接下来就是平台相关的事情了。<br><a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 目前的做法是在触发更新后，通过小程序 <code>Page</code> 对象的 <code>setData</code> 方法将<code>更新指令</code>传递给渲染进程;<br><code>渲染进程</code>侧再通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/" target="_blank" rel="noopener"><code>WXS</code></a> 机制，将<code>更新指令</code>恢复到树中； 最后再通过<code>模板</code>机制，将树递归渲染出来。</p><p>整体的架构如下:</p><p><img src="/images/remax/07.png" alt></p><p><br></p><p>先来看看<code>逻辑进程</code>侧是如何推送更新指令的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在根容器上管理更新</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 触发更新</span></span><br><span class="line">  requestUpdate(</span><br><span class="line">    path: Path,</span><br><span class="line">    start: number,</span><br><span class="line">    deleteCount: number,</span><br><span class="line">    immediately: boolean,</span><br><span class="line">    ...items: RawNode[]</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">const</span> update: SpliceUpdate = &#123;</span><br><span class="line">      path, <span class="comment">// 更新节点的树路径</span></span><br><span class="line">      start, <span class="comment">// 更新节点在children中的索引</span></span><br><span class="line">      deleteCount,</span><br><span class="line">      items, <span class="comment">// 当前节点的信息</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (immediately) &#123;</span><br><span class="line">      <span class="keyword">this</span>.updateQueue.push(update);</span><br><span class="line">      <span class="keyword">this</span>.applyUpdate();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 放入更新队列，延时收集更新指令</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.updateQueue.length === <span class="number">0</span>) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.applyUpdate());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.updateQueue.push(update);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  applyUpdate() &#123;</span><br><span class="line">    <span class="keyword">const</span> action = &#123;</span><br><span class="line">      type: <span class="string">'splice'</span>,</span><br><span class="line">      payload: <span class="keyword">this</span>.updateQueue.map(<span class="function"><span class="params">update</span> =&gt;</span> (&#123;</span><br><span class="line">        path: stringPath(update.path),</span><br><span class="line">        start: update.start,</span><br><span class="line">        deleteCount: update.deleteCount,</span><br><span class="line">        item: update.items[<span class="number">0</span>],</span><br><span class="line">      &#125;)),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过setData通知渲染进程</span></span><br><span class="line">    <span class="keyword">this</span>.context.setData(&#123; action &#125;);</span><br><span class="line">    <span class="keyword">this</span>.updateQueue = [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>逻辑还是比较清楚的，即将需要更新的节点(包含节点路径、节点信息)推入更新队列，然后触发 <code>setData</code> 通知到<code>渲染进程</code>。</p><p><br></p><p><code>渲染进程</code>侧，则需要通过 <code>WXS</code> 机制，相对应地将<code>更新指令</code>恢复到<code>渲染树</code>中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染树</span></span><br><span class="line"><span class="keyword">var</span> tree = &#123;</span><br><span class="line">  root: &#123;</span><br><span class="line">    children: [],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指令应用到渲染树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; action.payload.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> value = <span class="keyword">get</span>(tree, action.payload[i].path);</span><br><span class="line">        if (action.payload[i].item) &#123;</span><br><span class="line">          value.splice(</span><br><span class="line">            action.payload[i].start,</span><br><span class="line">            action.payload[i].deleteCount,</span><br><span class="line">            action.payload[i].item</span><br><span class="line">          );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          value.splice(action.payload[i].start, action.payload[i].deleteCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(tree, action.payload[i].path, value);</span><br><span class="line">      &#125;</span><br><span class="line">      return tree;</span><br><span class="line">    default:</span><br><span class="line">      return tree;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>OK, 接着开始渲染, <a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 采用了<code>模板</code>的形式进行渲染:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">wxs</span> <span class="attr">src</span>=<span class="string">"../../helper.wxs"</span> <span class="attr">module</span>=<span class="string">"helper"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">src</span>=<span class="string">"../../base.wxml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">"REMAX_TPL"</span> <span class="attr">data</span>=<span class="string">"&#123;&#123;tree: helper.reduce(action)&#125;&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 为每个组件类型都生成了一个<code>template</code>，动态’递归’渲染整颗树:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">"REMAX_TPL"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;tree.root.children&#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"&#123;&#123;id&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">"REMAX_TPL_1_CONTAINER"</span> <span class="attr">data</span>=<span class="string">"&#123;&#123;i: item&#125;&#125;"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">wxs</span> <span class="attr">module</span>=<span class="string">"_h"</span>&gt;</span></span><br><span class="line">  module.exports = &#123;</span><br><span class="line">  v: function(value) &#123;</span><br><span class="line">  return value !== undefined ? value : '';</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">wxs</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 按照层级生成模板 --&gt;</span></span><br><span class="line">&lt;% for (var i = 1; i &lt;= depth; i++) &#123; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">%var</span> <span class="attr">id</span> = <span class="string">i;</span> %&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 生成组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">for</span> (<span class="attr">let</span> <span class="attr">component</span> <span class="attr">of</span> <span class="attr">components</span>) &#123; %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%-</span> <span class="attr">include</span>('<span class="attr">.</span>/<span class="attr">component.ejs</span>', &#123;</span></span><br><span class="line"><span class="tag">        <span class="attr">props:</span> <span class="attr">component.props</span>,</span></span><br><span class="line"><span class="tag">        <span class="attr">id:</span> <span class="attr">component.id</span>,</span></span><br><span class="line"><span class="tag">        <span class="attr">templateId:</span> <span class="attr">id</span>,</span></span><br><span class="line"><span class="tag">      &#125;) %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">"REMAX_TPL_&lt;%=id%&gt;_plain-text"</span> <span class="attr">data</span>=<span class="string">"&#123;&#123;i: i&#125;&#125;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">block</span>&gt;</span>&#123;&#123;i.text&#125;&#125;<span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  把动态选择模板的逻辑放入一个模板内，可以提升性能问题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">"REMAX_TPL_&lt;%=id%&gt;_CONTAINER"</span> <span class="attr">data</span>=<span class="string">"&#123;&#123;i: i&#125;&#125;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">"&#123;&#123;'REMAX_TPL_&lt;%=id%&gt;_' + i.type&#125;&#125;"</span> <span class="attr">data</span>=<span class="string">"&#123;&#123;i: i&#125;&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><p>限于小程序的渲染机制，以下因素可能会影响渲染的性能:</p><ul><li>进程IPC。更新指令通过IPC通知到渲染进程，频繁更新可能会影响性能.  ReactNative 中涉及到 Native 和 JS引擎之间的通信，也是存在这个问题的。<br>所以小程序才有了 <code>WXS</code> 这类方案，用来处理复杂的视图交互问题，比如动画。未来 <a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 也需要考虑这个问题</li><li><code>Reconciler</code>这一层已经进行了 Diff，到<code>渲染进程</code>可能需要重复再做一遍？</li><li>基于模板的方案，局部更新是否会导致页面级别重新渲染？和小程序原生的自定义组件相比性能如何？</li></ul><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文以 <a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a> 为例，科普一个 React 自定义渲染器是如何运作的。对于 <a href="https://github.com/remaxjs" target="_blank" rel="noopener"><code>Remax</code></a>，目前还处于开发阶段，很多功能还不完善。至于<a href="https://github.com/remaxjs/remax/issues/156" target="_blank" rel="noopener">性能如何</a>，笔者还不好做评论，可以看官方给出的初步<a href="https://github.com/remaxjs/benchmark" target="_blank" rel="noopener">基准测试</a>。有能力的同学，可以参与代码贡献或者 Issue 讨论。</p><p>最后谢谢<a href="https://www.zhihu.com/people/meck" target="_blank" rel="noopener">边柳</a>对本文审校和建议。</p><p><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/79788488" target="_blank" rel="noopener">Remax - 使用真正的 React 构建小程序</a></li><li><a href="https://zhuanlan.zhihu.com/p/26027085" target="_blank" rel="noopener">React Fiber是什么</a></li><li><a href="https://zhuanlan.zhihu.com/p/57346388" target="_blank" rel="noopener">深入React fiber架构及源码</a></li><li><a href="https://medium.com/@agent_hunt/hello-world-custom-react-renderer-9a95b7cd04bc" target="_blank" rel="noopener">Hello World Custom React Renderer - Shailesh - Medium</a></li><li><a href="https://blog.atulr.com/react-custom-renderer-1/" target="_blank" rel="noopener">⚛️👆 Part 1/3 - Beginners guide to Custom React Renderers. How to build your own renderer from scratch?</a> 这系列文章很棒</li><li><a href="https://zhuanlan.zhihu.com/p/82741561" target="_blank" rel="noopener">谜之wxs，uni-app如何用它大幅提升性能</a></li><li><a href="https://zhuanlan.zhihu.com/p/59787245" target="_blank" rel="noopener">全新重构，uni-app实现微信端性能翻倍</a></li><li><a href="https://www.zhihu.com/search?type=content&amp;q=小程序原理" target="_blank" rel="noopener">浅谈小程序运行机制</a></li></ul><p><br></p><p><img src="/images/sponsor.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上个月蚂蚁金服前端发布了一个新的框架 &lt;a href=&quot;https://github.com/remaxjs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Remax&lt;/code&gt;&lt;/a&gt;, 口号是&lt;strong&gt;使用真正的、完整的 React
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>透过现象看本质: 常见的前端架构风格和案例</title>
    <link href="https://bobi.ink/2019/09/11/arch-pattern/"/>
    <id>https://bobi.ink/2019/09/11/arch-pattern/</id>
    <published>2019-09-10T16:00:00.000Z</published>
    <updated>2023-06-01T09:55:14.327Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>所谓软件架构风格，是指描述某个特定应用领域中系统组织方式的惯用模式。架构风格定义一个词汇表和一组约束，词汇表中包含一些组件及连接器，约束则指出系统如何将构建和连接器组合起来。软件架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将系统中的各个模块和子系统有机的结合为一个完整的系统</p></blockquote><p>没多少人能记住上面的定义，需要注意的是本文不是专业讨论系统架构的文章，笔者也还没到那个水平. 所以暂时没必要纠结于什么是架构模式、什么是架构风格。在这里<strong>尚且把它们都当成一个系统架构上的套路, 所谓的套路就是一些通用的、可复用的，用于应对某类问题的方式方法. 可以理解为类似“设计模式”的东西，只是解决问题的层次不一样</strong>。</p><p>透过现象看本质，本文将带你领略前端领域一些流行技术栈背后的架构思想。直接进入正题吧</p><p><strong>文章大纲</strong></p><!-- TOC --><ul><li><a href="#分层风格">分层风格</a><ul><li><a href="#virtual-dom">Virtual DOM</a></li><li><a href="#taro">Taro</a></li></ul></li><li><a href="#管道和过滤器">管道和过滤器</a><ul><li><a href="#中间件middleware">中间件(Middleware)</a></li></ul></li><li><a href="#事件驱动">事件驱动</a></li><li><a href="#mv">MV*</a><ul><li><a href="#家喻户晓的mvc">家喻户晓的MVC</a></li><li><a href="#redux">Redux</a></li></ul></li><li><a href="#复制风格">复制风格</a></li><li><a href="#微内核架构">微内核架构</a></li><li><a href="#微前端">微前端</a></li><li><a href="#组件化架构">组件化架构</a></li><li><a href="#其他">其他</a></li><li><a href="#扩展阅读">扩展阅读</a></li></ul><!-- /TOC --><p><br></p><h2 id="分层风格"><a href="#分层风格" class="headerlink" title="分层风格"></a>分层风格</h2><blockquote><p>没有什么问题是分层解决不了，如果解决不了, 就再加一层 —— 鲁迅 <br><br>不不，原话是: <code>Any problem  in computer science can be solved by anther layer of indirection.</code></p></blockquote><p>分层架构是最常见的软件架构，你要不知道用什么架构，或者不知道怎么解决问题，那就尝试加多一层。</p><p>一个分层系统是按照层次来组织的，每一层为在其之上的层提供服务，并且使用在其之下的层所提供的服务. <strong>分层通常可以解决什么问题</strong>？</p><ul><li><p><strong>是隔离业务复杂度与技术复杂度的利器</strong>. 典型的例子是网络协议, 越高层越面向人类，越底层越面向机器。一层一层往上，很多技术的细节都被隐藏了，比如我们使用<code>HTTP</code>时，不需要考虑<code>TCP</code>层的握手和包传输细节，<code>TCP</code>层不需要关心<code>IP</code>层的寻址和路由。</p><p><img src="/images/arch-pattern/tcp-ip-model.png" alt></p><p><br></p></li><li><p><strong>分离关注点和复用</strong>。减少跨越多层的耦合, 当一层变动时不会影响到其他层。例如我们前端项目建议拆分逻辑层和视图层，一方面可以降低逻辑和视图之间的耦合，当视图层元素变动时可以尽量减少对逻辑层的影响；另外一个好处是, 当逻辑抽取出去后，可以被不同平台的视图复用。</p></li></ul><p><br></p><p>关注点分离之后，软件的结构会变得容易理解和开发, 每一层可以被复用, 容易被测试, 其他层的接口通过模拟解决. 但是分层架构，也不是全是优点，<strong>分层的抽象可能会丢失部分效率和灵活性</strong>, 比如编程语言就有’层次’(此例可能不太严谨)，语言抽象的层次越高，一般运行效率可能会有所衰减:</p><p><img src="/images/arch-pattern/lang.png" alt></p><p>分层架构在软件领域的案例实在太多太多了，咱讲讲前端的一些’分层’案例：</p><p><br></p><h3 id="virtual-dom"><a href="#virtual-dom" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><p>前端石器时代，我们页面交互和渲染，是通过服务端渲染或者直接操作DOM实现的, 有点像C/C++这类系统编程语言手动操纵内存. 那时候<code>JQuery</code>很火:</p><p><img src="/images/arch-pattern/jquery.png" alt></p><p>后来随着软硬件性能越来越好、Web应用也越来越复杂，前端开发者的生产力也要跟上，类似JQuery这种命令式的编程方式无疑是比较低效的. 尽管手动操作 DOM 可能可以达到更高的性能和灵活性，但是这样对大部分开发者来说太低效了，我们是可以接受牺牲一点性能换取更高的开发效率的.</p><p>怎么解决，再加一层吧，后来React就搞了一层VirtualDOM。我们可以声明式、组合式地构建一颗对象树, 然后交由React将它映射到DOM：</p><p><img src="/images/arch-pattern/vd1.png" alt></p><p>一开始VirtualDOM和DOM的关系比较暧昧，两者是耦合在一起的。后面有人想，我们有了VirtualDOM这个抽象层，那应该能多搞点别的，比如渲染到移动端原生组件、PDF、Canvas、终端UI等等。</p><p>后来VirtualDOM进行了更彻底的分层，有着这个抽象层我们可以将VirtualDOM映射到更多类似应用场景:</p><p><img src="/images/arch-pattern/vd2.png" alt></p><p>所以说 VirtualDOM 更大的意义在于开发方式的转变: 声明式、 数据驱动, 让开发者不需要关心 DOM 的操作细节(属性操作、事件绑定、DOM 节点变更)，换句话说应用的开发方式变成了<code>view=f(state)</code>, 这对生产力的解放是有很大推动作用的; 另外有了VirtualDOM这一层抽象层，使得多平台渲染成为可能。</p><p>当然VirtualDOM或者React，不是唯一，也不是第一个这样的解决方案。其他前端框架，例如Vue、Angular基本都是这样一个发展历程。</p><p>上面说了，分层不是银弹。我们通过ReactNative可以开发跨平台的移动应用，但是众所周知，它运行效率或者灵活性暂时是无法与原生应用比拟的。</p><p><br></p><h3 id="taro"><a href="#taro" class="headerlink" title="Taro"></a>Taro</h3><p><strong><a href="https://taro-docs.jd.com/taro/docs/README.html" target="_blank" rel="noopener">Taro</a> 和React一样也采用分层架构风格，只不过他们解决的问题是相反的。React加上一个分层，可以渲染到不同的视图形态；而Taro则是为了统一多样的视图形态</strong>: 国内现如今市面上端的形态多种多样，Web、React-Native、微信小程序…… 针对不同的端去编写多套代码的成本非常高，这种需求催生了Taro这类框架的诞生. 使用 Taro，我们可以只书写一套代码, 通过编译工具可以输出到不同的端:</p><p><img src="/images/arch-pattern/taro.jpg" alt><br>(图片来源: <a href="https://aotu.io/notes/2018/06/07/Taro/" target="_blank" rel="noopener">多端统一开发框架 - Taro</a>)</p><p><br><br><br></p><h2 id="管道和过滤器"><a href="#管道和过滤器" class="headerlink" title="管道和过滤器"></a>管道和过滤器</h2><p>在管道/过滤器架构风格中，每个组件都有一组输入和输出，每个组件职责都很单一, 数据输入组件，经过内部处理，然后将处理过的数据输出。所以这些组件也称为过滤器，连接器按照业务需求将组件连接起来，其形状就像‘管道’一样，这种架构风格由此得名。</p><p><img src="/images/arch-pattern/pipeline.png" alt></p><p>这里面最经典的案例是<code>*unix</code> Shell命令，Unix的哲学就是“只做一件事，把它做好”，所以我们常用的Unix命令功能都非常单一，但是Unix Shell还有一件法宝就是管道，通过管道我们可以将命令通过<code>标准输入输出</code>串联起来实现复杂的功能:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 获取网页，并进行拼写检查。代码来源于wiki</span><br><span class="line">curl "http://en.wikipedia.org/wiki/Pipeline_(Unix)" | \</span><br><span class="line">sed 's/[^a-zA-Z ]/ /g' | \</span><br><span class="line">tr 'A-Z ' 'a-z\n' | \</span><br><span class="line">grep '[a-z]' | \</span><br><span class="line">sort -u | \</span><br><span class="line">comm -23 - /usr/share/dict/words | \</span><br><span class="line">less</span><br></pre></td></tr></table></figure><p><br></p><p>另一个和Unix管道相似的例子是<code>ReactiveX</code>, 例如<a href="https://github.com/ReactiveX/rxjs" target="_blank" rel="noopener">RxJS</a>. 很多教程将Rx比喻成河流，这个河流的开头就是一个事件源，这个事件源按照一定的频率发布事件。Rx真正强大的其实是它的操作符，有了这些操作符，你可以对这条河流<a href="https://rxjs.dev/operator-decision-tree" target="_blank" rel="noopener">做一切可以做的事情</a>，例如分流、节流、建大坝、转换、统计、合并、产生河流的河流……</p><p>这些操作符和Unix的命令一样，职责都很单一，只干好一件事情。但我们管道将它们组合起来的时候，就迸发了无限的能力.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fromEvent &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; throttleTime, map, scan &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</span><br><span class="line"></span><br><span class="line">fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>)</span><br><span class="line">  .pipe(</span><br><span class="line">    throttleTime(<span class="number">1000</span>),</span><br><span class="line">    map(<span class="function"><span class="params">event</span> =&gt;</span> event.clientX),</span><br><span class="line">    scan(<span class="function">(<span class="params">count, clientX</span>) =&gt;</span> count + clientX, <span class="number">0</span>)</span><br><span class="line">  )</span><br><span class="line">  .subscribe(<span class="function"><span class="params">count</span> =&gt;</span> <span class="built_in">console</span>.log(count));</span><br></pre></td></tr></table></figure><p><br></p><p>除了上述的RxJS，管道模式在前端领域也有很多应用，主要集中在前端工程化领域。例如’老牌’的项目构建工具<a href="https://www.gulpjs.com.cn/" target="_blank" rel="noopener">Gulp</a>, Gulp使用管道化模式来处理各种文件类型，管道中的每一个步骤称为Transpiler(转译器), 它们以 NodeJS 的Stream 作为输入输出。整个过程高效而简单。</p><p><img src="/images/arch-pattern/gulp.png" alt></p><p><br></p><p>不确定是否受到Gulp的影响，现代的<a href="https://www.webpackjs.com/" target="_blank" rel="noopener">Webpack</a>打包工具，也使用同样的模式来实现对文件的处理, 即<a href="https://www.webpackjs.com/concepts/loaders/" target="_blank" rel="noopener">Loader</a>, Loader 用于对模块的源代码进行转换, 通过Loader的组合，可以实现复杂的文件转译需求.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      use: [&#123;</span><br><span class="line">          loader: <span class="string">"style-loader"</span> <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">          loader: <span class="string">"css-loader"</span> <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">          loader: <span class="string">"sass-loader"</span> <span class="comment">// 将 Sass 编译成 CSS</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="中间件-middleware"><a href="#中间件-middleware" class="headerlink" title="中间件(Middleware)"></a>中间件(Middleware)</h3><p><img src="/images/arch-pattern/middleware.png" alt></p><p>如果开发过<code>Express</code>、<code>Koa</code>或者<code>Redux</code>, 你可能会发现中间件模式和上述的管道模式有一定的相似性，如上图。相比管道，中间件模式可以使用一个洋葱剖面来形容. 但和管道相比，一般的中间件实现有以下特点:</p><ul><li>中间件没有显式的输入输出。这些中间件之间通常通过集中式的上下文对象来共享状态</li><li>有一个循环的过程。管道中，数据处理完毕后交给下游了，后面就不管了。而中间件还有一个回归的过程，当下游处理完毕后会进行回溯，所以有机会干预下游的处理结果。</li></ul><p>我在谷歌上搜了老半天中间件，对于中间件都没有得到一个令我满意的定义. <strong>暂且把它当作一个特殊形式的管道模式吧</strong>。这种模式通常用于后端，它可以干净地分离出请求的不同阶段，也就是分离关注点。比如我们可以创建这些中间件：</p><ul><li>日志： 记录开始时间 ⏸ 计算响应时间，输出请求日志</li><li>认证： 验证用户是否登录</li><li>授权： 验证用户是否有执行该操作的权限</li><li>缓存： 是否有缓存结果，有的话就直接返回 ⏸ 当下游响应完成后，再判断一下响应是否可以被缓存</li><li>执行： 执行实际的请求处理 ⏸ 响应</li></ul><p>有了中间件之后，我们不需要在每个响应处理方法中都包含这些逻辑，关注好自己该做的事情。下面是Koa的示例代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// logger</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="keyword">const</span> rt = ctx.response.get(<span class="string">'X-Response-Time'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;rt&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// x-response-time</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="built_in">Date</span>.now() - start;</span><br><span class="line">  ctx.set(<span class="string">'X-Response-Time'</span>, <span class="string">`<span class="subst">$&#123;ms&#125;</span>ms`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// response</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'Hello World'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p><br></p><h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><p>事件驱动, 或者称为<code>发布-订阅</code>风格， 对于前端开发来说是再熟悉不过的概念了. 它<strong>定义了一种一对多的依赖关系</strong>， 在事件驱动系统风格中，组件不直接调用另一个组件，而是触发或广播一个或多个事件。系统中的其他组件在一个或多个事件中注册。当一个事件被触发，系统会自动通知在这个事件中注册的所有组件. </p><p>这样就<strong>分离了关注点，订阅者依赖于事件而不是依赖于发布者，发布者也不需要关心订阅者，两者解除了耦合</strong>。</p><p>生活中也有很多<code>发布-订阅</code>的例子，比如微信公众号信息订阅，当新增一个订阅者的时候，发布者并不需要作出任何调整，同样发布者调整的时候也不会影响到订阅者，只要协议没有变化。我们可以发现，<strong>发布者和订阅者之间其实是一种弱化的动态的关联关系</strong>。</p><p><strong>解除耦合目的是一方面, 另一方面也可能由基因决定的，一些事情天然就不适合或不支持用同步的方式去调用，或者这些行为是异步触发的</strong>。</p><p>JavaScript的基因决定事件驱动模式在前端领域的广泛使用. 在<a href="https://juejin.im/post/5d693d8b6fb9a06aca383488" target="_blank" rel="noopener">浏览器和Node中的JavaScript是如何工作的? 可视化解释</a> 简单介绍了Javascript的执行原理，其中提到JavaScript是单线程的编程语言，为了应对各种实际的应用场景，一个线程以压根忙不过来的，事件驱动的异步方式是JavaScript的救命稻草.</p><p>浏览器方面，浏览器就是一个GUI程序，<strong>GUI程序是一个循环(更专业的名字是事件循环)，接收用户输入，程序处理然后反馈到页面，再接收用户输入…</strong> 用户的输入是异步，将用户输入抽象为事件是最简洁、自然、灵活的方式。</p><blockquote><p>需要注意的是：事件驱动和异步是不能划等号的。异步 !== 事件驱动，事件驱动 !== 异步</p></blockquote><p><strong>扩展</strong>:</p><ul><li><strong>响应式编程</strong>: 响应式编程本质上也是事件驱动的，下面是前端领域比较流行的两种响应式模式：<ul><li><code>函数响应式(Functional Reactive Programming)</code>, 典型代表RxJS</li><li><code>透明的函数响应式编程(Transparently applying Functional Reactive Programming - TFRP)</code>, 典型代表Vue、Mobx</li></ul></li><li><strong>消息总线</strong>：指接收、发送消息的软件系统。消息基于一组已知的格式，以便系统无需知道实际接收者就能互相通信</li></ul><p><br></p><h2 id="mv"><a href="#mv" class="headerlink" title="MV*"></a>MV*</h2><p><code>MV*</code>架构风格应用也非常广泛。我觉MV*本质上也是一种分层架构，一样强调职责分离。其中最为经典的是MVC架构风格，除此之外还有各种衍生风格，例如<code>MVP</code>、<code>MVVM</code>、<a href="https://medium.com/@fkrautwald/plug-and-play-all-your-observable-streams-with-cycle-js-e543fc287872#.by4c219c8" target="_blank" rel="noopener"><code>MVI(Model View Intent)</code></a>. 还有有点关联<code>Flux</code>或者<code>Redux</code>模式。</p><p><br></p><h3 id="家喻户晓的mvc"><a href="#家喻户晓的mvc" class="headerlink" title="家喻户晓的MVC"></a>家喻户晓的MVC</h3><p><img src="/images/arch-pattern/mvc.png" alt></p><p>如其名，MVC将应用分为三层，分别是：</p><ul><li>视图层(View) 呈现数据给用户</li><li>控制器(Controller) 模型和视图之间的纽带，起到不同层的组织作用：<ul><li>处理事件并作出响应。一般事件有用户的行为(比如用户点击、客户端请求)，模型层的变更</li><li>控制程序的流程。根据请求选择适当的模型进行处理，然后选择适当的视图进行渲染，最后呈现给用户</li></ul></li><li>模型(Model) 封装与应用程序的业务逻辑相关的数据以及对数据的处理方法, 通常它需要和数据持久化层进行通信</li></ul><p>目前前端应用很少有纯粹使用MVC的，要么视图层混合了控制器层，要么就是模型和控制器混合，或者干脆就没有所谓的控制器. 但一点可以确定的是，很多应用都不约而同分离了’逻辑层’和’视图层’。</p><p>下面是典型的AngularJS代码, 视图层:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Todo<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">"TodoListController as todoList"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;todoList.remaining()&#125;&#125; of &#123;&#123;todoList.todos.length&#125;&#125; remaining<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  [ <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">ng-click</span>=<span class="string">"todoList.archive()"</span>&gt;</span>archive<span class="tag">&lt;/<span class="name">a</span>&gt;</span> ]</span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"unstyled"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">ng-repeat</span>=<span class="string">"todo in todoList.todos"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">ng-model</span>=<span class="string">"todo.done"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"done-&#123;&#123;todo.done&#125;&#125;"</span>&gt;</span>&#123;&#123;todo.text&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">ng-submit</span>=<span class="string">"todoList.addTodo()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">ng-model</span>=<span class="string">"todoList.todoText"</span>  <span class="attr">size</span>=<span class="string">"30"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">placeholder</span>=<span class="string">"add new todo here"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"btn-primary"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"add"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>逻辑层:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">angular.module(<span class="string">'todoApp'</span>, [])</span><br><span class="line">  .controller(<span class="string">'TodoListController'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> todoList = <span class="keyword">this</span>;</span><br><span class="line">    todoList.todos = [</span><br><span class="line">      &#123;<span class="attr">text</span>:<span class="string">'learn AngularJS'</span>, <span class="attr">done</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">text</span>:<span class="string">'build an AngularJS app'</span>, <span class="attr">done</span>:<span class="literal">false</span>&#125;];</span><br><span class="line"></span><br><span class="line">    todoList.addTodo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      todoList.todos.push(&#123;<span class="attr">text</span>:todoList.todoText, <span class="attr">done</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">      todoList.todoText = <span class="string">''</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    todoList.remaining = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">      angular.forEach(todoList.todos, <span class="function"><span class="keyword">function</span>(<span class="params">todo</span>) </span>&#123;</span><br><span class="line">        count += todo.done ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    todoList.archive = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> oldTodos = todoList.todos;</span><br><span class="line">      todoList.todos = [];</span><br><span class="line">      angular.forEach(oldTodos, <span class="function"><span class="keyword">function</span>(<span class="params">todo</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!todo.done) todoList.todos.push(todo);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>至于MVP、MVVM，这些MVC模式的延展或者升级，网上都大量的资源，这里就不予赘述。</p><p><br></p><h3 id="redux"><a href="#redux" class="headerlink" title="Redux"></a>Redux</h3><p>Redux是Flux架构的改进、融合了Elm语言中函数式的思想. 下面是Redux的架构图:</p><p><img src="/images/arch-pattern/redux.png" alt></p><p>从上图可以看出Redux架构有以下要点:</p><ul><li><strong>单一的数据源</strong>.</li><li><strong>单向的数据流</strong>.</li></ul><p>单一数据源, 首先解决的是传统MVC架构多模型数据流混乱问题(如下图)。单一的数据源可以让应用的状态可预测和可被调试。另外单一数据源也方便做数据镜像，实现撤销/重做，数据持久化等等功能</p><p><img src="/images/arch-pattern/multi-model.png" alt></p><p>单向数据流用于辅助单一数据源, 主要目的是阻止应用代码直接修改数据源，这样一方面简化数据流，同样也让应用状态变化变得可预测。</p><p>上面两个特点是Redux架构风格的核心，至于Redux还强调不可变数据、利用中间件封装副作用、范式化状态树，只是一种最佳实践。还有许多<code>类Redux</code>的框架，例如<a href="http://vuex.vuejs.org" target="_blank" rel="noopener"><code>Vuex</code></a>、<a href="https://ngrx.io" target="_blank" rel="noopener">ngrx</a>，在架构思想层次是一致的:</p><p><img src="/images/arch-pattern/vuex.png" alt></p><p><br></p><h2 id="复制风格"><a href="#复制风格" class="headerlink" title="复制风格"></a>复制风格</h2><p><img src="/images/arch-pattern/pm2.png" alt></p><p>基于复制(Replication)风格的系统，会利用多个实例提供相同的服务，来改善服务的可访问性和可伸缩性，以及性能。这种架构风格可以改善用户可察觉的性能，简单服务响应的延迟。</p><p>这种风格在后端用得比较多，举前端比较熟悉的例子，NodeJS. NodeJS是单线程的，为了利用多核资源，NodeJS标准库提供了一个<a href="https://nodejs.org/api/cluster.html" target="_blank" rel="noopener"><code>cluster</code></a>模块，它可以根据CPU数创建多个Worker进程，这些Worker进程可以共享一个服务器端口，对外提供同质的服务, Master进程会根据一定的策略将资源分配给Worker:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> numCPUs = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus().length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Master <span class="subst">$&#123;process.pid&#125;</span> is running`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fork workers.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCPUs; i++) &#123;</span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cluster.on(<span class="string">'exit'</span>, (worker, code, signal) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`worker <span class="subst">$&#123;worker.process.pid&#125;</span> died`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Workers可以共享任意的TCP连接 </span></span><br><span class="line">  <span class="comment">// 比如共享HTTP服务器 </span></span><br><span class="line">  http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>);</span><br><span class="line">    res.end(<span class="string">'hello world\n'</span>);</span><br><span class="line">  &#125;).listen(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Worker <span class="subst">$&#123;process.pid&#125;</span> started`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用多核能力可以提升应用的性能和可靠性。我们也可以利用<a href="http://pm2.keymetrics.io/docs/usage/cluster-mode/" target="_blank" rel="noopener">PM2</a>这样的进程管理工具，来简化Node集群的管理，它支持很多有用的特性，例如集群节点重启、日志归集、性能监视等。</p><p>复制风格常用于网络服务器。浏览器和Node都有<code>Worker</code>的概念，但是一般都只推荐在CPU密集型的场景使用它们，因为浏览器或者NodeJS内置的异步操作已经非常高效。实际上前端应用CPU密集型场景并不多，或者目前阶段不是特别实用。除此之外你还要权衡进程间通信的效率、Worker管理复杂度、异常处理等事情。</p><p>有一个典型的CPU密集型的场景，即源文件转译. 典型的例子是<a href="https://codesandbox.io/dashboard" target="_blank" rel="noopener">CodeSandbox</a>, 它就是利用浏览器的Worker机制来提高源文件的转译性能的:</p><p><img src="/images/arch-pattern/codesandbox.png" alt></p><p>除了处理CPU密集型任务，对于浏览器来说，Worker也是一个重要的安全机制，用于隔离不安全代码的执行，或者限制访问浏览器DOM相关的东西。小程序抽离逻辑进程的原因之一就是安全性</p><p>其他示例：</p><ul><li>ServerLess</li></ul><p><br></p><h2 id="微内核架构"><a href="#微内核架构" class="headerlink" title="微内核架构"></a>微内核架构</h2><p><img src="/images/arch-pattern/plugin-architecture.png" alt></p><p>微内核架构(MicroKernel)又称为”插件架构”, 指的是软件的内核相对较小，主要功能和业务逻辑都通过插件形式实现。内核只包含系统运行的最小功能。插件之间相互独立，插件之间的通信，应该降到最低，减少相互依赖。</p><p>微内核结构的难点在于建立一套粒度合适的插件协议、以及对插件之间进行适当的隔离和解耦。从而才能保证良好的扩展性、灵活性和可迁移性。</p><p>前端领域比较典型的例子是<code>Webpack</code>、<code>Babel</code>、<code>PostCSS</code>以及<code>ESLint</code>, 这些应用需要应对复杂的定制需求，而且这些需求时刻在变，只有微内核架构才能保证灵活和可扩展性。</p><p>以Webpack为例。Webpack的核心是一个Compiler，这个Compiler主要功能是集成插件系统、维护<code>模块对象图</code>, 对于模块代码具体编译工作、模块的打包、优化、分析、聚合统统都是基于外部插件完成的.</p><p>如上文说的Loader运用了管道模式，负责对源文件进行转译；那Plugin则可以将行为注入到Compiler运行的整个生命周期的钩子中, 完全访问Compiler的当前状态。</p><blockquote><p><a href="https://twitter.com/thelarkinn" target="_blank" rel="noopener">Sean Larkin</a>有个演讲: <a href="https://www.youtube.com/watch?v=4tQiJaFzuJ8" target="_blank" rel="noopener">Everything is a plugin! Mastering webpack from the inside out </a></p></blockquote><p><img src="/images/arch-pattern/webpack.png" alt></p><p><br></p><p>这里还有一篇文章<a href="https://yunsong0922.github.io/2018/12/09/%E5%BE%AE%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84%E5%BA%94%E7%94%A8%E7%A0%94%E7%A9%B6/" target="_blank" rel="noopener">&lt;微内核架构应用研究&gt;</a>专门写了前端微内核架构模式的一些应用，推荐阅读一下。</p><p><br></p><h2 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h2><p>前几天听了<a href="http://codetimecn.com/" target="_blank" rel="noopener">代码时间</a>上<a href="https://coolshell.cn/haoel" target="_blank" rel="noopener">左耳朵耗子</a>的一期<a href="http://codetimecn.com/episodes/manager" target="_blank" rel="noopener">节目</a>, 他介绍得了亚马逊内部有很多小团队，亚马逊网站上一块豆腐块大小的区域可能是一个团队在维护，比如地址选择器、购物车、运达时间计算… 大厂的这种超级项目是怎么协调和维护的呢？ 这也许就是微前端或者微服务出现的原因吧。</p><p>微前端旨在将<code>单体前端</code>分解成更小、更简单的模块，这些模块可以被独立的团队进行开发、测试和部署，最后再组合成一个大型的整体。</p><p><img src="/images/arch-pattern/microfrontend.jpg" alt></p><p>微前端下各个应用模块是独立运行、独立开发、独立部署的，相对应的会配备更加自治的团队(一个团队干好一件事情)。 微前端的实施还需要有稳固的前端基础设施和研发体系的支撑。</p><p>如果你想深入学习微前端架构，建议阅读<a href="https://www.zhihu.com/people/phodal/activities" target="_blank" rel="noopener">Phodal</a>的<a href="https://juejin.im/user/5567e339e4b0349d3313190b/posts" target="_blank" rel="noopener">相关文章</a>，还有他的新书<a href="https://www.amazon.cn/dp/B07TJ7R9DX/ref=sr_1_1?__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&amp;keywords=%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84&amp;qid=1568279892&amp;s=gateway&amp;sr=8-1" target="_blank" rel="noopener">《前端架构：从入门到微前端》</a></p><p><br></p><h2 id="组件化架构"><a href="#组件化架构" class="headerlink" title="组件化架构"></a>组件化架构</h2><p>组件化开发对现在的我们来说如此自然，就像水对鱼一样。 以致于我们忘了组件化也是一种非常重要的架构思想，它的中心思想就是分而治之。按照Wiki上面的定义是：<code>组件化就是基于可复用目的，将一个大的软件系统按照分离关注点的形式，拆分成多个独立的组件，主要目的就是减少耦合</code>.</p><p>从前端的角度具体来讲，如下图，石器时代开发方式(右侧), 组件时代(左侧):</p><p><img src="/images/arch-pattern/components2.png" alt><br>(图片来源: <a href="http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text" target="_blank" rel="noopener">http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text</a>)</p><p>按照Vue官网的说法: <code>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树</code>：</p><p><img src="/images/arch-pattern/components.png" alt></p><p>按照我的理解<strong>组件跟函数是一样的东西，这就是为什么函数式编程思想在React中会应用的如此自然</strong>。若干个简单函数，可以复合成复杂的函数，复杂的函数再复合成复杂的应用。对于前端来说，页面也是这么来的，一个复杂的页面就是有不同粒度的组件复合而成的。</p><p>组件另外一个重要的特征就是<strong>内聚性</strong>，它是一个独立的单元，自包含了所有需要的资源。例如一个前端组件较包含样式、视图结构、组件逻辑:</p><p><img src="/images/arch-pattern/vue-component.png" alt></p><p><br></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>我终于编不下去了</strong>！还有很多架构风格，限于文章篇幅, 且这些风格主要应用于后端领域，这里就不一一阐述了。你可以通过扩展阅读了解这些模式</p><ul><li>面向对象风格: 将应用或系统任务分割为单独、可复用、可自给的对象，每个对象都包含数据、以及对象相关的行为</li><li>C/S 客户端/服务器风格</li><li>面向服务架构(SOA): 指那些利用契约和消息将功能暴露为服务、消费功能服务的应用</li><li>N层/三层: 和分层架构差不多，侧重物理层. 例如C/S风格就是一个典型的N层架构</li><li>点对点风格</li></ul><p>通过上文，你估计会觉得架构风格比设计模式或者算法好理解多的，正所谓‘<strong>大道至简</strong>’，但是‘<strong>简洁而不简单</strong>’！大部分项目的架构不是一开始就是这样的，它们可能经过长期的迭代，踩着巨人的肩膀，一路走过来才成为今天的样子。</p><p>希望本文可以给你一点启发，对于我们前端工程师来说，最牛的不是能做多酷的页面、掌握多少API，要学会通过现象看本质，举一反三融会贯通，这才是进阶之道。</p><p>本文完！</p><p><br></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://wxs.me/2069" target="_blank" rel="noopener">几种常见的软件架构风格介绍</a></li><li><a href="https://docs.huihoo.com/rest/REST_cn.pdf" target="_blank" rel="noopener">架构风格与基于网络的软件架构设计</a> REST提议者，Roy Thomas Fielding的博士论文</li><li><a href="http://www.ruanyifeng.com/blog/2016/09/software-architecture.html" target="_blank" rel="noopener">软件架构入门</a></li><li><a href="https://zh.wikipedia.org/wiki/管道_\(Unix\" target="_blank" rel="noopener">管道 (Unix)</a>)</li><li><a href="https://zhuanlan.zhihu.com/p/20597452" target="_blank" rel="noopener">redux middleware 详解</a></li><li><a href="https://juejin.im/post/593021272f301e0058273468" target="_blank" rel="noopener">浅析前端开发中的 MVC/MVP/MVVM 模式</a></li><li><a href="https://juejin.im/post/5d1e0dea51882514bf5bedfa#comment" target="_blank" rel="noopener">CodeSandbox 浏览器端的webpack是如何工作的？ 上篇</a></li><li><a href="https://mp.weixin.qq.com/s/KT288QNmtJzKe-jaPyFtFA" target="_blank" rel="noopener">万金油CS与分层</a></li><li><a href="https://www.infoq.cn/article/03*BeU3zQegIbIytRsX9" target="_blank" rel="noopener">大前端时代下的微前端架构：实现增量升级、代码解耦、独立部署</a></li><li><a href="https://www.iteye.com/blog/moon-walker-2393310" target="_blank" rel="noopener">系统组件化架构设计</a></li><li><a href="https://github.com/xufei/blog/issues/19" target="_blank" rel="noopener">2015前端组件化框架之路</a></li></ul><p><br></p><p><img src="/images/sponsor.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;所谓软件架构风格，是指描述某个特定应用领域中系统组织方式的惯用模式。架构风格定义一个词汇表和一组约束，词汇表中包含一些组件及连接器，约束则指出系统如何将构建和连接器组合起来。软件架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将系统中
      
    
    </summary>
    
      <category term="前端" scheme="https://bobi.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
</feed>
