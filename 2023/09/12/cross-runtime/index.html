<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="前端技术百花齐放，但割裂也是全方位的：  小程序。小程序是中国特色 视图框架： React、Vue 等视图框架割据。甚至框架大版本升级也会进一步造成割裂。前有 Angular、后有 Vue 2/3、现在 React RSC 也饱受争议 服务端 vs 客户端。随着 SSR 以及全栈框架的流行，前端需要考虑编写服务端/客户端的同构代码，即 Write Once, Run on Both Client">
<meta name="keywords" content="Blog,FrontEnd,React,Javascript,Typescript">
<meta property="og:type" content="article">
<meta property="og:title" content="编写跨运行时的 JavaScript 程序">
<meta property="og:url" content="https://bobi.ink/2023/09/12/cross-runtime/index.html">
<meta property="og:site_name" content="Bobi.ink">
<meta property="og:description" content="前端技术百花齐放，但割裂也是全方位的：  小程序。小程序是中国特色 视图框架： React、Vue 等视图框架割据。甚至框架大版本升级也会进一步造成割裂。前有 Angular、后有 Vue 2/3、现在 React RSC 也饱受争议 服务端 vs 客户端。随着 SSR 以及全栈框架的流行，前端需要考虑编写服务端/客户端的同构代码，即 Write Once, Run on Both Client">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://bobi.ink/images/cross-runtime/Untitled.jpeg">
<meta property="og:image" content="https://bobi.ink/images/cross-runtime/Untitled.png">
<meta property="og:image" content="https://bobi.ink/images/cross-runtime/Untitled%201.png">
<meta property="og:image" content="https://bobi.ink/images/cross-runtime/Untitled%202.png">
<meta property="og:image" content="https://bobi.ink/images/cross-runtime/Untitled%203.png">
<meta property="og:image" content="https://bobi.ink/images/cross-runtime/Untitled%204.png">
<meta property="og:image" content="https://bobi.ink/images/cross-runtime/Untitled%205.png">
<meta property="og:image" content="https://bobi.ink/images/cross-runtime/Untitled%206.png">
<meta property="og:image" content="https://bobi.ink/images/cross-runtime/07C5246A-E844-4C00-8CB8-35DFA850B9BE.jpeg">
<meta property="og:image" content="https://bobi.ink/images/cross-runtime/Untitled%207.png">
<meta property="og:image" content="https://bobi.ink/images/cross-runtime/Untitled%208.png">
<meta property="og:image" content="https://bobi.ink/images/cross-runtime/Untitled%209.png">
<meta property="og:image" content="https://bobi.ink/images/cross-runtime/Untitled%2010.png">
<meta property="og:updated_time" content="2023-09-12T01:45:33.663Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="编写跨运行时的 JavaScript 程序">
<meta name="twitter:description" content="前端技术百花齐放，但割裂也是全方位的：  小程序。小程序是中国特色 视图框架： React、Vue 等视图框架割据。甚至框架大版本升级也会进一步造成割裂。前有 Angular、后有 Vue 2/3、现在 React RSC 也饱受争议 服务端 vs 客户端。随着 SSR 以及全栈框架的流行，前端需要考虑编写服务端/客户端的同构代码，即 Write Once, Run on Both Client">
<meta name="twitter:image" content="https://bobi.ink/images/cross-runtime/Untitled.jpeg">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>编写跨运行时的 JavaScript 程序</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2023/09/04/dont-reinvent/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2023/09/12/cross-runtime/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2023/09/12/cross-runtime/&text=编写跨运行时的 JavaScript 程序"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2023/09/12/cross-runtime/&title=编写跨运行时的 JavaScript 程序"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2023/09/12/cross-runtime/&is_video=false&description=编写跨运行时的 JavaScript 程序"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=编写跨运行时的 JavaScript 程序&body=Check out this article: https://bobi.ink/2023/09/12/cross-runtime/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2023/09/12/cross-runtime/&title=编写跨运行时的 JavaScript 程序"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2023/09/12/cross-runtime/&title=编写跨运行时的 JavaScript 程序"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2023/09/12/cross-runtime/&title=编写跨运行时的 JavaScript 程序"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2023/09/12/cross-runtime/&title=编写跨运行时的 JavaScript 程序"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2023/09/12/cross-runtime/&name=编写跨运行时的 JavaScript 程序&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#deno，destroy-node"><span class="toc-number">1.</span> <span class="toc-text">Deno，Destroy Node?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bun-1-0！"><span class="toc-number">2.</span> <span class="toc-text">Bun 1.0！</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#node-变得越来越好"><span class="toc-number">3.</span> <span class="toc-text">Node 变得越来越好</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#编写跨运行时程序-——-web-standard-api"><span class="toc-number">4.</span> <span class="toc-text">编写跨运行时程序 —— Web Standard API</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩展阅读"><span class="toc-number">5.</span> <span class="toc-text">扩展阅读</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        编写跨运行时的 JavaScript 程序
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Bobi.ink</span>
      </span>
      
    <div class="postdate">
        <time datetime="2023-09-11T16:00:00.000Z" itemprop="datePublished">2023-09-12</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p><img src="/images/cross-runtime/Untitled.jpeg" alt="Cover"></p>
<p>前端技术百花齐放，但割裂也是全方位的：</p>
<ul>
<li>小程序。小程序是中国特色</li>
<li>视图框架： React、Vue 等视图框架割据。甚至框架大版本升级也会进一步造成割裂。前有 Angular、后有 Vue 2/3、现在 React RSC 也饱受争议</li>
<li>服务端 vs 客户端。随着 SSR 以及全栈框架的流行，前端需要考虑编写服务端/客户端的同构代码，即 Write Once, Run on Both Client and Server。那 React Server Component 的 ‘use client’、’use server’ 的写法可能会进一步加剧这种心智负担</li>
<li>浏览器兼容性。浏览器兼容性适配是每个前端开发者必备的技能，现在很多开发者都不知道那个被 IE 蹂躏的年代。</li>
<li>npm、yarn、pnpm、pnpm 7、8… bun！</li>
<li>Webpack、Vite…</li>
<li>…</li>
</ul>
<p><br><br><br></p>
<p>前端一年，人间三年，技术迭代之快，一般人还真的很难跟上。前端开发者似乎一直摆脱不了’兼容性‘、’跨平台‘、碎片化的这些话题。</p>
<p>不过也有好的一面，这恰巧说明它生命力非常旺盛，前端开发的边界也一而再地被拓宽，打脸了前端已死的论调。</p>
<p>在 JavaScript 运行时（Runtime）领域，近些年也诞生了若干个 Node.js 的挑战者，比如 Deno、Bun…</p>
<p><br><br><br></p>
<h1 id="deno，destroy-node"><a href="#deno，destroy-node" class="headerlink" title="Deno，Destroy Node?"></a>Deno，Destroy Node?</h1><p>Deno 和 Node.js 的创造者都是 Ryan Dahl， 如果说 Nodejs 是奥创，那个 Deno 就是为了打败奥创而发明的“幻视”。</p>
<p>从它的名字就可以看出，它的目标就是为了解决 Node.js 的设计缺陷。</p>
<p><img src="/images/cross-runtime/Untitled.png" alt="Deno"></p>
<p><br></p>
<p>Deno 一开始主打的特性是： 安全、开箱即用的 Typescript 支持、去中心化的模块、支持标准的 <a href="https://deno.land/manual@v1.36.4/runtime/web_platform_apis" target="_blank" rel="noopener">Web API</a>、性能(基于 Rust)、完整的开发工具链(单元测试、格式化、检查等)</p>
<p><img src="/images/cross-runtime/Untitled%201.png" alt="Deno 对标法"></p>
<p>Deno 对标法</p>
<p><br><br><br></p>
<p>但是仅凭这些在 Node.js 庞大的生态市场面前，就是蚍蜉撼树:</p>
<p><img src="/images/cross-runtime/Untitled%202.png" alt="事实对标法"></p>
<p>事实对标法</p>
<p><br></p>
<p>所以，Deno 还是向现实低了头，在 Deno 1.28 开始就支持导入 npm 模块、Node.js 内置模块：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readFileSync &#125; <span class="keyword">from</span> <span class="string">'node:fs'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(readFileSync(<span class="string">'deno.json'</span>, &#123; <span class="attr">encoding</span>: <span class="string">'utf8'</span> &#125;))</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>Deno 作为一个二次创造的‘轮子’，自然在设计上、开发者体验上面要更加优秀。</p>
<p>除了从历史失败的设计中吸取的教训，它也从其他编程语言，譬如 Rust、Go 借鉴了一些设计和工程理念。</p>
<p>比如在设计方面，去中心化的模块加载、安全模型、向 Web 标准 API 看齐、开箱即用的 Typescript；</p>
<p>在工程化方面则体现在内置单元测试、基准测试、格式化、文档生成、打包成可执行文件。</p>
<p><br></p>
<p>在当前被各种‘过度’工程化蹂躏的阶段，显得难得可贵。</p>
<p><img src="/images/cross-runtime/Untitled%203.png" alt="Nextjs 的配置地狱"></p>
<p>Nextjs 的配置地狱</p>
<p><br><br><br></p>
<p>我觉得，另外一个比较重要的亮点就是向 Web 标准 API 看齐。和浏览器兼容是 Deno 的目标之一</p>
<p>比如支持使用 URL 来加载模块；还有一些看起来在服务端用不上的 API，如 Location、Navigator、localStorage，甚至还有 window</p>
<p><img src="/images/cross-runtime/Untitled%204.png" alt="Untitled"></p>
<p>Web 标准 API 经过更加严格的设计，在质量和稳定性上都要较高的保证。</p>
<p>上文我们也提到了客户端/服务端的同构应用的开发，会给开发者带来额外的心智负担，那么对齐浏览器和服务端的 API 就可以缩小这个 Gap, 降低学习成本。</p>
<p><br></p>
<p>还有一个重要的意义如本文标题所示 —— 跨平台。</p>
<p>不管是运行在浏览器、Worker、 Node.js、Deno、Bun、小程序的逻辑线程、还是各种云服务厂商提供的边缘计算运行时(<code>Edge Runtime</code>, 例如 <a href="https://vercel.com/docs/functions/edge-functions" target="_blank" rel="noopener">Vercel Edge Function</a>、<a href="https://developers.cloudflare.com/workers/learning/how-workers-works/" target="_blank" rel="noopener">Cloudflare Workers</a>)、Serverless 运行时。Web 标准 API 将会是那条最低“水位线”</p>
<p><img src="/images/cross-runtime/Untitled%205.png" alt="Untitled"></p>
<p><br></p>
<p>很多边缘计算/Serverless 运行时，出于轻量化和安全性考虑，仅支持部分 Web 标准 API。</p>
<p><img src="/images/cross-runtime/Untitled%206.png" alt="不同运行时的对比，来源 Nextjs 官网"></p>
<p>不同运行时的对比，来源 Nextjs 官网</p>
<p>虽然现在各种 runtime 比较割裂， 不过我相信未来它们将走向统一的道路，谁能担此重任？</p>
<p>现在还不清楚，可能是 Bun、可能是 Deno，也有可能还是 Nodejs 吞并了其他竞争者，毕竟它也不是停滞不前(下文会详细介绍) 。</p>
<p><strong>但不管怎样， Web Standard API 将在这个统一的道路上扮演重要的角色</strong>。</p>
<p><br><br><br></p>
<hr>
<p><br><br><br></p>
<h1 id="bun-1-0！"><a href="#bun-1-0！" class="headerlink" title="Bun 1.0！"></a>Bun 1.0！</h1><p>再看看 Bun，包子!</p>
<p><img src="/images/cross-runtime/07C5246A-E844-4C00-8CB8-35DFA850B9BE.jpeg" alt="07C5246A-E844-4C00-8CB8-35DFA850B9BE.jpeg"></p>
<p>它也才发布一年多，在我落笔的此刻，它刚好也发布了 1.0 版本。</p>
<p><br></p>
<p>它的宣传点就是 —— 快</p>
<p><img src="/images/cross-runtime/Untitled%207.png" alt="Untitled"></p>
<p>它的目的很简单，就是为了取代 Node.js，就是要提供一个更快的运行时，消灭现在复杂的开发乱象。同时尽量不影响现有的框架和程序的运行（兼容 Node.js）</p>
<p>用”兼容并包”来描述它最好不过，比如它同时支持 ESM 和 CommonJS，甚至允许这两个模块在一个文件中并存，而现在主流的观点是 CommonJS 是一个过时的技术。</p>
<p><br></p>
<p>因此除了作为运行时，开箱支持 Typescript 之外。他还将提供比 Deno 更丰富的工具链：</p>
<ul>
<li>包管理器。扬言要取代 pnpm、yarn、npm</li>
<li>打包工具。拳打 Vite、脚踢 rollup、深度碾压 Webpack</li>
<li>测试运行器。Vitest、Jest 在它面前就是弟弟</li>
<li>…</li>
</ul>
<p>大有一番一统天下的架势（取代 Node、npm、webpack、jest 等）。不过是不是‘大杂烩’， 能不能吃得下这么多大饼还不确定，交给时间去验证吧！</p>
<p><br><br><br></p>
<hr>
<p><br><br><br></p>
<h1 id="node-变得越来越好"><a href="#node-变得越来越好" class="headerlink" title="Node 变得越来越好"></a>Node 变得越来越好</h1><p>不管是 Deno、还是后来的搅局者 Bun。我们可以发现一些趋势：</p>
<ul>
<li>除了核心的运行时，他们还花了很多精力打造一套开箱即用、开发工具链，更加注重开发体验。</li>
<li>更加注重香 Web 标准 API 对齐。</li>
</ul>
<p><br><br><br></p>
<p>有了这些鲶鱼，Node.js 也不是等着挨打的，这不：</p>
<ul>
<li>20.0<ul>
<li>内置支持 .env 文件，<code>node --env-file=config.env index.js</code></li>
<li>支持 await using</li>
<li>加入了实验性的权限模型，借鉴 Deno</li>
<li>单元测试运行器稳定了。Node 可以直接写单元测试了</li>
<li>Web Crypto API</li>
<li>性能优化</li>
</ul>
</li>
<li>19.0<ul>
<li>支持 <code>—watch</code> ，可以取代 nodemon</li>
</ul>
</li>
<li>18.0<ul>
<li>Web Streams API</li>
<li>引入实验性的单元测试运行器</li>
<li>引入实验性的 watch mode</li>
<li>支持 <code>File</code> 类</li>
<li>支持编译从单文件可执行文件</li>
<li>引入 Web Crypto API</li>
<li>引入实验性的 <a href="https://dev.to/jakobjingleheimer/custom-esm-loaders-who-what-when-where-why-how-4i1o" target="_blank" rel="noopener">ESM Loader Hooks API</a></li>
</ul>
</li>
<li>17.0<ul>
<li>引入实验性的 fetch</li>
<li>支持 JSON Import assertions</li>
<li>readline 模块支持 Promise API</li>
</ul>
</li>
<li>16.0<ul>
<li>Timer Promise API</li>
<li>引入实验性的 <code>Web Streams API</code></li>
<li>引入 Corepack</li>
<li>Importing JSON modules now requires experimental import assertions syntax</li>
<li>新增 <code>util.parseArgs</code> 可以解析命令行参数</li>
<li>新增 <code>--experimental-network-imports</code> 可以像 Deno 一样导入 HTTP/HTTPS 模块</li>
</ul>
</li>
<li>14.0<ul>
<li>正式支持 ECMAScript Modules</li>
<li>支持 <strong>Top-Level Await</strong></li>
<li>支持 EventTarget</li>
<li>实验性的 AsyncLocalStorage</li>
<li>支持 <strong><code>AbortController</code>  和<code>AbortSignal</code></strong></li>
</ul>
</li>
<li>…</li>
</ul>
<p><br><br><br></p>
<p>Node.js 正在变得更加‘现代’，尤其是近几个版本不乏有 Web API、工具链、性能优化这些更新。</p>
<p>所以，不管你用不用 Deno、Bun, 都要感谢它们让 Node 变得越来越好用。</p>
<p>与此同时，通过这些变化趋势，我们可以推测这些运行时会变得越来越同质化。卷嘛</p>
<p><br><br><br></p>
<hr>
<p><br><br><br></p>
<h1 id="编写跨运行时程序-——-web-standard-api"><a href="#编写跨运行时程序-——-web-standard-api" class="headerlink" title="编写跨运行时程序 —— Web Standard API"></a>编写跨运行时程序 —— Web Standard API</h1><p>随着运行时的百花齐放, 越来越多的现代的前端‘框架’ 都避免自己和 Node.js 直接耦合。</p>
<p>比如 Remix、Qwik、Astro、SvelteKit…</p>
<p><br></p>
<p><img src="/images/cross-runtime/Untitled%208.png" alt="qwik 支持的部署平台"></p>
<p>qwik 支持的部署平台</p>
<p><img src="/images/cross-runtime/Untitled%209.png" alt="SvelteKit 各种平台的适配器"></p>
<p>SvelteKit 各种平台的适配器</p>
<p><br></p>
<p><img src="/images/cross-runtime/Untitled%2010.png" alt="Astro 不建议你直接使用 Node.js API"></p>
<p>Astro 不建议你直接使用 Node.js API</p>
<p><br></p>
<p>在 <code>Next.js</code> 下，为了支持你的程序跑在不同的运行时上，也强加了一些约束，比如：</p>
<ul>
<li>Middleware 的 request、response 继承自 Request 和 Response，只能进行非常有限的逻辑处理</li>
<li><p>Route Handler 使用的就是 Web Request / Response API</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; cookies &#125; <span class="keyword">from</span> <span class="string">'next/headers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">GET</span>(<span class="params">request: Request</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cookieStore = cookies()</span><br><span class="line">  <span class="keyword">const</span> token = cookieStore.get(<span class="string">'token'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Response(<span class="string">'Hello, Next.js!'</span>, &#123;</span><br><span class="line">    status: <span class="number">200</span>,</span><br><span class="line">    headers: &#123; <span class="string">'Set-Cookie'</span>: <span class="string">`token=<span class="subst">$&#123;token.value&#125;</span>`</span> &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>page 和 layout 支持指定 runtime, 如果是 edge 只能使用<a href="https://nextjs.org/docs/app/api-reference/edge" target="_blank" rel="noopener">受限的 Web API</a>。Next.js 在构建时会严格检查你是否使用非法 API.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app/page.tsx</span></span><br><span class="line"><span class="comment">// ❌ fs/promises 模块找不到</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs/promises'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> runtime = <span class="string">'edge'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> content = <span class="keyword">await</span> fs.readFile(<span class="string">'package.json'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;main className=<span class="string">"flex min-h-screen flex-col items-center justify-between p-24"</span>&gt;</span><br><span class="line">      &#123;content&#125;</span><br><span class="line">    &lt;<span class="regexp">/main&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br><br><br></p>
<hr>
<p><br></p>
<p><strong>自‘<a href="https://juejin.cn/post/7241027834490437669" target="_blank" rel="noopener">去 JavaScript</a>’ 之后，似乎 ’去 Node.js’ 也是一波潜在的小趋势</strong>。</p>
<p><br></p>
<p>而编写跨运行时的 JavaScript 程序的秘诀在于：<strong>尽量往 Web Standard API 靠拢，比如：</strong></p>
<ul>
<li>在设计服务端程序时，优先使用 <code>Request</code>、<code>Response</code> 、<code>URL</code>、<code>Blob</code> 这些 Web API 来响应 HTTP 请求；</li>
<li>使用 <code>fetch</code> 、<code>WebSocket</code> 进行网络请求；</li>
<li>文件系统操作可以使用 <code>File API</code>、<code>File System API</code>、<code>Web Stream API</code>；</li>
<li>使用 <code>Worker</code> 跑多线程任务；</li>
<li>还有强大的 <code>WebAssembly</code> …</li>
</ul>
<p><br></p>
<p>当然，目前 Web API 的还是功能太弱了，毕竟不是专门为服务端设计的，很难覆盖复杂的需求。因此短期内 Node.js 还难以撼动，JavaScript 运行时领域也还会继续内卷。</p>
<p><br></p>
<p>期待有一天 Web Standard API 能一统天下，那时候就无所谓 Deno、Bun、还是 Node 了。</p>
<p><br><br><br><br><br></p>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li><a href="https://vercel.com/docs/functions/edge-functions/edge-runtime" target="_blank" rel="noopener">Vercel Edge Runtime</a></li>
<li><a href="https://deno.land/manual@v1.36.4/runtime/web_platform_apis" target="_blank" rel="noopener">Deno Web Platform APIs</a></li>
<li><a href="https://dev.to/jakobjingleheimer/custom-esm-loaders-who-what-when-where-why-how-4i1o" target="_blank" rel="noopener">Custom ESM loaders</a></li>
<li><a href="https://nextjs.org/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes" target="_blank" rel="noopener">Nextjs Edge and Node.js Runtimes</a></li>
</ul>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#deno，destroy-node"><span class="toc-number">1.</span> <span class="toc-text">Deno，Destroy Node?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bun-1-0！"><span class="toc-number">2.</span> <span class="toc-text">Bun 1.0！</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#node-变得越来越好"><span class="toc-number">3.</span> <span class="toc-text">Node 变得越来越好</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#编写跨运行时程序-——-web-standard-api"><span class="toc-number">4.</span> <span class="toc-text">编写跨运行时程序 —— Web Standard API</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩展阅读"><span class="toc-number">5.</span> <span class="toc-text">扩展阅读</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2023/09/12/cross-runtime/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2023/09/12/cross-runtime/&text=编写跨运行时的 JavaScript 程序"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2023/09/12/cross-runtime/&title=编写跨运行时的 JavaScript 程序"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2023/09/12/cross-runtime/&is_video=false&description=编写跨运行时的 JavaScript 程序"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=编写跨运行时的 JavaScript 程序&body=Check out this article: https://bobi.ink/2023/09/12/cross-runtime/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2023/09/12/cross-runtime/&title=编写跨运行时的 JavaScript 程序"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2023/09/12/cross-runtime/&title=编写跨运行时的 JavaScript 程序"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2023/09/12/cross-runtime/&title=编写跨运行时的 JavaScript 程序"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2023/09/12/cross-runtime/&title=编写跨运行时的 JavaScript 程序"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2023/09/12/cross-runtime/&name=编写跨运行时的 JavaScript 程序&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2023 Ivan
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-44571525-2', 'auto');
        ga('send', 'pageview');
    </script>


    <!-- Disqus Comments -->
    <script type="text/javascript">
        var disqus_shortname = 'bobi-ink';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


