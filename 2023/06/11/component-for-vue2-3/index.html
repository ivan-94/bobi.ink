<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Vue 3 已经发布三年，我们有较多项目还停留在 Vue 2。Vue 3 的升级是比较割裂的。 我们主要做的是 2B 业务，项目、模块、分支都非常多，升级的成本和风险都比较高。 我们目前的策略是 “新旧并存，渐进式升级”， 旧的项目就尽量不变了，新的项目强制使用新的技术栈。利用微前端架构，新旧应用可以灵活地组合起来。 因此我们的业务组件库、工具库之类需要考虑兼容旧的 Vue 2 项目。这篇文章">
<meta name="keywords" content="Blog,FrontEnd,React,Javascript,Typescript">
<meta property="og:type" content="article">
<meta property="og:title" content="如何实现支持跨 Vue 2&#x2F;3 的组件库">
<meta property="og:url" content="https://bobi.ink/2023/06/11/component-for-vue2-3/index.html">
<meta property="og:site_name" content="Bobi.ink">
<meta property="og:description" content="Vue 3 已经发布三年，我们有较多项目还停留在 Vue 2。Vue 3 的升级是比较割裂的。 我们主要做的是 2B 业务，项目、模块、分支都非常多，升级的成本和风险都比较高。 我们目前的策略是 “新旧并存，渐进式升级”， 旧的项目就尽量不变了，新的项目强制使用新的技术栈。利用微前端架构，新旧应用可以灵活地组合起来。 因此我们的业务组件库、工具库之类需要考虑兼容旧的 Vue 2 项目。这篇文章">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://bobi.ink/images/component-for-vue2-3/Untitled.jpeg">
<meta property="og:image" content="https://bobi.ink/images/component-for-vue2-3/Untitled.png">
<meta property="og:image" content="https://bobi.ink/images/component-for-vue2-3/Untitled%201.png">
<meta property="og:image" content="https://bobi.ink/images/component-for-vue2-3/Untitled%202.png">
<meta property="og:image" content="https://bobi.ink/images/component-for-vue2-3/Untitled%203.png">
<meta property="og:updated_time" content="2023-06-11T14:21:51.353Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="如何实现支持跨 Vue 2&#x2F;3 的组件库">
<meta name="twitter:description" content="Vue 3 已经发布三年，我们有较多项目还停留在 Vue 2。Vue 3 的升级是比较割裂的。 我们主要做的是 2B 业务，项目、模块、分支都非常多，升级的成本和风险都比较高。 我们目前的策略是 “新旧并存，渐进式升级”， 旧的项目就尽量不变了，新的项目强制使用新的技术栈。利用微前端架构，新旧应用可以灵活地组合起来。 因此我们的业务组件库、工具库之类需要考虑兼容旧的 Vue 2 项目。这篇文章">
<meta name="twitter:image" content="https://bobi.ink/images/component-for-vue2-3/Untitled.jpeg">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>如何实现支持跨 Vue 2/3 的组件库</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2023/06/05/render-patterns/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2023/06/11/component-for-vue2-3/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2023/06/11/component-for-vue2-3/&text=如何实现支持跨 Vue 2/3 的组件库"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2023/06/11/component-for-vue2-3/&title=如何实现支持跨 Vue 2/3 的组件库"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2023/06/11/component-for-vue2-3/&is_video=false&description=如何实现支持跨 Vue 2/3 的组件库"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=如何实现支持跨 Vue 2/3 的组件库&body=Check out this article: https://bobi.ink/2023/06/11/component-for-vue2-3/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2023/06/11/component-for-vue2-3/&title=如何实现支持跨 Vue 2/3 的组件库"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2023/06/11/component-for-vue2-3/&title=如何实现支持跨 Vue 2/3 的组件库"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2023/06/11/component-for-vue2-3/&title=如何实现支持跨 Vue 2/3 的组件库"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2023/06/11/component-for-vue2-3/&title=如何实现支持跨 Vue 2/3 的组件库"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2023/06/11/component-for-vue2-3/&name=如何实现支持跨 Vue 2/3 的组件库&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#方案决策"><span class="toc-number">1.</span> <span class="toc-text">方案决策</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#策略"><span class="toc-number">2.</span> <span class="toc-text">策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现"><span class="toc-number">3.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#api-兼容：vue-demi"><span class="toc-number">3.1.</span> <span class="toc-text">API 兼容：vue demi</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#渲染语法：jsx-runtime-的实现"><span class="toc-number">3.2.</span> <span class="toc-text">渲染语法：JSX runtime 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组件定义与-typescript-支持"><span class="toc-number">3.3.</span> <span class="toc-text">组件定义与 Typescript 支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型组件"><span class="toc-number">3.4.</span> <span class="toc-text">泛型组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#element-adapter"><span class="toc-number">3.5.</span> <span class="toc-text">element-adapter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#router-adapter"><span class="toc-number">3.6.</span> <span class="toc-text">router-adapter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#🎉-开源-🎉"><span class="toc-number">3.7.</span> <span class="toc-text">🎉 开源 🎉</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展阅读"><span class="toc-number">4.</span> <span class="toc-text">扩展阅读</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        如何实现支持跨 Vue 2/3 的组件库
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Bobi.ink</span>
      </span>
      
    <div class="postdate">
        <time datetime="2023-06-10T16:00:00.000Z" itemprop="datePublished">2023-06-11</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p><br></p>
<p><img src="/images/component-for-vue2-3/Untitled.jpeg" alt="Untitled"></p>
<p>Vue 3 已经<a href="https://vue-js.com/topic/5f65624c96b2cb0032c38550" target="_blank" rel="noopener">发布</a>三年，我们有较多项目还停留在 Vue 2。Vue 3 的升级是比较割裂的。</p>
<p>我们主要做的是 <code>2B</code> 业务，项目、模块、分支都非常多，升级的成本和风险都比较高。</p>
<p>我们目前的策略是 “新旧并存，渐进式升级”， 旧的项目就尽量不变了，新的项目强制使用新的技术栈。利用<code>微前端</code>架构，新旧应用可以灵活地组合起来。</p>
<p>因此我们的业务组件库、工具库之类需要考虑兼容旧的 Vue 2 项目。这篇文章，就向大家展示我们开发跨版本组件库，其中的决策和实现过程。</p>
<p><br><br><br></p>
<h2 id="方案决策"><a href="#方案决策" class="headerlink" title="方案决策"></a>方案决策</h2><p>实现跨版本的组件都多种方案，下面列举分析几种主要方案：</p>
<p><br></p>
<p><strong>方案一：使用 Vue SFC / 模板</strong></p>
<p>单纯从外观上看 Vue 2 / 3 在模板的语法上<a href="https://v3-migration.vuejs.org/zh/breaking-changes/v-model.html" target="_blank" rel="noopener">差别并不大</a>。在 <a href="https://blog.vuejs.org/posts/vue-2-7-naruto" target="_blank" rel="noopener">Vue 2.7</a> 开始内置了对 <code>script setup</code> 也有了较好的支持。</p>
<p>理论上，我们可以编写一份代码，然后分别针对 2 / 3 编译两份输出。</p>
<p><img src="/images/component-for-vue2-3/Untitled.png" alt="总体流程如上"></p>
<p>总体流程如上</p>
<p><strong>笔者提供了一个简单的 DEMO 来验证了这个方案的可行性，详见<a href="https://github.com/wakeadmin/cvv-sfc-demo" target="_blank" rel="noopener">这里</a>。</strong></p>
<ul>
<li>优点<ul>
<li>模板是 Vue 的第一公民，不需要为了兼容不同版本改变原有的开发习惯。学习成本比较低</li>
<li>支持静态编译，比如可以针对不同的版本进行条件编译，<strong>优化包体积</strong>。另外可以<strong>保留<a href="https://cn.vuejs.org/guide/extras/rendering-mechanism.html#compiler-informed-virtual-dom" target="_blank" rel="noopener">Vue 模板编译优化</a>机制</strong>。</li>
<li>使用公开标准语法，不需要 hack 或者关心太多框架底层的差异。</li>
</ul>
</li>
<li>缺点<ul>
<li>构建相对复杂，需要两份代码输出。</li>
<li>灵活性较差。模板语法差异很小，但不以为着没有差异，当需要处理某些跨版本差异时可能会比较棘手。比如<a href="https://v3-migration.vuejs.org/zh/breaking-changes/render-function-api.html" target="_blank" rel="noopener">向下透传事件、props 或者 slots</a> , <a href="https://v3-migration.vuejs.org/zh/breaking-changes/v-bind.html" target="_blank" rel="noopener">v-bind.sync 废弃了</a> 、<a href="https://v3-migration.vuejs.org/zh/breaking-changes/key-attribute.html" target="_blank" rel="noopener">template v-for key</a> <strong>、</strong>v-model 协议变化。</li>
<li>⚠️ 语法固化，为了兼容 Vue 2，template 语法需要停留在 Vue 3.0，这意味着后续发布的新特性可能无法使用，比如 <code>defineModel</code>，<code>defineOptions</code>。</li>
</ul>
</li>
</ul>
<p><br><br><br><br><br></p>
<p><strong>方案 2： 渲染函数</strong></p>
<p>Vue 2 和 Vue 3 都支持渲染函数，但是两者之间有非常大的差异。<strong>详细的差异对比可以看笔者整理的这篇文档： <a href="https://www.notion.so/Vue-2-3-302cbe0e37794345bbfbd89e32d617db?pvs=21" target="_blank" rel="noopener">Vue 2/3 渲染函数差异以及兼容方案</a></strong></p>
<p><br></p>
<p><strong>那 Vue 官方的 JSX 插件呢？</strong></p>
<p>Vue 2/3 JSX Babel (<strong><a href="https://github.com/vuejs/jsx-vue2" target="_blank" rel="noopener">jsx-vue2</a>、<a href="https://github.com/vuejs/babel-plugin-jsx" target="_blank" rel="noopener">babel-plugin-jsx</a></strong>)插件加了一些语法糖，来简化渲染函数的编写，但是这两个插件的语法完全是两个东西。</p>
<p>因此这个方案不在我们的考虑之列。</p>
<p><br><br><br><br><br></p>
<p><strong>方案 3：标准的 JSX</strong></p>
<p>那为什么不用标准的 <code>JSX</code> 呢？使用统一的 JSX 语法，转换为不同版本的渲染函数。</p>
<p><img src="/images/component-for-vue2-3/Untitled%201.png" alt="Untitled"></p>
<p>使用标准的 JSX 语法，意味着：</p>
<ul>
<li><p>不需要任何 <code>Babel</code> 插件，能够被市面上主流的编译器(如 tsc， swc，esbuild)直接处理。<br>例如 Typescript</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">/** tsconfig.json */</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"jsx"</span>: <span class="string">"react-jsx"</span>,</span><br><span class="line">    <span class="attr">"jsxImportSource"</span>: <span class="string">"JSX 运行时名称"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<strong>运行时</strong>转换到对应版本的渲染函数。</p>
</li>
<li>Typescript friendly。纯 TSX，不需要额外插件(比如 <code>Volar</code>)辅助。</li>
<li><p>使用习惯上接近 <code>React</code>。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">/** 🔴 1. 事件订阅  **/</span><br><span class="line">// 🤮</span><br><span class="line"><span class="deletion">- &lt;input vOn:click=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;input vOn:click_stop_prevent=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line">// 👍 使用 on* 注册时间</span><br><span class="line"><span class="addition">+ &lt;input onClick=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line"></span><br><span class="line">/** 🔴 2. 没有指令  **/</span><br><span class="line">// 🤮</span><br><span class="line"><span class="deletion">- &lt;input v-show=&#123;this.visible&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;input vModel=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;input vModel_trim=&#123;this.newTodoText&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;A v-model=&#123;[val, "argument", ["modifier"]]&#125; /&gt;</span></span><br><span class="line"><span class="deletion">- &lt;a v-loading=&#123;val&#125; /&gt;;</span></span><br><span class="line"></span><br><span class="line">// 👍 没有语法糖</span><br><span class="line"><span class="addition">+ &lt;input modelValue=&#123;val&#125; onUpdate:modelValue=&#123;handleValChange&#125; /&gt;</span></span><br><span class="line"><span class="addition">+ &lt;input style=&#123;&#123;display: this.visible ? 'block' : 'none' &#125;&#125; /&gt;</span></span><br><span class="line"><span class="addition">+ &lt;a &#123;...withDirectives([[vLoading, val]])&#125;&gt;</span></span><br><span class="line"></span><br><span class="line">/** 🔴 3. slots  **/</span><br><span class="line">// 🤮</span><br><span class="line"><span class="deletion">- &lt;MyComponent&gt;</span></span><br><span class="line"><span class="deletion">-   &lt;header slot="header"&gt;header&lt;/header&gt;</span></span><br><span class="line"><span class="deletion">-   &lt;footer slot="footer"&gt;footer&lt;/footer&gt;</span></span><br><span class="line"><span class="deletion">- &lt;/MyComponent&gt;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">- const scopedSlots = &#123;</span></span><br><span class="line"><span class="deletion">-   header: () =&gt; &lt;header&gt;header&lt;/header&gt;,</span></span><br><span class="line"><span class="deletion">-   footer: () =&gt; &lt;footer&gt;footer&lt;/footer&gt;</span></span><br><span class="line"><span class="deletion">- &#125;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">- &lt;MyComponent scopedSlots=&#123;scopedSlots&#125; /&gt;</span></span><br><span class="line"></span><br><span class="line">// 👍 对齐 vue 3</span><br><span class="line"><span class="addition">+ const App = &#123;</span></span><br><span class="line"><span class="addition">+   setup() &#123;</span></span><br><span class="line"><span class="addition">+     const slots = &#123;</span></span><br><span class="line"><span class="addition">+       bar: () =&gt; &lt;span&gt;B&lt;/span&gt;,</span></span><br><span class="line"><span class="addition">+     &#125;;</span></span><br><span class="line"><span class="addition">+     return () =&gt; (</span></span><br><span class="line"><span class="addition">+       &lt;A v-slots=&#123;slots&#125;&gt;</span></span><br><span class="line"><span class="addition">+         &lt;div&gt;A&lt;/div&gt;</span></span><br><span class="line"><span class="addition">+       &lt;/A&gt;</span></span><br><span class="line"><span class="addition">+     );</span></span><br><span class="line"><span class="addition">+   &#125;,</span></span><br><span class="line"><span class="addition">+ &#125;;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br><br><br></p>
<ul>
<li><p>优点</p>
<ul>
<li>构建很简单，使用标准的 JSX 只需构建一次。不需要引入特定的编译器，使用 <code>Typescript CLI</code>，<code>esbuild</code> 就可以直接编译。</li>
<li>Typescript Friendly, 另外相比 <code>vue-tsc</code> 编译结果会好一点。</li>
<li>灵活性。毋庸置疑，<code>JSX</code> 的灵活性，可操行性太强了。</li>
<li>相对模板编译来说，可控一点(Hackable)。</li>
<li>可以替换官方的 JSX 库，除了本文介绍的<code>跨版本组件库</code>场景，在日常 Vue 2/3 应用开发中也可以使用啊。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>使用 <code>JSX</code> 则意味着放弃<a href="https://cn.vuejs.org/guide/extras/rendering-mechanism.html#compiler-informed-virtual-dom" target="_blank" rel="noopener">模板编译优化</a>的机会，比如动态节点标注，预字符串化，缓存，静态提升等等。</li>
<li>为了抹平版本之间的差异，多了一层抽象转换(主要是 Vue 2 上)，会有一些性能损耗。</li>
<li>实现上需要熟知两个版本之间的差异性。比较 hack</li>
<li>可读性较差，相比 <code>React</code> 简洁的 Api，Vue 上的一些特殊的框架特性，还是会让代码有些不太优雅，比如指令、Slot</li>
</ul>
</li>
</ul>
<p>后面我们选择了 <code>JSX</code> 方案，因为实现起来更简单，方案更加可控，尤其是应对后续的版本更新。</p>
<p><br><br><br><br><br></p>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>构建跨版本的组件库，需要考虑的不仅仅是组件语法问题。Vue 2/3 从底层的 API 到渲染函数、再到应用层的组件库、路由、多语言等等，都出现了割裂。我们得兼顾这些变化。</p>
<p><br></p>
<ol>
<li><strong>分层策略</strong></li>
</ol>
<p><img src="/images/component-for-vue2-3/Untitled%202.png" alt="Untitled"></p>
<p>我们按照引用关系进行分层：</p>
<ul>
<li><strong><code>API 层</code></strong>。好在 Vue 3 大部分特性(主要是 <code>Composition API</code> 和 <code>defineComponent</code>) 已经下放到了 Vue 2，我们只需要使用 <a href="https://github.com/vueuse/vue-demi" target="_blank" rel="noopener">vue-demi</a> 就可以无缝使用这些核心的 API。<br>相对应的，上层的组件库、适配器代码禁止直接导入 ‘vue’</li>
<li><strong><code>视图语法层</code></strong>。就如上文说的，我们会封装一个 jsx-runtime, 抹平 Vue 2/3 在渲染函数上的差异。</li>
<li><strong><code>适配器层</code></strong>。应用层的各种类库的适配。比如我们公司主要使用 element-ui, 新旧版本的差异会在 element-adapter 中处理，并暴露统一接口。</li>
<li><strong><code>组件库层</code></strong>。最后我们的组件库基于下层提供的抽象能力，实现跨版本。</li>
<li><strong><code>应用</code></strong>。上层的 Vue 2 / 3 应用。下层的适配器，会根据应用使用的 Vue 版本，动态切换适配。</li>
</ul>
<p><br><br><br></p>
<p><strong>2) 新版本优先策略</strong></p>
<p>在封装适配器 或者 jsx-runtime 时，当新旧版本出现差异时，我们如何抉择？</p>
<p>这里采用的是“新版本优先”的策略，举一些例子：</p>
<ul>
<li>JSX 的语法对齐 Vue 3 的渲染函数。</li>
<li>只使用 Composition API</li>
<li>只使用 defineComponent</li>
</ul>
<p>换句话说，如果情况允许，我们始终以 Vue 3 为基准。</p>
<p><br><br><br></p>
<p><strong>3) 短板优先策略</strong></p>
<p>短板对齐是实现兼容的基础策略，主要分两个方面：</p>
<ul>
<li>削头: 并不是所有 Vue 3 的特性都能下放到 Vue 2, 比如 <code>Fragment</code>、<code>Teleport</code>、<code>Suspense</code>/<code>await setup</code>。我们只能放弃这些功能。</li>
<li>补尾：针对一些 Vue 2 的短板，需要一些额外的工作，比如 <a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">Vue 2 响应式系统的局限性</a>。</li>
</ul>
<p><br><br><br></p>
<p><strong>4) 回退策略</strong></p>
<p>对于一些无法抹平的差异，可以按照不同的版本特殊处理。可以使用 vue-demi 的 <code>isVue2</code> 来分条件处理。</p>
<p><br><br><br><br><br></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="api-兼容：vue-demi"><a href="#api-兼容：vue-demi" class="headerlink" title="API 兼容：vue demi"></a>API 兼容：vue demi</h3><p><a href="https://github.com/vueuse/vue-demi" target="_blank" rel="noopener">vue-demi</a> 为实现跨 Vue 版本的库提供基础的支持。它的主要策略：</p>
<ul>
<li><code>&lt;=2.6</code>: 导出  <code>vue</code> + <code>@vue/composition-api</code>.</li>
<li><code>2.7</code>: 导出  <code>vue</code> ( Vue 2.7 内置支持 Composition API).</li>
<li><code>&gt;=3.0</code>: 导出  <code>vue</code>, 模拟了 Vue 2 的<code>set</code> 、 <code>del</code> API.</li>
</ul>
<p>vue-demi 的实现很简单，就是在 npm 的 <code>postinstall</code> 钩子中，判断当前环境安装的 vue 库版本，决定导入的库。</p>
<p>在我们的场景中，除了 Composition API 和一些基础类型信息还不够，我们 Fork 了 vue-demi 来扩充了一些填充物，进一步抹平一些差异。</p>
<p><br><br><br><br><br></p>
<h3 id="渲染语法：jsx-runtime-的实现"><a href="#渲染语法：jsx-runtime-的实现" class="headerlink" title="渲染语法：JSX runtime 的实现"></a>渲染语法：JSX runtime 的实现</h3><p>JSX runtime 的实现并不涉及太复杂的技术，主要还是处理渲染函数的繁琐 API 差异。</p>
<p>文章篇幅有限，这里我就不展开讲细节了。<strong>⚠️ 完整的差异对比和应对方式可以看这里</strong>：</p>
<p><br></p>
<p><a href="https://www.notion.so/Vue-2-3-302cbe0e37794345bbfbd89e32d617db?pvs=21" target="_blank" rel="noopener">🎉Vue 2 / 3 渲染函数的差异 🎉</a></p>
<p><br></p>
<p>简单来说，我们的 JSX 语法以 Vue 3 为基准，主要涉及事件订阅、slots、指令的转换。</p>
<p><br></p>
<p><img src="/images/component-for-vue2-3/Untitled%203.png" alt="Untitled"></p>
<p>具体实现可以看<a href="https://github.com/wakeadmin/tools/tree/main/packages/h" target="_blank" rel="noopener">这里</a></p>
<p><br><br><br><br><br></p>
<h3 id="组件定义与-typescript-支持"><a href="#组件定义与-typescript-支持" class="headerlink" title="组件定义与 Typescript 支持"></a>组件定义与 Typescript 支持</h3><p>Typescript + Volar 就是一门玄学，类型‘体操’几乎占据了开发的三分之一时间。主要问题：</p>
<ul>
<li>Vue 2/3 类型定义和导出有细微的差别。我们的 jsx-runtime 要求一致的类型。</li>
<li>JSX 的 slots 不支持类型检查。渲染函数毕竟不是 Vue 的第一公民，slots 在 JSX 下无法类型检查。</li>
<li>为了兼容 options API, <code>defineComponent</code> 类型定义和推导比较<a href="https://github.com/vuejs/core/blob/a95e612b252ae59eaf56e0b8ddba66948d4ac20e/packages/runtime-core/src/apiDefineComponent.ts#L44" target="_blank" rel="noopener">复杂</a>。</li>
<li>泛型组件实现比较复杂，Volar 泛型的支持也比较玄学。</li>
</ul>
<p><br><br><br></p>
<p>为了能够更好地定义跨版本的组件，提供更好的类型支持，我们打算简化 <code>defineComponent</code>。为了避免命名冲突，尚且命名为 <code>declareComponent</code> 吧, 这个函数有以下职责：</p>
<ul>
<li>为实现跨版本支持提供必要约束。<code>declareComponent</code> 裁剪掉了 <code>Options API</code>, 只保留 setup、props、render 等属性。强制走 <code>Composition API</code>。</li>
<li>为 JSX (比如 v-slots 属性)提供更好类型检查支持</li>
<li>同时兼容 vue template 的类型检查 (<code>volar</code>)。</li>
<li>在运行时抹平一些跨版本的差异。绝大部分差异，Vue 2.7 在 <code>defineComponent</code> 方法内部已经抹平了。还有一些 <code>inheritAttrs</code> 带来的<a href="https://www.notion.so/Vue-2-3-302cbe0e37794345bbfbd89e32d617db?pvs=21" target="_blank" rel="noopener">隐式差异</a>，<strong>declareComponent 直接关闭了 <code>inheritAttrs</code></strong> 。</li>
<li>补全短板，并且向下保持兼容。Vue 2 已经不更新了，我们想要支持一些新的特性，比如泛型。</li>
</ul>
<p><br></p>
<p>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Counter = declareComponent(&#123;</span><br><span class="line">  name: &apos;Counter&apos;,</span><br><span class="line">  // 定义 props</span><br><span class="line">  props: declareProps&lt;&#123;</span><br><span class="line">    initialValue: number</span><br><span class="line">  &#125;&gt;(</span><br><span class="line">    // ⚠️ 和 defineComponent 一样，我们还是需要显式定义 props, 否则会被当做 attrs</span><br><span class="line">    [&apos;initialValue&apos;]</span><br><span class="line">  ),</span><br><span class="line"></span><br><span class="line">  // 定义事件</span><br><span class="line">  emits: declareEmits&lt;&#123; change: (value: number) =&gt; void &#125;&gt;(),</span><br><span class="line"></span><br><span class="line">  // 定义插槽</span><br><span class="line">  // slots: declareSlots&lt;&#123; foo: &#123; a: number &#125; &#125;&gt;(),</span><br><span class="line"></span><br><span class="line">  // setup</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    const count = ref(props.initialValue)</span><br><span class="line">    const handleClick = () =&gt; &#123;</span><br><span class="line">      count.value++</span><br><span class="line"></span><br><span class="line">      emit(&apos;change&apos;, count.value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return () =&gt; (</span><br><span class="line">      &lt;div title=&quot;count&quot; onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">        count: &#123;count.value&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<p>为了实现这个目标，我们先来看下 <code>Volar</code> 是如何推断组件的类型：</p>
<p><br></p>
<p>大致的推导过程如下, 其次可以参考 <code>vue-tsc</code> 的编译输出或者 Vue <code>defineComponent</code> 的类型声明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// https://github.com/vuejs/language-tools/blob/71240c78f1a205605f4c079a299b2701250ef9be/packages/vue-component-type-helpers/index.d.ts#L5</span><br><span class="line">export type ComponentProps&lt;T&gt; = T extends new () =&gt; &#123; $props: infer P &#125;</span><br><span class="line">  ? NonNullable&lt;P&gt;</span><br><span class="line">  : T extends (props: infer P, ...args: any) =&gt; any</span><br><span class="line">  ? P</span><br><span class="line">  : &#123;&#125;</span><br><span class="line"></span><br><span class="line">export type ComponentSlots&lt;T&gt; = T extends new () =&gt; &#123; $slots: infer S &#125;</span><br><span class="line">  ? NonNullable&lt;S&gt;</span><br><span class="line">  : T extends (props: any, ctx: &#123; slots: infer S &#125;, ...args: any) =&gt; any</span><br><span class="line">  ? NonNullable&lt;S&gt;</span><br><span class="line">  : &#123;&#125;</span><br><span class="line"></span><br><span class="line">export type ComponentEmit&lt;T&gt; = T extends new () =&gt; &#123; $emit: infer E &#125;</span><br><span class="line">  ? NonNullable&lt;E&gt;</span><br><span class="line">  : T extends (props: any, ctx: &#123; emit: infer E &#125;, ...args: any) =&gt; any</span><br><span class="line">  ? NonNullable&lt;E&gt;</span><br><span class="line">  : &#123;&#125;</span><br><span class="line"></span><br><span class="line">export type ComponentExposed&lt;T&gt; = T extends new () =&gt; infer E</span><br><span class="line">  ? E</span><br><span class="line">  : T extends (props: any, ctx: &#123; expose(exposed: infer E): any &#125;, ...args: any) =&gt; any</span><br><span class="line">  ? NonNullable&lt;E&gt;</span><br><span class="line">  : &#123;&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Vue 2.x</span><br><span class="line"> */</span><br><span class="line">export type Vue2ComponentSlots&lt;T&gt; = T extends new () =&gt; &#123; $scopedSlots: infer S &#125;</span><br><span class="line">  ? NonNullable&lt;S&gt;</span><br><span class="line">  : T extends (props: any, ctx: &#123; slots: infer S &#125;, ...args: any) =&gt; any</span><br><span class="line">  ? NonNullable&lt;S&gt;</span><br><span class="line">  : &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>简单来说 <code>defineComponent</code> 方法最终输出的组件的类型外观长这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type YourComponent = new (...args: any[]): &#123;</span><br><span class="line">  $props: Props 类型</span><br><span class="line">  $emit: 事件类型</span><br><span class="line">  $slots: 插槽类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>💡 那 Typescript 的 JSX 怎么对组件进行类型检查呢？这个可以参考 Typescript 的 <a href="https://www.typescriptlang.org/docs/handbook/jsx.html" target="_blank" rel="noopener">JSX 文档</a>，还有 Vue 的 JSX <a href="https://github.com/vuejs/core/blob/a95e612b252ae59eaf56e0b8ddba66948d4ac20e/packages/vue/jsx.d.ts#L3" target="_blank" rel="noopener">类型定义</a>。简单说也是从上述的 <code>$props</code> 中推导的。</p>
</blockquote>
<p><br><br><br></p>
<p>我们的 <code>declareComponent</code> 只要保持和上面的类型兼容，就可以让 <code>volar</code> 在 vue template 下进行类型检查了。</p>
<p><br></p>
<p>因为刨除掉了不必要的 Options API, 相比 defineComponent, 类型定义可以简化很多:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function declareComponent&lt;</span><br><span class="line">  Props extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Emit extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Slots extends &#123;&#125; = &#123;&#125;</span><br><span class="line">&gt;(</span><br><span class="line">  options: SimpleComponentOptions&lt;Props, Emit, Expose, Slots&gt;</span><br><span class="line">): DefineComponent&lt;Props, Emit, Expose, Slots&gt; &#123;</span><br><span class="line">  /// .. 实现忽略，简单封装 defineComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 🔴 简化 defineComponent API, 只保留 Composition API</span><br><span class="line">export type SimpleComponentOptions&lt;</span><br><span class="line">  Props extends &#123;&#125;,</span><br><span class="line">  Emit extends &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125;,</span><br><span class="line">  Slots extends &#123;&#125;</span><br><span class="line">&gt; = &#123;</span><br><span class="line">  name?: string</span><br><span class="line">  props?: Props</span><br><span class="line">  emits?: Emit</span><br><span class="line">  slots?: Slots</span><br><span class="line">  expose?: Expose</span><br><span class="line">  setup: (</span><br><span class="line">    props: Props,</span><br><span class="line">    ctx: SetupContext&lt;Emit, DefaultSlots &amp; Slots, Expose, Data&gt;</span><br><span class="line">  ) =&gt; Promise&lt;RenderFunction | void&gt; | RenderFunction | void</span><br><span class="line">  inheritAttrs?: boolean</span><br><span class="line">  serverPrefetch?(): Promise&lt;any&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export interface ComponentInstance&lt;</span><br><span class="line">  Props extends &#123;&#125;,</span><br><span class="line">  Emit extends &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125;,</span><br><span class="line">  Slots extends &#123;&#125;</span><br><span class="line">&gt; &#123;</span><br><span class="line">  // props 定义</span><br><span class="line">  $props: Props &amp;</span><br><span class="line">    // 🔴 将 emit 转换为 on* 形式，方便 JSX 场景使用</span><br><span class="line">    EmitsToProps&lt;Emit&gt; &amp; &#123; &apos;v-slots&apos;?: Partial&lt;VSlotType&lt;Slots&gt;&gt; &#125; &amp; &#123;</span><br><span class="line">      // 🔴 扩展了 v-slots 的定义，方便 JSX 场景使用</span><br><span class="line">      &apos;v-children&apos;?: VChildrenType&lt;Slots&gt;</span><br><span class="line">    &#125; &amp; &#123;</span><br><span class="line">      ref?: RefType&lt;Expose | Expose[]&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  // 🔴 支持 volar 推断 slots</span><br><span class="line">  $slots: VSlotType&lt;Slots&gt;</span><br><span class="line">  // 🔴 支持 volar 推断 事件</span><br><span class="line">  $emit: EmitFn&lt;Emit&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以对比 Vue 的 DefineComponent 看看</span><br><span class="line">export interface DefineComponent&lt;</span><br><span class="line">  Props extends &#123;&#125;,</span><br><span class="line">  Emit extends &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125;,</span><br><span class="line">  Slots extends &#123;&#125;</span><br><span class="line">&gt; &#123;</span><br><span class="line">  new (...args: any[]): ComponentInstance&lt;Props, Emit, Expose, Slots&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>那怎么支持泛型组件吗？</strong></p>
<p><br><br><br><br><br></p>
<h3 id="泛型组件"><a href="#泛型组件" class="headerlink" title="泛型组件"></a><strong>泛型组件</strong></h3><blockquote>
<p>Volar 需要升级到最新版本。</p>
</blockquote>
<blockquote>
<p>Volar 的泛型支持比较玄学，我建议不要随意尝试！</p>
</blockquote>
<p>Vue 3.3 官方正式支持了<a href="https://blog.vuejs.org/posts/vue-3-3" target="_blank" rel="noopener">泛型 SFC</a> 和 defineComponent, 笔者实测 Volar 这块支持还有待改进。但是不妨碍我们进行初步的尝试。</p>
<p>上文的 <code>declareComponent</code> 写法是不支持泛型组件的。有两种方式可以实现泛型组件的声明，先来看一个比较简单的：</p>
<ol>
<li><p><strong>类型断言</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 🔴 使用泛型定义 props、emit 和 expose 等类型</span><br><span class="line">interface Props&lt;T&gt; &#123;</span><br><span class="line">  list: T[]</span><br><span class="line">  filter: (item: T) =&gt; boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 📢 这里要用 type</span><br><span class="line">type Emit&lt;T&gt; = &#123;</span><br><span class="line">  add: (item: T) =&gt; void</span><br><span class="line">  change: (list: T[]) =&gt; void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Expose&lt;T&gt; = &#123;</span><br><span class="line">  open: (item: T) =&gt; void</span><br><span class="line">  list: T[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Slots&lt;T&gt; = &#123;</span><br><span class="line">  foo: (list: T[]) =&gt; any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const GenericBar = declareComponent(&#123;</span><br><span class="line">  props: declareProps&lt;Props&lt;any&gt;&gt;([]),</span><br><span class="line">  emits: declareEmits&lt;Emit&lt;any&gt;&gt;(),</span><br><span class="line">  expose: declareExpose&lt;Expose&lt;any&gt;&gt;(),</span><br><span class="line">  slots: declareSlots&lt;Slots&lt;any&gt;&gt;(),</span><br><span class="line">  setup(props, ctx) &#123;</span><br><span class="line">    expectType&lt;any[]&gt;(props.list)</span><br><span class="line">    ctx.emit(&apos;change&apos;, [])</span><br><span class="line">    ctx.slots.foo?.([])</span><br><span class="line">    ctx.expose(&#123;</span><br><span class="line">      list: [],</span><br><span class="line">      open() &#123;</span><br><span class="line">        // ignore</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    return &#123;&#125; as any</span><br><span class="line">  &#125;,</span><br><span class="line">  // 🔴 重新断言，支持 泛型</span><br><span class="line">&#125;) as new &lt;T&gt;(...args: any[]) =&gt; ComponentInstance&lt;Props&lt;T&gt;, Emit&lt;T&gt;, Expose&lt;T&gt;, Slots&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">;&lt;GenericBar</span><br><span class="line">  list=&#123;[1, 2]&#125;</span><br><span class="line">  filter=&#123;(i) =&gt; &#123;</span><br><span class="line">    expectType&lt;number&gt;(i)</span><br><span class="line">    return true</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  onAdd=&#123;(i) =&gt; &#123;</span><br><span class="line">    expectType&lt;number&gt;(i)</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  onChange=&#123;(i) =&gt; &#123;</span><br><span class="line">    expectType&lt;number[]&gt;(i)</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  v-slots=&#123;&#123;</span><br><span class="line">    foo(i) &#123;</span><br><span class="line">      expectType&lt;number[]&gt;(i)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;&lt;/GenericBar&gt;</span><br></pre></td></tr></table></figure>
<p> <br></p>
<p>上面的方式在 JSX 表现正常，<strong>但是目前 Volar 在 vue template 并不支持。</strong></p>
<blockquote>
<p>💡 <strong>这里也有一些冷知识。</strong>假设 目标类型约束了 <code>Index Signature</code>, 比如 <code>{[key: string]: Function }</code>, 那么 <code>interface</code> 是无法赋值给它的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; interface Indexed &#123;</span><br><span class="line">&gt;   [key: string]: Function</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; interface Foo &#123;</span><br><span class="line">&gt;   hello: () =&gt; void</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; declare let a: Indexed</span><br><span class="line">&gt; declare let b: Foo</span><br><span class="line">&gt;</span><br><span class="line">&gt; a = b // 🚨 Index signature for type &apos;string&apos; is missing in type &apos;Foo&apos;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>如果使用 <code>type</code> 创建类型就可以:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; type Bar = &#123;</span><br><span class="line">&gt;   hello: () =&gt; void</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; declare let c: Bar</span><br><span class="line">&gt; a = c // it&apos;s work</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>笔者推测，应该<strong>是 interface 允许 <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces" target="_blank" rel="noopener">合并</a>，不是静态的，因此不能安全地满足 Index Signature 的约束</strong>。</p>
<p>了解更多：</p>
<p><a href="https://stackoverflow.com/questions/60697214/how-to-fix-index-signature-is-missing-in-type-error" target="_blank" rel="noopener">How to fix “Index signature is missing in type” error?</a></p>
</blockquote>
<p> <br><br> <br></p>
</li>
<li><p><strong>函数形式</strong></p>
<p>Vue 3.3 的 <code>defineComponent</code> 新增了一种<a href="https://cn.vuejs.org/api/general.html#definecomponent" target="_blank" rel="noopener">函数签名形式</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Comp = defineComponent(</span><br><span class="line">  &lt;T extends string | number&gt;(props: &#123; msg: T; list: T[] &#125;) =&gt; &#123;</span><br><span class="line">    // 就像在 &lt;script setup&gt; 中一样使用组合式 API</span><br><span class="line">    const count = ref(0)</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      // 渲染函数或 JSX</span><br><span class="line">      return &lt;div&gt;&#123;count.value&#125;&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 去掉注释，泛型会失效</span><br><span class="line">  // 目前仍然需要手动声明运行时的 props</span><br><span class="line">  // &#123;</span><br><span class="line">  //  props: [&apos;msg&apos;, &apos;list&apos;]</span><br><span class="line">  /// &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>尴尬的是，Vue 组件必须显式定义 props 参数，不然会被当做 attrs 处理。所以，当你将上面的<strong>props 参数注释去掉时，泛型就会失效了 😀</strong> 。</p>
<p>另外一件尴尬的事情是，截止目前为止，用上面语法创建的组件，在 Volar 上并不能得到很好的支持(只能正确推断 props)。</p>
<p><br></p>
<p>但使用 <a href="https://cn.vuejs.org/api/sfc-script-setup.html#generics" target="_blank" rel="noopener">SFC 泛型语法</a> 则会表现好一点。SFC 有什么特殊？</p>
<p>我使用 vue-tsc 将组件编译了一下，大概结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare const _default: &lt;T&gt;(</span><br><span class="line">  // 🔴 props 类型</span><br><span class="line">  __VLS_props: &#123;</span><br><span class="line">    list: T[]</span><br><span class="line">    filter: (item: T) =&gt; boolean</span><br><span class="line">  &#125; &amp; VNodeProps &amp;</span><br><span class="line">    AllowedComponentProps &amp;</span><br><span class="line">    ComponentCustomProps,</span><br><span class="line"></span><br><span class="line">  // 🔴 context 类型</span><br><span class="line">  __VLS_ctx?:</span><br><span class="line">    | Pick&lt;</span><br><span class="line">        &#123;</span><br><span class="line">          props: &#123;</span><br><span class="line">            list: T[]</span><br><span class="line">            filter: (item: T) =&gt; boolean</span><br><span class="line">          &#125;</span><br><span class="line">          expose(exposed: &#123; data: Ref&lt;T[] | null | undefined&gt; &#125;): void</span><br><span class="line">          attrs: any</span><br><span class="line">          slots: &#123;</span><br><span class="line">            foo: (scope: &#123; list: T[] &#125;) =&gt; any</span><br><span class="line">          &#125;</span><br><span class="line">          emit: &#123;</span><br><span class="line">            change: [T[]]</span><br><span class="line">            foo: [T, number]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;attrs&apos; | &apos;emit&apos; | &apos;slots&apos;</span><br><span class="line">      &gt;</span><br><span class="line">    | undefined</span><br><span class="line">) =&gt; // 🔴 返回值</span><br><span class="line">VNode &amp; &#123;</span><br><span class="line">  __ctx?:</span><br><span class="line">    | &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">          list: T[]</span><br><span class="line">          filter: (item: T) =&gt; boolean</span><br><span class="line">        &#125;</span><br><span class="line">        expose(exposed: &#123; data: Ref&lt;T[] | null | undefined&gt; &#125;): void</span><br><span class="line">        attrs: any</span><br><span class="line">        slots: &#123;</span><br><span class="line">          foo: (scope: &#123; list: T[] &#125;) =&gt; any</span><br><span class="line">        &#125;</span><br><span class="line">        emit: &#123;</span><br><span class="line">          change: [T[]]</span><br><span class="line">          foo: [T, number]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    | undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SFC 的编译结果多出了 <code>__ctx</code> 字段，实际上 Volar 就是从 __ctx 中提取了相关类型。</p>
<aside><br>💡 __ctx 应该是 volar 的内部实现细节，不排除后面会变动<br><br></aside>

<p>那我们现在就模仿它，重构一下 <code>declareComponent</code> 的签名:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface DefineComponentContext&lt;</span><br><span class="line">  Emit extends ObjectEmitsOptions = &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Slots extends &#123; [key: string]: Function &#125; = &#123;&#125;,</span><br><span class="line">  Attrs extends &#123;&#125; = &#123;&#125;</span><br><span class="line">&gt; &#123;</span><br><span class="line">  attrs: Attrs</span><br><span class="line">  slots: Slots</span><br><span class="line">  emit: EmitFn&lt;Emit&gt;</span><br><span class="line">  expose: ExposeFn&lt;Expose&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function declareComponent&lt;</span><br><span class="line">  Props extends &#123;&#125;,</span><br><span class="line">  Emit extends ObjectEmitsOptions = &#123;&#125;,</span><br><span class="line">  Expose extends &#123;&#125; = &#123;&#125;,</span><br><span class="line">  Slots extends &#123; [key: string]: Function &#125; = &#123;&#125;,</span><br><span class="line">  Attrs extends &#123;&#125; = &#123;&#125;</span><br><span class="line">&gt;(</span><br><span class="line">  setup: (</span><br><span class="line">    props: Props,</span><br><span class="line">    ctx: DefineComponentContext&lt;Emit, Expose, Slots, Attrs&gt;</span><br><span class="line">  ) =&gt; Promise&lt;RenderFunction | void&gt; | RenderFunction | void,</span><br><span class="line">  options?: &#123;</span><br><span class="line">    props?: Array&lt;keyof Props&gt; | ComponentObjectPropsOptions&lt;Partial&lt;Props&gt;&gt;</span><br><span class="line">    name?: string</span><br><span class="line">    inheritAttrs?: boolean</span><br><span class="line">    serverPrefetch?(): Promise&lt;any&gt;</span><br><span class="line">  &#125;</span><br><span class="line">): (</span><br><span class="line">  props: PropsType&lt;Props, Emit, Slots, Expose&gt;,</span><br><span class="line">  ctx: DefineComponentContext&lt;Emit, Expose, Slots, Attrs&gt;</span><br><span class="line">) =&gt; VNode &amp; &#123;</span><br><span class="line">  // 🛑</span><br><span class="line">  __ctx: &#123;</span><br><span class="line">    emit: EmitFn&lt;Emit&gt;</span><br><span class="line">    slots: Slots</span><br><span class="line">    expose: ExposeFn&lt;Expose&gt;</span><br><span class="line">    attrs: Attrs</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo&lt;T&gt;(</span><br><span class="line">  props: &#123; list: T[]; filter: (item: T) =&gt; boolean &#125;,</span><br><span class="line">  ctx: DefineComponentContext&lt;</span><br><span class="line">    &#123; change: (list: T[]) =&gt; void; add: (item: T) =&gt; void &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      open: (item: T) =&gt; void</span><br><span class="line">      list: T[]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      foo: (list: T[]) =&gt; any</span><br><span class="line">    &#125;</span><br><span class="line">  &gt;</span><br><span class="line">) &#123;</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    // render</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ⚠️ props 还是要定义</span><br><span class="line">Foo.props = [&apos;list&apos;, &apos;filter&apos;]</span><br><span class="line"></span><br><span class="line">export default declareComponent(Foo)</span><br></pre></td></tr></table></figure>
<p>目前 Volar 在泛型的支持上还有不少的坑。比如上面的示例中事件处理器的泛型变量会推断为 unknown。让子弹再飞一会吧。</p>
</li>
</ol>
<p><br><br><br><br><br> </p>
<h3 id="element-adapter"><a href="#element-adapter" class="headerlink" title="element-adapter"></a>element-adapter</h3><p>实现的原理和 vue-demi 类似，在 postinstall 时决定使用哪个版本。项目的结构如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scripts/             <span class="comment"># 和 vue-demi 一样，实现了 postinstall 和切换 CLI</span></span><br><span class="line">  postinstall.mjs</span><br><span class="line">  switch-cli.mjs</span><br><span class="line">src/</span><br><span class="line">  shared/</span><br><span class="line">  v2/                <span class="comment"># element-ui 导出</span></span><br><span class="line">    components/</span><br><span class="line">      Table.js</span><br><span class="line">      Slide.js</span><br><span class="line">      ...</span><br><span class="line">  v3/                <span class="comment"># element-plus 导出</span></span><br><span class="line">    components/</span><br><span class="line">      ...</span><br><span class="line">types/               <span class="comment"># 重新声明组件的类型信息。</span></span><br><span class="line">  alert.d.ts</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p><br> </p>
<p>大部分组件不需要特殊处理，重新导出就行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> &#123; Button &#125; from <span class="string">'element-ui'</span>;</span><br></pre></td></tr></table></figure>
<p><br> </p>
<p>有一些组件参数名称发生了变化，则以 element-plus 为基准做一下调整：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; TimePicker as ElTimePicker &#125; from &apos;element-ui&apos;</span><br><span class="line">import &#123; h &#125; from &apos;@wakeadmin/h&apos;</span><br><span class="line"></span><br><span class="line">import &#123; normalizeDateFormat &#125; from &apos;../../shared/date-format&apos;</span><br><span class="line"></span><br><span class="line">export const TimePicker = &#123;</span><br><span class="line">  functional: true,</span><br><span class="line">  render(_, context) &#123;</span><br><span class="line">    const &#123; format, selectableRange, valueFormat, ...other &#125; = context.props</span><br><span class="line"></span><br><span class="line">    // vue3 pickerOptions 提取到了全局</span><br><span class="line">    other.pickerOptions = &#123;</span><br><span class="line">      ...other.pickerOptions,</span><br><span class="line">      format: format &amp;&amp; normalizeDateFormat(format),</span><br><span class="line">      selectableRange,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (valueFormat) &#123;</span><br><span class="line">      other.valueFormat = normalizeDateFormat(valueFormat)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return h(</span><br><span class="line">      ElTimePicker,</span><br><span class="line">      Object.assign(&#123;&#125;, context.data, &#123; props: other, attrs: undefined &#125;),</span><br><span class="line">      context.slots()</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br> </p>
<p>另外，我们也会移植一些 element-plus 的新组件，比如 <code>TreeSelect</code>。</p>
<p>对于 icon 这类差异比较大，我们直接放弃了。可以使用外部图标库或者 SVG 组件库（参考这个<a href="https://github.com/wakeadmin/tools/tree/main/packages/icons" target="_blank" rel="noopener">实现</a>跨版本的 SVG 图标库）。</p>
<p><br><br><br><br><br> </p>
<h3 id="router-adapter"><a href="#router-adapter" class="headerlink" title="router-adapter"></a>router-adapter</h3><p>我们的组件库是可能会涉及到路由的订阅和操作。因为 vue-router API 差异并不大，处理起来会简单很多。</p>
<p>不管是 vue 2 还是 3，vue-router 都会在组件实例上挂载相关的 API, 我们直接获取就行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface RouteLike &#123;</span><br><span class="line">  query: Record&lt;string, any&gt;</span><br><span class="line">  params: Record&lt;string, any&gt;</span><br><span class="line">  hash: string</span><br><span class="line">  path: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export type RouteLocation =</span><br><span class="line">  | string</span><br><span class="line">  | &#123;</span><br><span class="line">      query?: Record&lt;string, any&gt;</span><br><span class="line">      hash?: string</span><br><span class="line">      path?: string</span><br><span class="line">      name?: string</span><br><span class="line">      params?: Record&lt;string, any&gt;</span><br><span class="line">      replace?: boolean</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">export interface RouterLike &#123;</span><br><span class="line">  push(to: RouteLocation): Promise&lt;any&gt;</span><br><span class="line">  replace(to: RouteLocation): Promise&lt;any&gt;</span><br><span class="line">  back(): void</span><br><span class="line">  forward(): void</span><br><span class="line">  go(delta: number): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function useRouter() &#123;</span><br><span class="line">  const instance = getCurrentInstance()</span><br><span class="line"></span><br><span class="line">  if (isVue2) &#123;</span><br><span class="line">    return (instance?.proxy?.$root as &#123; $router: RouterLike &#125; | undefined)?.$router</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return (instance?.root?.proxy as unknown as &#123; $router: RouterLike &#125;)?.$router</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ... useRoute 同理</span><br></pre></td></tr></table></figure>
<p><br> </p>
<p>其他的库可以采取类似的策略。</p>
<p><br><br><br><br><br> </p>
<h3 id="🎉-开源-🎉"><a href="#🎉-开源-🎉" class="headerlink" title="🎉 开源 🎉"></a>🎉 开源 🎉</h3><p>借着这篇文章，我们也将相关的<a href="https://github.com/wakeadmin" target="_blank" rel="noopener">程序开源了</a>! 希望能帮助到大家！</p>
<ul>
<li><a href="https://github.com/wakeadmin/tools/tree/main/packages/h" target="_blank" rel="noopener">jsx-runtime 实现</a></li>
<li><a href="https://github.com/wakeadmin/components" target="_blank" rel="noopener">组件库实现</a></li>
</ul>
<p>欢迎 Fork Star PR</p>
<p><br><br><br><br><br> </p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a href="https://www.notion.so/Vue-2-3-302cbe0e37794345bbfbd89e32d617db?pvs=21" target="_blank" rel="noopener">Vue 2/3 渲染函数差异以及兼容方案</a></li>
<li><a href="https://github.com/vuejs/core/pull/7963" target="_blank" rel="noopener">feat(types): <code>defineComponent()</code> with generics support</a></li>
<li><a href="https://cn.vitejs.dev/config/" target="_blank" rel="noopener">vitejs</a></li>
<li><a href="https://github.com/vitejs/vite-plugin-vue" target="_blank" rel="noopener">https://github.com/vitejs/vite-plugin-vue</a></li>
<li><a href="https://github.com/vitejs/vite-plugin-vue2" target="_blank" rel="noopener">https://github.com/vitejs/vite-plugin-vue2</a></li>
<li><a href="https://github.com/vuejs/babel-plugin-jsx" target="_blank" rel="noopener">https://github.com/vuejs/babel-plugin-jsx</a></li>
<li><a href="https://github.com/vuejs/jsx-vue2" target="_blank" rel="noopener">https://github.com/vuejs/jsx-vue2</a></li>
<li><a href="https://github.com/vuejs/language-tools" target="_blank" rel="noopener">https://github.com/vuejs/language-tools</a></li>
<li><a href="https://github.com/vuejs/vue-loader/" target="_blank" rel="noopener">https://github.com/vuejs/vue-loader/</a></li>
</ul>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#方案决策"><span class="toc-number">1.</span> <span class="toc-text">方案决策</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#策略"><span class="toc-number">2.</span> <span class="toc-text">策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现"><span class="toc-number">3.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#api-兼容：vue-demi"><span class="toc-number">3.1.</span> <span class="toc-text">API 兼容：vue demi</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#渲染语法：jsx-runtime-的实现"><span class="toc-number">3.2.</span> <span class="toc-text">渲染语法：JSX runtime 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组件定义与-typescript-支持"><span class="toc-number">3.3.</span> <span class="toc-text">组件定义与 Typescript 支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型组件"><span class="toc-number">3.4.</span> <span class="toc-text">泛型组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#element-adapter"><span class="toc-number">3.5.</span> <span class="toc-text">element-adapter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#router-adapter"><span class="toc-number">3.6.</span> <span class="toc-text">router-adapter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#🎉-开源-🎉"><span class="toc-number">3.7.</span> <span class="toc-text">🎉 开源 🎉</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展阅读"><span class="toc-number">4.</span> <span class="toc-text">扩展阅读</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2023/06/11/component-for-vue2-3/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2023/06/11/component-for-vue2-3/&text=如何实现支持跨 Vue 2/3 的组件库"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2023/06/11/component-for-vue2-3/&title=如何实现支持跨 Vue 2/3 的组件库"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2023/06/11/component-for-vue2-3/&is_video=false&description=如何实现支持跨 Vue 2/3 的组件库"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=如何实现支持跨 Vue 2/3 的组件库&body=Check out this article: https://bobi.ink/2023/06/11/component-for-vue2-3/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2023/06/11/component-for-vue2-3/&title=如何实现支持跨 Vue 2/3 的组件库"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2023/06/11/component-for-vue2-3/&title=如何实现支持跨 Vue 2/3 的组件库"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2023/06/11/component-for-vue2-3/&title=如何实现支持跨 Vue 2/3 的组件库"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2023/06/11/component-for-vue2-3/&title=如何实现支持跨 Vue 2/3 的组件库"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2023/06/11/component-for-vue2-3/&name=如何实现支持跨 Vue 2/3 的组件库&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2023 Ivan
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-44571525-2', 'auto');
        ga('send', 'pageview');
    </script>


    <!-- Disqus Comments -->
    <script type="text/javascript">
        var disqus_shortname = 'bobi-ink';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


