<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="本文主要参考的内容来源是patterns.dev。这个网站收录了许多实用的前端设计模式，大家赶紧收藏起来！   React 发布已经十年了，笔者接触前端差不多也有十年时间了。说实话，如果没有 Head First 系列图书，我可能都没有走上编程这条道路。  Head first  尽管现在看来这系列图书内容可能过时了。 Head First 系列图书让我知道，原来编程也可以这么通俗易懂的，对于刚">
<meta name="keywords" content="Blog,FrontEnd,React,Javascript,Typescript">
<meta property="og:type" content="article">
<meta property="og:title" content="现代前端框架的渲染模式">
<meta property="og:url" content="https://bobi.ink/2023/06/05/render-patterns/index.html">
<meta property="og:site_name" content="Bobi.ink">
<meta property="og:description" content="本文主要参考的内容来源是patterns.dev。这个网站收录了许多实用的前端设计模式，大家赶紧收藏起来！   React 发布已经十年了，笔者接触前端差不多也有十年时间了。说实话，如果没有 Head First 系列图书，我可能都没有走上编程这条道路。  Head first  尽管现在看来这系列图书内容可能过时了。 Head First 系列图书让我知道，原来编程也可以这么通俗易懂的，对于刚">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://bobi.ink/images/render-patterns/Untitled.png">
<meta property="og:image" content="https://bobi.ink/images/render-patterns/Untitled%201.png">
<meta property="og:image" content="https://bobi.ink/images/render-patterns/Untitled%202.png">
<meta property="og:image" content="https://bobi.ink/images/render-patterns/Untitled%203.png">
<meta property="og:image" content="https://bobi.ink/images/render-patterns/Untitled%204.png">
<meta property="og:image" content="https://bobi.ink/images/render-patterns/Untitled%205.png">
<meta property="og:image" content="https://bobi.ink/images/render-patterns/Untitled%206.png">
<meta property="og:image" content="https://bobi.ink/images/render-patterns/Untitled%207.png">
<meta property="og:image" content="https://bobi.ink/images/render-patterns/Untitled%208.png">
<meta property="og:image" content="https://bobi.ink/images/render-patterns/Untitled%209.png">
<meta property="og:image" content="https://bobi.ink/images/render-patterns/Untitled%2010.png">
<meta property="og:image" content="https://bobi.ink/images/render-patterns/Untitled%2011.png">
<meta property="og:image" content="https://bobi.ink/images/render-patterns/Untitled%2012.png">
<meta property="og:image" content="https://bobi.ink/images/render-patterns/Untitled%2013.png">
<meta property="og:image" content="https://bobi.ink/images/render-patterns/Untitled%2014.png">
<meta property="og:image" content="https://bobi.ink/images/render-patterns/Untitled%2015.png">
<meta property="og:image" content="https://bobi.ink/images/render-patterns/Untitled%2016.png">
<meta property="og:image" content="https://bobi.ink/images/render-patterns/Untitled%2017.png">
<meta property="og:image" content="https://bobi.ink/images/render-patterns/Untitled%2018.png">
<meta property="og:updated_time" content="2023-06-05T03:25:04.885Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="现代前端框架的渲染模式">
<meta name="twitter:description" content="本文主要参考的内容来源是patterns.dev。这个网站收录了许多实用的前端设计模式，大家赶紧收藏起来！   React 发布已经十年了，笔者接触前端差不多也有十年时间了。说实话，如果没有 Head First 系列图书，我可能都没有走上编程这条道路。  Head first  尽管现在看来这系列图书内容可能过时了。 Head First 系列图书让我知道，原来编程也可以这么通俗易懂的，对于刚">
<meta name="twitter:image" content="https://bobi.ink/images/render-patterns/Untitled.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>现代前端框架的渲染模式</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2023/06/11/component-for-vue2-3/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2023/06/01/island-pattern/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2023/06/05/render-patterns/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2023/06/05/render-patterns/&text=现代前端框架的渲染模式"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2023/06/05/render-patterns/&title=现代前端框架的渲染模式"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2023/06/05/render-patterns/&is_video=false&description=现代前端框架的渲染模式"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=现代前端框架的渲染模式&body=Check out this article: https://bobi.ink/2023/06/05/render-patterns/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2023/06/05/render-patterns/&title=现代前端框架的渲染模式"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2023/06/05/render-patterns/&title=现代前端框架的渲染模式"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2023/06/05/render-patterns/&title=现代前端框架的渲染模式"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2023/06/05/render-patterns/&title=现代前端框架的渲染模式"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2023/06/05/render-patterns/&name=现代前端框架的渲染模式&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#csr-客户端渲染"><span class="toc-number">1.</span> <span class="toc-text">CSR - 客户端渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ssr-服务端渲染"><span class="toc-number">2.</span> <span class="toc-text">SSR - 服务端渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ssg-静态生成"><span class="toc-number">3.</span> <span class="toc-text">SSG - 静态生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#isg-增量静态生成"><span class="toc-number">4.</span> <span class="toc-text">ISG - 增量静态生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#progressive-hydration-渐进水合"><span class="toc-number">5.</span> <span class="toc-text">Progressive Hydration - 渐进水合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ssr-with-streaming-流式-ssr"><span class="toc-number">6.</span> <span class="toc-text">SSR with streaming - 流式 SSR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#selective-hydration-选择性水合"><span class="toc-number">7.</span> <span class="toc-text">Selective Hydration - 选择性水合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#islands-architecture-岛屿架构"><span class="toc-number">8.</span> <span class="toc-text">Islands Architecture - 岛屿架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#react-server-component-react-服务端组件"><span class="toc-number">9.</span> <span class="toc-text">React Server Component - React 服务端组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">10.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展阅读"><span class="toc-number">11.</span> <span class="toc-text">扩展阅读</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        现代前端框架的渲染模式
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Bobi.ink</span>
      </span>
      
    <div class="postdate">
        <time datetime="2023-06-04T16:00:00.000Z" itemprop="datePublished">2023-06-05</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <blockquote>
<p>本文主要参考的内容来源是<a href="https://www.patterns.dev/" target="_blank" rel="noopener">patterns.dev</a>。这个网站收录了许多实用的前端设计模式，大家赶紧收藏起来！</p>
</blockquote>
<p><br></p>
<p>React 发布已经十年了，笔者接触前端差不多也有十年时间了。说实话，如果没有 <a href="https://search.douban.com/book/subject_search?search_text=head+first&amp;cat=1001" target="_blank" rel="noopener">Head First 系列图书</a>，我可能都没有走上编程这条道路。</p>
<p><br></p>
<p><img src="/images/render-patterns/Untitled.png" alt="Head first"><br>Head first</p>
<p><br></p>
<p>尽管现在看来这系列图书内容可能过时了。</p>
<p>Head First 系列图书让我知道，原来编程也可以这么通俗易懂的，对于刚接触这个领域的同学来说，从这里可以获得很多信心和成就感。<br>这种风格也一直影响着我，学习和工作、传道授业过程中，我会努力把复杂的事情简化、通俗化，提炼本质。</p>
<p><br><br><br></p>
<p>这十年，前端渲染方式一直在演进，我觉得大概可以分为以下三个阶段：</p>
<p><img src="/images/render-patterns/Untitled%201.png" alt="Untitled"></p>
<ul>
<li>传统 SSR: 那时候前端还没有分离，在 JSP、ASP、Ruby on Rails、Django 这些 MVC 框架下，通过模板来渲染页面。jQuery 是这个阶段的主角</li>
<li>前后端分离：从 Node.js 发布，到目前为止，是前端发展最迅速的 10 年。<br>前后端分离的典型代表是 Angular 和 React、Vue 等框架，我觉得，促进前后端分离的主要原因还是<strong>随着需求的复杂化，分工精细化了</strong>。 前端可以专注于 UI 的设计和交互逻辑。后端只需要提供 API，不需要关心前端的具体实现。</li>
<li>同构前端：这几年前端框架的发展进入的深水区，随着云原生、容器技术、Serverless、边缘计算等底层技术设施的普及，也让‘前端’生存范围延展到服务端。前端开始寻求 <code>UX</code> 和 <code>DX</code> 的平衡点</li>
</ul>
<p><br><br><br><br><br></p>
<p>通过这篇文章，你就可以知道近些年前端渲染模式的演变。</p>
<p>废话不多说，直接开始吧。</p>
<p><br><br><br><br><br></p>
<h2 id="csr-客户端渲染"><a href="#csr-客户端渲染" class="headerlink" title="CSR - 客户端渲染"></a>CSR - 客户端渲染</h2><p><img src="/images/render-patterns/Untitled%202.png" alt="Untitled"></p>
<p>这个我们再熟悉不过了， 即前端页面在浏览器中渲染，服务端仅仅是静态资源服务器(比如 nginx)。</p>
<p>初始的 HTML 文件只是一个空壳，我们需要等待 JavaScript 包加载和执行完毕，才能进行交互，白屏时间比较长。</p>
<ul>
<li>优点<ul>
<li>部署简单</li>
<li>页面过渡、功能交互友好</li>
<li>适合复杂交互型应用程序开发</li>
</ul>
</li>
<li>缺点<ul>
<li><code>SEO</code> 不友好</li>
<li>白屏时间长</li>
<li>可能需要复杂的状态管理。时至今日，状态管理方面的轮子还在不停地造</li>
</ul>
</li>
</ul>
<p><br><br><br><br><br></p>
<h2 id="ssr-服务端渲染"><a href="#ssr-服务端渲染" class="headerlink" title="SSR - 服务端渲染"></a>SSR - 服务端渲染</h2><p><img src="/images/render-patterns/Untitled%203.png" alt="Untitled"></p>
<p>为了解决 SEO 和白屏问题，各大框架开始支持在服务端渲染 HTML 字符串。</p>
<p>SSR 把数据拉取放到了服务端，因为离数据源比较近，数据拉取的速度会快一点。但这也不是完全没有副作用，因为需要在服务端等待数据就绪, <code>TTFB(Time to First Byte)</code> 相比 CSR 会长一点。</p>
<p>SSR 只是给我们准备好了初始的数据和 HTML, 实际上和 CSR 一样，我们还是需要加载完整的<code>客户端程序</code>，然后在浏览器端重新渲染一遍(更专业的说是 <code>Hydration  水合/注水</code>)，才能让 DOM 有交互能力。</p>
<p><strong>也就说， <code>FCP(First Contentful Paint)</code> 相比 CSR 提前了, 但是 <code>TTI(Time to Interactive)</code> 并没有太多差别。只是用户可以更快地看到内容了。</strong></p>
<blockquote>
<p>hydration 的主要目的是挂载事件处理器、触发副作用等等</p>
</blockquote>
<p>优点</p>
<ul>
<li>SEO 友好</li>
<li>用户可以更快看到内容了</li>
</ul>
<p>缺点</p>
<ul>
<li>部署环境要求。需要 Nodejs 等 JavaScript 服务端运行环境</li>
<li>需要包含完整的 JavaScript 客户端渲染程序，<code>TTI</code> 还有改善空间</li>
</ul>
<p><br><br><br><br><br><br><br></p>
<h2 id="ssg-静态生成"><a href="#ssg-静态生成" class="headerlink" title="SSG - 静态生成"></a>SSG - 静态生成</h2><p><img src="/images/render-patterns/Untitled%204.png" alt="Untitled"></p>
<p>对于完全静态的页面，比如博客，公司主页等等，也可以使用 SSG 静态渲染。</p>
<p>和 SSR 的区别是，SSG 是在<code>构建时</code>渲染的。</p>
<p>和 CSR 一样，因为是静态的，所以在服务端不需要渲染运行时，部署在静态服务器就行了。</p>
<p>VuePress、VitePress、Gatsby、Docusaurus 这些框架都属于 SSG 的范畴。</p>
<p><br><br><br></p>
<p>优点</p>
<ul>
<li>相比 SSR, 因为不需要服务端运行时、数据拉取，TTFB/FCP 等都会提前。</li>
</ul>
<p>缺点</p>
<ul>
<li>和 SSR 一样，也有客户端渲染程序、需要进行 Hydrate。<br>对于<code>内容为中心</code>的站点来说，实际上并不需要太多交互，客户端程序还有较大压缩的空间。</li>
<li>在构建时渲染，如果内容变更，需要重新构建，比较麻烦</li>
</ul>
<p><br><br><br><br><br><br><br></p>
<h2 id="isg-增量静态生成"><a href="#isg-增量静态生成" class="headerlink" title="ISG - 增量静态生成"></a>ISG - 增量静态生成</h2><p><img src="/images/render-patterns/Untitled%205.png" alt="Untitled"></p>
<p>ISG 是 SSG 的升级版。解决 SSG 内容变更繁琐问题。</p>
<p>ISG 依旧会在构建时预渲染页面，但是这里多出了一个<code>服务端运行时</code>，这个运行时会按照一定的过期/刷新策略(通常会使用 <strong><a href="https://web.dev/stale-while-revalidate/" target="_blank" rel="noopener">stale-while-revalidate</a></strong> )来重新生成页面。</p>
<p><br><br><br><br><br><br><br></p>
<h2 id="progressive-hydration-渐进水合"><a href="#progressive-hydration-渐进水合" class="headerlink" title="Progressive Hydration - 渐进水合"></a>Progressive Hydration - 渐进水合</h2><p><img src="/images/render-patterns/Untitled%206.png" alt="Untitled"></p>
<p>上文提到，常规的 SSR 通常需要完整加载客户端程序(上图的 bundle.js)，水合之后才能得到可交互页面，这就导致 <code>TTI</code> 会偏晚。</p>
<p>最直接的解决办法就是压缩客户端程序的体积。那么自然会想到使用<code>代码分割</code>(code splitting)技术。<br><code>渐进式水合 （Progressive Hydration ）</code> 就是这么来的。</p>
<p>如上图，我们使用<code>代码分割</code>的方式，将 Foo、Bar 抽取为<code>异步组件</code>，抽取后<code>主包</code>的体积下降了，<code>TTI</code> 就可以提前了。</p>
<p>而 Foo、Bar 可以按照一定的策略来按需加载和水合，比如在视口可见时、浏览器空闲时，或者交给 <code>React Concurrent Mode</code> 根据交互的优先级来加载。</p>
<p>React 18 官方支持了渐进式水合（官方叫 <code>Selective Hydration</code>）。</p>
<p>要深入了解 Progress Hydration, 可以看这个<a href="https://www.youtube.com/watch?v=k-A2VfuUROg&amp;t=960s" target="_blank" rel="noopener">视频</a>。</p>
<p><br><br><br><br><br></p>
<h2 id="ssr-with-streaming-流式-ssr"><a href="#ssr-with-streaming-流式-ssr" class="headerlink" title="SSR with streaming - 流式 SSR"></a>SSR with streaming - 流式 SSR</h2><p><img src="/images/render-patterns/Untitled%207.png" alt="Untitled"></p>
<p>这个很好理解。尤其是在最近 <code>ChatGPT</code> 这么火。ChatGPT API 有两种响应模式：普通响应、流式响应</p>
<ul>
<li><a href="https://react.dev/reference/react-dom/server/renderToString" target="_blank" rel="noopener">renderToString</a> → 普通响应。即 SSR 会等待完整的 HTML 渲染完毕后，才给客户端发送第一个字节。</li>
<li><a href="https://react.dev/reference/react-dom/server/renderToNodeStream" target="_blank" rel="noopener">renderToNodeStream</a> → 流式响应。渲染多少，就发送多少。就像 ChatGPT 聊天消息一样，一个字一个字的蹦，尽管接收完整消息的时间可能差不多，用户体验却相差甚远。</li>
</ul>
<p>浏览器能够很好地处理 HTML 流，快速地将内容呈现给用户，而不是白屏干等。</p>
<p>下面这张图可以更直观感受两者区别：</p>
<p><img src="/images/render-patterns/Untitled%208.png" alt="来源：[https://mxstbr.com/thoughts/streaming-ssr/](https://mxstbr.com/thoughts/streaming-ssr/)"></p>
<p>来源：<a href="https://mxstbr.com/thoughts/streaming-ssr/" target="_blank" rel="noopener">https://mxstbr.com/thoughts/streaming-ssr/</a></p>
<p>对于常规的流式 SSR，优化效果可能没有我们想象的那么明显。<strong>因为框架还是得等数据拉取完成之后才能开始渲染</strong>。因此，除非是比较复杂、长序列的 HTML 树，至上而下需要较长时间的渲染，否则效果并不明显。</p>
<p><br><br><br></p>
<p>优点</p>
<ul>
<li>相比普通响应，流式响应可以提前 TTFB 和 FCP, 浏览器不用空转等待，可以连续绘制。</li>
</ul>
<p>缺点</p>
<ul>
<li><strong>数据拉取是 TTFB/FCP 的主要阻塞原因。为了解决这个问题，下文的 <code>Selective Hydration</code> 如何巧妙地解决这个问题。</strong></li>
</ul>
<p><br><br><br><br><br></p>
<h2 id="selective-hydration-选择性水合"><a href="#selective-hydration-选择性水合" class="headerlink" title="Selective Hydration - 选择性水合"></a>Selective Hydration - 选择性水合</h2><p><img src="/images/render-patterns/Untitled%209.png" alt="Untitled"></p>
<p><code>选择性水合（Progressive Hydration）</code> 是 <code>渐进式水合(Progressive Hydration)</code> 和 <code>流式SSR(SSR with Streaming)</code> 的升级版。<strong>主要通过选择性地跳过‘<code>慢组件</code>’，避免阻塞，来实现更快的 HTML 输出， 从而让流式响应发挥应有的作用。</strong></p>
<blockquote>
<p><code>慢组件</code>通常指的是：需要异步获取数据、体积较大、或者是计算量比较复杂的组件。</p>
</blockquote>
<p>比较典型的<code>慢组件</code>是异步数据获取的组件, 如下图，未开启 Selective Hydration 的情况，会等待所有异步任务完成后才开始输出，而 Selective Hydration 可以跳过这些组件，等待它们就绪后，继续输出。</p>
<p><img src="/images/render-patterns/Untitled%2010.png" alt="Untitled"></p>
<p>我们可以在最新的 Next.js(当前是 13.4) 演示一下。</p>
<details><br> <summary>没有开启 Selective Hydration 的 Demo:</summary><br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function delay(time: number) &#123;</span><br><span class="line">  return new Promise((resolve) =&gt; setTimeout(resolve, time))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取关键数据</span><br><span class="line"> */</span><br><span class="line">function getCrucialData() &#123;</span><br><span class="line">  return delay(1000).then(() =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      data: Math.random(),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getData(time: number) &#123;</span><br><span class="line">  return delay(time).then(() =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      data: Math.random(),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Foo = async () =&gt; &#123;</span><br><span class="line">  const data = await getData(1000)</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;foo: &#123;data.data&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Bar = async () =&gt; &#123;</span><br><span class="line">  const data = await getData(2000)</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;bar: &#123;data.data&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 页面 🔴</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">export default async function WithoutSelective() &#123;</span><br><span class="line">  // 获取关键数据</span><br><span class="line">  const crucialData = await getCrucialData()</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Without Selective&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;This page is rendered without Selective Hydration.&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;crucial data: &#123;crucialData.data&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Foo&gt;&lt;/Foo&gt;</span><br><span class="line">      &lt;Bar&gt;&lt;/Bar&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>运行结果：浏览器等待响应的时间为 3s<br><img src="/images/render-patterns/Untitled%2011.png" alt="Untitled"><br>即所有<code>服务端组件（Server Component）</code> 就绪后才会有实际的内容输出。<br><br></details>

<p><br><br><br></p>
<p>开启 Selective Hydration 很简单，我们只需要用 Suspend 包裹起来，提示 React 这可能是一个‘慢组件’，可以跳过他：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default async function WithoutSelective() &#123;</span><br><span class="line">  // 获取关键数据</span><br><span class="line">  const crucialData = await getCrucialData()</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Without Selective&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;This page is rendered without Selective Hydration.&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;crucial data: &#123;crucialData.data&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Suspense fallback=&quot;foo loading&quot;&gt;</span><br><span class="line">        &lt;Foo&gt;&lt;/Foo&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">      &lt;Suspense fallback=&quot;bar loading&quot;&gt;</span><br><span class="line">        &lt;Bar&gt;&lt;/Bar&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>现在来看运行结果：</p>
<p><img src="/images/render-patterns/Untitled%2012.png" alt="Untitled"></p>
<p>明显 TTFB 提前了！但是完整的请求时间没变。</p>
<p><br></p>
<p>当 Foo 和 Bar 就绪后，Next.js 会将渲染结果写入流中。怎么做到的？</p>
<p><br></p>
<p>看一眼 HTML 就知道了：</p>
<p><img src="/images/render-patterns/Untitled%2013.png" alt="Untitled"></p>
<p>对于<code>慢组件</code>，React 会先渲染 Suspend 的 fallback 内容，并留一个插槽。</p>
<p>继续往下看，可以看到 Foo、Bar 的渲染结果：</p>
<p><img src="/images/render-patterns/Untitled%2014.png" alt="Untitled"></p>
<p>接着将渲染结果替换掉插槽。用于后续的水合。</p>
<p><br><br><br><br><br></p>
<p>总之，在服务端，Selective Hydration 在 SSR With Streaming 的基础上，通过选择性地跳过一些低优先级的慢组件来优化了 TTFB(主要的，相对于 FCP 等指标也优化了)，更快地向用户呈现页面。</p>
<p>在客户端 Selective Hydration 的运行过程同 Progressive Hydration 。</p>
<p>关于 Selective Hydration 细节，可以阅读以下文章：</p>
<ul>
<li><a href="https://github.com/reactwg/react-18/discussions/130" target="_blank" rel="noopener">New in 18: Selective Hydration</a></li>
<li><a href="https://github.com/reactwg/react-18/discussions/37" target="_blank" rel="noopener">New Suspense SSR Architecture in React 18</a></li>
</ul>
<p><br><br><br><br><br><br><br></p>
<h2 id="islands-architecture-岛屿架构"><a href="#islands-architecture-岛屿架构" class="headerlink" title="Islands Architecture - 岛屿架构"></a>Islands Architecture - 岛屿架构</h2><p><img src="/images/render-patterns/Untitled%2015.png" alt="Untitled"></p>
<p>近两年，<strong>去 JavaScript 成为一波小趋势</strong>，这其中的典型代表是 <code>Islands Architecture</code> (岛屿架构)和 <code>React Server Component</code>(RSC, React 服务端组件)。</p>
<p>它们主张是：<strong>在服务端渲染，然后去掉不必要 JavaScript</strong></p>
<p>岛屿架构的主要代表是 <code>Astro</code>。如上图，Astro 在服务端渲染后，<strong>默认情况下，在客户端侧没有客户端程序和水合的过程。而对于需要 JavaScript 增强，实现动态交互的组件，需要显式标记为岛屿。</strong></p>
<p><br></p>
<p>这有点类似 Progressive Hydration 的意思。但是还是有很大的差别：</p>
<ul>
<li>岛屿是在<code>去 JavaScript</code> 这个背景下的交互增强手段。按 Astro 解释是： 你可以将‘岛屿’想象成在一片由<em>静态（不可交互）的 HTML</em> 页面中的<em>动态岛屿</em></li>
<li>每个岛屿都是独立加载、局部水合。而 Progressive Hydration 是整棵树水合的分支，只不过延后了。</li>
<li>岛屿可以框架无关。</li>
</ul>
<p><br></p>
<p>去 JavaScript 后，可以缓解典型的 SSR <code>TTI</code> 问题。<strong>但是岛屿架构并不能通吃所有的场景，最擅长的是”内容为中心“的站点，即当静态的页面比重远高于动态比重时，去 JavaScript 的收益才是显著的。</strong></p>
<p><br><br><br><br><br></p>
<h2 id="react-server-component-react-服务端组件"><a href="#react-server-component-react-服务端组件" class="headerlink" title="React Server Component - React 服务端组件"></a>React Server Component - React 服务端组件</h2><p><img src="/images/render-patterns/Untitled%2016.png" alt="Untitled"></p>
<p>在笔者看来，<code>React Server Component(RSC)</code> 本质上和岛屿架构的目的是一样的，都是去 JavaScript。只是实现的手段不同。</p>
<p><br></p>
<p>这是 Next.js 官方文档的示例图：和岛屿架构类似，对于静态的内容推荐使用 <code>Server Component (SC),</code> 而需要交互增强的，可以使用 <code>Client Component (CC)</code>。</p>
<p><img src="/images/render-patterns/Untitled%2017.png" alt="Untitled"></p>
<p><br></p>
<p>顾名思义，RSC <strong>就是只能在服务端运行的组件</strong>。下面简单对比一下两者的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>Server Component</th>
<th>Client Component</th>
</tr>
</thead>
<tbody>
<tr>
<td>运行环境</td>
<td>服务端</td>
<td>- 服务端 + 客户端</td>
</tr>
<tr>
<td>- 仅客户端</td>
</tr>
<tr>
<td>JavaScript</td>
<td>服务端组件依赖的相关程序对客户端不可见。</td>
</tr>
<tr>
<td>在这里实现了 ‘去 JavaScript’</td>
<td>需要打包分发给客户端</td>
</tr>
<tr>
<td>水合</td>
<td>不需要水合</td>
<td>需要水合</td>
</tr>
<tr>
<td>支持 async</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>支持状态(state, context)</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>支持事件、副作用</td>
<td>N</td>
<td>Y</td>
</tr>
</tbody>
</table>
<blockquote>
<p>RSC 优点类似 React Hooks 出来之前的<a href="https://web.archive.org/web/20170621181013/https://facebook.github.io/react/docs/components-and-props.html" target="_blank" rel="noopener">函数组件</a>: 就是一个普通的函数，不能使用 hooks，没有状态，只会被调用一次。</p>
</blockquote>
<p>你可以通过 <a href="https://nextjs.org/docs/getting-started/react-essentials" target="_blank" rel="noopener">Next.js 的文档</a>，深入学习 RSC。React 官方的<a href="https://github.com/reactwg/server-components/discussions" target="_blank" rel="noopener">讨论组</a>也是不错的一手学习场地。</p>
<p><br><br><br></p>
<p><strong>那么相比岛屿架构呢？</strong></p>
<p>优点</p>
<ul>
<li>Server Component 和 Client Component 都是 React 框架的组件，尽管有些区别，但是心智模型是统一的。</li>
<li>React Server Component 是 React 框架下一体化的原生解决方案，支持和 Selective Hydration 配合使用。岛屿架构只是一个架构模式。</li>
<li>可以进行更细粒度和更灵活的组合。</li>
</ul>
<p>缺点</p>
<ul>
<li>Server Component 和 Client Component 还是有较大差别，在组合、通信上也有较多限制，需要开发者规划好服务端和客户端的边界。初期有一定上手门槛。<br>当然，Islands 可能也有类似的问题。</li>
</ul>
<p><br><br><br><br><br></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文篇幅较长，我给大家整理了这些渲染模式的发展历程和关系脉络</p>
<p><img src="/images/render-patterns/Untitled%2018.png" alt="Untitled"></p>
<p>任何技术的迭代都是有其动机和脉络。不推荐大家面向热度编程，大部分情况下，做到‘知其然，也知其所以然’，就足够了。</p>
<p><br><br><br><br><br></p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a href="https://www.patterns.dev/posts/react-selective-hydration" target="_blank" rel="noopener">Pattern dev</a></li>
<li><a href="https://nextjs.org/docs/getting-started/react-essentials" target="_blank" rel="noopener">Next.js</a></li>
<li><a href="https://nextjs.org/docs/pages/building-your-application/data-fetching/incremental-static-regeneration" target="_blank" rel="noopener">Next.js Incremental Static RegenerationExamples</a></li>
<li><a href="https://github.com/reactwg/server-components/discussions" target="_blank" rel="noopener">reactwg/<strong>server-components</strong></a></li>
<li><strong><a href="https://dev.to/this-is-learning/is-0kb-of-javascript-in-your-future-48og" target="_blank" rel="noopener">Is 0kb of JavaScript in your Future?</a></strong></li>
<li><a href="https://jasonformat.com/islands-architecture/" target="_blank" rel="noopener">Islands Architecture</a></li>
</ul>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#csr-客户端渲染"><span class="toc-number">1.</span> <span class="toc-text">CSR - 客户端渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ssr-服务端渲染"><span class="toc-number">2.</span> <span class="toc-text">SSR - 服务端渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ssg-静态生成"><span class="toc-number">3.</span> <span class="toc-text">SSG - 静态生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#isg-增量静态生成"><span class="toc-number">4.</span> <span class="toc-text">ISG - 增量静态生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#progressive-hydration-渐进水合"><span class="toc-number">5.</span> <span class="toc-text">Progressive Hydration - 渐进水合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ssr-with-streaming-流式-ssr"><span class="toc-number">6.</span> <span class="toc-text">SSR with streaming - 流式 SSR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#selective-hydration-选择性水合"><span class="toc-number">7.</span> <span class="toc-text">Selective Hydration - 选择性水合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#islands-architecture-岛屿架构"><span class="toc-number">8.</span> <span class="toc-text">Islands Architecture - 岛屿架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#react-server-component-react-服务端组件"><span class="toc-number">9.</span> <span class="toc-text">React Server Component - React 服务端组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">10.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展阅读"><span class="toc-number">11.</span> <span class="toc-text">扩展阅读</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2023/06/05/render-patterns/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2023/06/05/render-patterns/&text=现代前端框架的渲染模式"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2023/06/05/render-patterns/&title=现代前端框架的渲染模式"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2023/06/05/render-patterns/&is_video=false&description=现代前端框架的渲染模式"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=现代前端框架的渲染模式&body=Check out this article: https://bobi.ink/2023/06/05/render-patterns/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2023/06/05/render-patterns/&title=现代前端框架的渲染模式"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2023/06/05/render-patterns/&title=现代前端框架的渲染模式"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2023/06/05/render-patterns/&title=现代前端框架的渲染模式"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2023/06/05/render-patterns/&title=现代前端框架的渲染模式"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2023/06/05/render-patterns/&name=现代前端框架的渲染模式&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2023 Ivan
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-44571525-2', 'auto');
        ga('send', 'pageview');
    </script>


    <!-- Disqus Comments -->
    <script type="text/javascript">
        var disqus_shortname = 'bobi-ink';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


