<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="写这篇文章的动机可以追溯到 3 年前， 我发现很多身边开发者并没有正确地使用 React Hooks, 所以我觉得应该把我的开发经验和思维整理下来。 尽管本文主要从 Vue 的角度出发，但是很多思维也可以用在 React Hooks 上。 从广义的的“响应式编程(Reactive Programing)” 上看，Vue、React、Rxjs 等框架都属于这个范畴。而狭义的响应式编程通常指的是 r">
<meta name="keywords" content="Blog,FrontEnd,React,Javascript,Typescript">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue 开发的正确姿势：响应式编程思维">
<meta property="og:url" content="https://bobi.ink/2023/07/09/vue-with-rx/index.html">
<meta property="og:site_name" content="Bobi.ink">
<meta property="og:description" content="写这篇文章的动机可以追溯到 3 年前， 我发现很多身边开发者并没有正确地使用 React Hooks, 所以我觉得应该把我的开发经验和思维整理下来。 尽管本文主要从 Vue 的角度出发，但是很多思维也可以用在 React Hooks 上。 从广义的的“响应式编程(Reactive Programing)” 上看，Vue、React、Rxjs 等框架都属于这个范畴。而狭义的响应式编程通常指的是 r">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://bobi.ink/images/vue-with-rx/Untitled.png">
<meta property="og:image" content="https://bobi.ink/images/vue-with-rx/Untitled%201.png">
<meta property="og:updated_time" content="2023-07-13T02:01:44.044Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vue 开发的正确姿势：响应式编程思维">
<meta name="twitter:description" content="写这篇文章的动机可以追溯到 3 年前， 我发现很多身边开发者并没有正确地使用 React Hooks, 所以我觉得应该把我的开发经验和思维整理下来。 尽管本文主要从 Vue 的角度出发，但是很多思维也可以用在 React Hooks 上。 从广义的的“响应式编程(Reactive Programing)” 上看，Vue、React、Rxjs 等框架都属于这个范畴。而狭义的响应式编程通常指的是 r">
<meta name="twitter:image" content="https://bobi.ink/images/vue-with-rx/Untitled.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Vue 开发的正确姿势：响应式编程思维</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2023/07/13/microfrontend/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2023/07/02/fe-view-future/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2023/07/09/vue-with-rx/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2023/07/09/vue-with-rx/&text=Vue 开发的正确姿势：响应式编程思维"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2023/07/09/vue-with-rx/&title=Vue 开发的正确姿势：响应式编程思维"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2023/07/09/vue-with-rx/&is_video=false&description=Vue 开发的正确姿势：响应式编程思维"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Vue 开发的正确姿势：响应式编程思维&body=Check out this article: https://bobi.ink/2023/07/09/vue-with-rx/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2023/07/09/vue-with-rx/&title=Vue 开发的正确姿势：响应式编程思维"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2023/07/09/vue-with-rx/&title=Vue 开发的正确姿势：响应式编程思维"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2023/07/09/vue-with-rx/&title=Vue 开发的正确姿势：响应式编程思维"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2023/07/09/vue-with-rx/&title=Vue 开发的正确姿势：响应式编程思维"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2023/07/09/vue-with-rx/&name=Vue 开发的正确姿势：响应式编程思维&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#简述-rxjs"><span class="toc-number">1.</span> <span class="toc-text">简述 RxJS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为什么建议你去学习-rxjs？"><span class="toc-number">2.</span> <span class="toc-text">为什么建议你去学习 rxjs？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rxjs-和-vue-reactivity-data-有什么关联？"><span class="toc-number">3.</span> <span class="toc-text">RxJS 和 Vue Reactivity Data 有什么关联？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#看看你代码中的坏味道"><span class="toc-number">4.</span> <span class="toc-text">看看你代码中的坏味道</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实践"><span class="toc-number">5.</span> <span class="toc-text">实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分页"><span class="toc-number">5.1.</span> <span class="toc-text">分页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实时搜索"><span class="toc-number">5.2.</span> <span class="toc-text">实时搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定时刷新"><span class="toc-number">5.3.</span> <span class="toc-text">定时刷新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#省市区选择器"><span class="toc-number">5.4.</span> <span class="toc-text">省市区选择器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#原则和建议"><span class="toc-number">6.</span> <span class="toc-text">原则和建议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩展阅读"><span class="toc-number">7.</span> <span class="toc-text">扩展阅读</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Vue 开发的正确姿势：响应式编程思维
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Bobi.ink</span>
      </span>
      
    <div class="postdate">
        <time datetime="2023-07-08T16:00:00.000Z" itemprop="datePublished">2023-07-09</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p><img src="/images/vue-with-rx/Untitled.png" alt="Untitled"></p>
<p>写这篇文章的动机可以追溯到 3 年前， 我发现很多身边开发者并没有正确地使用 React Hooks, 所以我觉得应该把我的开发经验和思维整理下来。</p>
<p>尽管本文主要从 Vue 的角度出发，但是很多思维也可以用在 React Hooks 上。</p>
<p>从广义的的“<a href="https://en.wikipedia.org/wiki/Reactive_programming" target="_blank" rel="noopener">响应式编程(Reactive Programing)</a>” 上看，Vue、React、Rxjs 等框架都属于这个范畴。而狭义的响应式编程通常指的是 rxjs 这类 “面向数据<a href="https://zh.wikipedia.org/wiki/%E4%B8%B2%E6%B5%81" target="_blank" rel="noopener">串流</a>和变化传播的<a href="https://zh.wikipedia.org/wiki/%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">声明式</a><a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F" target="_blank" rel="noopener">编程范式</a>”</p>
<p>虽然 Vue 也是‘响应式编程’， 但是和 RxJS 是完全不一样的概念，至少RxJS 是有范式约束的，不管是编码上还是思维上面，我们都可以感受到它的强力约束，这和我们惯用的命令式编程差别很大。这也导致了它的学习门槛比较高。</p>
<p>为什么要牵扯到 RxJS 呢？因为它的思维对我们写好 Vue 代码很有帮助！</p>
<p><br><br><br></p>
<h1 id="简述-rxjs"><a href="#简述-rxjs" class="headerlink" title="简述 RxJS"></a>简述 RxJS</h1><p>先祭上<a href="https://zhuanlan.zhihu.com/p/25383159" target="_blank" rel="noopener">徐飞的买房的例子</a>，感受一下 RxJS 的魅力：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//           工资周期  ———&gt;  工资</span></span><br><span class="line"><span class="comment">//                            ↓</span></span><br><span class="line"><span class="comment">// 房租周期  ———&gt;  租金  ———&gt;  收入  ———&gt;  现金 </span></span><br><span class="line"><span class="comment">//                ↑           ↓ </span></span><br><span class="line"><span class="comment">//             房子数量 &lt;——— 新购房</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 挣钱是为了买房，买房是为了赚钱</span></span><br><span class="line"><span class="keyword">const</span> house$ = <span class="keyword">new</span> Subject()</span><br><span class="line"><span class="keyword">const</span> houseCount$ = house$.scan(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> acc + num, <span class="number">0</span>).startWith(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工资始终不涨</span></span><br><span class="line"><span class="keyword">const</span> salary$ = Observable.interval(<span class="number">100</span>).mapTo(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> rent$ = Observable.interval(<span class="number">3000</span>)</span><br><span class="line">  .withLatestFrom(houseCount$)</span><br><span class="line">  .map(<span class="function"><span class="params">arr</span> =&gt;</span> arr[<span class="number">1</span>] * <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一买了房，就没现金了……</span></span><br><span class="line"><span class="keyword">const</span> income$ = Observable.merge(salary$, rent$)</span><br><span class="line"><span class="keyword">const</span> cash$ = income$</span><br><span class="line">  .scan(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newSum = acc + num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newHouse = <span class="built_in">Math</span>.floor(newSum / <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">if</span> (newHouse &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      house$.next(newHouse)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newSum % <span class="number">100</span></span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// houseCount$.subscribe(num =&gt; console.log(`houseCount: $&#123;num&#125;`))</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>如果用几个关键字来描述 RxJS 的话，我想应该是：</p>
<ul>
<li>事件：观察者模式</li>
<li>序列：迭代器模式</li>
<li>流：管道模式</li>
</ul>
<p>这几个模式我们分开去理解都没啥特别，比如 Vue 的 reactivity 数据就是观察者模式；JavaScript 的 for…of/generator 就是迭代器模式；数组的map/filter/reduce, shell 命令都符合管道模式。</p>
<p>RxJS  的牛逼之处就是把这三个模式优雅地组合起来了。它把事件抽象成为类似’数组’一样的序列，然后提供了丰富的操作符来变换这个序列，就像操作数组一样自然，最后通过管道将这些操作符组合起来实现复杂的功能变换。</p>
<p><br><br><br></p>
<h1 id="为什么建议你去学习-rxjs？"><a href="#为什么建议你去学习-rxjs？" class="headerlink" title="为什么建议你去学习 rxjs？"></a>为什么建议你去学习 rxjs？</h1><p>至少它可以帮助你写好 Vue 代码。它可以帮你写出更简洁、结构更清晰、低耦合、更容易测试的代码，这些代码更能体现原本的交互逻辑或业务流程。</p>
<p>相信我，尝试换个思路，可能原本复杂的实现，会变得更加简单。</p>
<p><br></p>
<h1 id="rxjs-和-vue-reactivity-data-有什么关联？"><a href="#rxjs-和-vue-reactivity-data-有什么关联？" class="headerlink" title="RxJS 和 Vue Reactivity Data 有什么关联？"></a>RxJS 和 Vue Reactivity Data 有什么关联？</h1><p>一些和 RxJS 相似的概念</p>
<ul>
<li><p>响应式数据。我们用 ref 或reactive 创建的数据，可以等似于 RxJS 的 Observable。只不过响应式数据并不像 rxjs 有显式的事件发布和订阅过程，也不存在事件流(序列)。</p>
<p>  <strong>我们可以认为Vue 数据的每次变更就相当于 RxJS 发出每次事件</strong>。</p>
</li>
<li><p>衍生数据。我们会使用 computed 来衍生新的数据，等似于 RxJS 用操作符衍生出新的 Observable。<strong>即 Vue 数据衍生数据，RxJS 事件衍生事件</strong></p>
</li>
<li>副作用。在 Vue 中， watch/watcheffects/render 相当于 RxJS 的 subscribe，RxJS 的数据流的终点通常也是副作用处理，比如将数据渲染到页面上。</li>
</ul>
<p><br></p>
<p>RxJS 的很多东西并不能直接套用过来，但思想和原则是可以复用的。</p>
<p>其中一个重要的思想就是：管道变换。这是一种思维方式的转变，在以往的编程设计中，我们更多操心的是类、模块、数据结构和算法。而管道变换我们会把程序视作从输入到输出的一个变换去构思:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># “列出目录树中最长的五个文”</span></span><br><span class="line">find . -<span class="built_in">type</span> f | xargs wc -l | sort -n | tail -5</span><br></pre></td></tr></table></figure>
<p>不要把数据看作是遍布整个系统的小数据池，而要把数据看作是一条浩浩荡荡的河流。</p>
<p>另一方面，编写 RxJS 代码一些原则，对我们编写 Vue 代码也大有裨益：</p>
<ul>
<li>避免副作用。RxJS 的操作符应该是没有副作用的函数，只关注输入的数据，然后对数据进行变换，传递给下一个。</li>
<li><p>避免外部状态/缓存状态。外部状态也是副作用的一种，单独拎出来讲，是因为我们在 Vue 中创建外部状态太容易了，而 RxJS 则相对来说麻烦一些，毕竟外部状态和事件流显得格格不入。</p>
<p>  在 RxJS 中管道是自包含的， 所有的状态从一个操作器流向下一个操作器，而不需要外部变量：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Observable.from([1, 2, 3, 4, 5, 6, 7, 8])</span><br><span class="line">  .filter(val =&gt; val % 2)</span><br><span class="line">  .map(val =&gt; val * 10);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br><br><br></p>
<h1 id="看看你代码中的坏味道"><a href="#看看你代码中的坏味道" class="headerlink" title="看看你代码中的坏味道"></a>看看你代码中的坏味道</h1><p>看看你的 Vue 代码有没有这些现象，如果存在这些坏味道，说明你并没有正确使用 Vue 的 Reactivity API。</p>
<ul>
<li>创建了大量的缓存状态。比如 sum，avg，temp…</li>
<li>使用了很多 <code>watch</code> / <code>watchEffect</code>…</li>
<li>冗长的 <code>setup</code> 方法或者组件代码</li>
<li>状态被随意修改，修改不属于管辖范围内的状态</li>
<li>…</li>
</ul>
<p><br><br><br></p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>先从简单的场景开始: 分页请求。</p>
<p>❌ 常规的做法：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = reactive(&#123;&#125;) <span class="comment">// 查询参数</span></span><br><span class="line"><span class="keyword">const</span> pagination = reactive(&#123;<span class="attr">pageNo</span>: <span class="number">1</span>, <span class="attr">pageSize</span>: <span class="number">10</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> total = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> list = ref([])</span><br><span class="line"><span class="keyword">const</span> loading = ref(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">const</span> error = ref()</span><br><span class="line"></span><br><span class="line">watch([query, pagination], <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    error.value = <span class="literal">undefined</span></span><br><span class="line">    loading.value = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> request(<span class="string">`/something?<span class="subst">$&#123;qs(&#123;...query, ...pagination&#125;</span>)&#125;`</span>)</span><br><span class="line">    total.value = data.total</span><br><span class="line">    list.value = data.list</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err)&#123;</span><br><span class="line">    error.value = err</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    loading.value = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;<span class="attr">immediate</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>✅ 推荐做法：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = reactive(&#123;&#125;) <span class="comment">// 查询参数</span></span><br><span class="line"><span class="keyword">const</span> pagination = reactive(&#123;<span class="attr">pageNo</span>: <span class="number">1</span>, <span class="attr">pageSize</span>: <span class="number">10</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// data 包含了 list、loading、error、total 等信息</span></span><br><span class="line"><span class="keyword">const</span> data = useRequest(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`/something?<span class="subst">$&#123;qs(&#123;...query, ...pagination&#125;</span>)&#125;`</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>自然地表达 query/pagination → data 的数据流。useRequest 更像 computed 的语义，从一个数据衍生出新的数据，不管它是同步的还是异步的。</p>
<p>  而使用 watch 会中断数据的流动，并且我们需要创建冗余缓存状态，代码看起来会比较混乱。想象一下复杂的页面，我们可能会有很多复杂、联动的异步请求，情况就会慢慢失控。</p>
</li>
<li><p><code>useRequest</code> 是啥？它封装了网络请求， useRequest 可以基于 <a href="https://docs-swrv.netlify.app/guide.html" target="_blank" rel="noopener">swrv</a>(swr 在 Vue 下的实现, 非官方)、或者VueUse 里面的 <a href="https://vueuse.org/core/computedAsync/" target="_blank" rel="noopener">computedAsync</a>、<a href="https://vueuse.org/core/useFetch/" target="_blank" rel="noopener">useFetch</a> 来封装。</p>
<p>  useRequest 类似于 RxJS 的 switchMap，当新的发起新的请求时，应该将旧的请求抛弃。</p>
<p>  笔者推荐使用 swr 这类库去处理网络请求，相比直接用 watch, 这类库支持数据缓存、Stale-while-revalidate 更新、还有并发竞态的处理等等。</p>
</li>
</ul>
<p><br><br><br></p>
<h2 id="实时搜索"><a href="#实时搜索" class="headerlink" title="实时搜索"></a>实时搜索</h2><p>第二个例子也比较简单，用户输入文本，我们debounce 发起数据请求</p>
<p>⚠️ 常规的实现：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = ref(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法一：在事件处理器加 debounce</span></span><br><span class="line"><span class="comment">// 如果这么实现，双向绑定到表单可能有卡顿问题</span></span><br><span class="line"><span class="keyword">const</span> handleQueryChange = debounce(<span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">  query.value = evt.target.value</span><br><span class="line">&#125;, <span class="number">800</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = ref()</span><br><span class="line"></span><br><span class="line">watch(query, <span class="keyword">async</span> (q) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetchData(q)</span><br><span class="line">  <span class="comment">// <span class="doctag">FIXME:</span> 需要处理竞态问题</span></span><br><span class="line">  data.value = res</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 法二，在 watch 回调或者 fetchData 加上 debounce</span></span><br><span class="line"><span class="keyword">const</span> handleQueryChange = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">  query.value = evt.target.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">watch(query, debounce(<span class="keyword">async</span> (q) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetchData(q)</span><br><span class="line">  data.value = res</span><br><span class="line">&#125;, <span class="number">800</span>))</span><br></pre></td></tr></table></figure>
<p>RxJS  实现:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> searchInput$ = fromEvent(searchInput, <span class="string">'input'</span>).pipe(</span><br><span class="line">  <span class="comment">// 使用 debounceTime 进行防抖处理</span></span><br><span class="line">  debounceTime(<span class="number">800</span>),</span><br><span class="line">  <span class="comment">// 使用 map 将事件转换为输入框的值</span></span><br><span class="line">  map(<span class="function"><span class="params">event</span> =&gt;</span> event.target.value),</span><br><span class="line">  <span class="comment">// 使用 distinctUntilChanged 进行去重处理</span></span><br><span class="line">  distinctUntilChanged(),</span><br><span class="line">  <span class="comment">// 使用 switchMap 进行请求并转换为列表数据</span></span><br><span class="line">  switchMap(<span class="function"><span class="params">keyword</span> =&gt;</span> <span class="keyword">from</span>(searchList(keyword)))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>我们使用 Vue 也可以表达类似的流程：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = ref(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">const</span> debouncedQuery = refDebounced(input, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = useRequest(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`/something?<span class="subst">$&#123;qs(&#123;query: query.value&#125;</span>)&#125;`</span>)</span><br></pre></td></tr></table></figure>
<p>refDebounce 来源于 VueUse，可以 “Debounce” 指定输入 ref 值的变动。</p>
<p><br><br><br></p>
<h2 id="定时刷新"><a href="#定时刷新" class="headerlink" title="定时刷新"></a>定时刷新</h2><p>假设我们要在上面的分页基础上实现定时轮询的功能：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = reactive(&#123;&#125;) <span class="comment">// 查询参数</span></span><br><span class="line"><span class="keyword">const</span> tick = useInterval(<span class="number">5000</span>)</span><br><span class="line"><span class="keyword">const</span> pagination = reactive(&#123;<span class="attr">pageNo</span>: <span class="number">1</span>, <span class="attr">pageSize</span>: <span class="number">10</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// data 包含了 list、loading、error、total 等信息</span></span><br><span class="line"><span class="keyword">const</span> data = useRequest(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`/something?<span class="subst">$&#123;qs(&#123;...query, ...pagination, _t: tick.value&#125;</span>)&#125;`</span>)</span><br></pre></td></tr></table></figure>
<p>我们看到上面的流程很自然。</p>
<p>现在加大难度，如果要在特定条件下终止呢？</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = reactive(&#123;&#125;) <span class="comment">// 查询参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认关闭</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">counter</span>: tick, pause, resume&#125; = useInterval(<span class="number">5000</span>, &#123;<span class="attr">controls</span>: <span class="literal">true</span>, <span class="attr">immediate</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> pagination = reactive(&#123;<span class="attr">pageNo</span>: <span class="number">1</span>, <span class="attr">pageSize</span>: <span class="number">10</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// data 包含了 list、loading、error、total 等信息</span></span><br><span class="line"><span class="keyword">const</span> data = useRequest(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`/something?<span class="subst">$&#123;qs(&#123;...query, ...pagination, _t: tick.value&#125;</span>)&#125;`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否轮询</span></span><br><span class="line"><span class="keyword">const</span> shouldPoll = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> data.data?.some(<span class="function"><span class="params">i</span> =&gt;</span> i.expired &gt; <span class="built_in">Date</span>.now())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按条件开启轮训</span></span><br><span class="line">watch(shoudPoll, (p) =&gt; p ? resume() : pause())</span><br></pre></td></tr></table></figure>
<p>如果用 RxJS 来实现的话，代码大概如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> interval$ = interval(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> poll$ = interval$.pipe(</span><br><span class="line">  <span class="comment">// 查询</span></span><br><span class="line">  switchMap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">from</span>(fetchData())),</span><br><span class="line">  share()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stop$ = poll$.pipe(</span><br><span class="line">  <span class="comment">// 终止轮询条件</span></span><br><span class="line">  filter(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i.every(<span class="function"><span class="params">i</span> =&gt;</span> i.expired &lt;= <span class="built_in">Date</span>.now())</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 poll$ 和 stop$ 组合在一起</span></span><br><span class="line">poll$</span><br><span class="line">  .pipe(</span><br><span class="line">    <span class="comment">// 使用 takeUntil 在 stop$ 发送事件后停止轮询</span></span><br><span class="line">    takeUntil(stop$)</span><br><span class="line">  )</span><br><span class="line">  .subscribe(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>因为 RxJS 的 Observable 是惰性的，只有被 subscribe 时才会开始执行，同理停止订阅就会中断执行。</p>
<p>中断执行后，如果要重新发起请求，重新订阅就好了。有点异曲同工之妙吧</p>
<p><br><br><br></p>
<h2 id="省市区选择器"><a href="#省市区选择器" class="headerlink" title="省市区选择器"></a>省市区选择器</h2><p>再来看一个稍微复杂一点的例子，常见的省市区选择器，这是一个典型的数据联动的场景。</p>
<p>我们先来看一个反例吧，我们的选择器需要先选择国家或地区，然后根据它来确定行政区域的划分，接着渲染各级行政区域选择器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default defineComponent(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    modelValue: &#123;</span><br><span class="line">      type: Array as () =&gt; number[],</span><br><span class="line">      default: () =&gt; [],</span><br><span class="line">    &#125;,</span><br><span class="line">    onChange: &#123;</span><br><span class="line">      type: Function,</span><br><span class="line">      default: () =&gt; &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    const isEchoingData = ref(false);</span><br><span class="line">    const regionList = ref&lt;RegionInfoDTO[][]&gt;([]);</span><br><span class="line">    const regionUrl = ref(&apos;&apos;);</span><br><span class="line">    const queryParams = ref(&#123;&#125; as IQueryParams);</span><br><span class="line"></span><br><span class="line">    const selectedRegion = computed&lt;number[]&gt;(&#123;</span><br><span class="line">      get: () =&gt; props.modelValue,</span><br><span class="line">      set: value =&gt; emit(&apos;update:modelValue&apos;, [...value]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const &#123; data: countryList &#125; = useRequest&lt;CountryInfoDTO&gt;(</span><br><span class="line">      () =&gt; `请求国家列表`</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 请求区域列表</span><br><span class="line">    const &#123; data: regionItems &#125; = useRequest&lt;RegionInfoDTO&gt;(() =&gt; regionUrl.value);</span><br><span class="line"></span><br><span class="line">    watch(regionItems, () =&gt; &#123;</span><br><span class="line">      regionList.value[queryParams.value.level] = regionItems.value?.data!;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const countryOptions = computed(() =&gt; &#123;</span><br><span class="line">      return countryList.value?.data.map(i =&gt; &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          label: i.name,</span><br><span class="line">          value: i.id,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    watch(queryParams, async newValue =&gt; &#123;</span><br><span class="line">      if (!Object.keys(newValue).length) return;</span><br><span class="line"></span><br><span class="line">      const query = `&amp;countryId=$&#123;newValue.level ? &apos;&apos; : newValue.value&#125;&amp;parentId=$&#123;</span><br><span class="line">        newValue.level ? newValue.value : &apos;&apos;</span><br><span class="line">      &#125;&amp;level=$&#123;newValue.level + 1&#125;`;</span><br><span class="line">      regionUrl.value = `区域请求路径$&#123;query&#125;`;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    watch(</span><br><span class="line">      props.modelValue,</span><br><span class="line">      async (newValue, oldValue) =&gt; &#123;</span><br><span class="line">        const newLen = newValue.length;</span><br><span class="line">        const oldLen = oldValue?.length ?? 0;</span><br><span class="line"></span><br><span class="line">        if (newLen &amp;&amp; newLen !== oldLen) &#123;</span><br><span class="line">          const index = 0;</span><br><span class="line"></span><br><span class="line">          queryParams.value = &#123; value: newValue[index], level: index &#125;;</span><br><span class="line">          isEchoingData.value = true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; immediate: true &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    watch(</span><br><span class="line">      regionList,</span><br><span class="line">      newVal =&gt; &#123;</span><br><span class="line">        const len = newVal.length;</span><br><span class="line">        const selectedLen = selectedRegion.value.length;</span><br><span class="line"></span><br><span class="line">        if (isEchoingData.value &amp;&amp; selectedLen &gt; len) &#123;</span><br><span class="line">          if (len === selectedLen - 1) return (isEchoingData.value = false);</span><br><span class="line"></span><br><span class="line">          queryParams.value = &#123; value: selectedRegion.value[len], level: len &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; deep: true &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    const onRegionChange = (value: number, level: number) =&gt; &#123;</span><br><span class="line">      selectedRegion.value.splice(level);</span><br><span class="line">      regionList.value.splice(level);</span><br><span class="line">      selectedRegion.value.push(value);</span><br><span class="line"></span><br><span class="line">      const currentRegion = regionList.value[level - 1]?.find(region =&gt; region.id === value);</span><br><span class="line"></span><br><span class="line">      if (!currentRegion?.isLeaf) &#123;</span><br><span class="line">        queryParams.value = &#123; value, level &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      props.onChange?.([...selectedRegion.value], [...selectedRegionNames.value]);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const currentRegionPlaceholder = (index: number) =&gt; &#123;</span><br><span class="line">      return `$&#123;selectedCountry.value?.regionLevelInfos[index]?.name ?? &apos;区域&apos;&#125;`;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const selectedCountry = computed(() =&gt; &#123;</span><br><span class="line">      const selectedCountryId = selectedRegion.value[0];</span><br><span class="line">      const selectedCountry = countryList.value?.data.find(country =&gt; country.id === selectedCountryId);</span><br><span class="line"></span><br><span class="line">      return selectedCountry;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const selectedRegionNames = computed(() =&gt; &#123;</span><br><span class="line">      const names = [];</span><br><span class="line"></span><br><span class="line">      if (selectedCountry.value) &#123;</span><br><span class="line">        names.push(selectedCountry.value.name);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      selectedRegion.value.slice(1).forEach((id, index) =&gt; &#123;</span><br><span class="line">        const region = regionList.value[index]?.find(region =&gt; region.id === id);</span><br><span class="line">        if (region) &#123;</span><br><span class="line">          names.push(region.name);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      return names;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return () =&gt; (</span><br><span class="line">      &lt;FatSpace&gt;</span><br><span class="line">        &lt;ElSelect</span><br><span class="line">          modelValue=&#123;selectedRegion.value[0]&#125;</span><br><span class="line">          placeholder=&quot;请选择国家&quot;</span><br><span class="line">          onChange=&#123;val =&gt; onRegionChange(val, 0)&#125;</span><br><span class="line">          filterable</span><br><span class="line">        &gt;</span><br><span class="line">          &#123;countryOptions.value?.map(country =&gt; (</span><br><span class="line">            &lt;ElOption key=&#123;country.value&#125; label=&#123;country.label&#125; value=&#123;country.value&#125; /&gt;</span><br><span class="line">          ))&#125;</span><br><span class="line">        &lt;/ElSelect&gt;</span><br><span class="line"></span><br><span class="line">        &#123;regionList.value.map((regions, index) =&gt; (</span><br><span class="line">          &lt;ElSelect</span><br><span class="line">            key=&#123;index&#125;</span><br><span class="line">            modelValue=&#123;selectedRegion.value[index + 1]&#125;</span><br><span class="line">            placeholder=&#123;`请选择$&#123;currentRegionPlaceholder(index)&#125;`&#125;</span><br><span class="line">            onChange=&#123;val =&gt; onRegionChange(val, index + 1)&#125;</span><br><span class="line">            filterable</span><br><span class="line">          &gt;</span><br><span class="line">            &#123;regions.map(region =&gt; (</span><br><span class="line">              &lt;ElOption key=&#123;region.id&#125; label=&#123;region.name&#125; value=&#123;region.id&#125; /&gt;</span><br><span class="line">            ))&#125;</span><br><span class="line">          &lt;/ElSelect&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/FatSpace&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>也就 150 行左右的代码，实现的是 <code>国家-国家各种区域</code> 的选择器，比如选择了中国就会有 <code>中国-省-市-区</code> 这样的分级。</p>
<p>读者也没必要读懂这些代码，我看到也头大，你只需要记住，这个充斥着我们上文提到的各种坏味道：过渡依赖 watch、数据流混乱…</p>
<p><img src="/images/vue-with-rx/Untitled%201.png" alt="Untitled"></p>
<p>让我们回归到业务本身，我们为什么需要不恪守这样的联动关系去组织代码呢？</p>
<p>可以的，一个比较重要的技巧就是自顶而下地去分析流程/数据流变换的过程。</p>
<p>首先从国家开始，只有用户选择了指定国家之后，我们才能获取到区域的结构信息(是省/市/区, 还是州/城市，anyway):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const AreaSelect2 = defineComponent(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    // 表单值是数组格式，每一项保存的是区域的 id</span><br><span class="line">    modelValue: Array as PropType&lt;number[]&gt;,</span><br><span class="line">  &#125;,</span><br><span class="line">  emits: [&apos;update:modelValue&apos;],</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    // 🔴 获取国家列表</span><br><span class="line">    const country = useCountryList();</span><br><span class="line"></span><br><span class="line">    // 🔴 计算当前选中的国家，我们从这里拿到行政区域结构</span><br><span class="line">    const currentCountry = computed(() =&gt; &#123;</span><br><span class="line">      return country.data.value?.data?.find(i =&gt; i.id === props.modelValue?.[0]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const handleCountryChange = (value: number) =&gt; &#123;</span><br><span class="line">      if (value !== props.modelValue?.[0]) &#123;</span><br><span class="line">        // 🛑 国家变动后，重置掉后续的数据</span><br><span class="line">        emit(&apos;update:modelValue&apos;, [value]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;ElSelect</span><br><span class="line">            modelValue=&#123;props.modelValue?.[0]&#125;</span><br><span class="line">            placeholder=&quot;请选择国家&quot;</span><br><span class="line">            onUpdate:modelValue=&#123;handleCountryChange&#125;</span><br><span class="line">            filterable</span><br><span class="line">            fitInputWidth</span><br><span class="line">            loading=&#123;country.isValidating.value&#125;</span><br><span class="line">          &gt;</span><br><span class="line">            &#123;country.data.value?.data?.map(i =&gt; &#123;</span><br><span class="line">              return &lt;ElOption key=&#123;i.id&#125; label=&#123;i.name&#125; value=&#123;i.id&#125;&gt;&lt;/ElOption&gt;;</span><br><span class="line">            &#125;)&#125;</span><br><span class="line">          &lt;/ElSelect&gt;</span><br><span class="line">          &#123;/* 此处暂时忽略 */&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>Composition API 的好处是，它让组合和封装变得非常便利。如上面的代码，我们将获取国家的相关逻辑封装成 useCountryList，代码变得更加简洁易读。</li>
<li>避免中间变量。恪守 v-model 单向数据流</li>
</ul>
<p><br></p>
<hr>
<p><br></p>
<p>接着我们根据选中的国家来渲染后续的区域联动。</p>
<p>这里提醒一下读者：“不要吝啬创建组件”</p>
<p>我在  <a href="https://juejin.cn/post/6844903844711759880#heading-2" target="_blank" rel="noopener">React组件设计实践总结04 - 组件的思维</a> 中讲过：</p>
<blockquote>
<p>大部分情况下, 组件表示是一个 UI 对象. 其实组件不单单可以表示 UI, 也可以用来抽象业务对象, 有时候抽象为组件可以巧妙地解决一些问题</p>
</blockquote>
<p>组件这个设计实在太好用了，笔者觉得它体现的更重要的思想是分治，而不是复用。组件一些比较重要的特性是：</p>
<ul>
<li>和函数一样，它是一个封闭的、自包含的单元。父组件不应该操心它，而应该让他自我组织。</li>
<li>组件有状态。这个是和函数不一样的地方</li>
<li><p>组件有生命周期。这就意味着组件可以自己管理和销毁自己的资源，不会泄露出去。</p>
<p>  这是组件和 Hooks 是有本质区别的！我们使用 Hooks 也可以实现一个自我组织的、封闭的、自包含的单元，但是它的生命周期不是它决定的，而是由使用它的宿主组件决定的</p>
</li>
</ul>
<blockquote>
<p>关于这块的详细阐述可以看笔者的<a href="https://juejin.cn/post/6844903844711759880#heading-2" target="_blank" rel="noopener">旧文章</a>。</p>
</blockquote>
<p>所以说，我们可以创建组件来封装区域选择的逻辑，将复杂度分流出去。或者说通过 props 将数据流往下传递给子组件… </p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">export const AreaSelect2 = defineComponent(&#123;</span><br><span class="line">  // 省略</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    // 省略</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;ElSelect</span><br><span class="line">           // 省略</span><br><span class="line">          &gt;</span><br><span class="line">            &#123;country.data.value?.data?.map(i =&gt; &#123;</span><br><span class="line">              return &lt;ElOption key=&#123;i.id&#125; label=&#123;i.name&#125; value=&#123;i.id&#125;&gt;&lt;/ElOption&gt;;</span><br><span class="line">            &#125;)&#125;</span><br><span class="line">          &lt;/ElSelect&gt;</span><br><span class="line">     </span><br><span class="line"><span class="addition">+          &#123;!!currentCountry.value &amp;&amp;</span></span><br><span class="line"><span class="addition">+            currentCountry.value?.regionLevelInfos?.map((i, index) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+              // 父区域 id</span></span><br><span class="line"><span class="addition">+              const parentValue = props.modelValue?.[index];</span></span><br><span class="line"><span class="addition">+              // 当前区域</span></span><br><span class="line"><span class="addition">+              const value = props.modelValue?.[index + 1];</span></span><br><span class="line"><span class="addition">+              // 父区域信息</span></span><br><span class="line"><span class="addition">+              const parentRegion: RegionLevelDTO =</span></span><br><span class="line"><span class="addition">+                index === 0</span></span><br><span class="line"><span class="addition">+                  ? &#123; code: currentCountry.value?.code!, name: currentCountry.value?.name! &#125;</span></span><br><span class="line"><span class="addition">+                  : currentCountry.value?.regionLevelInfos?.[index - 1]!;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+              const handleChange = (nextValue: number) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+                if (value === nextValue) &#123;</span></span><br><span class="line"><span class="addition">+                  return;</span></span><br><span class="line"><span class="addition">+                &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+                assert(Array.isArray(props.modelValue), 'modelValue is required');</span></span><br><span class="line"><span class="addition">+                // 裁剪掉当前区域后面的区域数据</span></span><br><span class="line"><span class="addition">+                const clone = [...props.modelValue].slice(0, index + 2);</span></span><br><span class="line"><span class="addition">+                clone[index + 1] = nextValue;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+                emit('update:modelValue', clone);</span></span><br><span class="line"><span class="addition">+              &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+              return (</span></span><br><span class="line"><span class="addition">+                &lt;Section</span></span><br><span class="line"><span class="addition">+                  index=&#123;index&#125;</span></span><br><span class="line"><span class="addition">+                  parentValue=&#123;parentValue&#125;</span></span><br><span class="line"><span class="addition">+                  modelValue=&#123;value&#125;</span></span><br><span class="line"><span class="addition">+                  region=&#123;i&#125;</span></span><br><span class="line"><span class="addition">+                  parentRegion=&#123;parentRegion&#125;</span></span><br><span class="line"><span class="addition">+                  country=&#123;currentCountry.value!&#125;</span></span><br><span class="line"><span class="addition">+                  onUpdate:modelValue=&#123;handleChange&#125;</span></span><br><span class="line"><span class="addition">+                /&gt;</span></span><br><span class="line"><span class="addition">+              );</span></span><br><span class="line"><span class="addition">+            &#125;)&#125;</span></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>继续分流, 看看 Section 组件的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Section = defineComponent(&#123;</span><br><span class="line">  name: &apos;AreaSelectSection&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 当前索引</span><br><span class="line">     */</span><br><span class="line">    index: &#123; type: Number, required: true &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 区域信息</span><br><span class="line">     */</span><br><span class="line">    region: &#123; type: Object as PropType&lt;RegionLevelDTO&gt;, required: true &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当前国家</span><br><span class="line">     */</span><br><span class="line">    country: &#123; type: Object as PropType&lt;CountryInfoDTO&gt;, required: true &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 父级</span><br><span class="line">     */</span><br><span class="line">    parentRegion: &#123; type: Object as PropType&lt;RegionLevelDTO&gt;, required: true &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 父级的值</span><br><span class="line">     */</span><br><span class="line">    parentValue: Number,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当前值</span><br><span class="line">     */</span><br><span class="line">    modelValue: Number,</span><br><span class="line">  &#125;,</span><br><span class="line">  emits: [&apos;update:modelValue&apos;],</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    // 获取区域列表</span><br><span class="line">    const region = useRegion(</span><br><span class="line">      computed(() =&gt; &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          countryId: props.country.id,</span><br><span class="line">          level: props.index + 1,</span><br><span class="line">          parentId: props.parentValue,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    const handleChange = (value: number) =&gt; &#123;</span><br><span class="line">      emit(&apos;update:modelValue&apos;, value);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;ElSelect</span><br><span class="line">          modelValue=&#123;props.modelValue&#125;</span><br><span class="line">          placeholder=&#123;`请选择$&#123;props.region.name&#125;`&#125;</span><br><span class="line">          filterable</span><br><span class="line">          fitInputWidth</span><br><span class="line">          disabled=&#123;!props.parentValue&#125;</span><br><span class="line">          onUpdate:modelValue=&#123;handleChange&#125;</span><br><span class="line">          loading=&#123;region.isValidating.value&#125;</span><br><span class="line">          class=&#123;s.select&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          &#123;region.data.value?.data?.map(i =&gt; &#123;</span><br><span class="line">            return &lt;ElOption key=&#123;i.id&#125; label=&#123;i.name&#125; value=&#123;i.id&#125;&gt;&lt;/ElOption&gt;;</span><br><span class="line">          &#125;)&#125;</span><br><span class="line">        &lt;/ElSelect&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可见，Section 的实现也再简单不过了。到这里，我相信很多读者已经感受到“响应式”编程的魅力了吧</p>
<p><br><br><br><br><br></p>
<h1 id="原则和建议"><a href="#原则和建议" class="headerlink" title="原则和建议"></a>原则和建议</h1><ol>
<li>优先使用 <code>computed</code>，警惕 <code>watch</code>/<code>watchEffect</code> 等 API 的使用。转换思维先从克制使用 watch 开始。</li>
<li>适当使用 <code>readonly</code>, 禁止状态被坏人修改</li>
<li>最小化状态。避免创建‘缓存’状态，让数据自然流动，不要阻断。</li>
<li>自顶而下，将细节/副作用分流到 hooks 或子组件中，起一个好一点的名字， 让流程看起来更清晰</li>
<li>将 watch 转换为 computed 的语义。外观上的差别是 watch 有 callback， 而 computed 是「管道」，会衍生新的数据。比如上面 useRequest 的例子</li>
<li>推荐使用 VueUse</li>
<li>封装 hooks， 让各种外部的状态或副作用优雅地集成进来</li>
<li>单向数据流，对这个有两层理解<ul>
<li>表示是一种数据流动的方向，通常和 CQRS 模式配合，比如 Redux、Vuex，只能单向的修改和查询</li>
<li>表示一种数据管辖的范围。 通常应用只有数据的拥有者才有权限变更。进一步地讲，我们应该以组件为边界，来限定数据的管辖范围。需要变更时，通过‘事件’ 来通知拥有者。比如 严格遵循 v-model 协议。</li>
</ul>
</li>
<li><p>使用响应式开发思维，构造单向的数据流</p>
<ul>
<li>尽量管道化的方式去设计你的程序</li>
<li>声明式，不要命令式</li>
<li>拆分组件或hooks来分治数据流</li>
<li>组件之间 props 传递也属于数据流。</li>
</ul>
<ol start="10">
<li>使用 ref/reactive → computed → watch → handler → render 这样的顺序组织代码</li>
</ol>
</li>
</ol>
<p>🌹本文完，你的点赞是我写作的最大动力，欢迎留言转发（备注原文作者和链接）。</p>
<p><br><br><br></p>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li><a href="https://juejin.cn/post/6844903844711759880#heading-4" target="_blank" rel="noopener">React组件设计实践总结04 - 组件的思维</a></li>
<li><a href="https://rxjs.dev/" target="_blank" rel="noopener">RxJS</a></li>
<li><a href="https://dev.to/lloyds-digital/comparing-reactivity-models-react-vs-vue-vs-svelte-vs-mobx-vs-solid-29m8" target="_blank" rel="noopener">Comparing reactivity models - React vs Vue vs Svelte vs MobX vs Solid vs Redux</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25383159" target="_blank" rel="noopener">RxJS 入门指引和初步应用</a></li>
</ul>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#简述-rxjs"><span class="toc-number">1.</span> <span class="toc-text">简述 RxJS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为什么建议你去学习-rxjs？"><span class="toc-number">2.</span> <span class="toc-text">为什么建议你去学习 rxjs？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rxjs-和-vue-reactivity-data-有什么关联？"><span class="toc-number">3.</span> <span class="toc-text">RxJS 和 Vue Reactivity Data 有什么关联？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#看看你代码中的坏味道"><span class="toc-number">4.</span> <span class="toc-text">看看你代码中的坏味道</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实践"><span class="toc-number">5.</span> <span class="toc-text">实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分页"><span class="toc-number">5.1.</span> <span class="toc-text">分页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实时搜索"><span class="toc-number">5.2.</span> <span class="toc-text">实时搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定时刷新"><span class="toc-number">5.3.</span> <span class="toc-text">定时刷新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#省市区选择器"><span class="toc-number">5.4.</span> <span class="toc-text">省市区选择器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#原则和建议"><span class="toc-number">6.</span> <span class="toc-text">原则和建议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩展阅读"><span class="toc-number">7.</span> <span class="toc-text">扩展阅读</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bobi.ink/2023/07/09/vue-with-rx/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bobi.ink/2023/07/09/vue-with-rx/&text=Vue 开发的正确姿势：响应式编程思维"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bobi.ink/2023/07/09/vue-with-rx/&title=Vue 开发的正确姿势：响应式编程思维"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bobi.ink/2023/07/09/vue-with-rx/&is_video=false&description=Vue 开发的正确姿势：响应式编程思维"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Vue 开发的正确姿势：响应式编程思维&body=Check out this article: https://bobi.ink/2023/07/09/vue-with-rx/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bobi.ink/2023/07/09/vue-with-rx/&title=Vue 开发的正确姿势：响应式编程思维"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bobi.ink/2023/07/09/vue-with-rx/&title=Vue 开发的正确姿势：响应式编程思维"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bobi.ink/2023/07/09/vue-with-rx/&title=Vue 开发的正确姿势：响应式编程思维"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bobi.ink/2023/07/09/vue-with-rx/&title=Vue 开发的正确姿势：响应式编程思维"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bobi.ink/2023/07/09/vue-with-rx/&name=Vue 开发的正确姿势：响应式编程思维&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2023 Ivan
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Blogs</a></li>
         
          <li><a href="http://github.com/ivan-94">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-44571525-2', 'auto');
        ga('send', 'pageview');
    </script>


    <!-- Disqus Comments -->
    <script type="text/javascript">
        var disqus_shortname = 'bobi-ink';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


