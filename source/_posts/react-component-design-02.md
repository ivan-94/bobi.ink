---
title: React组件设计实践总结02 - 组件的组织
date: 2019/4/23
categories: 前端
---

## 组件的组织

### 组件的分类

- 1️⃣ **容器组件**和**展示组件**分离
  *容器组件和展示组件分离*是 React 开发的重要思想, 它影响的 React 应用项目的组织和架构. 下面总结一下两者的区别

  |          | 容器组件        | 展示组件 |
  | -------- | --------------- | -------- |
  | 关注点   | 业务            | UI       |
  | 数据源   | 状态管理器/后端 | props    |
  | 组件形式 | 高阶组件        | 普通组件 |

  了解更多[Presentational and Container Components](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)

  - **展示组件**是一个只关注展示的'元件', 为了可以在多个地方被复用, 它不应该耦合'业务/功能', 或者说不应该过渡耦合. 像`antd`这类组件库提供组件明显就是'展示组件'

    下面是一个典型的应用目录结构, 我们可以看到展示组件和业务/功能是有不同的耦合程度的, 和业务的耦合程度越低, 通用性/可复用性越强:

    ```shell
    node_modules/antd/     🔴 通用的组件库, 不能和任何项目的业务耦合
    src/
      components/          🔴 项目通用的组件库, 可以被多个容器组件共享
      containers/
        Foo/
          components/      🔴 容器组件特有的组件库, 和一个业务/功能深度耦合. 以致于不能被其他容器组件共享
          index.tsx
        Bar/
          components/
          index.tsx
    ```

  - **容器组件**主要关注业务处理. 容器组件一般以'高阶组件'形式存在, 它一般 ① 从外部数据源(redux 这些状态管理器或者直接请求服务端数据)获取数据, 然后 ② 组合*展示组件*来构建完整的视图.

    <img src="/images/04/container.png" width="400" />

    *容器组件*通过组合*展示组件*来构建完整视图, 但两者直接并不是简单的包含与被包含的关系.

    在 React Hooks 出来以后, 容器组件的职责就被 hooks 取代了 👇

  `容器组件和展示组件的分离`可以带来好处主要是**可复用性**和**可维护性**:

  - 可复用性: 展示组件可以用于多个不同的数据源(容器组件). 容器组件(业务逻辑)也可以被复用于不同'平台'的展示组件
  - 展示和容器组件更好的分离，有助于更好的理解应用和 UI, 可以独立地维护
  - 展示组件变得轻量(无状态/或局部状态), 更容易被测试

- 2️⃣ 分离逻辑和视图: `容器组件和展示组件`的分离本质上是`逻辑和视图`的分离.

  在`React Hooks`出现后, 容器组件进化为 Hooks 形式, Hooks 可以和视图层更自然的分离. 它为视图层提供纯粹的数据来源, 可以复用于不同的'展示平台', 例如 web 版和 native 版:

  ```shell
  Login/
    useLogin.ts   // 可复用的业务逻辑
    index.web.tsx
    index.tsx
  ```

  上面使用了`useLogin.tsx`来单独维护业务逻辑. 可以被 web 平台和 native 平台的代码复用

- 3️⃣ 有状态组件和无状态组件

  无状态组件内部不存储状态, 完全由外部的 props 来映射. 这类组件一般以函数组件形式, 作为低级/高复用的底层展示型组件.
  无状态组件天然就是'纯组件', 如果无状态组件的映射需要一点成本, 可以使用 React.memo 避免重复渲染

- 4️⃣ 纯组件和非纯组件

  纯组件的'纯'来源于函数式编程. 指的是"对于一个函数而言, 给定相同的输入, 它总是返回相同的输出, 过程没有副作用, 没有额外的状态依赖". 对应到 React 组件中, 纯组件指的是 props(严格上说还有 state 和 context, 它们也是组件的输入)没有变化, 组件的输出就不会变动.

  <img src="/images/04/input-output.png" width="400" />

  函数式编程和组件式编程思想是一致的, 它们都是'组合'的艺术. 一个大的函数可以有多个职责单一函数组合而成, 一个组件也是如此. 我们将一个大的组件拆分为子组件, 对组件做更细粒度的控制, 保持它们的纯净性, 让它们的职责更单一, 更独立. 这带来的好处就是可复用性, 可测试性和可预测性.

  纯组件对 React 的重要意义还有性能优化. 如果一个组件是一个纯组件, 如果'输入'没有变动, 那么这个组件就不需要重新渲染. 组件树越大, 纯组件带来的性能优化收益就越高.

  我们可以很容易地保证一个底层组件的纯净性, 因为它本来就很简单. 对于一个复杂的组件树, 则需要花点心思进行构建, 所以才有了'状态管理'的概念, Redux 就是一个典型的解决方案, 在 Redux 的世界里*'一个复杂的组件树就是一颗状态树的映射'*, 只要状态树(需要依靠不可变数据来保证状态的可预测性)不变, 组件树就不变. Redux 推荐保持组件的纯净性, 由 Redux 和配套的异步处理工具来维护状态, 这样就将整个应用抽象成了一个"单一的数据流", 这是一种简单的"输入/输出"关系

  <img src="/images/04/redux.png" width="400" />

- 5️⃣ 按照UI划分为'布局组件'和'内容组件'

### 目录划分

多入口项目

一个项目下
好处
共享资源, 一起优化
不能独立编译
workspace 模式
独立编译

不要耦合业务, 当做一个第三方 UI 库来设计

### 组件的识别

以 gzb-bn 为例

### 拆分

拆分为子函数
拆分为子组件

### 模块化

### 导出

展示组件和容器组件, 展示组件避免耦合业务

### 子组件

### 文档

- 3️⃣ 跨平台的另外一种方式, taro
